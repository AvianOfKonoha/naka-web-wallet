var l6 = Object.defineProperty;
var u6 = (t, e, n) =>
  e in t
    ? l6(t, e, {enumerable: !0, configurable: !0, writable: !0, value: n})
    : (t[e] = n);
var d6 = (t, e) => () => (e || t((e = {exports: {}}).exports, e), e.exports);
var Ai = (t, e, n) => u6(t, typeof e != 'symbol' ? e + '' : e, n);
var IG = d6((MG, al) => {
  (function () {
    const e = document.createElement('link').relList;
    if (e && e.supports && e.supports('modulepreload')) return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
      r(i);
    new MutationObserver((i) => {
      for (const s of i)
        if (s.type === 'childList')
          for (const o of s.addedNodes)
            o.tagName === 'LINK' && o.rel === 'modulepreload' && r(o);
    }).observe(document, {childList: !0, subtree: !0});
    function n(i) {
      const s = {};
      return (
        i.integrity && (s.integrity = i.integrity),
        i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy),
        i.crossOrigin === 'use-credentials'
          ? (s.credentials = 'include')
          : i.crossOrigin === 'anonymous'
            ? (s.credentials = 'omit')
            : (s.credentials = 'same-origin'),
        s
      );
    }
    function r(i) {
      if (i.ep) return;
      i.ep = !0;
      const s = n(i);
      fetch(i.href, s);
    }
  })();
  /**
   * @vue/shared v3.5.17
   * (c) 2018-present Yuxi (Evan) You and Vue contributors
   * @license MIT
   **/ /*! #__NO_SIDE_EFFECTS__ */ function py(t) {
    const e = Object.create(null);
    for (const n of t.split(',')) e[n] = 1;
    return (n) => n in e;
  }
  const pt = {},
    ja = [],
    ci = () => {},
    f6 = () => !1,
    Zh = (t) =>
      t.charCodeAt(0) === 111 &&
      t.charCodeAt(1) === 110 &&
      (t.charCodeAt(2) > 122 || t.charCodeAt(2) < 97),
    my = (t) => t.startsWith('onUpdate:'),
    gn = Object.assign,
    gy = (t, e) => {
      const n = t.indexOf(e);
      n > -1 && t.splice(n, 1);
    },
    h6 = Object.prototype.hasOwnProperty,
    ut = (t, e) => h6.call(t, e),
    Me = Array.isArray,
    Ua = (t) => Cu(t) === '[object Map]',
    Yh = (t) => Cu(t) === '[object Set]',
    P1 = (t) => Cu(t) === '[object Date]',
    je = (t) => typeof t == 'function',
    Lt = (t) => typeof t == 'string',
    Dr = (t) => typeof t == 'symbol',
    wt = (t) => t !== null && typeof t == 'object',
    bE = (t) => (wt(t) || je(t)) && je(t.then) && je(t.catch),
    wE = Object.prototype.toString,
    Cu = (t) => wE.call(t),
    p6 = (t) => Cu(t).slice(8, -1),
    _E = (t) => Cu(t) === '[object Object]',
    yy = (t) =>
      Lt(t) && t !== 'NaN' && t[0] !== '-' && '' + parseInt(t, 10) === t,
    cl = py(
      ',key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted'
    ),
    Qh = (t) => {
      const e = Object.create(null);
      return (n) => e[n] || (e[n] = t(n));
    },
    m6 = /-(\w)/g,
    Ys = Qh((t) => t.replace(m6, (e, n) => (n ? n.toUpperCase() : ''))),
    g6 = /\B([A-Z])/g,
    ra = Qh((t) => t.replace(g6, '-$1').toLowerCase()),
    EE = Qh((t) => t.charAt(0).toUpperCase() + t.slice(1)),
    Yp = Qh((t) => (t ? `on${EE(t)}` : '')),
    Us = (t, e) => !Object.is(t, e),
    Pd = (t, ...e) => {
      for (let n = 0; n < t.length; n++) t[n](...e);
    },
    I0 = (t, e, n, r = !1) => {
      Object.defineProperty(t, e, {
        configurable: !0,
        enumerable: !1,
        writable: r,
        value: n
      });
    },
    vf = (t) => {
      const e = parseFloat(t);
      return isNaN(e) ? t : e;
    };
  let M1;
  const Jh = () =>
    M1 ||
    (M1 =
      typeof globalThis < 'u'
        ? globalThis
        : typeof self < 'u'
          ? self
          : typeof window < 'u'
            ? window
            : typeof global < 'u'
              ? global
              : {});
  function vy(t) {
    if (Me(t)) {
      const e = {};
      for (let n = 0; n < t.length; n++) {
        const r = t[n],
          i = Lt(r) ? w6(r) : vy(r);
        if (i) for (const s in i) e[s] = i[s];
      }
      return e;
    } else if (Lt(t) || wt(t)) return t;
  }
  const y6 = /;(?![^(]*\))/g,
    v6 = /:([^]+)/,
    b6 = /\/\*[^]*?\*\//g;
  function w6(t) {
    const e = {};
    return (
      t
        .replace(b6, '')
        .split(y6)
        .forEach((n) => {
          if (n) {
            const r = n.split(v6);
            r.length > 1 && (e[r[0].trim()] = r[1].trim());
          }
        }),
      e
    );
  }
  function tn(t) {
    let e = '';
    if (Lt(t)) e = t;
    else if (Me(t))
      for (let n = 0; n < t.length; n++) {
        const r = tn(t[n]);
        r && (e += r + ' ');
      }
    else if (wt(t)) for (const n in t) t[n] && (e += n + ' ');
    return e.trim();
  }
  const _6 =
      'itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly',
    E6 = py(_6);
  function AE(t) {
    return !!t || t === '';
  }
  function A6(t, e) {
    if (t.length !== e.length) return !1;
    let n = !0;
    for (let r = 0; n && r < t.length; r++) n = Xh(t[r], e[r]);
    return n;
  }
  function Xh(t, e) {
    if (t === e) return !0;
    let n = P1(t),
      r = P1(e);
    if (n || r) return n && r ? t.getTime() === e.getTime() : !1;
    if (((n = Dr(t)), (r = Dr(e)), n || r)) return t === e;
    if (((n = Me(t)), (r = Me(e)), n || r)) return n && r ? A6(t, e) : !1;
    if (((n = wt(t)), (r = wt(e)), n || r)) {
      if (!n || !r) return !1;
      const i = Object.keys(t).length,
        s = Object.keys(e).length;
      if (i !== s) return !1;
      for (const o in t) {
        const a = t.hasOwnProperty(o),
          c = e.hasOwnProperty(o);
        if ((a && !c) || (!a && c) || !Xh(t[o], e[o])) return !1;
      }
    }
    return String(t) === String(e);
  }
  function S6(t, e) {
    return t.findIndex((n) => Xh(n, e));
  }
  const SE = (t) => !!(t && t.__v_isRef === !0),
    Ft = (t) =>
      Lt(t)
        ? t
        : t == null
          ? ''
          : Me(t) || (wt(t) && (t.toString === wE || !je(t.toString)))
            ? SE(t)
              ? Ft(t.value)
              : JSON.stringify(t, xE, 2)
            : String(t),
    xE = (t, e) =>
      SE(e)
        ? xE(t, e.value)
        : Ua(e)
          ? {
              [`Map(${e.size})`]: [...e.entries()].reduce(
                (n, [r, i], s) => ((n[Qp(r, s) + ' =>'] = i), n),
                {}
              )
            }
          : Yh(e)
            ? {[`Set(${e.size})`]: [...e.values()].map((n) => Qp(n))}
            : Dr(e)
              ? Qp(e)
              : wt(e) && !Me(e) && !_E(e)
                ? String(e)
                : e,
    Qp = (t, e = '') => {
      var n;
      return Dr(t) ? `Symbol(${(n = t.description) != null ? n : e})` : t;
    };
  /**
   * @vue/reactivity v3.5.17
   * (c) 2018-present Yuxi (Evan) You and Vue contributors
   * @license MIT
   **/ let cn;
  class CE {
    constructor(e = !1) {
      ((this.detached = e),
        (this._active = !0),
        (this._on = 0),
        (this.effects = []),
        (this.cleanups = []),
        (this._isPaused = !1),
        (this.parent = cn),
        !e &&
          cn &&
          (this.index = (cn.scopes || (cn.scopes = [])).push(this) - 1));
    }
    get active() {
      return this._active;
    }
    pause() {
      if (this._active) {
        this._isPaused = !0;
        let e, n;
        if (this.scopes)
          for (e = 0, n = this.scopes.length; e < n; e++)
            this.scopes[e].pause();
        for (e = 0, n = this.effects.length; e < n; e++)
          this.effects[e].pause();
      }
    }
    resume() {
      if (this._active && this._isPaused) {
        this._isPaused = !1;
        let e, n;
        if (this.scopes)
          for (e = 0, n = this.scopes.length; e < n; e++)
            this.scopes[e].resume();
        for (e = 0, n = this.effects.length; e < n; e++)
          this.effects[e].resume();
      }
    }
    run(e) {
      if (this._active) {
        const n = cn;
        try {
          return ((cn = this), e());
        } finally {
          cn = n;
        }
      }
    }
    on() {
      ++this._on === 1 && ((this.prevScope = cn), (cn = this));
    }
    off() {
      this._on > 0 &&
        --this._on === 0 &&
        ((cn = this.prevScope), (this.prevScope = void 0));
    }
    stop(e) {
      if (this._active) {
        this._active = !1;
        let n, r;
        for (n = 0, r = this.effects.length; n < r; n++) this.effects[n].stop();
        for (
          this.effects.length = 0, n = 0, r = this.cleanups.length;
          n < r;
          n++
        )
          this.cleanups[n]();
        if (((this.cleanups.length = 0), this.scopes)) {
          for (n = 0, r = this.scopes.length; n < r; n++)
            this.scopes[n].stop(!0);
          this.scopes.length = 0;
        }
        if (!this.detached && this.parent && !e) {
          const i = this.parent.scopes.pop();
          i &&
            i !== this &&
            ((this.parent.scopes[this.index] = i), (i.index = this.index));
        }
        this.parent = void 0;
      }
    }
  }
  function TE(t) {
    return new CE(t);
  }
  function IE() {
    return cn;
  }
  function x6(t, e = !1) {
    cn && cn.cleanups.push(t);
  }
  let yt;
  const Jp = new WeakSet();
  class kE {
    constructor(e) {
      ((this.fn = e),
        (this.deps = void 0),
        (this.depsTail = void 0),
        (this.flags = 5),
        (this.next = void 0),
        (this.cleanup = void 0),
        (this.scheduler = void 0),
        cn && cn.active && cn.effects.push(this));
    }
    pause() {
      this.flags |= 64;
    }
    resume() {
      this.flags & 64 &&
        ((this.flags &= -65),
        Jp.has(this) && (Jp.delete(this), this.trigger()));
    }
    notify() {
      (this.flags & 2 && !(this.flags & 32)) || this.flags & 8 || PE(this);
    }
    run() {
      if (!(this.flags & 1)) return this.fn();
      ((this.flags |= 2), O1(this), ME(this));
      const e = yt,
        n = Nr;
      ((yt = this), (Nr = !0));
      try {
        return this.fn();
      } finally {
        (OE(this), (yt = e), (Nr = n), (this.flags &= -3));
      }
    }
    stop() {
      if (this.flags & 1) {
        for (let e = this.deps; e; e = e.nextDep) _y(e);
        ((this.deps = this.depsTail = void 0),
          O1(this),
          this.onStop && this.onStop(),
          (this.flags &= -2));
      }
    }
    trigger() {
      this.flags & 64
        ? Jp.add(this)
        : this.scheduler
          ? this.scheduler()
          : this.runIfDirty();
    }
    runIfDirty() {
      k0(this) && this.run();
    }
    get dirty() {
      return k0(this);
    }
  }
  let RE = 0,
    ll,
    ul;
  function PE(t, e = !1) {
    if (((t.flags |= 8), e)) {
      ((t.next = ul), (ul = t));
      return;
    }
    ((t.next = ll), (ll = t));
  }
  function by() {
    RE++;
  }
  function wy() {
    if (--RE > 0) return;
    if (ul) {
      let e = ul;
      for (ul = void 0; e; ) {
        const n = e.next;
        ((e.next = void 0), (e.flags &= -9), (e = n));
      }
    }
    let t;
    for (; ll; ) {
      let e = ll;
      for (ll = void 0; e; ) {
        const n = e.next;
        if (((e.next = void 0), (e.flags &= -9), e.flags & 1))
          try {
            e.trigger();
          } catch (r) {
            t || (t = r);
          }
        e = n;
      }
    }
    if (t) throw t;
  }
  function ME(t) {
    for (let e = t.deps; e; e = e.nextDep)
      ((e.version = -1),
        (e.prevActiveLink = e.dep.activeLink),
        (e.dep.activeLink = e));
  }
  function OE(t) {
    let e,
      n = t.depsTail,
      r = n;
    for (; r; ) {
      const i = r.prevDep;
      (r.version === -1 ? (r === n && (n = i), _y(r), C6(r)) : (e = r),
        (r.dep.activeLink = r.prevActiveLink),
        (r.prevActiveLink = void 0),
        (r = i));
    }
    ((t.deps = e), (t.depsTail = n));
  }
  function k0(t) {
    for (let e = t.deps; e; e = e.nextDep)
      if (
        e.dep.version !== e.version ||
        (e.dep.computed && (NE(e.dep.computed) || e.dep.version !== e.version))
      )
        return !0;
    return !!t._dirty;
  }
  function NE(t) {
    if (
      (t.flags & 4 && !(t.flags & 16)) ||
      ((t.flags &= -17), t.globalVersion === Pl) ||
      ((t.globalVersion = Pl),
      !t.isSSR && t.flags & 128 && ((!t.deps && !t._dirty) || !k0(t)))
    )
      return;
    t.flags |= 2;
    const e = t.dep,
      n = yt,
      r = Nr;
    ((yt = t), (Nr = !0));
    try {
      ME(t);
      const i = t.fn(t._value);
      (e.version === 0 || Us(i, t._value)) &&
        ((t.flags |= 128), (t._value = i), e.version++);
    } catch (i) {
      throw (e.version++, i);
    } finally {
      ((yt = n), (Nr = r), OE(t), (t.flags &= -3));
    }
  }
  function _y(t, e = !1) {
    const {dep: n, prevSub: r, nextSub: i} = t;
    if (
      (r && ((r.nextSub = i), (t.prevSub = void 0)),
      i && ((i.prevSub = r), (t.nextSub = void 0)),
      n.subs === t && ((n.subs = r), !r && n.computed))
    ) {
      n.computed.flags &= -5;
      for (let s = n.computed.deps; s; s = s.nextDep) _y(s, !0);
    }
    !e && !--n.sc && n.map && n.map.delete(n.key);
  }
  function C6(t) {
    const {prevDep: e, nextDep: n} = t;
    (e && ((e.nextDep = n), (t.prevDep = void 0)),
      n && ((n.prevDep = e), (t.nextDep = void 0)));
  }
  let Nr = !0;
  const LE = [];
  function Ji() {
    (LE.push(Nr), (Nr = !1));
  }
  function Xi() {
    const t = LE.pop();
    Nr = t === void 0 ? !0 : t;
  }
  function O1(t) {
    const {cleanup: e} = t;
    if (((t.cleanup = void 0), e)) {
      const n = yt;
      yt = void 0;
      try {
        e();
      } finally {
        yt = n;
      }
    }
  }
  let Pl = 0;
  class T6 {
    constructor(e, n) {
      ((this.sub = e),
        (this.dep = n),
        (this.version = n.version),
        (this.nextDep =
          this.prevDep =
          this.nextSub =
          this.prevSub =
          this.prevActiveLink =
            void 0));
    }
  }
  class Ey {
    constructor(e) {
      ((this.computed = e),
        (this.version = 0),
        (this.activeLink = void 0),
        (this.subs = void 0),
        (this.map = void 0),
        (this.key = void 0),
        (this.sc = 0),
        (this.__v_skip = !0));
    }
    track(e) {
      if (!yt || !Nr || yt === this.computed) return;
      let n = this.activeLink;
      if (n === void 0 || n.sub !== yt)
        ((n = this.activeLink = new T6(yt, this)),
          yt.deps
            ? ((n.prevDep = yt.depsTail),
              (yt.depsTail.nextDep = n),
              (yt.depsTail = n))
            : (yt.deps = yt.depsTail = n),
          BE(n));
      else if (n.version === -1 && ((n.version = this.version), n.nextDep)) {
        const r = n.nextDep;
        ((r.prevDep = n.prevDep),
          n.prevDep && (n.prevDep.nextDep = r),
          (n.prevDep = yt.depsTail),
          (n.nextDep = void 0),
          (yt.depsTail.nextDep = n),
          (yt.depsTail = n),
          yt.deps === n && (yt.deps = r));
      }
      return n;
    }
    trigger(e) {
      (this.version++, Pl++, this.notify(e));
    }
    notify(e) {
      by();
      try {
        for (let n = this.subs; n; n = n.prevSub)
          n.sub.notify() && n.sub.dep.notify();
      } finally {
        wy();
      }
    }
  }
  function BE(t) {
    if ((t.dep.sc++, t.sub.flags & 4)) {
      const e = t.dep.computed;
      if (e && !t.dep.subs) {
        e.flags |= 20;
        for (let r = e.deps; r; r = r.nextDep) BE(r);
      }
      const n = t.dep.subs;
      (n !== t && ((t.prevSub = n), n && (n.nextSub = t)), (t.dep.subs = t));
    }
  }
  const bf = new WeakMap(),
    No = Symbol(''),
    R0 = Symbol(''),
    Ml = Symbol('');
  function dn(t, e, n) {
    if (Nr && yt) {
      let r = bf.get(t);
      r || bf.set(t, (r = new Map()));
      let i = r.get(n);
      (i || (r.set(n, (i = new Ey())), (i.map = r), (i.key = n)), i.track());
    }
  }
  function Ui(t, e, n, r, i, s) {
    const o = bf.get(t);
    if (!o) {
      Pl++;
      return;
    }
    const a = (c) => {
      c && c.trigger();
    };
    if ((by(), e === 'clear')) o.forEach(a);
    else {
      const c = Me(t),
        l = c && yy(n);
      if (c && n === 'length') {
        const u = Number(r);
        o.forEach((d, f) => {
          (f === 'length' || f === Ml || (!Dr(f) && f >= u)) && a(d);
        });
      } else
        switch (
          ((n !== void 0 || o.has(void 0)) && a(o.get(n)), l && a(o.get(Ml)), e)
        ) {
          case 'add':
            c ? l && a(o.get('length')) : (a(o.get(No)), Ua(t) && a(o.get(R0)));
            break;
          case 'delete':
            c || (a(o.get(No)), Ua(t) && a(o.get(R0)));
            break;
          case 'set':
            Ua(t) && a(o.get(No));
            break;
        }
    }
    wy();
  }
  function I6(t, e) {
    const n = bf.get(t);
    return n && n.get(e);
  }
  function da(t) {
    const e = He(t);
    return e === t ? e : (dn(e, 'iterate', Ml), Er(t) ? e : e.map(Jt));
  }
  function ep(t) {
    return (dn((t = He(t)), 'iterate', Ml), t);
  }
  const k6 = {
    __proto__: null,
    [Symbol.iterator]() {
      return Xp(this, Symbol.iterator, Jt);
    },
    concat(...t) {
      return da(this).concat(...t.map((e) => (Me(e) ? da(e) : e)));
    },
    entries() {
      return Xp(this, 'entries', (t) => ((t[1] = Jt(t[1])), t));
    },
    every(t, e) {
      return Si(this, 'every', t, e, void 0, arguments);
    },
    filter(t, e) {
      return Si(this, 'filter', t, e, (n) => n.map(Jt), arguments);
    },
    find(t, e) {
      return Si(this, 'find', t, e, Jt, arguments);
    },
    findIndex(t, e) {
      return Si(this, 'findIndex', t, e, void 0, arguments);
    },
    findLast(t, e) {
      return Si(this, 'findLast', t, e, Jt, arguments);
    },
    findLastIndex(t, e) {
      return Si(this, 'findLastIndex', t, e, void 0, arguments);
    },
    forEach(t, e) {
      return Si(this, 'forEach', t, e, void 0, arguments);
    },
    includes(...t) {
      return em(this, 'includes', t);
    },
    indexOf(...t) {
      return em(this, 'indexOf', t);
    },
    join(t) {
      return da(this).join(t);
    },
    lastIndexOf(...t) {
      return em(this, 'lastIndexOf', t);
    },
    map(t, e) {
      return Si(this, 'map', t, e, void 0, arguments);
    },
    pop() {
      return $c(this, 'pop');
    },
    push(...t) {
      return $c(this, 'push', t);
    },
    reduce(t, ...e) {
      return N1(this, 'reduce', t, e);
    },
    reduceRight(t, ...e) {
      return N1(this, 'reduceRight', t, e);
    },
    shift() {
      return $c(this, 'shift');
    },
    some(t, e) {
      return Si(this, 'some', t, e, void 0, arguments);
    },
    splice(...t) {
      return $c(this, 'splice', t);
    },
    toReversed() {
      return da(this).toReversed();
    },
    toSorted(t) {
      return da(this).toSorted(t);
    },
    toSpliced(...t) {
      return da(this).toSpliced(...t);
    },
    unshift(...t) {
      return $c(this, 'unshift', t);
    },
    values() {
      return Xp(this, 'values', Jt);
    }
  };
  function Xp(t, e, n) {
    const r = ep(t),
      i = r[e]();
    return (
      r !== t &&
        !Er(t) &&
        ((i._next = i.next),
        (i.next = () => {
          const s = i._next();
          return (s.value && (s.value = n(s.value)), s);
        })),
      i
    );
  }
  const R6 = Array.prototype;
  function Si(t, e, n, r, i, s) {
    const o = ep(t),
      a = o !== t && !Er(t),
      c = o[e];
    if (c !== R6[e]) {
      const d = c.apply(t, s);
      return a ? Jt(d) : d;
    }
    let l = n;
    o !== t &&
      (a
        ? (l = function (d, f) {
            return n.call(this, Jt(d), f, t);
          })
        : n.length > 2 &&
          (l = function (d, f) {
            return n.call(this, d, f, t);
          }));
    const u = c.call(o, l, r);
    return a && i ? i(u) : u;
  }
  function N1(t, e, n, r) {
    const i = ep(t);
    let s = n;
    return (
      i !== t &&
        (Er(t)
          ? n.length > 3 &&
            (s = function (o, a, c) {
              return n.call(this, o, a, c, t);
            })
          : (s = function (o, a, c) {
              return n.call(this, o, Jt(a), c, t);
            })),
      i[e](s, ...r)
    );
  }
  function em(t, e, n) {
    const r = He(t);
    dn(r, 'iterate', Ml);
    const i = r[e](...n);
    return (i === -1 || i === !1) && xy(n[0])
      ? ((n[0] = He(n[0])), r[e](...n))
      : i;
  }
  function $c(t, e, n = []) {
    (Ji(), by());
    const r = He(t)[e].apply(t, n);
    return (wy(), Xi(), r);
  }
  const P6 = py('__proto__,__v_isRef,__isVue'),
    DE = new Set(
      Object.getOwnPropertyNames(Symbol)
        .filter((t) => t !== 'arguments' && t !== 'caller')
        .map((t) => Symbol[t])
        .filter(Dr)
    );
  function M6(t) {
    Dr(t) || (t = String(t));
    const e = He(this);
    return (dn(e, 'has', t), e.hasOwnProperty(t));
  }
  class FE {
    constructor(e = !1, n = !1) {
      ((this._isReadonly = e), (this._isShallow = n));
    }
    get(e, n, r) {
      if (n === '__v_skip') return e.__v_skip;
      const i = this._isReadonly,
        s = this._isShallow;
      if (n === '__v_isReactive') return !i;
      if (n === '__v_isReadonly') return i;
      if (n === '__v_isShallow') return s;
      if (n === '__v_raw')
        return r === (i ? (s ? U6 : UE) : s ? jE : HE).get(e) ||
          Object.getPrototypeOf(e) === Object.getPrototypeOf(r)
          ? e
          : void 0;
      const o = Me(e);
      if (!i) {
        let c;
        if (o && (c = k6[n])) return c;
        if (n === 'hasOwnProperty') return M6;
      }
      const a = Reflect.get(e, n, Pt(e) ? e : r);
      return (Dr(n) ? DE.has(n) : P6(n)) || (i || dn(e, 'get', n), s)
        ? a
        : Pt(a)
          ? o && yy(n)
            ? a
            : a.value
          : wt(a)
            ? i
              ? qE(a)
              : Ar(a)
            : a;
    }
  }
  class $E extends FE {
    constructor(e = !1) {
      super(!1, e);
    }
    set(e, n, r, i) {
      let s = e[n];
      if (!this._isShallow) {
        const c = Qs(s);
        if (
          (!Er(r) && !Qs(r) && ((s = He(s)), (r = He(r))),
          !Me(e) && Pt(s) && !Pt(r))
        )
          return c ? !1 : ((s.value = r), !0);
      }
      const o = Me(e) && yy(n) ? Number(n) < e.length : ut(e, n),
        a = Reflect.set(e, n, r, Pt(e) ? e : i);
      return (
        e === He(i) &&
          (o ? Us(r, s) && Ui(e, 'set', n, r) : Ui(e, 'add', n, r)),
        a
      );
    }
    deleteProperty(e, n) {
      const r = ut(e, n);
      e[n];
      const i = Reflect.deleteProperty(e, n);
      return (i && r && Ui(e, 'delete', n, void 0), i);
    }
    has(e, n) {
      const r = Reflect.has(e, n);
      return ((!Dr(n) || !DE.has(n)) && dn(e, 'has', n), r);
    }
    ownKeys(e) {
      return (dn(e, 'iterate', Me(e) ? 'length' : No), Reflect.ownKeys(e));
    }
  }
  class O6 extends FE {
    constructor(e = !1) {
      super(!0, e);
    }
    set(e, n) {
      return !0;
    }
    deleteProperty(e, n) {
      return !0;
    }
  }
  const N6 = new $E(),
    L6 = new O6(),
    B6 = new $E(!0),
    P0 = (t) => t,
    Wu = (t) => Reflect.getPrototypeOf(t);
  function D6(t, e, n) {
    return function (...r) {
      const i = this.__v_raw,
        s = He(i),
        o = Ua(s),
        a = t === 'entries' || (t === Symbol.iterator && o),
        c = t === 'keys' && o,
        l = i[t](...r),
        u = n ? P0 : e ? wf : Jt;
      return (
        !e && dn(s, 'iterate', c ? R0 : No),
        {
          next() {
            const {value: d, done: f} = l.next();
            return f
              ? {value: d, done: f}
              : {value: a ? [u(d[0]), u(d[1])] : u(d), done: f};
          },
          [Symbol.iterator]() {
            return this;
          }
        }
      );
    };
  }
  function Zu(t) {
    return function (...e) {
      return t === 'delete' ? !1 : t === 'clear' ? void 0 : this;
    };
  }
  function F6(t, e) {
    const n = {
      get(i) {
        const s = this.__v_raw,
          o = He(s),
          a = He(i);
        t || (Us(i, a) && dn(o, 'get', i), dn(o, 'get', a));
        const {has: c} = Wu(o),
          l = e ? P0 : t ? wf : Jt;
        if (c.call(o, i)) return l(s.get(i));
        if (c.call(o, a)) return l(s.get(a));
        s !== o && s.get(i);
      },
      get size() {
        const i = this.__v_raw;
        return (!t && dn(He(i), 'iterate', No), Reflect.get(i, 'size', i));
      },
      has(i) {
        const s = this.__v_raw,
          o = He(s),
          a = He(i);
        return (
          t || (Us(i, a) && dn(o, 'has', i), dn(o, 'has', a)),
          i === a ? s.has(i) : s.has(i) || s.has(a)
        );
      },
      forEach(i, s) {
        const o = this,
          a = o.__v_raw,
          c = He(a),
          l = e ? P0 : t ? wf : Jt;
        return (
          !t && dn(c, 'iterate', No),
          a.forEach((u, d) => i.call(s, l(u), l(d), o))
        );
      }
    };
    return (
      gn(
        n,
        t
          ? {
              add: Zu('add'),
              set: Zu('set'),
              delete: Zu('delete'),
              clear: Zu('clear')
            }
          : {
              add(i) {
                !e && !Er(i) && !Qs(i) && (i = He(i));
                const s = He(this);
                return (
                  Wu(s).has.call(s, i) || (s.add(i), Ui(s, 'add', i, i)),
                  this
                );
              },
              set(i, s) {
                !e && !Er(s) && !Qs(s) && (s = He(s));
                const o = He(this),
                  {has: a, get: c} = Wu(o);
                let l = a.call(o, i);
                l || ((i = He(i)), (l = a.call(o, i)));
                const u = c.call(o, i);
                return (
                  o.set(i, s),
                  l ? Us(s, u) && Ui(o, 'set', i, s) : Ui(o, 'add', i, s),
                  this
                );
              },
              delete(i) {
                const s = He(this),
                  {has: o, get: a} = Wu(s);
                let c = o.call(s, i);
                (c || ((i = He(i)), (c = o.call(s, i))), a && a.call(s, i));
                const l = s.delete(i);
                return (c && Ui(s, 'delete', i, void 0), l);
              },
              clear() {
                const i = He(this),
                  s = i.size !== 0,
                  o = i.clear();
                return (s && Ui(i, 'clear', void 0, void 0), o);
              }
            }
      ),
      ['keys', 'values', 'entries', Symbol.iterator].forEach((i) => {
        n[i] = D6(i, t, e);
      }),
      n
    );
  }
  function Ay(t, e) {
    const n = F6(t, e);
    return (r, i, s) =>
      i === '__v_isReactive'
        ? !t
        : i === '__v_isReadonly'
          ? t
          : i === '__v_raw'
            ? r
            : Reflect.get(ut(n, i) && i in r ? n : r, i, s);
  }
  const $6 = {get: Ay(!1, !1)},
    H6 = {get: Ay(!1, !0)},
    j6 = {get: Ay(!0, !1)},
    HE = new WeakMap(),
    jE = new WeakMap(),
    UE = new WeakMap(),
    U6 = new WeakMap();
  function K6(t) {
    switch (t) {
      case 'Object':
      case 'Array':
        return 1;
      case 'Map':
      case 'Set':
      case 'WeakMap':
      case 'WeakSet':
        return 2;
      default:
        return 0;
    }
  }
  function q6(t) {
    return t.__v_skip || !Object.isExtensible(t) ? 0 : K6(p6(t));
  }
  function Ar(t) {
    return Qs(t) ? t : Sy(t, !1, N6, $6, HE);
  }
  function KE(t) {
    return Sy(t, !1, B6, H6, jE);
  }
  function qE(t) {
    return Sy(t, !0, L6, j6, UE);
  }
  function Sy(t, e, n, r, i) {
    if (!wt(t) || (t.__v_raw && !(e && t.__v_isReactive))) return t;
    const s = q6(t);
    if (s === 0) return t;
    const o = i.get(t);
    if (o) return o;
    const a = new Proxy(t, s === 2 ? r : n);
    return (i.set(t, a), a);
  }
  function Ks(t) {
    return Qs(t) ? Ks(t.__v_raw) : !!(t && t.__v_isReactive);
  }
  function Qs(t) {
    return !!(t && t.__v_isReadonly);
  }
  function Er(t) {
    return !!(t && t.__v_isShallow);
  }
  function xy(t) {
    return t ? !!t.__v_raw : !1;
  }
  function He(t) {
    const e = t && t.__v_raw;
    return e ? He(e) : t;
  }
  function Cy(t) {
    return (
      !ut(t, '__v_skip') && Object.isExtensible(t) && I0(t, '__v_skip', !0),
      t
    );
  }
  const Jt = (t) => (wt(t) ? Ar(t) : t),
    wf = (t) => (wt(t) ? qE(t) : t);
  function Pt(t) {
    return t ? t.__v_isRef === !0 : !1;
  }
  function Pr(t) {
    return VE(t, !1);
  }
  function V6(t) {
    return VE(t, !0);
  }
  function VE(t, e) {
    return Pt(t) ? t : new G6(t, e);
  }
  class G6 {
    constructor(e, n) {
      ((this.dep = new Ey()),
        (this.__v_isRef = !0),
        (this.__v_isShallow = !1),
        (this._rawValue = n ? e : He(e)),
        (this._value = n ? e : Jt(e)),
        (this.__v_isShallow = n));
    }
    get value() {
      return (this.dep.track(), this._value);
    }
    set value(e) {
      const n = this._rawValue,
        r = this.__v_isShallow || Er(e) || Qs(e);
      ((e = r ? e : He(e)),
        Us(e, n) &&
          ((this._rawValue = e),
          (this._value = r ? e : Jt(e)),
          this.dep.trigger()));
    }
  }
  function he(t) {
    return Pt(t) ? t.value : t;
  }
  const z6 = {
    get: (t, e, n) => (e === '__v_raw' ? t : he(Reflect.get(t, e, n))),
    set: (t, e, n, r) => {
      const i = t[e];
      return Pt(i) && !Pt(n) ? ((i.value = n), !0) : Reflect.set(t, e, n, r);
    }
  };
  function GE(t) {
    return Ks(t) ? t : new Proxy(t, z6);
  }
  function W6(t) {
    const e = Me(t) ? new Array(t.length) : {};
    for (const n in t) e[n] = Y6(t, n);
    return e;
  }
  class Z6 {
    constructor(e, n, r) {
      ((this._object = e),
        (this._key = n),
        (this._defaultValue = r),
        (this.__v_isRef = !0),
        (this._value = void 0));
    }
    get value() {
      const e = this._object[this._key];
      return (this._value = e === void 0 ? this._defaultValue : e);
    }
    set value(e) {
      this._object[this._key] = e;
    }
    get dep() {
      return I6(He(this._object), this._key);
    }
  }
  function Y6(t, e, n) {
    const r = t[e];
    return Pt(r) ? r : new Z6(t, e, n);
  }
  class Q6 {
    constructor(e, n, r) {
      ((this.fn = e),
        (this.setter = n),
        (this._value = void 0),
        (this.dep = new Ey(this)),
        (this.__v_isRef = !0),
        (this.deps = void 0),
        (this.depsTail = void 0),
        (this.flags = 16),
        (this.globalVersion = Pl - 1),
        (this.next = void 0),
        (this.effect = this),
        (this.__v_isReadonly = !n),
        (this.isSSR = r));
    }
    notify() {
      if (((this.flags |= 16), !(this.flags & 8) && yt !== this))
        return (PE(this, !0), !0);
    }
    get value() {
      const e = this.dep.track();
      return (NE(this), e && (e.version = this.dep.version), this._value);
    }
    set value(e) {
      this.setter && this.setter(e);
    }
  }
  function J6(t, e, n = !1) {
    let r, i;
    return (je(t) ? (r = t) : ((r = t.get), (i = t.set)), new Q6(r, i, n));
  }
  const Yu = {},
    _f = new WeakMap();
  let bo;
  function X6(t, e = !1, n = bo) {
    if (n) {
      let r = _f.get(n);
      (r || _f.set(n, (r = [])), r.push(t));
    }
  }
  function eI(t, e, n = pt) {
    const {
        immediate: r,
        deep: i,
        once: s,
        scheduler: o,
        augmentJob: a,
        call: c
      } = n,
      l = (x) => (i ? x : Er(x) || i === !1 || i === 0 ? Ki(x, 1) : Ki(x));
    let u,
      d,
      f,
      h,
      g = !1,
      m = !1;
    if (
      (Pt(t)
        ? ((d = () => t.value), (g = Er(t)))
        : Ks(t)
          ? ((d = () => l(t)), (g = !0))
          : Me(t)
            ? ((m = !0),
              (g = t.some((x) => Ks(x) || Er(x))),
              (d = () =>
                t.map((x) => {
                  if (Pt(x)) return x.value;
                  if (Ks(x)) return l(x);
                  if (je(x)) return c ? c(x, 2) : x();
                })))
            : je(t)
              ? e
                ? (d = c ? () => c(t, 2) : t)
                : (d = () => {
                    if (f) {
                      Ji();
                      try {
                        f();
                      } finally {
                        Xi();
                      }
                    }
                    const x = bo;
                    bo = u;
                    try {
                      return c ? c(t, 3, [h]) : t(h);
                    } finally {
                      bo = x;
                    }
                  })
              : (d = ci),
      e && i)
    ) {
      const x = d,
        C = i === !0 ? 1 / 0 : i;
      d = () => Ki(x(), C);
    }
    const y = IE(),
      p = () => {
        (u.stop(), y && y.active && gy(y.effects, u));
      };
    if (s && e) {
      const x = e;
      e = (...C) => {
        (x(...C), p());
      };
    }
    let b = m ? new Array(t.length).fill(Yu) : Yu;
    const v = (x) => {
      if (!(!(u.flags & 1) || (!u.dirty && !x)))
        if (e) {
          const C = u.run();
          if (i || g || (m ? C.some(($, G) => Us($, b[G])) : Us(C, b))) {
            f && f();
            const $ = bo;
            bo = u;
            try {
              const G = [C, b === Yu ? void 0 : m && b[0] === Yu ? [] : b, h];
              ((b = C), c ? c(e, 3, G) : e(...G));
            } finally {
              bo = $;
            }
          }
        } else u.run();
    };
    return (
      a && a(v),
      (u = new kE(d)),
      (u.scheduler = o ? () => o(v, !1) : v),
      (h = (x) => X6(x, !1, u)),
      (f = u.onStop =
        () => {
          const x = _f.get(u);
          if (x) {
            if (c) c(x, 4);
            else for (const C of x) C();
            _f.delete(u);
          }
        }),
      e ? (r ? v(!0) : (b = u.run())) : o ? o(v.bind(null, !0), !0) : u.run(),
      (p.pause = u.pause.bind(u)),
      (p.resume = u.resume.bind(u)),
      (p.stop = p),
      p
    );
  }
  function Ki(t, e = 1 / 0, n) {
    if (e <= 0 || !wt(t) || t.__v_skip || ((n = n || new Set()), n.has(t)))
      return t;
    if ((n.add(t), e--, Pt(t))) Ki(t.value, e, n);
    else if (Me(t)) for (let r = 0; r < t.length; r++) Ki(t[r], e, n);
    else if (Yh(t) || Ua(t))
      t.forEach((r) => {
        Ki(r, e, n);
      });
    else if (_E(t)) {
      for (const r in t) Ki(t[r], e, n);
      for (const r of Object.getOwnPropertySymbols(t))
        Object.prototype.propertyIsEnumerable.call(t, r) && Ki(t[r], e, n);
    }
    return t;
  }
  /**
   * @vue/runtime-core v3.5.17
   * (c) 2018-present Yuxi (Evan) You and Vue contributors
   * @license MIT
   **/ function Tu(t, e, n, r) {
    try {
      return r ? t(...r) : t();
    } catch (i) {
      tp(i, e, n);
    }
  }
  function pi(t, e, n, r) {
    if (je(t)) {
      const i = Tu(t, e, n, r);
      return (
        i &&
          bE(i) &&
          i.catch((s) => {
            tp(s, e, n);
          }),
        i
      );
    }
    if (Me(t)) {
      const i = [];
      for (let s = 0; s < t.length; s++) i.push(pi(t[s], e, n, r));
      return i;
    }
  }
  function tp(t, e, n, r = !0) {
    const i = e ? e.vnode : null,
      {errorHandler: s, throwUnhandledErrorInProduction: o} =
        (e && e.appContext.config) || pt;
    if (e) {
      let a = e.parent;
      const c = e.proxy,
        l = `https://vuejs.org/error-reference/#runtime-${n}`;
      for (; a; ) {
        const u = a.ec;
        if (u) {
          for (let d = 0; d < u.length; d++) if (u[d](t, c, l) === !1) return;
        }
        a = a.parent;
      }
      if (s) {
        (Ji(), Tu(s, null, 10, [t, c, l]), Xi());
        return;
      }
    }
    tI(t, n, i, r, o);
  }
  function tI(t, e, n, r = !0, i = !1) {
    if (i) throw t;
    console.error(t);
  }
  const En = [];
  let zr = -1;
  const Ka = [];
  let Cs = null,
    _a = 0;
  const zE = Promise.resolve();
  let Ef = null;
  function ia(t) {
    const e = Ef || zE;
    return t ? e.then(this ? t.bind(this) : t) : e;
  }
  function nI(t) {
    let e = zr + 1,
      n = En.length;
    for (; e < n; ) {
      const r = (e + n) >>> 1,
        i = En[r],
        s = Ol(i);
      s < t || (s === t && i.flags & 2) ? (e = r + 1) : (n = r);
    }
    return e;
  }
  function Ty(t) {
    if (!(t.flags & 1)) {
      const e = Ol(t),
        n = En[En.length - 1];
      (!n || (!(t.flags & 2) && e >= Ol(n))
        ? En.push(t)
        : En.splice(nI(e), 0, t),
        (t.flags |= 1),
        WE());
    }
  }
  function WE() {
    Ef || (Ef = zE.then(YE));
  }
  function rI(t) {
    (Me(t)
      ? Ka.push(...t)
      : Cs && t.id === -1
        ? Cs.splice(_a + 1, 0, t)
        : t.flags & 1 || (Ka.push(t), (t.flags |= 1)),
      WE());
  }
  function L1(t, e, n = zr + 1) {
    for (; n < En.length; n++) {
      const r = En[n];
      if (r && r.flags & 2) {
        if (t && r.id !== t.uid) continue;
        (En.splice(n, 1),
          n--,
          r.flags & 4 && (r.flags &= -2),
          r(),
          r.flags & 4 || (r.flags &= -2));
      }
    }
  }
  function ZE(t) {
    if (Ka.length) {
      const e = [...new Set(Ka)].sort((n, r) => Ol(n) - Ol(r));
      if (((Ka.length = 0), Cs)) {
        Cs.push(...e);
        return;
      }
      for (Cs = e, _a = 0; _a < Cs.length; _a++) {
        const n = Cs[_a];
        (n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), (n.flags &= -2));
      }
      ((Cs = null), (_a = 0));
    }
  }
  const Ol = (t) => (t.id == null ? (t.flags & 2 ? -1 : 1 / 0) : t.id);
  function YE(t) {
    try {
      for (zr = 0; zr < En.length; zr++) {
        const e = En[zr];
        e &&
          !(e.flags & 8) &&
          (e.flags & 4 && (e.flags &= -2),
          Tu(e, e.i, e.i ? 15 : 14),
          e.flags & 4 || (e.flags &= -2));
      }
    } finally {
      for (; zr < En.length; zr++) {
        const e = En[zr];
        e && (e.flags &= -2);
      }
      ((zr = -1),
        (En.length = 0),
        ZE(),
        (Ef = null),
        (En.length || Ka.length) && YE());
    }
  }
  let en = null,
    QE = null;
  function Af(t) {
    const e = en;
    return ((en = t), (QE = (t && t.type.__scopeId) || null), e);
  }
  function Ns(t, e = en, n) {
    if (!e || t._n) return t;
    const r = (...i) => {
      r._d && V1(-1);
      const s = Af(e);
      let o;
      try {
        o = t(...i);
      } finally {
        (Af(s), r._d && V1(1));
      }
      return o;
    };
    return ((r._n = !0), (r._c = !0), (r._d = !0), r);
  }
  function Iy(t, e) {
    if (en === null) return t;
    const n = op(en),
      r = t.dirs || (t.dirs = []);
    for (let i = 0; i < e.length; i++) {
      let [s, o, a, c = pt] = e[i];
      s &&
        (je(s) && (s = {mounted: s, updated: s}),
        s.deep && Ki(o),
        r.push({
          dir: s,
          instance: n,
          value: o,
          oldValue: void 0,
          arg: a,
          modifiers: c
        }));
    }
    return t;
  }
  function ho(t, e, n, r) {
    const i = t.dirs,
      s = e && e.dirs;
    for (let o = 0; o < i.length; o++) {
      const a = i[o];
      s && (a.oldValue = s[o].value);
      let c = a.dir[r];
      c && (Ji(), pi(c, n, 8, [t.el, a, t, e]), Xi());
    }
  }
  const iI = Symbol('_vte'),
    sI = (t) => t.__isTeleport;
  function ky(t, e) {
    t.shapeFlag & 6 && t.component
      ? ((t.transition = e), ky(t.component.subTree, e))
      : t.shapeFlag & 128
        ? ((t.ssContent.transition = e.clone(t.ssContent)),
          (t.ssFallback.transition = e.clone(t.ssFallback)))
        : (t.transition = e);
  }
  /*! #__NO_SIDE_EFFECTS__ */ function xt(t, e) {
    return je(t) ? gn({name: t.name}, e, {setup: t}) : t;
  }
  function JE(t) {
    t.ids = [t.ids[0] + t.ids[2]++ + '-', 0, 0];
  }
  function dl(t, e, n, r, i = !1) {
    if (Me(t)) {
      t.forEach((g, m) => dl(g, e && (Me(e) ? e[m] : e), n, r, i));
      return;
    }
    if (qa(r) && !i) {
      r.shapeFlag & 512 &&
        r.type.__asyncResolved &&
        r.component.subTree.component &&
        dl(t, e, n, r.component.subTree);
      return;
    }
    const s = r.shapeFlag & 4 ? op(r.component) : r.el,
      o = i ? null : s,
      {i: a, r: c} = t,
      l = e && e.r,
      u = a.refs === pt ? (a.refs = {}) : a.refs,
      d = a.setupState,
      f = He(d),
      h = d === pt ? () => !1 : (g) => ut(f, g);
    if (
      (l != null &&
        l !== c &&
        (Lt(l)
          ? ((u[l] = null), h(l) && (d[l] = null))
          : Pt(l) && (l.value = null)),
      je(c))
    )
      Tu(c, a, 12, [o, u]);
    else {
      const g = Lt(c),
        m = Pt(c);
      if (g || m) {
        const y = () => {
          if (t.f) {
            const p = g ? (h(c) ? d[c] : u[c]) : c.value;
            i
              ? Me(p) && gy(p, s)
              : Me(p)
                ? p.includes(s) || p.push(s)
                : g
                  ? ((u[c] = [s]), h(c) && (d[c] = u[c]))
                  : ((c.value = [s]), t.k && (u[t.k] = c.value));
          } else
            g
              ? ((u[c] = o), h(c) && (d[c] = o))
              : m && ((c.value = o), t.k && (u[t.k] = o));
        };
        o ? ((y.id = -1), Wn(y, n)) : y();
      }
    }
  }
  Jh().requestIdleCallback;
  Jh().cancelIdleCallback;
  const qa = (t) => !!t.type.__asyncLoader,
    XE = (t) => t.type.__isKeepAlive;
  function oI(t, e) {
    eA(t, 'a', e);
  }
  function aI(t, e) {
    eA(t, 'da', e);
  }
  function eA(t, e, n = hn) {
    const r =
      t.__wdc ||
      (t.__wdc = () => {
        let i = n;
        for (; i; ) {
          if (i.isDeactivated) return;
          i = i.parent;
        }
        return t();
      });
    if ((np(e, r, n), n)) {
      let i = n.parent;
      for (; i && i.parent; )
        (XE(i.parent.vnode) && cI(r, e, n, i), (i = i.parent));
    }
  }
  function cI(t, e, n, r) {
    const i = np(e, t, r, !0);
    rp(() => {
      gy(r[e], i);
    }, n);
  }
  function np(t, e, n = hn, r = !1) {
    if (n) {
      const i = n[t] || (n[t] = []),
        s =
          e.__weh ||
          (e.__weh = (...o) => {
            Ji();
            const a = Iu(n),
              c = pi(e, n, t, o);
            return (a(), Xi(), c);
          });
      return (r ? i.unshift(s) : i.push(s), s);
    }
  }
  const os =
      (t) =>
      (e, n = hn) => {
        (!Ll || t === 'sp') && np(t, (...r) => e(...r), n);
      },
    lI = os('bm'),
    Ic = os('m'),
    uI = os('bu'),
    dI = os('u'),
    fI = os('bum'),
    rp = os('um'),
    hI = os('sp'),
    pI = os('rtg'),
    mI = os('rtc');
  function gI(t, e = hn) {
    np('ec', t, e);
  }
  const yI = Symbol.for('v-ndc');
  function B1(t, e, n, r) {
    let i;
    const s = n,
      o = Me(t);
    if (o || Lt(t)) {
      const a = o && Ks(t);
      let c = !1,
        l = !1;
      (a && ((c = !Er(t)), (l = Qs(t)), (t = ep(t))),
        (i = new Array(t.length)));
      for (let u = 0, d = t.length; u < d; u++)
        i[u] = e(c ? (l ? wf(Jt(t[u])) : Jt(t[u])) : t[u], u, void 0, s);
    } else if (typeof t == 'number') {
      i = new Array(t);
      for (let a = 0; a < t; a++) i[a] = e(a + 1, a, void 0, s);
    } else if (wt(t))
      if (t[Symbol.iterator]) i = Array.from(t, (a, c) => e(a, c, void 0, s));
      else {
        const a = Object.keys(t);
        i = new Array(a.length);
        for (let c = 0, l = a.length; c < l; c++) {
          const u = a[c];
          i[c] = e(t[u], u, c, s);
        }
      }
    else i = [];
    return i;
  }
  function vI(t, e, n = {}, r, i) {
    if (en.ce || (en.parent && qa(en.parent) && en.parent.ce))
      return (Ce(), Sn(Dt, null, [ke('slot', n, r)], 64));
    let s = t[e];
    (s && s._c && (s._d = !1), Ce());
    const o = s && tA(s(n)),
      a = n.key || (o && o.key),
      c = Sn(
        Dt,
        {key: (a && !Dr(a) ? a : `_${e}`) + (!o && r ? '_fb' : '')},
        o || [],
        o && t._ === 1 ? 64 : -2
      );
    return (
      c.scopeId && (c.slotScopeIds = [c.scopeId + '-s']),
      s && s._c && (s._d = !0),
      c
    );
  }
  function tA(t) {
    return t.some((e) =>
      Ko(e) ? !(e.type === es || (e.type === Dt && !tA(e.children))) : !0
    )
      ? t
      : null;
  }
  const M0 = (t) => (t ? (wA(t) ? op(t) : M0(t.parent)) : null),
    fl = gn(Object.create(null), {
      $: (t) => t,
      $el: (t) => t.vnode.el,
      $data: (t) => t.data,
      $props: (t) => t.props,
      $attrs: (t) => t.attrs,
      $slots: (t) => t.slots,
      $refs: (t) => t.refs,
      $parent: (t) => M0(t.parent),
      $root: (t) => M0(t.root),
      $host: (t) => t.ce,
      $emit: (t) => t.emit,
      $options: (t) => rA(t),
      $forceUpdate: (t) =>
        t.f ||
        (t.f = () => {
          Ty(t.update);
        }),
      $nextTick: (t) => t.n || (t.n = ia.bind(t.proxy)),
      $watch: (t) => HI.bind(t)
    }),
    tm = (t, e) => t !== pt && !t.__isScriptSetup && ut(t, e),
    bI = {
      get({_: t}, e) {
        if (e === '__v_skip') return !0;
        const {
          ctx: n,
          setupState: r,
          data: i,
          props: s,
          accessCache: o,
          type: a,
          appContext: c
        } = t;
        let l;
        if (e[0] !== '$') {
          const h = o[e];
          if (h !== void 0)
            switch (h) {
              case 1:
                return r[e];
              case 2:
                return i[e];
              case 4:
                return n[e];
              case 3:
                return s[e];
            }
          else {
            if (tm(r, e)) return ((o[e] = 1), r[e]);
            if (i !== pt && ut(i, e)) return ((o[e] = 2), i[e]);
            if ((l = t.propsOptions[0]) && ut(l, e)) return ((o[e] = 3), s[e]);
            if (n !== pt && ut(n, e)) return ((o[e] = 4), n[e]);
            O0 && (o[e] = 0);
          }
        }
        const u = fl[e];
        let d, f;
        if (u) return (e === '$attrs' && dn(t.attrs, 'get', ''), u(t));
        if ((d = a.__cssModules) && (d = d[e])) return d;
        if (n !== pt && ut(n, e)) return ((o[e] = 4), n[e]);
        if (((f = c.config.globalProperties), ut(f, e))) return f[e];
      },
      set({_: t}, e, n) {
        const {data: r, setupState: i, ctx: s} = t;
        return tm(i, e)
          ? ((i[e] = n), !0)
          : r !== pt && ut(r, e)
            ? ((r[e] = n), !0)
            : ut(t.props, e) || (e[0] === '$' && e.slice(1) in t)
              ? !1
              : ((s[e] = n), !0);
      },
      has(
        {
          _: {
            data: t,
            setupState: e,
            accessCache: n,
            ctx: r,
            appContext: i,
            propsOptions: s
          }
        },
        o
      ) {
        let a;
        return (
          !!n[o] ||
          (t !== pt && ut(t, o)) ||
          tm(e, o) ||
          ((a = s[0]) && ut(a, o)) ||
          ut(r, o) ||
          ut(fl, o) ||
          ut(i.config.globalProperties, o)
        );
      },
      defineProperty(t, e, n) {
        return (
          n.get != null
            ? (t._.accessCache[e] = 0)
            : ut(n, 'value') && this.set(t, e, n.value, null),
          Reflect.defineProperty(t, e, n)
        );
      }
    };
  function D1(t) {
    return Me(t) ? t.reduce((e, n) => ((e[n] = null), e), {}) : t;
  }
  let O0 = !0;
  function wI(t) {
    const e = rA(t),
      n = t.proxy,
      r = t.ctx;
    ((O0 = !1), e.beforeCreate && F1(e.beforeCreate, t, 'bc'));
    const {
      data: i,
      computed: s,
      methods: o,
      watch: a,
      provide: c,
      inject: l,
      created: u,
      beforeMount: d,
      mounted: f,
      beforeUpdate: h,
      updated: g,
      activated: m,
      deactivated: y,
      beforeDestroy: p,
      beforeUnmount: b,
      destroyed: v,
      unmounted: x,
      render: C,
      renderTracked: $,
      renderTriggered: G,
      errorCaptured: L,
      serverPrefetch: F,
      expose: k,
      inheritAttrs: V,
      components: K,
      directives: B,
      filters: D
    } = e;
    if ((l && _I(l, r, null), o))
      for (const U in o) {
        const w = o[U];
        je(w) && (r[U] = w.bind(n));
      }
    if (i) {
      const U = i.call(n, n);
      wt(U) && (t.data = Ar(U));
    }
    if (((O0 = !0), s))
      for (const U in s) {
        const w = s[U],
          A = je(w) ? w.bind(n, n) : je(w.get) ? w.get.bind(n, n) : ci,
          T = !je(w) && je(w.set) ? w.set.bind(n) : ci,
          R = ht({get: A, set: T});
        Object.defineProperty(r, U, {
          enumerable: !0,
          configurable: !0,
          get: () => R.value,
          set: (_) => (R.value = _)
        });
      }
    if (a) for (const U in a) nA(a[U], r, n, U);
    if (c) {
      const U = je(c) ? c.call(n) : c;
      Reflect.ownKeys(U).forEach((w) => {
        Md(w, U[w]);
      });
    }
    u && F1(u, t, 'c');
    function P(U, w) {
      Me(w) ? w.forEach((A) => U(A.bind(n))) : w && U(w.bind(n));
    }
    if (
      (P(lI, d),
      P(Ic, f),
      P(uI, h),
      P(dI, g),
      P(oI, m),
      P(aI, y),
      P(gI, L),
      P(mI, $),
      P(pI, G),
      P(fI, b),
      P(rp, x),
      P(hI, F),
      Me(k))
    )
      if (k.length) {
        const U = t.exposed || (t.exposed = {});
        k.forEach((w) => {
          Object.defineProperty(U, w, {
            get: () => n[w],
            set: (A) => (n[w] = A)
          });
        });
      } else t.exposed || (t.exposed = {});
    (C && t.render === ci && (t.render = C),
      V != null && (t.inheritAttrs = V),
      K && (t.components = K),
      B && (t.directives = B),
      F && JE(t));
  }
  function _I(t, e, n = ci) {
    Me(t) && (t = N0(t));
    for (const r in t) {
      const i = t[r];
      let s;
      (wt(i)
        ? 'default' in i
          ? (s = li(i.from || r, i.default, !0))
          : (s = li(i.from || r))
        : (s = li(i)),
        Pt(s)
          ? Object.defineProperty(e, r, {
              enumerable: !0,
              configurable: !0,
              get: () => s.value,
              set: (o) => (s.value = o)
            })
          : (e[r] = s));
    }
  }
  function F1(t, e, n) {
    pi(Me(t) ? t.map((r) => r.bind(e.proxy)) : t.bind(e.proxy), e, n);
  }
  function nA(t, e, n, r) {
    let i = r.includes('.') ? mA(n, r) : () => n[r];
    if (Lt(t)) {
      const s = e[t];
      je(s) && qs(i, s);
    } else if (je(t)) qs(i, t.bind(n));
    else if (wt(t))
      if (Me(t)) t.forEach((s) => nA(s, e, n, r));
      else {
        const s = je(t.handler) ? t.handler.bind(n) : e[t.handler];
        je(s) && qs(i, s, t);
      }
  }
  function rA(t) {
    const e = t.type,
      {mixins: n, extends: r} = e,
      {
        mixins: i,
        optionsCache: s,
        config: {optionMergeStrategies: o}
      } = t.appContext,
      a = s.get(e);
    let c;
    return (
      a
        ? (c = a)
        : !i.length && !n && !r
          ? (c = e)
          : ((c = {}),
            i.length && i.forEach((l) => Sf(c, l, o, !0)),
            Sf(c, e, o)),
      wt(e) && s.set(e, c),
      c
    );
  }
  function Sf(t, e, n, r = !1) {
    const {mixins: i, extends: s} = e;
    (s && Sf(t, s, n, !0), i && i.forEach((o) => Sf(t, o, n, !0)));
    for (const o in e)
      if (!(r && o === 'expose')) {
        const a = EI[o] || (n && n[o]);
        t[o] = a ? a(t[o], e[o]) : e[o];
      }
    return t;
  }
  const EI = {
    data: $1,
    props: H1,
    emits: H1,
    methods: Xc,
    computed: Xc,
    beforeCreate: bn,
    created: bn,
    beforeMount: bn,
    mounted: bn,
    beforeUpdate: bn,
    updated: bn,
    beforeDestroy: bn,
    beforeUnmount: bn,
    destroyed: bn,
    unmounted: bn,
    activated: bn,
    deactivated: bn,
    errorCaptured: bn,
    serverPrefetch: bn,
    components: Xc,
    directives: Xc,
    watch: SI,
    provide: $1,
    inject: AI
  };
  function $1(t, e) {
    return e
      ? t
        ? function () {
            return gn(
              je(t) ? t.call(this, this) : t,
              je(e) ? e.call(this, this) : e
            );
          }
        : e
      : t;
  }
  function AI(t, e) {
    return Xc(N0(t), N0(e));
  }
  function N0(t) {
    if (Me(t)) {
      const e = {};
      for (let n = 0; n < t.length; n++) e[t[n]] = t[n];
      return e;
    }
    return t;
  }
  function bn(t, e) {
    return t ? [...new Set([].concat(t, e))] : e;
  }
  function Xc(t, e) {
    return t ? gn(Object.create(null), t, e) : e;
  }
  function H1(t, e) {
    return t
      ? Me(t) && Me(e)
        ? [...new Set([...t, ...e])]
        : gn(Object.create(null), D1(t), D1(e ?? {}))
      : e;
  }
  function SI(t, e) {
    if (!t) return e;
    if (!e) return t;
    const n = gn(Object.create(null), t);
    for (const r in e) n[r] = bn(t[r], e[r]);
    return n;
  }
  function iA() {
    return {
      app: null,
      config: {
        isNativeTag: f6,
        performance: !1,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: Object.create(null),
      optionsCache: new WeakMap(),
      propsCache: new WeakMap(),
      emitsCache: new WeakMap()
    };
  }
  let xI = 0;
  function CI(t, e) {
    return function (r, i = null) {
      (je(r) || (r = gn({}, r)), i != null && !wt(i) && (i = null));
      const s = iA(),
        o = new WeakSet(),
        a = [];
      let c = !1;
      const l = (s.app = {
        _uid: xI++,
        _component: r,
        _props: i,
        _container: null,
        _context: s,
        _instance: null,
        version: sk,
        get config() {
          return s.config;
        },
        set config(u) {},
        use(u, ...d) {
          return (
            o.has(u) ||
              (u && je(u.install)
                ? (o.add(u), u.install(l, ...d))
                : je(u) && (o.add(u), u(l, ...d))),
            l
          );
        },
        mixin(u) {
          return (s.mixins.includes(u) || s.mixins.push(u), l);
        },
        component(u, d) {
          return d ? ((s.components[u] = d), l) : s.components[u];
        },
        directive(u, d) {
          return d ? ((s.directives[u] = d), l) : s.directives[u];
        },
        mount(u, d, f) {
          if (!c) {
            const h = l._ceVNode || ke(r, i);
            return (
              (h.appContext = s),
              f === !0 ? (f = 'svg') : f === !1 && (f = void 0),
              t(h, u, f),
              (c = !0),
              (l._container = u),
              (u.__vue_app__ = l),
              op(h.component)
            );
          }
        },
        onUnmount(u) {
          a.push(u);
        },
        unmount() {
          c &&
            (pi(a, l._instance, 16),
            t(null, l._container),
            delete l._container.__vue_app__);
        },
        provide(u, d) {
          return ((s.provides[u] = d), l);
        },
        runWithContext(u) {
          const d = Lo;
          Lo = l;
          try {
            return u();
          } finally {
            Lo = d;
          }
        }
      });
      return l;
    };
  }
  let Lo = null;
  function Md(t, e) {
    if (hn) {
      let n = hn.provides;
      const r = hn.parent && hn.parent.provides;
      (r === n && (n = hn.provides = Object.create(r)), (n[t] = e));
    }
  }
  function li(t, e, n = !1) {
    const r = hn || en;
    if (r || Lo) {
      let i = Lo
        ? Lo._context.provides
        : r
          ? r.parent == null || r.ce
            ? r.vnode.appContext && r.vnode.appContext.provides
            : r.parent.provides
          : void 0;
      if (i && t in i) return i[t];
      if (arguments.length > 1) return n && je(e) ? e.call(r && r.proxy) : e;
    }
  }
  function TI() {
    return !!(hn || en || Lo);
  }
  const sA = {},
    oA = () => Object.create(sA),
    aA = (t) => Object.getPrototypeOf(t) === sA;
  function II(t, e, n, r = !1) {
    const i = {},
      s = oA();
    ((t.propsDefaults = Object.create(null)), cA(t, e, i, s));
    for (const o in t.propsOptions[0]) o in i || (i[o] = void 0);
    (n
      ? (t.props = r ? i : KE(i))
      : t.type.props
        ? (t.props = i)
        : (t.props = s),
      (t.attrs = s));
  }
  function kI(t, e, n, r) {
    const {
        props: i,
        attrs: s,
        vnode: {patchFlag: o}
      } = t,
      a = He(i),
      [c] = t.propsOptions;
    let l = !1;
    if ((r || o > 0) && !(o & 16)) {
      if (o & 8) {
        const u = t.vnode.dynamicProps;
        for (let d = 0; d < u.length; d++) {
          let f = u[d];
          if (ip(t.emitsOptions, f)) continue;
          const h = e[f];
          if (c)
            if (ut(s, f)) h !== s[f] && ((s[f] = h), (l = !0));
            else {
              const g = Ys(f);
              i[g] = L0(c, a, g, h, t, !1);
            }
          else h !== s[f] && ((s[f] = h), (l = !0));
        }
      }
    } else {
      cA(t, e, i, s) && (l = !0);
      let u;
      for (const d in a)
        (!e || (!ut(e, d) && ((u = ra(d)) === d || !ut(e, u)))) &&
          (c
            ? n &&
              (n[d] !== void 0 || n[u] !== void 0) &&
              (i[d] = L0(c, a, d, void 0, t, !0))
            : delete i[d]);
      if (s !== a)
        for (const d in s) (!e || !ut(e, d)) && (delete s[d], (l = !0));
    }
    l && Ui(t.attrs, 'set', '');
  }
  function cA(t, e, n, r) {
    const [i, s] = t.propsOptions;
    let o = !1,
      a;
    if (e)
      for (let c in e) {
        if (cl(c)) continue;
        const l = e[c];
        let u;
        i && ut(i, (u = Ys(c)))
          ? !s || !s.includes(u)
            ? (n[u] = l)
            : ((a || (a = {}))[u] = l)
          : ip(t.emitsOptions, c) ||
            ((!(c in r) || l !== r[c]) && ((r[c] = l), (o = !0)));
      }
    if (s) {
      const c = He(n),
        l = a || pt;
      for (let u = 0; u < s.length; u++) {
        const d = s[u];
        n[d] = L0(i, c, d, l[d], t, !ut(l, d));
      }
    }
    return o;
  }
  function L0(t, e, n, r, i, s) {
    const o = t[n];
    if (o != null) {
      const a = ut(o, 'default');
      if (a && r === void 0) {
        const c = o.default;
        if (o.type !== Function && !o.skipFactory && je(c)) {
          const {propsDefaults: l} = i;
          if (n in l) r = l[n];
          else {
            const u = Iu(i);
            ((r = l[n] = c.call(null, e)), u());
          }
        } else r = c;
        i.ce && i.ce._setProp(n, r);
      }
      o[0] &&
        (s && !a ? (r = !1) : o[1] && (r === '' || r === ra(n)) && (r = !0));
    }
    return r;
  }
  const RI = new WeakMap();
  function lA(t, e, n = !1) {
    const r = n ? RI : e.propsCache,
      i = r.get(t);
    if (i) return i;
    const s = t.props,
      o = {},
      a = [];
    let c = !1;
    if (!je(t)) {
      const u = (d) => {
        c = !0;
        const [f, h] = lA(d, e, !0);
        (gn(o, f), h && a.push(...h));
      };
      (!n && e.mixins.length && e.mixins.forEach(u),
        t.extends && u(t.extends),
        t.mixins && t.mixins.forEach(u));
    }
    if (!s && !c) return (wt(t) && r.set(t, ja), ja);
    if (Me(s))
      for (let u = 0; u < s.length; u++) {
        const d = Ys(s[u]);
        j1(d) && (o[d] = pt);
      }
    else if (s)
      for (const u in s) {
        const d = Ys(u);
        if (j1(d)) {
          const f = s[u],
            h = (o[d] = Me(f) || je(f) ? {type: f} : gn({}, f)),
            g = h.type;
          let m = !1,
            y = !0;
          if (Me(g))
            for (let p = 0; p < g.length; ++p) {
              const b = g[p],
                v = je(b) && b.name;
              if (v === 'Boolean') {
                m = !0;
                break;
              } else v === 'String' && (y = !1);
            }
          else m = je(g) && g.name === 'Boolean';
          ((h[0] = m), (h[1] = y), (m || ut(h, 'default')) && a.push(d));
        }
      }
    const l = [o, a];
    return (wt(t) && r.set(t, l), l);
  }
  function j1(t) {
    return t[0] !== '$' && !cl(t);
  }
  const Ry = (t) => t[0] === '_' || t === '$stable',
    Py = (t) => (Me(t) ? t.map(Zr) : [Zr(t)]),
    PI = (t, e, n) => {
      if (e._n) return e;
      const r = Ns((...i) => Py(e(...i)), n);
      return ((r._c = !1), r);
    },
    uA = (t, e, n) => {
      const r = t._ctx;
      for (const i in t) {
        if (Ry(i)) continue;
        const s = t[i];
        if (je(s)) e[i] = PI(i, s, r);
        else if (s != null) {
          const o = Py(s);
          e[i] = () => o;
        }
      }
    },
    dA = (t, e) => {
      const n = Py(e);
      t.slots.default = () => n;
    },
    fA = (t, e, n) => {
      for (const r in e) (n || !Ry(r)) && (t[r] = e[r]);
    },
    MI = (t, e, n) => {
      const r = (t.slots = oA());
      if (t.vnode.shapeFlag & 32) {
        const i = e.__;
        i && I0(r, '__', i, !0);
        const s = e._;
        s ? (fA(r, e, n), n && I0(r, '_', s, !0)) : uA(e, r);
      } else e && dA(t, e);
    },
    OI = (t, e, n) => {
      const {vnode: r, slots: i} = t;
      let s = !0,
        o = pt;
      if (r.shapeFlag & 32) {
        const a = e._;
        (a
          ? n && a === 1
            ? (s = !1)
            : fA(i, e, n)
          : ((s = !e.$stable), uA(e, i)),
          (o = e));
      } else e && (dA(t, e), (o = {default: 1}));
      if (s) for (const a in i) !Ry(a) && o[a] == null && delete i[a];
    },
    Wn = zI;
  function NI(t) {
    return LI(t);
  }
  function LI(t, e) {
    const n = Jh();
    n.__VUE__ = !0;
    const {
        insert: r,
        remove: i,
        patchProp: s,
        createElement: o,
        createText: a,
        createComment: c,
        setText: l,
        setElementText: u,
        parentNode: d,
        nextSibling: f,
        setScopeId: h = ci,
        insertStaticContent: g
      } = t,
      m = (
        N,
        j,
        W,
        J = null,
        Q = null,
        Y = null,
        se = void 0,
        ne = null,
        oe = !!j.dynamicChildren
      ) => {
        if (N === j) return;
        (N && !Hc(N, j) && ((J = M(N)), _(N, Q, Y, !0), (N = null)),
          j.patchFlag === -2 && ((oe = !1), (j.dynamicChildren = null)));
        const {type: ce, ref: fe, shapeFlag: le} = j;
        switch (ce) {
          case sp:
            y(N, j, W, J);
            break;
          case es:
            p(N, j, W, J);
            break;
          case Nd:
            N == null && b(j, W, J, se);
            break;
          case Dt:
            K(N, j, W, J, Q, Y, se, ne, oe);
            break;
          default:
            le & 1
              ? C(N, j, W, J, Q, Y, se, ne, oe)
              : le & 6
                ? B(N, j, W, J, Q, Y, se, ne, oe)
                : (le & 64 || le & 128) &&
                  ce.process(N, j, W, J, Q, Y, se, ne, oe, Z);
        }
        fe != null && Q
          ? dl(fe, N && N.ref, Y, j || N, !j)
          : fe == null && N && N.ref != null && dl(N.ref, null, Y, N, !0);
      },
      y = (N, j, W, J) => {
        if (N == null) r((j.el = a(j.children)), W, J);
        else {
          const Q = (j.el = N.el);
          j.children !== N.children && l(Q, j.children);
        }
      },
      p = (N, j, W, J) => {
        N == null ? r((j.el = c(j.children || '')), W, J) : (j.el = N.el);
      },
      b = (N, j, W, J) => {
        [N.el, N.anchor] = g(N.children, j, W, J, N.el, N.anchor);
      },
      v = ({el: N, anchor: j}, W, J) => {
        let Q;
        for (; N && N !== j; ) ((Q = f(N)), r(N, W, J), (N = Q));
        r(j, W, J);
      },
      x = ({el: N, anchor: j}) => {
        let W;
        for (; N && N !== j; ) ((W = f(N)), i(N), (N = W));
        i(j);
      },
      C = (N, j, W, J, Q, Y, se, ne, oe) => {
        (j.type === 'svg' ? (se = 'svg') : j.type === 'math' && (se = 'mathml'),
          N == null ? $(j, W, J, Q, Y, se, ne, oe) : F(N, j, Q, Y, se, ne, oe));
      },
      $ = (N, j, W, J, Q, Y, se, ne) => {
        let oe, ce;
        const {props: fe, shapeFlag: le, transition: ve, dirs: _e} = N;
        if (
          ((oe = N.el = o(N.type, Y, fe && fe.is, fe)),
          le & 8
            ? u(oe, N.children)
            : le & 16 && L(N.children, oe, null, J, Q, nm(N, Y), se, ne),
          _e && ho(N, null, J, 'created'),
          G(oe, N, N.scopeId, se, J),
          fe)
        ) {
          for (const st in fe)
            st !== 'value' && !cl(st) && s(oe, st, null, fe[st], Y, J);
          ('value' in fe && s(oe, 'value', null, fe.value, Y),
            (ce = fe.onVnodeBeforeMount) && Ur(ce, J, N));
        }
        _e && ho(N, null, J, 'beforeMount');
        const Te = BI(Q, ve);
        (Te && ve.beforeEnter(oe),
          r(oe, j, W),
          ((ce = fe && fe.onVnodeMounted) || Te || _e) &&
            Wn(() => {
              (ce && Ur(ce, J, N),
                Te && ve.enter(oe),
                _e && ho(N, null, J, 'mounted'));
            }, Q));
      },
      G = (N, j, W, J, Q) => {
        if ((W && h(N, W), J)) for (let Y = 0; Y < J.length; Y++) h(N, J[Y]);
        if (Q) {
          let Y = Q.subTree;
          if (
            j === Y ||
            (yA(Y.type) && (Y.ssContent === j || Y.ssFallback === j))
          ) {
            const se = Q.vnode;
            G(N, se, se.scopeId, se.slotScopeIds, Q.parent);
          }
        }
      },
      L = (N, j, W, J, Q, Y, se, ne, oe = 0) => {
        for (let ce = oe; ce < N.length; ce++) {
          const fe = (N[ce] = ne ? Ts(N[ce]) : Zr(N[ce]));
          m(null, fe, j, W, J, Q, Y, se, ne);
        }
      },
      F = (N, j, W, J, Q, Y, se) => {
        const ne = (j.el = N.el);
        let {patchFlag: oe, dynamicChildren: ce, dirs: fe} = j;
        oe |= N.patchFlag & 16;
        const le = N.props || pt,
          ve = j.props || pt;
        let _e;
        if (
          (W && po(W, !1),
          (_e = ve.onVnodeBeforeUpdate) && Ur(_e, W, j, N),
          fe && ho(j, N, W, 'beforeUpdate'),
          W && po(W, !0),
          ((le.innerHTML && ve.innerHTML == null) ||
            (le.textContent && ve.textContent == null)) &&
            u(ne, ''),
          ce
            ? k(N.dynamicChildren, ce, ne, W, J, nm(j, Q), Y)
            : se || w(N, j, ne, null, W, J, nm(j, Q), Y, !1),
          oe > 0)
        ) {
          if (oe & 16) V(ne, le, ve, W, Q);
          else if (
            (oe & 2 &&
              le.class !== ve.class &&
              s(ne, 'class', null, ve.class, Q),
            oe & 4 && s(ne, 'style', le.style, ve.style, Q),
            oe & 8)
          ) {
            const Te = j.dynamicProps;
            for (let st = 0; st < Te.length; st++) {
              const et = Te[st],
                zt = le[et],
                nn = ve[et];
              (nn !== zt || et === 'value') && s(ne, et, zt, nn, Q, W);
            }
          }
          oe & 1 && N.children !== j.children && u(ne, j.children);
        } else !se && ce == null && V(ne, le, ve, W, Q);
        ((_e = ve.onVnodeUpdated) || fe) &&
          Wn(() => {
            (_e && Ur(_e, W, j, N), fe && ho(j, N, W, 'updated'));
          }, J);
      },
      k = (N, j, W, J, Q, Y, se) => {
        for (let ne = 0; ne < j.length; ne++) {
          const oe = N[ne],
            ce = j[ne],
            fe =
              oe.el && (oe.type === Dt || !Hc(oe, ce) || oe.shapeFlag & 198)
                ? d(oe.el)
                : W;
          m(oe, ce, fe, null, J, Q, Y, se, !0);
        }
      },
      V = (N, j, W, J, Q) => {
        if (j !== W) {
          if (j !== pt)
            for (const Y in j) !cl(Y) && !(Y in W) && s(N, Y, j[Y], null, Q, J);
          for (const Y in W) {
            if (cl(Y)) continue;
            const se = W[Y],
              ne = j[Y];
            se !== ne && Y !== 'value' && s(N, Y, ne, se, Q, J);
          }
          'value' in W && s(N, 'value', j.value, W.value, Q);
        }
      },
      K = (N, j, W, J, Q, Y, se, ne, oe) => {
        const ce = (j.el = N ? N.el : a('')),
          fe = (j.anchor = N ? N.anchor : a(''));
        let {patchFlag: le, dynamicChildren: ve, slotScopeIds: _e} = j;
        (_e && (ne = ne ? ne.concat(_e) : _e),
          N == null
            ? (r(ce, W, J),
              r(fe, W, J),
              L(j.children || [], W, fe, Q, Y, se, ne, oe))
            : le > 0 && le & 64 && ve && N.dynamicChildren
              ? (k(N.dynamicChildren, ve, W, Q, Y, se, ne),
                (j.key != null || (Q && j === Q.subTree)) && hA(N, j, !0))
              : w(N, j, W, fe, Q, Y, se, ne, oe));
      },
      B = (N, j, W, J, Q, Y, se, ne, oe) => {
        ((j.slotScopeIds = ne),
          N == null
            ? j.shapeFlag & 512
              ? Q.ctx.activate(j, W, J, se, oe)
              : D(j, W, J, Q, Y, se, oe)
            : E(N, j, oe));
      },
      D = (N, j, W, J, Q, Y, se) => {
        const ne = (N.component = XI(N, J, Q));
        if ((XE(N) && (ne.ctx.renderer = Z), ek(ne, !1, se), ne.asyncDep)) {
          if ((Q && Q.registerDep(ne, P, se), !N.el)) {
            const oe = (ne.subTree = ke(es));
            p(null, oe, j, W);
          }
        } else P(ne, N, j, W, Q, Y, se);
      },
      E = (N, j, W) => {
        const J = (j.component = N.component);
        if (VI(N, j, W))
          if (J.asyncDep && !J.asyncResolved) {
            U(J, j, W);
            return;
          } else ((J.next = j), J.update());
        else ((j.el = N.el), (J.vnode = j));
      },
      P = (N, j, W, J, Q, Y, se) => {
        const ne = () => {
          if (N.isMounted) {
            let {next: le, bu: ve, u: _e, parent: Te, vnode: st} = N;
            {
              const or = pA(N);
              if (or) {
                (le && ((le.el = st.el), U(N, le, se)),
                  or.asyncDep.then(() => {
                    N.isUnmounted || ne();
                  }));
                return;
              }
            }
            let et = le,
              zt;
            (po(N, !1),
              le ? ((le.el = st.el), U(N, le, se)) : (le = st),
              ve && Pd(ve),
              (zt = le.props && le.props.onVnodeBeforeUpdate) &&
                Ur(zt, Te, le, st),
              po(N, !0));
            const nn = K1(N),
              rn = N.subTree;
            ((N.subTree = nn),
              m(rn, nn, d(rn.el), M(rn), N, Q, Y),
              (le.el = nn.el),
              et === null && GI(N, nn.el),
              _e && Wn(_e, Q),
              (zt = le.props && le.props.onVnodeUpdated) &&
                Wn(() => Ur(zt, Te, le, st), Q));
          } else {
            let le;
            const {el: ve, props: _e} = j,
              {bm: Te, m: st, parent: et, root: zt, type: nn} = N,
              rn = qa(j);
            (po(N, !1),
              Te && Pd(Te),
              !rn && (le = _e && _e.onVnodeBeforeMount) && Ur(le, et, j),
              po(N, !0));
            {
              zt.ce &&
                zt.ce._def.shadowRoot !== !1 &&
                zt.ce._injectChildStyle(nn);
              const or = (N.subTree = K1(N));
              (m(null, or, W, J, N, Q, Y), (j.el = or.el));
            }
            if ((st && Wn(st, Q), !rn && (le = _e && _e.onVnodeMounted))) {
              const or = j;
              Wn(() => Ur(le, et, or), Q);
            }
            ((j.shapeFlag & 256 ||
              (et && qa(et.vnode) && et.vnode.shapeFlag & 256)) &&
              N.a &&
              Wn(N.a, Q),
              (N.isMounted = !0),
              (j = W = J = null));
          }
        };
        N.scope.on();
        const oe = (N.effect = new kE(ne));
        N.scope.off();
        const ce = (N.update = oe.run.bind(oe)),
          fe = (N.job = oe.runIfDirty.bind(oe));
        ((fe.i = N),
          (fe.id = N.uid),
          (oe.scheduler = () => Ty(fe)),
          po(N, !0),
          ce());
      },
      U = (N, j, W) => {
        j.component = N;
        const J = N.vnode.props;
        ((N.vnode = j),
          (N.next = null),
          kI(N, j.props, J, W),
          OI(N, j.children, W),
          Ji(),
          L1(N),
          Xi());
      },
      w = (N, j, W, J, Q, Y, se, ne, oe = !1) => {
        const ce = N && N.children,
          fe = N ? N.shapeFlag : 0,
          le = j.children,
          {patchFlag: ve, shapeFlag: _e} = j;
        if (ve > 0) {
          if (ve & 128) {
            T(ce, le, W, J, Q, Y, se, ne, oe);
            return;
          } else if (ve & 256) {
            A(ce, le, W, J, Q, Y, se, ne, oe);
            return;
          }
        }
        _e & 8
          ? (fe & 16 && H(ce, Q, Y), le !== ce && u(W, le))
          : fe & 16
            ? _e & 16
              ? T(ce, le, W, J, Q, Y, se, ne, oe)
              : H(ce, Q, Y, !0)
            : (fe & 8 && u(W, ''), _e & 16 && L(le, W, J, Q, Y, se, ne, oe));
      },
      A = (N, j, W, J, Q, Y, se, ne, oe) => {
        ((N = N || ja), (j = j || ja));
        const ce = N.length,
          fe = j.length,
          le = Math.min(ce, fe);
        let ve;
        for (ve = 0; ve < le; ve++) {
          const _e = (j[ve] = oe ? Ts(j[ve]) : Zr(j[ve]));
          m(N[ve], _e, W, null, Q, Y, se, ne, oe);
        }
        ce > fe ? H(N, Q, Y, !0, !1, le) : L(j, W, J, Q, Y, se, ne, oe, le);
      },
      T = (N, j, W, J, Q, Y, se, ne, oe) => {
        let ce = 0;
        const fe = j.length;
        let le = N.length - 1,
          ve = fe - 1;
        for (; ce <= le && ce <= ve; ) {
          const _e = N[ce],
            Te = (j[ce] = oe ? Ts(j[ce]) : Zr(j[ce]));
          if (Hc(_e, Te)) m(_e, Te, W, null, Q, Y, se, ne, oe);
          else break;
          ce++;
        }
        for (; ce <= le && ce <= ve; ) {
          const _e = N[le],
            Te = (j[ve] = oe ? Ts(j[ve]) : Zr(j[ve]));
          if (Hc(_e, Te)) m(_e, Te, W, null, Q, Y, se, ne, oe);
          else break;
          (le--, ve--);
        }
        if (ce > le) {
          if (ce <= ve) {
            const _e = ve + 1,
              Te = _e < fe ? j[_e].el : J;
            for (; ce <= ve; )
              (m(
                null,
                (j[ce] = oe ? Ts(j[ce]) : Zr(j[ce])),
                W,
                Te,
                Q,
                Y,
                se,
                ne,
                oe
              ),
                ce++);
          }
        } else if (ce > ve) for (; ce <= le; ) (_(N[ce], Q, Y, !0), ce++);
        else {
          const _e = ce,
            Te = ce,
            st = new Map();
          for (ce = Te; ce <= ve; ce++) {
            const vn = (j[ce] = oe ? Ts(j[ce]) : Zr(j[ce]));
            vn.key != null && st.set(vn.key, ce);
          }
          let et,
            zt = 0;
          const nn = ve - Te + 1;
          let rn = !1,
            or = 0;
          const fo = new Array(nn);
          for (ce = 0; ce < nn; ce++) fo[ce] = 0;
          for (ce = _e; ce <= le; ce++) {
            const vn = N[ce];
            if (zt >= nn) {
              _(vn, Q, Y, !0);
              continue;
            }
            let Nn;
            if (vn.key != null) Nn = st.get(vn.key);
            else
              for (et = Te; et <= ve; et++)
                if (fo[et - Te] === 0 && Hc(vn, j[et])) {
                  Nn = et;
                  break;
                }
            Nn === void 0
              ? _(vn, Q, Y, !0)
              : ((fo[Nn - Te] = ce + 1),
                Nn >= or ? (or = Nn) : (rn = !0),
                m(vn, j[Nn], W, null, Q, Y, se, ne, oe),
                zt++);
          }
          const Gu = rn ? DI(fo) : ja;
          for (et = Gu.length - 1, ce = nn - 1; ce >= 0; ce--) {
            const vn = Te + ce,
              Nn = j[vn],
              zu = vn + 1 < fe ? j[vn + 1].el : J;
            fo[ce] === 0
              ? m(null, Nn, W, zu, Q, Y, se, ne, oe)
              : rn && (et < 0 || ce !== Gu[et] ? R(Nn, W, zu, 2) : et--);
          }
        }
      },
      R = (N, j, W, J, Q = null) => {
        const {
          el: Y,
          type: se,
          transition: ne,
          children: oe,
          shapeFlag: ce
        } = N;
        if (ce & 6) {
          R(N.component.subTree, j, W, J);
          return;
        }
        if (ce & 128) {
          N.suspense.move(j, W, J);
          return;
        }
        if (ce & 64) {
          se.move(N, j, W, Z);
          return;
        }
        if (se === Dt) {
          r(Y, j, W);
          for (let le = 0; le < oe.length; le++) R(oe[le], j, W, J);
          r(N.anchor, j, W);
          return;
        }
        if (se === Nd) {
          v(N, j, W);
          return;
        }
        if (J !== 2 && ce & 1 && ne)
          if (J === 0)
            (ne.beforeEnter(Y), r(Y, j, W), Wn(() => ne.enter(Y), Q));
          else {
            const {leave: le, delayLeave: ve, afterLeave: _e} = ne,
              Te = () => {
                N.ctx.isUnmounted ? i(Y) : r(Y, j, W);
              },
              st = () => {
                le(Y, () => {
                  (Te(), _e && _e());
                });
              };
            ve ? ve(Y, Te, st) : st();
          }
        else r(Y, j, W);
      },
      _ = (N, j, W, J = !1, Q = !1) => {
        const {
          type: Y,
          props: se,
          ref: ne,
          children: oe,
          dynamicChildren: ce,
          shapeFlag: fe,
          patchFlag: le,
          dirs: ve,
          cacheIndex: _e
        } = N;
        if (
          (le === -2 && (Q = !1),
          ne != null && (Ji(), dl(ne, null, W, N, !0), Xi()),
          _e != null && (j.renderCache[_e] = void 0),
          fe & 256)
        ) {
          j.ctx.deactivate(N);
          return;
        }
        const Te = fe & 1 && ve,
          st = !qa(N);
        let et;
        if (
          (st && (et = se && se.onVnodeBeforeUnmount) && Ur(et, j, N), fe & 6)
        )
          O(N.component, W, J);
        else {
          if (fe & 128) {
            N.suspense.unmount(W, J);
            return;
          }
          (Te && ho(N, null, j, 'beforeUnmount'),
            fe & 64
              ? N.type.remove(N, j, W, Z, J)
              : ce && !ce.hasOnce && (Y !== Dt || (le > 0 && le & 64))
                ? H(ce, j, W, !1, !0)
                : ((Y === Dt && le & 384) || (!Q && fe & 16)) && H(oe, j, W),
            J && S(N));
        }
        ((st && (et = se && se.onVnodeUnmounted)) || Te) &&
          Wn(() => {
            (et && Ur(et, j, N), Te && ho(N, null, j, 'unmounted'));
          }, W);
      },
      S = (N) => {
        const {type: j, el: W, anchor: J, transition: Q} = N;
        if (j === Dt) {
          I(W, J);
          return;
        }
        if (j === Nd) {
          x(N);
          return;
        }
        const Y = () => {
          (i(W), Q && !Q.persisted && Q.afterLeave && Q.afterLeave());
        };
        if (N.shapeFlag & 1 && Q && !Q.persisted) {
          const {leave: se, delayLeave: ne} = Q,
            oe = () => se(W, Y);
          ne ? ne(N.el, Y, oe) : oe();
        } else Y();
      },
      I = (N, j) => {
        let W;
        for (; N !== j; ) ((W = f(N)), i(N), (N = W));
        i(j);
      },
      O = (N, j, W) => {
        const {
          bum: J,
          scope: Q,
          job: Y,
          subTree: se,
          um: ne,
          m: oe,
          a: ce,
          parent: fe,
          slots: {__: le}
        } = N;
        (U1(oe),
          U1(ce),
          J && Pd(J),
          fe &&
            Me(le) &&
            le.forEach((ve) => {
              fe.renderCache[ve] = void 0;
            }),
          Q.stop(),
          Y && ((Y.flags |= 8), _(se, N, j, W)),
          ne && Wn(ne, j),
          Wn(() => {
            N.isUnmounted = !0;
          }, j),
          j &&
            j.pendingBranch &&
            !j.isUnmounted &&
            N.asyncDep &&
            !N.asyncResolved &&
            N.suspenseId === j.pendingId &&
            (j.deps--, j.deps === 0 && j.resolve()));
      },
      H = (N, j, W, J = !1, Q = !1, Y = 0) => {
        for (let se = Y; se < N.length; se++) _(N[se], j, W, J, Q);
      },
      M = (N) => {
        if (N.shapeFlag & 6) return M(N.component.subTree);
        if (N.shapeFlag & 128) return N.suspense.next();
        const j = f(N.anchor || N.el),
          W = j && j[iI];
        return W ? f(W) : j;
      };
    let q = !1;
    const z = (N, j, W) => {
        (N == null
          ? j._vnode && _(j._vnode, null, null, !0)
          : m(j._vnode || null, N, j, null, null, null, W),
          (j._vnode = N),
          q || ((q = !0), L1(), ZE(), (q = !1)));
      },
      Z = {p: m, um: _, m: R, r: S, mt: D, mc: L, pc: w, pbc: k, n: M, o: t};
    return {render: z, hydrate: void 0, createApp: CI(z)};
  }
  function nm({type: t, props: e}, n) {
    return (n === 'svg' && t === 'foreignObject') ||
      (n === 'mathml' &&
        t === 'annotation-xml' &&
        e &&
        e.encoding &&
        e.encoding.includes('html'))
      ? void 0
      : n;
  }
  function po({effect: t, job: e}, n) {
    n ? ((t.flags |= 32), (e.flags |= 4)) : ((t.flags &= -33), (e.flags &= -5));
  }
  function BI(t, e) {
    return (!t || (t && !t.pendingBranch)) && e && !e.persisted;
  }
  function hA(t, e, n = !1) {
    const r = t.children,
      i = e.children;
    if (Me(r) && Me(i))
      for (let s = 0; s < r.length; s++) {
        const o = r[s];
        let a = i[s];
        (a.shapeFlag & 1 &&
          !a.dynamicChildren &&
          ((a.patchFlag <= 0 || a.patchFlag === 32) &&
            ((a = i[s] = Ts(i[s])), (a.el = o.el)),
          !n && a.patchFlag !== -2 && hA(o, a)),
          a.type === sp && (a.el = o.el),
          a.type === es && !a.el && (a.el = o.el));
      }
  }
  function DI(t) {
    const e = t.slice(),
      n = [0];
    let r, i, s, o, a;
    const c = t.length;
    for (r = 0; r < c; r++) {
      const l = t[r];
      if (l !== 0) {
        if (((i = n[n.length - 1]), t[i] < l)) {
          ((e[r] = i), n.push(r));
          continue;
        }
        for (s = 0, o = n.length - 1; s < o; )
          ((a = (s + o) >> 1), t[n[a]] < l ? (s = a + 1) : (o = a));
        l < t[n[s]] && (s > 0 && (e[r] = n[s - 1]), (n[s] = r));
      }
    }
    for (s = n.length, o = n[s - 1]; s-- > 0; ) ((n[s] = o), (o = e[o]));
    return n;
  }
  function pA(t) {
    const e = t.subTree.component;
    if (e) return e.asyncDep && !e.asyncResolved ? e : pA(e);
  }
  function U1(t) {
    if (t) for (let e = 0; e < t.length; e++) t[e].flags |= 8;
  }
  const FI = Symbol.for('v-scx'),
    $I = () => li(FI);
  function Od(t, e) {
    return My(t, null, e);
  }
  function qs(t, e, n) {
    return My(t, e, n);
  }
  function My(t, e, n = pt) {
    const {immediate: r, deep: i, flush: s, once: o} = n,
      a = gn({}, n),
      c = (e && r) || (!e && s !== 'post');
    let l;
    if (Ll) {
      if (s === 'sync') {
        const h = $I();
        l = h.__watcherHandles || (h.__watcherHandles = []);
      } else if (!c) {
        const h = () => {};
        return ((h.stop = ci), (h.resume = ci), (h.pause = ci), h);
      }
    }
    const u = hn;
    a.call = (h, g, m) => pi(h, u, g, m);
    let d = !1;
    (s === 'post'
      ? (a.scheduler = (h) => {
          Wn(h, u && u.suspense);
        })
      : s !== 'sync' &&
        ((d = !0),
        (a.scheduler = (h, g) => {
          g ? h() : Ty(h);
        })),
      (a.augmentJob = (h) => {
        (e && (h.flags |= 4),
          d && ((h.flags |= 2), u && ((h.id = u.uid), (h.i = u))));
      }));
    const f = eI(t, e, a);
    return (Ll && (l ? l.push(f) : c && f()), f);
  }
  function HI(t, e, n) {
    const r = this.proxy,
      i = Lt(t) ? (t.includes('.') ? mA(r, t) : () => r[t]) : t.bind(r, r);
    let s;
    je(e) ? (s = e) : ((s = e.handler), (n = e));
    const o = Iu(this),
      a = My(i, s.bind(r), n);
    return (o(), a);
  }
  function mA(t, e) {
    const n = e.split('.');
    return () => {
      let r = t;
      for (let i = 0; i < n.length && r; i++) r = r[n[i]];
      return r;
    };
  }
  const jI = (t, e) =>
    e === 'modelValue' || e === 'model-value'
      ? t.modelModifiers
      : t[`${e}Modifiers`] || t[`${Ys(e)}Modifiers`] || t[`${ra(e)}Modifiers`];
  function UI(t, e, ...n) {
    if (t.isUnmounted) return;
    const r = t.vnode.props || pt;
    let i = n;
    const s = e.startsWith('update:'),
      o = s && jI(r, e.slice(7));
    o &&
      (o.trim && (i = n.map((u) => (Lt(u) ? u.trim() : u))),
      o.number && (i = n.map(vf)));
    let a,
      c = r[(a = Yp(e))] || r[(a = Yp(Ys(e)))];
    (!c && s && (c = r[(a = Yp(ra(e)))]), c && pi(c, t, 6, i));
    const l = r[a + 'Once'];
    if (l) {
      if (!t.emitted) t.emitted = {};
      else if (t.emitted[a]) return;
      ((t.emitted[a] = !0), pi(l, t, 6, i));
    }
  }
  function gA(t, e, n = !1) {
    const r = e.emitsCache,
      i = r.get(t);
    if (i !== void 0) return i;
    const s = t.emits;
    let o = {},
      a = !1;
    if (!je(t)) {
      const c = (l) => {
        const u = gA(l, e, !0);
        u && ((a = !0), gn(o, u));
      };
      (!n && e.mixins.length && e.mixins.forEach(c),
        t.extends && c(t.extends),
        t.mixins && t.mixins.forEach(c));
    }
    return !s && !a
      ? (wt(t) && r.set(t, null), null)
      : (Me(s) ? s.forEach((c) => (o[c] = null)) : gn(o, s),
        wt(t) && r.set(t, o),
        o);
  }
  function ip(t, e) {
    return !t || !Zh(e)
      ? !1
      : ((e = e.slice(2).replace(/Once$/, '')),
        ut(t, e[0].toLowerCase() + e.slice(1)) || ut(t, ra(e)) || ut(t, e));
  }
  function K1(t) {
    const {
        type: e,
        vnode: n,
        proxy: r,
        withProxy: i,
        propsOptions: [s],
        slots: o,
        attrs: a,
        emit: c,
        render: l,
        renderCache: u,
        props: d,
        data: f,
        setupState: h,
        ctx: g,
        inheritAttrs: m
      } = t,
      y = Af(t);
    let p, b;
    try {
      if (n.shapeFlag & 4) {
        const x = i || r,
          C = x;
        ((p = Zr(l.call(C, x, u, d, h, f, g))), (b = a));
      } else {
        const x = e;
        ((p = Zr(
          x.length > 1 ? x(d, {attrs: a, slots: o, emit: c}) : x(d, null)
        )),
          (b = e.props ? a : KI(a)));
      }
    } catch (x) {
      ((hl.length = 0), tp(x, t, 1), (p = ke(es)));
    }
    let v = p;
    if (b && m !== !1) {
      const x = Object.keys(b),
        {shapeFlag: C} = v;
      x.length &&
        C & 7 &&
        (s && x.some(my) && (b = qI(b, s)), (v = qo(v, b, !1, !0)));
    }
    return (
      n.dirs &&
        ((v = qo(v, null, !1, !0)),
        (v.dirs = v.dirs ? v.dirs.concat(n.dirs) : n.dirs)),
      n.transition && ky(v, n.transition),
      (p = v),
      Af(y),
      p
    );
  }
  const KI = (t) => {
      let e;
      for (const n in t)
        (n === 'class' || n === 'style' || Zh(n)) &&
          ((e || (e = {}))[n] = t[n]);
      return e;
    },
    qI = (t, e) => {
      const n = {};
      for (const r in t) (!my(r) || !(r.slice(9) in e)) && (n[r] = t[r]);
      return n;
    };
  function VI(t, e, n) {
    const {props: r, children: i, component: s} = t,
      {props: o, children: a, patchFlag: c} = e,
      l = s.emitsOptions;
    if (e.dirs || e.transition) return !0;
    if (n && c >= 0) {
      if (c & 1024) return !0;
      if (c & 16) return r ? q1(r, o, l) : !!o;
      if (c & 8) {
        const u = e.dynamicProps;
        for (let d = 0; d < u.length; d++) {
          const f = u[d];
          if (o[f] !== r[f] && !ip(l, f)) return !0;
        }
      }
    } else
      return (i || a) && (!a || !a.$stable)
        ? !0
        : r === o
          ? !1
          : r
            ? o
              ? q1(r, o, l)
              : !0
            : !!o;
    return !1;
  }
  function q1(t, e, n) {
    const r = Object.keys(e);
    if (r.length !== Object.keys(t).length) return !0;
    for (let i = 0; i < r.length; i++) {
      const s = r[i];
      if (e[s] !== t[s] && !ip(n, s)) return !0;
    }
    return !1;
  }
  function GI({vnode: t, parent: e}, n) {
    for (; e; ) {
      const r = e.subTree;
      if (
        (r.suspense && r.suspense.activeBranch === t && (r.el = t.el), r === t)
      )
        (((t = e.vnode).el = n), (e = e.parent));
      else break;
    }
  }
  const yA = (t) => t.__isSuspense;
  function zI(t, e) {
    e && e.pendingBranch
      ? Me(t)
        ? e.effects.push(...t)
        : e.effects.push(t)
      : rI(t);
  }
  const Dt = Symbol.for('v-fgt'),
    sp = Symbol.for('v-txt'),
    es = Symbol.for('v-cmt'),
    Nd = Symbol.for('v-stc'),
    hl = [];
  let er = null;
  function Ce(t = !1) {
    hl.push((er = t ? null : []));
  }
  function WI() {
    (hl.pop(), (er = hl[hl.length - 1] || null));
  }
  let Nl = 1;
  function V1(t, e = !1) {
    ((Nl += t), t < 0 && er && e && (er.hasOnce = !0));
  }
  function vA(t) {
    return (
      (t.dynamicChildren = Nl > 0 ? er || ja : null),
      WI(),
      Nl > 0 && er && er.push(t),
      t
    );
  }
  function qe(t, e, n, r, i, s) {
    return vA(ee(t, e, n, r, i, s, !0));
  }
  function Sn(t, e, n, r, i) {
    return vA(ke(t, e, n, r, i, !0));
  }
  function Ko(t) {
    return t ? t.__v_isVNode === !0 : !1;
  }
  function Hc(t, e) {
    return t.type === e.type && t.key === e.key;
  }
  const bA = ({key: t}) => t ?? null,
    Ld = ({ref: t, ref_key: e, ref_for: n}) => (
      typeof t == 'number' && (t = '' + t),
      t != null
        ? Lt(t) || Pt(t) || je(t)
          ? {i: en, r: t, k: e, f: !!n}
          : t
        : null
    );
  function ee(
    t,
    e = null,
    n = null,
    r = 0,
    i = null,
    s = t === Dt ? 0 : 1,
    o = !1,
    a = !1
  ) {
    const c = {
      __v_isVNode: !0,
      __v_skip: !0,
      type: t,
      props: e,
      key: e && bA(e),
      ref: e && Ld(e),
      scopeId: QE,
      slotScopeIds: null,
      children: n,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetStart: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag: s,
      patchFlag: r,
      dynamicProps: i,
      dynamicChildren: null,
      appContext: null,
      ctx: en
    };
    return (
      a
        ? (Oy(c, n), s & 128 && t.normalize(c))
        : n && (c.shapeFlag |= Lt(n) ? 8 : 16),
      Nl > 0 &&
        !o &&
        er &&
        (c.patchFlag > 0 || s & 6) &&
        c.patchFlag !== 32 &&
        er.push(c),
      c
    );
  }
  const ke = ZI;
  function ZI(t, e = null, n = null, r = 0, i = null, s = !1) {
    if (((!t || t === yI) && (t = es), Ko(t))) {
      const a = qo(t, e, !0);
      return (
        n && Oy(a, n),
        Nl > 0 &&
          !s &&
          er &&
          (a.shapeFlag & 6 ? (er[er.indexOf(t)] = a) : er.push(a)),
        (a.patchFlag = -2),
        a
      );
    }
    if ((ik(t) && (t = t.__vccOpts), e)) {
      e = YI(e);
      let {class: a, style: c} = e;
      (a && !Lt(a) && (e.class = tn(a)),
        wt(c) && (xy(c) && !Me(c) && (c = gn({}, c)), (e.style = vy(c))));
    }
    const o = Lt(t) ? 1 : yA(t) ? 128 : sI(t) ? 64 : wt(t) ? 4 : je(t) ? 2 : 0;
    return ee(t, e, n, r, i, o, s, !0);
  }
  function YI(t) {
    return t ? (xy(t) || aA(t) ? gn({}, t) : t) : null;
  }
  function qo(t, e, n = !1, r = !1) {
    const {props: i, ref: s, patchFlag: o, children: a, transition: c} = t,
      l = e ? as(i || {}, e) : i,
      u = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: t.type,
        props: l,
        key: l && bA(l),
        ref:
          e && e.ref
            ? n && s
              ? Me(s)
                ? s.concat(Ld(e))
                : [s, Ld(e)]
              : Ld(e)
            : s,
        scopeId: t.scopeId,
        slotScopeIds: t.slotScopeIds,
        children: a,
        target: t.target,
        targetStart: t.targetStart,
        targetAnchor: t.targetAnchor,
        staticCount: t.staticCount,
        shapeFlag: t.shapeFlag,
        patchFlag: e && t.type !== Dt ? (o === -1 ? 16 : o | 16) : o,
        dynamicProps: t.dynamicProps,
        dynamicChildren: t.dynamicChildren,
        appContext: t.appContext,
        dirs: t.dirs,
        transition: c,
        component: t.component,
        suspense: t.suspense,
        ssContent: t.ssContent && qo(t.ssContent),
        ssFallback: t.ssFallback && qo(t.ssFallback),
        el: t.el,
        anchor: t.anchor,
        ctx: t.ctx,
        ce: t.ce
      };
    return (c && r && ky(u, c.clone(u)), u);
  }
  function Mr(t = ' ', e = 0) {
    return ke(sp, null, t, e);
  }
  function Js(t, e) {
    const n = ke(Nd, null, t);
    return ((n.staticCount = e), n);
  }
  function rt(t = '', e = !1) {
    return e ? (Ce(), Sn(es, null, t)) : ke(es, null, t);
  }
  function Zr(t) {
    return t == null || typeof t == 'boolean'
      ? ke(es)
      : Me(t)
        ? ke(Dt, null, t.slice())
        : Ko(t)
          ? Ts(t)
          : ke(sp, null, String(t));
  }
  function Ts(t) {
    return (t.el === null && t.patchFlag !== -1) || t.memo ? t : qo(t);
  }
  function Oy(t, e) {
    let n = 0;
    const {shapeFlag: r} = t;
    if (e == null) e = null;
    else if (Me(e)) n = 16;
    else if (typeof e == 'object')
      if (r & 65) {
        const i = e.default;
        i && (i._c && (i._d = !1), Oy(t, i()), i._c && (i._d = !0));
        return;
      } else {
        n = 32;
        const i = e._;
        !i && !aA(e)
          ? (e._ctx = en)
          : i === 3 &&
            en &&
            (en.slots._ === 1 ? (e._ = 1) : ((e._ = 2), (t.patchFlag |= 1024)));
      }
    else
      je(e)
        ? ((e = {default: e, _ctx: en}), (n = 32))
        : ((e = String(e)), r & 64 ? ((n = 16), (e = [Mr(e)])) : (n = 8));
    ((t.children = e), (t.shapeFlag |= n));
  }
  function as(...t) {
    const e = {};
    for (let n = 0; n < t.length; n++) {
      const r = t[n];
      for (const i in r)
        if (i === 'class')
          e.class !== r.class && (e.class = tn([e.class, r.class]));
        else if (i === 'style') e.style = vy([e.style, r.style]);
        else if (Zh(i)) {
          const s = e[i],
            o = r[i];
          o &&
            s !== o &&
            !(Me(s) && s.includes(o)) &&
            (e[i] = s ? [].concat(s, o) : o);
        } else i !== '' && (e[i] = r[i]);
    }
    return e;
  }
  function Ur(t, e, n, r = null) {
    pi(t, e, 7, [n, r]);
  }
  const QI = iA();
  let JI = 0;
  function XI(t, e, n) {
    const r = t.type,
      i = (e ? e.appContext : t.appContext) || QI,
      s = {
        uid: JI++,
        vnode: t,
        type: r,
        parent: e,
        appContext: i,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        job: null,
        scope: new CE(!0),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: e ? e.provides : Object.create(i.provides),
        ids: e ? e.ids : ['', 0, 0],
        accessCache: null,
        renderCache: [],
        components: null,
        directives: null,
        propsOptions: lA(r, i),
        emitsOptions: gA(r, i),
        emit: null,
        emitted: null,
        propsDefaults: pt,
        inheritAttrs: r.inheritAttrs,
        ctx: pt,
        data: pt,
        props: pt,
        attrs: pt,
        slots: pt,
        refs: pt,
        setupState: pt,
        setupContext: null,
        suspense: n,
        suspenseId: n ? n.pendingId : 0,
        asyncDep: null,
        asyncResolved: !1,
        isMounted: !1,
        isUnmounted: !1,
        isDeactivated: !1,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
      };
    return (
      (s.ctx = {_: s}),
      (s.root = e ? e.root : s),
      (s.emit = UI.bind(null, s)),
      t.ce && t.ce(s),
      s
    );
  }
  let hn = null,
    xf,
    B0;
  {
    const t = Jh(),
      e = (n, r) => {
        let i;
        return (
          (i = t[n]) || (i = t[n] = []),
          i.push(r),
          (s) => {
            i.length > 1 ? i.forEach((o) => o(s)) : i[0](s);
          }
        );
      };
    ((xf = e('__VUE_INSTANCE_SETTERS__', (n) => (hn = n))),
      (B0 = e('__VUE_SSR_SETTERS__', (n) => (Ll = n))));
  }
  const Iu = (t) => {
      const e = hn;
      return (
        xf(t),
        t.scope.on(),
        () => {
          (t.scope.off(), xf(e));
        }
      );
    },
    G1 = () => {
      (hn && hn.scope.off(), xf(null));
    };
  function wA(t) {
    return t.vnode.shapeFlag & 4;
  }
  let Ll = !1;
  function ek(t, e = !1, n = !1) {
    e && B0(e);
    const {props: r, children: i} = t.vnode,
      s = wA(t);
    (II(t, r, s, e), MI(t, i, n || e));
    const o = s ? tk(t, e) : void 0;
    return (e && B0(!1), o);
  }
  function tk(t, e) {
    const n = t.type;
    ((t.accessCache = Object.create(null)), (t.proxy = new Proxy(t.ctx, bI)));
    const {setup: r} = n;
    if (r) {
      Ji();
      const i = (t.setupContext = r.length > 1 ? rk(t) : null),
        s = Iu(t),
        o = Tu(r, t, 0, [t.props, i]),
        a = bE(o);
      if ((Xi(), s(), (a || t.sp) && !qa(t) && JE(t), a)) {
        if ((o.then(G1, G1), e))
          return o
            .then((c) => {
              z1(t, c);
            })
            .catch((c) => {
              tp(c, t, 0);
            });
        t.asyncDep = o;
      } else z1(t, o);
    } else _A(t);
  }
  function z1(t, e, n) {
    (je(e)
      ? t.type.__ssrInlineRender
        ? (t.ssrRender = e)
        : (t.render = e)
      : wt(e) && (t.setupState = GE(e)),
      _A(t));
  }
  function _A(t, e, n) {
    const r = t.type;
    t.render || (t.render = r.render || ci);
    {
      const i = Iu(t);
      Ji();
      try {
        wI(t);
      } finally {
        (Xi(), i());
      }
    }
  }
  const nk = {
    get(t, e) {
      return (dn(t, 'get', ''), t[e]);
    }
  };
  function rk(t) {
    const e = (n) => {
      t.exposed = n || {};
    };
    return {
      attrs: new Proxy(t.attrs, nk),
      slots: t.slots,
      emit: t.emit,
      expose: e
    };
  }
  function op(t) {
    return t.exposed
      ? t.exposeProxy ||
          (t.exposeProxy = new Proxy(GE(Cy(t.exposed)), {
            get(e, n) {
              if (n in e) return e[n];
              if (n in fl) return fl[n](t);
            },
            has(e, n) {
              return n in e || n in fl;
            }
          }))
      : t.proxy;
  }
  function ik(t) {
    return je(t) && '__vccOpts' in t;
  }
  const ht = (t, e) => J6(t, e, Ll);
  function Ra(t, e, n) {
    const r = arguments.length;
    return r === 2
      ? wt(e) && !Me(e)
        ? Ko(e)
          ? ke(t, null, [e])
          : ke(t, e)
        : ke(t, null, e)
      : (r > 3
          ? (n = Array.prototype.slice.call(arguments, 2))
          : r === 3 && Ko(n) && (n = [n]),
        ke(t, e, n));
  }
  const sk = '3.5.17';
  /**
   * @vue/runtime-dom v3.5.17
   * (c) 2018-present Yuxi (Evan) You and Vue contributors
   * @license MIT
   **/ let D0;
  const W1 = typeof window < 'u' && window.trustedTypes;
  if (W1)
    try {
      D0 = W1.createPolicy('vue', {createHTML: (t) => t});
    } catch {}
  const EA = D0 ? (t) => D0.createHTML(t) : (t) => t,
    ok = 'http://www.w3.org/2000/svg',
    ak = 'http://www.w3.org/1998/Math/MathML',
    Ni = typeof document < 'u' ? document : null,
    Z1 = Ni && Ni.createElement('template'),
    ck = {
      insert: (t, e, n) => {
        e.insertBefore(t, n || null);
      },
      remove: (t) => {
        const e = t.parentNode;
        e && e.removeChild(t);
      },
      createElement: (t, e, n, r) => {
        const i =
          e === 'svg'
            ? Ni.createElementNS(ok, t)
            : e === 'mathml'
              ? Ni.createElementNS(ak, t)
              : n
                ? Ni.createElement(t, {is: n})
                : Ni.createElement(t);
        return (
          t === 'select' &&
            r &&
            r.multiple != null &&
            i.setAttribute('multiple', r.multiple),
          i
        );
      },
      createText: (t) => Ni.createTextNode(t),
      createComment: (t) => Ni.createComment(t),
      setText: (t, e) => {
        t.nodeValue = e;
      },
      setElementText: (t, e) => {
        t.textContent = e;
      },
      parentNode: (t) => t.parentNode,
      nextSibling: (t) => t.nextSibling,
      querySelector: (t) => Ni.querySelector(t),
      setScopeId(t, e) {
        t.setAttribute(e, '');
      },
      insertStaticContent(t, e, n, r, i, s) {
        const o = n ? n.previousSibling : e.lastChild;
        if (i && (i === s || i.nextSibling))
          for (
            ;
            e.insertBefore(i.cloneNode(!0), n),
              !(i === s || !(i = i.nextSibling));

          );
        else {
          Z1.innerHTML = EA(
            r === 'svg'
              ? `<svg>${t}</svg>`
              : r === 'mathml'
                ? `<math>${t}</math>`
                : t
          );
          const a = Z1.content;
          if (r === 'svg' || r === 'mathml') {
            const c = a.firstChild;
            for (; c.firstChild; ) a.appendChild(c.firstChild);
            a.removeChild(c);
          }
          e.insertBefore(a, n);
        }
        return [
          o ? o.nextSibling : e.firstChild,
          n ? n.previousSibling : e.lastChild
        ];
      }
    },
    lk = Symbol('_vtc');
  function uk(t, e, n) {
    const r = t[lk];
    (r && (e = (e ? [e, ...r] : [...r]).join(' ')),
      e == null
        ? t.removeAttribute('class')
        : n
          ? t.setAttribute('class', e)
          : (t.className = e));
  }
  const Y1 = Symbol('_vod'),
    dk = Symbol('_vsh'),
    fk = Symbol(''),
    hk = /(^|;)\s*display\s*:/;
  function pk(t, e, n) {
    const r = t.style,
      i = Lt(n);
    let s = !1;
    if (n && !i) {
      if (e)
        if (Lt(e))
          for (const o of e.split(';')) {
            const a = o.slice(0, o.indexOf(':')).trim();
            n[a] == null && Bd(r, a, '');
          }
        else for (const o in e) n[o] == null && Bd(r, o, '');
      for (const o in n) (o === 'display' && (s = !0), Bd(r, o, n[o]));
    } else if (i) {
      if (e !== n) {
        const o = r[fk];
        (o && (n += ';' + o), (r.cssText = n), (s = hk.test(n)));
      }
    } else e && t.removeAttribute('style');
    Y1 in t && ((t[Y1] = s ? r.display : ''), t[dk] && (r.display = 'none'));
  }
  const Q1 = /\s*!important$/;
  function Bd(t, e, n) {
    if (Me(n)) n.forEach((r) => Bd(t, e, r));
    else if ((n == null && (n = ''), e.startsWith('--'))) t.setProperty(e, n);
    else {
      const r = mk(t, e);
      Q1.test(n)
        ? t.setProperty(ra(r), n.replace(Q1, ''), 'important')
        : (t[r] = n);
    }
  }
  const J1 = ['Webkit', 'Moz', 'ms'],
    rm = {};
  function mk(t, e) {
    const n = rm[e];
    if (n) return n;
    let r = Ys(e);
    if (r !== 'filter' && r in t) return (rm[e] = r);
    r = EE(r);
    for (let i = 0; i < J1.length; i++) {
      const s = J1[i] + r;
      if (s in t) return (rm[e] = s);
    }
    return e;
  }
  const X1 = 'http://www.w3.org/1999/xlink';
  function eb(t, e, n, r, i, s = E6(e)) {
    r && e.startsWith('xlink:')
      ? n == null
        ? t.removeAttributeNS(X1, e.slice(6, e.length))
        : t.setAttributeNS(X1, e, n)
      : n == null || (s && !AE(n))
        ? t.removeAttribute(e)
        : t.setAttribute(e, s ? '' : Dr(n) ? String(n) : n);
  }
  function tb(t, e, n, r, i) {
    if (e === 'innerHTML' || e === 'textContent') {
      n != null && (t[e] = e === 'innerHTML' ? EA(n) : n);
      return;
    }
    const s = t.tagName;
    if (e === 'value' && s !== 'PROGRESS' && !s.includes('-')) {
      const a = s === 'OPTION' ? t.getAttribute('value') || '' : t.value,
        c = n == null ? (t.type === 'checkbox' ? 'on' : '') : String(n);
      ((a !== c || !('_value' in t)) && (t.value = c),
        n == null && t.removeAttribute(e),
        (t._value = n));
      return;
    }
    let o = !1;
    if (n === '' || n == null) {
      const a = typeof t[e];
      a === 'boolean'
        ? (n = AE(n))
        : n == null && a === 'string'
          ? ((n = ''), (o = !0))
          : a === 'number' && ((n = 0), (o = !0));
    }
    try {
      t[e] = n;
    } catch {}
    o && t.removeAttribute(i || e);
  }
  function Ao(t, e, n, r) {
    t.addEventListener(e, n, r);
  }
  function gk(t, e, n, r) {
    t.removeEventListener(e, n, r);
  }
  const nb = Symbol('_vei');
  function yk(t, e, n, r, i = null) {
    const s = t[nb] || (t[nb] = {}),
      o = s[e];
    if (r && o) o.value = r;
    else {
      const [a, c] = vk(e);
      if (r) {
        const l = (s[e] = _k(r, i));
        Ao(t, a, l, c);
      } else o && (gk(t, a, o, c), (s[e] = void 0));
    }
  }
  const rb = /(?:Once|Passive|Capture)$/;
  function vk(t) {
    let e;
    if (rb.test(t)) {
      e = {};
      let r;
      for (; (r = t.match(rb)); )
        ((t = t.slice(0, t.length - r[0].length)),
          (e[r[0].toLowerCase()] = !0));
    }
    return [t[2] === ':' ? t.slice(3) : ra(t.slice(2)), e];
  }
  let im = 0;
  const bk = Promise.resolve(),
    wk = () => im || (bk.then(() => (im = 0)), (im = Date.now()));
  function _k(t, e) {
    const n = (r) => {
      if (!r._vts) r._vts = Date.now();
      else if (r._vts <= n.attached) return;
      pi(Ek(r, n.value), e, 5, [r]);
    };
    return ((n.value = t), (n.attached = wk()), n);
  }
  function Ek(t, e) {
    if (Me(e)) {
      const n = t.stopImmediatePropagation;
      return (
        (t.stopImmediatePropagation = () => {
          (n.call(t), (t._stopped = !0));
        }),
        e.map((r) => (i) => !i._stopped && r && r(i))
      );
    } else return e;
  }
  const ib = (t) =>
      t.charCodeAt(0) === 111 &&
      t.charCodeAt(1) === 110 &&
      t.charCodeAt(2) > 96 &&
      t.charCodeAt(2) < 123,
    Ak = (t, e, n, r, i, s) => {
      const o = i === 'svg';
      e === 'class'
        ? uk(t, r, o)
        : e === 'style'
          ? pk(t, n, r)
          : Zh(e)
            ? my(e) || yk(t, e, n, r, s)
            : (
                  e[0] === '.'
                    ? ((e = e.slice(1)), !0)
                    : e[0] === '^'
                      ? ((e = e.slice(1)), !1)
                      : Sk(t, e, r, o)
                )
              ? (tb(t, e, r),
                !t.tagName.includes('-') &&
                  (e === 'value' || e === 'checked' || e === 'selected') &&
                  eb(t, e, r, o, s, e !== 'value'))
              : t._isVueCE && (/[A-Z]/.test(e) || !Lt(r))
                ? tb(t, Ys(e), r, s, e)
                : (e === 'true-value'
                    ? (t._trueValue = r)
                    : e === 'false-value' && (t._falseValue = r),
                  eb(t, e, r, o));
    };
  function Sk(t, e, n, r) {
    if (r)
      return !!(
        e === 'innerHTML' ||
        e === 'textContent' ||
        (e in t && ib(e) && je(n))
      );
    if (
      e === 'spellcheck' ||
      e === 'draggable' ||
      e === 'translate' ||
      e === 'autocorrect' ||
      e === 'form' ||
      (e === 'list' && t.tagName === 'INPUT') ||
      (e === 'type' && t.tagName === 'TEXTAREA')
    )
      return !1;
    if (e === 'width' || e === 'height') {
      const i = t.tagName;
      if (i === 'IMG' || i === 'VIDEO' || i === 'CANVAS' || i === 'SOURCE')
        return !1;
    }
    return ib(e) && Lt(n) ? !1 : e in t;
  }
  const Cf = (t) => {
    const e = t.props['onUpdate:modelValue'] || !1;
    return Me(e) ? (n) => Pd(e, n) : e;
  };
  function xk(t) {
    t.target.composing = !0;
  }
  function sb(t) {
    const e = t.target;
    e.composing && ((e.composing = !1), e.dispatchEvent(new Event('input')));
  }
  const Va = Symbol('_assign'),
    AA = {
      created(t, {modifiers: {lazy: e, trim: n, number: r}}, i) {
        t[Va] = Cf(i);
        const s = r || (i.props && i.props.type === 'number');
        (Ao(t, e ? 'change' : 'input', (o) => {
          if (o.target.composing) return;
          let a = t.value;
          (n && (a = a.trim()), s && (a = vf(a)), t[Va](a));
        }),
          n &&
            Ao(t, 'change', () => {
              t.value = t.value.trim();
            }),
          e ||
            (Ao(t, 'compositionstart', xk),
            Ao(t, 'compositionend', sb),
            Ao(t, 'change', sb)));
      },
      mounted(t, {value: e}) {
        t.value = e ?? '';
      },
      beforeUpdate(
        t,
        {value: e, oldValue: n, modifiers: {lazy: r, trim: i, number: s}},
        o
      ) {
        if (((t[Va] = Cf(o)), t.composing)) return;
        const a =
            (s || t.type === 'number') && !/^0\d/.test(t.value)
              ? vf(t.value)
              : t.value,
          c = e ?? '';
        a !== c &&
          ((document.activeElement === t &&
            t.type !== 'range' &&
            ((r && e === n) || (i && t.value.trim() === c))) ||
            (t.value = c));
      }
    },
    Ck = {
      deep: !0,
      created(t, {value: e, modifiers: {number: n}}, r) {
        const i = Yh(e);
        (Ao(t, 'change', () => {
          const s = Array.prototype.filter
            .call(t.options, (o) => o.selected)
            .map((o) => (n ? vf(Tf(o)) : Tf(o)));
          (t[Va](t.multiple ? (i ? new Set(s) : s) : s[0]),
            (t._assigning = !0),
            ia(() => {
              t._assigning = !1;
            }));
        }),
          (t[Va] = Cf(r)));
      },
      mounted(t, {value: e}) {
        ob(t, e);
      },
      beforeUpdate(t, e, n) {
        t[Va] = Cf(n);
      },
      updated(t, {value: e}) {
        t._assigning || ob(t, e);
      }
    };
  function ob(t, e) {
    const n = t.multiple,
      r = Me(e);
    if (!(n && !r && !Yh(e))) {
      for (let i = 0, s = t.options.length; i < s; i++) {
        const o = t.options[i],
          a = Tf(o);
        if (n)
          if (r) {
            const c = typeof a;
            c === 'string' || c === 'number'
              ? (o.selected = e.some((l) => String(l) === String(a)))
              : (o.selected = S6(e, a) > -1);
          } else o.selected = e.has(a);
        else if (Xh(Tf(o), e)) {
          t.selectedIndex !== i && (t.selectedIndex = i);
          return;
        }
      }
      !n && t.selectedIndex !== -1 && (t.selectedIndex = -1);
    }
  }
  function Tf(t) {
    return '_value' in t ? t._value : t.value;
  }
  const Tk = ['ctrl', 'shift', 'alt', 'meta'],
    Ik = {
      stop: (t) => t.stopPropagation(),
      prevent: (t) => t.preventDefault(),
      self: (t) => t.target !== t.currentTarget,
      ctrl: (t) => !t.ctrlKey,
      shift: (t) => !t.shiftKey,
      alt: (t) => !t.altKey,
      meta: (t) => !t.metaKey,
      left: (t) => 'button' in t && t.button !== 0,
      middle: (t) => 'button' in t && t.button !== 1,
      right: (t) => 'button' in t && t.button !== 2,
      exact: (t, e) => Tk.some((n) => t[`${n}Key`] && !e.includes(n))
    },
    SA = (t, e) => {
      const n = t._withMods || (t._withMods = {}),
        r = e.join('.');
      return (
        n[r] ||
        (n[r] = (i, ...s) => {
          for (let o = 0; o < e.length; o++) {
            const a = Ik[e[o]];
            if (a && a(i, e)) return;
          }
          return t(i, ...s);
        })
      );
    },
    kk = gn({patchProp: Ak}, ck);
  let ab;
  function Rk() {
    return ab || (ab = NI(kk));
  }
  const xA = (...t) => {
    const e = Rk().createApp(...t),
      {mount: n} = e;
    return (
      (e.mount = (r) => {
        const i = Mk(r);
        if (!i) return;
        const s = e._component;
        (!je(s) && !s.render && !s.template && (s.template = i.innerHTML),
          i.nodeType === 1 && (i.textContent = ''));
        const o = n(i, !1, Pk(i));
        return (
          i instanceof Element &&
            (i.removeAttribute('v-cloak'), i.setAttribute('data-v-app', '')),
          o
        );
      }),
      e
    );
  };
  function Pk(t) {
    if (t instanceof SVGElement) return 'svg';
    if (typeof MathMLElement == 'function' && t instanceof MathMLElement)
      return 'mathml';
  }
  function Mk(t) {
    return Lt(t) ? document.querySelector(t) : t;
  }
  /*!
   * pinia v3.0.3
   * (c) 2025 Eduardo San Martin Morote
   * @license MIT
   */ let CA;
  const ap = (t) => (CA = t),
    TA = Symbol();
  function F0(t) {
    return (
      t &&
      typeof t == 'object' &&
      Object.prototype.toString.call(t) === '[object Object]' &&
      typeof t.toJSON != 'function'
    );
  }
  var pl;
  (function (t) {
    ((t.direct = 'direct'),
      (t.patchObject = 'patch object'),
      (t.patchFunction = 'patch function'));
  })(pl || (pl = {}));
  function Ok() {
    const t = TE(!0),
      e = t.run(() => Pr({}));
    let n = [],
      r = [];
    const i = Cy({
      install(s) {
        (ap(i),
          (i._a = s),
          s.provide(TA, i),
          (s.config.globalProperties.$pinia = i),
          r.forEach((o) => n.push(o)),
          (r = []));
      },
      use(s) {
        return (this._a ? n.push(s) : r.push(s), this);
      },
      _p: n,
      _a: null,
      _e: t,
      _s: new Map(),
      state: e
    });
    return i;
  }
  const IA = () => {};
  function cb(t, e, n, r = IA) {
    t.push(e);
    const i = () => {
      const s = t.indexOf(e);
      s > -1 && (t.splice(s, 1), r());
    };
    return (!n && IE() && x6(i), i);
  }
  function fa(t, ...e) {
    t.slice().forEach((n) => {
      n(...e);
    });
  }
  const Nk = (t) => t(),
    lb = Symbol(),
    sm = Symbol();
  function $0(t, e) {
    t instanceof Map && e instanceof Map
      ? e.forEach((n, r) => t.set(r, n))
      : t instanceof Set && e instanceof Set && e.forEach(t.add, t);
    for (const n in e) {
      if (!e.hasOwnProperty(n)) continue;
      const r = e[n],
        i = t[n];
      F0(i) && F0(r) && t.hasOwnProperty(n) && !Pt(r) && !Ks(r)
        ? (t[n] = $0(i, r))
        : (t[n] = r);
    }
    return t;
  }
  const Lk = Symbol();
  function Bk(t) {
    return !F0(t) || !Object.prototype.hasOwnProperty.call(t, Lk);
  }
  const {assign: _s} = Object;
  function Dk(t) {
    return !!(Pt(t) && t.effect);
  }
  function Fk(t, e, n, r) {
    const {state: i, actions: s, getters: o} = e,
      a = n.state.value[t];
    let c;
    function l() {
      a || (n.state.value[t] = i ? i() : {});
      const u = W6(n.state.value[t]);
      return _s(
        u,
        s,
        Object.keys(o || {}).reduce(
          (d, f) => (
            (d[f] = Cy(
              ht(() => {
                ap(n);
                const h = n._s.get(t);
                return o[f].call(h, h);
              })
            )),
            d
          ),
          {}
        )
      );
    }
    return ((c = kA(t, l, e, n, r, !0)), c);
  }
  function kA(t, e, n = {}, r, i, s) {
    let o;
    const a = _s({actions: {}}, n),
      c = {deep: !0};
    let l,
      u,
      d = [],
      f = [],
      h;
    const g = r.state.value[t];
    (!s && !g && (r.state.value[t] = {}), Pr({}));
    let m;
    function y(L) {
      let F;
      ((l = u = !1),
        typeof L == 'function'
          ? (L(r.state.value[t]),
            (F = {type: pl.patchFunction, storeId: t, events: h}))
          : ($0(r.state.value[t], L),
            (F = {type: pl.patchObject, payload: L, storeId: t, events: h})));
      const k = (m = Symbol());
      (ia().then(() => {
        m === k && (l = !0);
      }),
        (u = !0),
        fa(d, F, r.state.value[t]));
    }
    const p = s
      ? function () {
          const {state: F} = n,
            k = F ? F() : {};
          this.$patch((V) => {
            _s(V, k);
          });
        }
      : IA;
    function b() {
      (o.stop(), (d = []), (f = []), r._s.delete(t));
    }
    const v = (L, F = '') => {
        if (lb in L) return ((L[sm] = F), L);
        const k = function () {
          ap(r);
          const V = Array.from(arguments),
            K = [],
            B = [];
          function D(U) {
            K.push(U);
          }
          function E(U) {
            B.push(U);
          }
          fa(f, {args: V, name: k[sm], store: C, after: D, onError: E});
          let P;
          try {
            P = L.apply(this && this.$id === t ? this : C, V);
          } catch (U) {
            throw (fa(B, U), U);
          }
          return P instanceof Promise
            ? P.then((U) => (fa(K, U), U)).catch(
                (U) => (fa(B, U), Promise.reject(U))
              )
            : (fa(K, P), P);
        };
        return ((k[lb] = !0), (k[sm] = F), k);
      },
      x = {
        _p: r,
        $id: t,
        $onAction: cb.bind(null, f),
        $patch: y,
        $reset: p,
        $subscribe(L, F = {}) {
          const k = cb(d, L, F.detached, () => V()),
            V = o.run(() =>
              qs(
                () => r.state.value[t],
                (K) => {
                  (F.flush === 'sync' ? u : l) &&
                    L({storeId: t, type: pl.direct, events: h}, K);
                },
                _s({}, c, F)
              )
            );
          return k;
        },
        $dispose: b
      },
      C = Ar(x);
    r._s.set(t, C);
    const G = ((r._a && r._a.runWithContext) || Nk)(() =>
      r._e.run(() => (o = TE()).run(() => e({action: v})))
    );
    for (const L in G) {
      const F = G[L];
      if ((Pt(F) && !Dk(F)) || Ks(F))
        s ||
          (g && Bk(F) && (Pt(F) ? (F.value = g[L]) : $0(F, g[L])),
          (r.state.value[t][L] = F));
      else if (typeof F == 'function') {
        const k = v(F, L);
        ((G[L] = k), (a.actions[L] = F));
      }
    }
    return (
      _s(C, G),
      _s(He(C), G),
      Object.defineProperty(C, '$state', {
        get: () => r.state.value[t],
        set: (L) => {
          y((F) => {
            _s(F, L);
          });
        }
      }),
      r._p.forEach((L) => {
        _s(
          C,
          o.run(() => L({store: C, app: r._a, pinia: r, options: a}))
        );
      }),
      g && s && n.hydrate && n.hydrate(C.$state, g),
      (l = !0),
      (u = !0),
      C
    );
  }
  /*! #__NO_SIDE_EFFECTS__ */ function $k(t, e, n) {
    let r;
    const i = typeof e == 'function';
    r = i ? n : e;
    function s(o, a) {
      const c = TI();
      return (
        (o = o || (c ? li(TA, null) : null)),
        o && ap(o),
        (o = CA),
        o._s.has(t) || (i ? kA(t, e, r, o) : Fk(t, r, o)),
        o._s.get(t)
      );
    }
    return ((s.$id = t), s);
  }
  /*!
   * vue-router v4.5.1
   * (c) 2025 Eduardo San Martin Morote
   * @license MIT
   */ const Ea = typeof document < 'u';
  function RA(t) {
    return (
      typeof t == 'object' ||
      'displayName' in t ||
      'props' in t ||
      '__vccOpts' in t
    );
  }
  function Hk(t) {
    return (
      t.__esModule ||
      t[Symbol.toStringTag] === 'Module' ||
      (t.default && RA(t.default))
    );
  }
  const lt = Object.assign;
  function om(t, e) {
    const n = {};
    for (const r in e) {
      const i = e[r];
      n[r] = Fr(i) ? i.map(t) : t(i);
    }
    return n;
  }
  const ml = () => {},
    Fr = Array.isArray,
    PA = /#/g,
    jk = /&/g,
    Uk = /\//g,
    Kk = /=/g,
    qk = /\?/g,
    MA = /\+/g,
    Vk = /%5B/g,
    Gk = /%5D/g,
    OA = /%5E/g,
    zk = /%60/g,
    NA = /%7B/g,
    Wk = /%7C/g,
    LA = /%7D/g,
    Zk = /%20/g;
  function Ny(t) {
    return encodeURI('' + t)
      .replace(Wk, '|')
      .replace(Vk, '[')
      .replace(Gk, ']');
  }
  function Yk(t) {
    return Ny(t).replace(NA, '{').replace(LA, '}').replace(OA, '^');
  }
  function H0(t) {
    return Ny(t)
      .replace(MA, '%2B')
      .replace(Zk, '+')
      .replace(PA, '%23')
      .replace(jk, '%26')
      .replace(zk, '`')
      .replace(NA, '{')
      .replace(LA, '}')
      .replace(OA, '^');
  }
  function Qk(t) {
    return H0(t).replace(Kk, '%3D');
  }
  function Jk(t) {
    return Ny(t).replace(PA, '%23').replace(qk, '%3F');
  }
  function Xk(t) {
    return t == null ? '' : Jk(t).replace(Uk, '%2F');
  }
  function Bl(t) {
    try {
      return decodeURIComponent('' + t);
    } catch {}
    return '' + t;
  }
  const e8 = /\/$/,
    t8 = (t) => t.replace(e8, '');
  function am(t, e, n = '/') {
    let r,
      i = {},
      s = '',
      o = '';
    const a = e.indexOf('#');
    let c = e.indexOf('?');
    return (
      a < c && a >= 0 && (c = -1),
      c > -1 &&
        ((r = e.slice(0, c)),
        (s = e.slice(c + 1, a > -1 ? a : e.length)),
        (i = t(s))),
      a > -1 && ((r = r || e.slice(0, a)), (o = e.slice(a, e.length))),
      (r = s8(r ?? e, n)),
      {fullPath: r + (s && '?') + s + o, path: r, query: i, hash: Bl(o)}
    );
  }
  function n8(t, e) {
    const n = e.query ? t(e.query) : '';
    return e.path + (n && '?') + n + (e.hash || '');
  }
  function ub(t, e) {
    return !e || !t.toLowerCase().startsWith(e.toLowerCase())
      ? t
      : t.slice(e.length) || '/';
  }
  function r8(t, e, n) {
    const r = e.matched.length - 1,
      i = n.matched.length - 1;
    return (
      r > -1 &&
      r === i &&
      nc(e.matched[r], n.matched[i]) &&
      BA(e.params, n.params) &&
      t(e.query) === t(n.query) &&
      e.hash === n.hash
    );
  }
  function nc(t, e) {
    return (t.aliasOf || t) === (e.aliasOf || e);
  }
  function BA(t, e) {
    if (Object.keys(t).length !== Object.keys(e).length) return !1;
    for (const n in t) if (!i8(t[n], e[n])) return !1;
    return !0;
  }
  function i8(t, e) {
    return Fr(t) ? db(t, e) : Fr(e) ? db(e, t) : t === e;
  }
  function db(t, e) {
    return Fr(e)
      ? t.length === e.length && t.every((n, r) => n === e[r])
      : t.length === 1 && t[0] === e;
  }
  function s8(t, e) {
    if (t.startsWith('/')) return t;
    if (!t) return e;
    const n = e.split('/'),
      r = t.split('/'),
      i = r[r.length - 1];
    (i === '..' || i === '.') && r.push('');
    let s = n.length - 1,
      o,
      a;
    for (o = 0; o < r.length; o++)
      if (((a = r[o]), a !== '.'))
        if (a === '..') s > 1 && s--;
        else break;
    return n.slice(0, s).join('/') + '/' + r.slice(o).join('/');
  }
  const hs = {
    path: '/',
    name: void 0,
    params: {},
    query: {},
    hash: '',
    fullPath: '/',
    matched: [],
    meta: {},
    redirectedFrom: void 0
  };
  var Dl;
  (function (t) {
    ((t.pop = 'pop'), (t.push = 'push'));
  })(Dl || (Dl = {}));
  var gl;
  (function (t) {
    ((t.back = 'back'), (t.forward = 'forward'), (t.unknown = ''));
  })(gl || (gl = {}));
  function o8(t) {
    if (!t)
      if (Ea) {
        const e = document.querySelector('base');
        ((t = (e && e.getAttribute('href')) || '/'),
          (t = t.replace(/^\w+:\/\/[^\/]+/, '')));
      } else t = '/';
    return (t[0] !== '/' && t[0] !== '#' && (t = '/' + t), t8(t));
  }
  const a8 = /^[^#]+#/;
  function c8(t, e) {
    return t.replace(a8, '#') + e;
  }
  function l8(t, e) {
    const n = document.documentElement.getBoundingClientRect(),
      r = t.getBoundingClientRect();
    return {
      behavior: e.behavior,
      left: r.left - n.left - (e.left || 0),
      top: r.top - n.top - (e.top || 0)
    };
  }
  const cp = () => ({left: window.scrollX, top: window.scrollY});
  function u8(t) {
    let e;
    if ('el' in t) {
      const n = t.el,
        r = typeof n == 'string' && n.startsWith('#'),
        i =
          typeof n == 'string'
            ? r
              ? document.getElementById(n.slice(1))
              : document.querySelector(n)
            : n;
      if (!i) return;
      e = l8(i, t);
    } else e = t;
    'scrollBehavior' in document.documentElement.style
      ? window.scrollTo(e)
      : window.scrollTo(
          e.left != null ? e.left : window.scrollX,
          e.top != null ? e.top : window.scrollY
        );
  }
  function fb(t, e) {
    return (history.state ? history.state.position - e : -1) + t;
  }
  const j0 = new Map();
  function d8(t, e) {
    j0.set(t, e);
  }
  function f8(t) {
    const e = j0.get(t);
    return (j0.delete(t), e);
  }
  let h8 = () => location.protocol + '//' + location.host;
  function DA(t, e) {
    const {pathname: n, search: r, hash: i} = e,
      s = t.indexOf('#');
    if (s > -1) {
      let a = i.includes(t.slice(s)) ? t.slice(s).length : 1,
        c = i.slice(a);
      return (c[0] !== '/' && (c = '/' + c), ub(c, ''));
    }
    return ub(n, t) + r + i;
  }
  function p8(t, e, n, r) {
    let i = [],
      s = [],
      o = null;
    const a = ({state: f}) => {
      const h = DA(t, location),
        g = n.value,
        m = e.value;
      let y = 0;
      if (f) {
        if (((n.value = h), (e.value = f), o && o === g)) {
          o = null;
          return;
        }
        y = m ? f.position - m.position : 0;
      } else r(h);
      i.forEach((p) => {
        p(n.value, g, {
          delta: y,
          type: Dl.pop,
          direction: y ? (y > 0 ? gl.forward : gl.back) : gl.unknown
        });
      });
    };
    function c() {
      o = n.value;
    }
    function l(f) {
      i.push(f);
      const h = () => {
        const g = i.indexOf(f);
        g > -1 && i.splice(g, 1);
      };
      return (s.push(h), h);
    }
    function u() {
      const {history: f} = window;
      f.state && f.replaceState(lt({}, f.state, {scroll: cp()}), '');
    }
    function d() {
      for (const f of s) f();
      ((s = []),
        window.removeEventListener('popstate', a),
        window.removeEventListener('beforeunload', u));
    }
    return (
      window.addEventListener('popstate', a),
      window.addEventListener('beforeunload', u, {passive: !0}),
      {pauseListeners: c, listen: l, destroy: d}
    );
  }
  function hb(t, e, n, r = !1, i = !1) {
    return {
      back: t,
      current: e,
      forward: n,
      replaced: r,
      position: window.history.length,
      scroll: i ? cp() : null
    };
  }
  function m8(t) {
    const {history: e, location: n} = window,
      r = {value: DA(t, n)},
      i = {value: e.state};
    i.value ||
      s(
        r.value,
        {
          back: null,
          current: r.value,
          forward: null,
          position: e.length - 1,
          replaced: !0,
          scroll: null
        },
        !0
      );
    function s(c, l, u) {
      const d = t.indexOf('#'),
        f =
          d > -1
            ? (n.host && document.querySelector('base') ? t : t.slice(d)) + c
            : h8() + t + c;
      try {
        (e[u ? 'replaceState' : 'pushState'](l, '', f), (i.value = l));
      } catch (h) {
        (console.error(h), n[u ? 'replace' : 'assign'](f));
      }
    }
    function o(c, l) {
      const u = lt({}, e.state, hb(i.value.back, c, i.value.forward, !0), l, {
        position: i.value.position
      });
      (s(c, u, !0), (r.value = c));
    }
    function a(c, l) {
      const u = lt({}, i.value, e.state, {forward: c, scroll: cp()});
      s(u.current, u, !0);
      const d = lt({}, hb(r.value, c, null), {position: u.position + 1}, l);
      (s(c, d, !1), (r.value = c));
    }
    return {location: r, state: i, push: a, replace: o};
  }
  function g8(t) {
    t = o8(t);
    const e = m8(t),
      n = p8(t, e.state, e.location, e.replace);
    function r(s, o = !0) {
      (o || n.pauseListeners(), history.go(s));
    }
    const i = lt(
      {location: '', base: t, go: r, createHref: c8.bind(null, t)},
      e,
      n
    );
    return (
      Object.defineProperty(i, 'location', {
        enumerable: !0,
        get: () => e.location.value
      }),
      Object.defineProperty(i, 'state', {
        enumerable: !0,
        get: () => e.state.value
      }),
      i
    );
  }
  function y8(t) {
    return typeof t == 'string' || (t && typeof t == 'object');
  }
  function FA(t) {
    return typeof t == 'string' || typeof t == 'symbol';
  }
  const $A = Symbol('');
  var pb;
  (function (t) {
    ((t[(t.aborted = 4)] = 'aborted'),
      (t[(t.cancelled = 8)] = 'cancelled'),
      (t[(t.duplicated = 16)] = 'duplicated'));
  })(pb || (pb = {}));
  function rc(t, e) {
    return lt(new Error(), {type: t, [$A]: !0}, e);
  }
  function xi(t, e) {
    return t instanceof Error && $A in t && (e == null || !!(t.type & e));
  }
  const mb = '[^/]+?',
    v8 = {sensitive: !1, strict: !1, start: !0, end: !0},
    b8 = /[.+*?^${}()[\]/\\]/g;
  function w8(t, e) {
    const n = lt({}, v8, e),
      r = [];
    let i = n.start ? '^' : '';
    const s = [];
    for (const l of t) {
      const u = l.length ? [] : [90];
      n.strict && !l.length && (i += '/');
      for (let d = 0; d < l.length; d++) {
        const f = l[d];
        let h = 40 + (n.sensitive ? 0.25 : 0);
        if (f.type === 0)
          (d || (i += '/'), (i += f.value.replace(b8, '\\$&')), (h += 40));
        else if (f.type === 1) {
          const {value: g, repeatable: m, optional: y, regexp: p} = f;
          s.push({name: g, repeatable: m, optional: y});
          const b = p || mb;
          if (b !== mb) {
            h += 10;
            try {
              new RegExp(`(${b})`);
            } catch (x) {
              throw new Error(
                `Invalid custom RegExp for param "${g}" (${b}): ` + x.message
              );
            }
          }
          let v = m ? `((?:${b})(?:/(?:${b}))*)` : `(${b})`;
          (d || (v = y && l.length < 2 ? `(?:/${v})` : '/' + v),
            y && (v += '?'),
            (i += v),
            (h += 20),
            y && (h += -8),
            m && (h += -20),
            b === '.*' && (h += -50));
        }
        u.push(h);
      }
      r.push(u);
    }
    if (n.strict && n.end) {
      const l = r.length - 1;
      r[l][r[l].length - 1] += 0.7000000000000001;
    }
    (n.strict || (i += '/?'),
      n.end ? (i += '$') : n.strict && !i.endsWith('/') && (i += '(?:/|$)'));
    const o = new RegExp(i, n.sensitive ? '' : 'i');
    function a(l) {
      const u = l.match(o),
        d = {};
      if (!u) return null;
      for (let f = 1; f < u.length; f++) {
        const h = u[f] || '',
          g = s[f - 1];
        d[g.name] = h && g.repeatable ? h.split('/') : h;
      }
      return d;
    }
    function c(l) {
      let u = '',
        d = !1;
      for (const f of t) {
        ((!d || !u.endsWith('/')) && (u += '/'), (d = !1));
        for (const h of f)
          if (h.type === 0) u += h.value;
          else if (h.type === 1) {
            const {value: g, repeatable: m, optional: y} = h,
              p = g in l ? l[g] : '';
            if (Fr(p) && !m)
              throw new Error(
                `Provided param "${g}" is an array but it is not repeatable (* or + modifiers)`
              );
            const b = Fr(p) ? p.join('/') : p;
            if (!b)
              if (y)
                f.length < 2 &&
                  (u.endsWith('/') ? (u = u.slice(0, -1)) : (d = !0));
              else throw new Error(`Missing required param "${g}"`);
            u += b;
          }
      }
      return u || '/';
    }
    return {re: o, score: r, keys: s, parse: a, stringify: c};
  }
  function _8(t, e) {
    let n = 0;
    for (; n < t.length && n < e.length; ) {
      const r = e[n] - t[n];
      if (r) return r;
      n++;
    }
    return t.length < e.length
      ? t.length === 1 && t[0] === 80
        ? -1
        : 1
      : t.length > e.length
        ? e.length === 1 && e[0] === 80
          ? 1
          : -1
        : 0;
  }
  function HA(t, e) {
    let n = 0;
    const r = t.score,
      i = e.score;
    for (; n < r.length && n < i.length; ) {
      const s = _8(r[n], i[n]);
      if (s) return s;
      n++;
    }
    if (Math.abs(i.length - r.length) === 1) {
      if (gb(r)) return 1;
      if (gb(i)) return -1;
    }
    return i.length - r.length;
  }
  function gb(t) {
    const e = t[t.length - 1];
    return t.length > 0 && e[e.length - 1] < 0;
  }
  const E8 = {type: 0, value: ''},
    A8 = /[a-zA-Z0-9_]/;
  function S8(t) {
    if (!t) return [[]];
    if (t === '/') return [[E8]];
    if (!t.startsWith('/')) throw new Error(`Invalid path "${t}"`);
    function e(h) {
      throw new Error(`ERR (${n})/"${l}": ${h}`);
    }
    let n = 0,
      r = n;
    const i = [];
    let s;
    function o() {
      (s && i.push(s), (s = []));
    }
    let a = 0,
      c,
      l = '',
      u = '';
    function d() {
      l &&
        (n === 0
          ? s.push({type: 0, value: l})
          : n === 1 || n === 2 || n === 3
            ? (s.length > 1 &&
                (c === '*' || c === '+') &&
                e(
                  `A repeatable param (${l}) must be alone in its segment. eg: '/:ids+.`
                ),
              s.push({
                type: 1,
                value: l,
                regexp: u,
                repeatable: c === '*' || c === '+',
                optional: c === '*' || c === '?'
              }))
            : e('Invalid state to consume buffer'),
        (l = ''));
    }
    function f() {
      l += c;
    }
    for (; a < t.length; ) {
      if (((c = t[a++]), c === '\\' && n !== 2)) {
        ((r = n), (n = 4));
        continue;
      }
      switch (n) {
        case 0:
          c === '/' ? (l && d(), o()) : c === ':' ? (d(), (n = 1)) : f();
          break;
        case 4:
          (f(), (n = r));
          break;
        case 1:
          c === '('
            ? (n = 2)
            : A8.test(c)
              ? f()
              : (d(), (n = 0), c !== '*' && c !== '?' && c !== '+' && a--);
          break;
        case 2:
          c === ')'
            ? u[u.length - 1] == '\\'
              ? (u = u.slice(0, -1) + c)
              : (n = 3)
            : (u += c);
          break;
        case 3:
          (d(), (n = 0), c !== '*' && c !== '?' && c !== '+' && a--, (u = ''));
          break;
        default:
          e('Unknown state');
          break;
      }
    }
    return (
      n === 2 && e(`Unfinished custom RegExp for param "${l}"`),
      d(),
      o(),
      i
    );
  }
  function x8(t, e, n) {
    const r = w8(S8(t.path), n),
      i = lt(r, {record: t, parent: e, children: [], alias: []});
    return (
      e && !i.record.aliasOf == !e.record.aliasOf && e.children.push(i),
      i
    );
  }
  function C8(t, e) {
    const n = [],
      r = new Map();
    e = wb({strict: !1, end: !0, sensitive: !1}, e);
    function i(d) {
      return r.get(d);
    }
    function s(d, f, h) {
      const g = !h,
        m = vb(d);
      m.aliasOf = h && h.record;
      const y = wb(e, d),
        p = [m];
      if ('alias' in d) {
        const x = typeof d.alias == 'string' ? [d.alias] : d.alias;
        for (const C of x)
          p.push(
            vb(
              lt({}, m, {
                components: h ? h.record.components : m.components,
                path: C,
                aliasOf: h ? h.record : m
              })
            )
          );
      }
      let b, v;
      for (const x of p) {
        const {path: C} = x;
        if (f && C[0] !== '/') {
          const $ = f.record.path,
            G = $[$.length - 1] === '/' ? '' : '/';
          x.path = f.record.path + (C && G + C);
        }
        if (
          ((b = x8(x, f, y)),
          h
            ? h.alias.push(b)
            : ((v = v || b),
              v !== b && v.alias.push(b),
              g && d.name && !bb(b) && o(d.name)),
          jA(b) && c(b),
          m.children)
        ) {
          const $ = m.children;
          for (let G = 0; G < $.length; G++) s($[G], b, h && h.children[G]);
        }
        h = h || b;
      }
      return v
        ? () => {
            o(v);
          }
        : ml;
    }
    function o(d) {
      if (FA(d)) {
        const f = r.get(d);
        f &&
          (r.delete(d),
          n.splice(n.indexOf(f), 1),
          f.children.forEach(o),
          f.alias.forEach(o));
      } else {
        const f = n.indexOf(d);
        f > -1 &&
          (n.splice(f, 1),
          d.record.name && r.delete(d.record.name),
          d.children.forEach(o),
          d.alias.forEach(o));
      }
    }
    function a() {
      return n;
    }
    function c(d) {
      const f = k8(d, n);
      (n.splice(f, 0, d), d.record.name && !bb(d) && r.set(d.record.name, d));
    }
    function l(d, f) {
      let h,
        g = {},
        m,
        y;
      if ('name' in d && d.name) {
        if (((h = r.get(d.name)), !h)) throw rc(1, {location: d});
        ((y = h.record.name),
          (g = lt(
            yb(
              f.params,
              h.keys
                .filter((v) => !v.optional)
                .concat(h.parent ? h.parent.keys.filter((v) => v.optional) : [])
                .map((v) => v.name)
            ),
            d.params &&
              yb(
                d.params,
                h.keys.map((v) => v.name)
              )
          )),
          (m = h.stringify(g)));
      } else if (d.path != null)
        ((m = d.path),
          (h = n.find((v) => v.re.test(m))),
          h && ((g = h.parse(m)), (y = h.record.name)));
      else {
        if (
          ((h = f.name ? r.get(f.name) : n.find((v) => v.re.test(f.path))), !h)
        )
          throw rc(1, {location: d, currentLocation: f});
        ((y = h.record.name),
          (g = lt({}, f.params, d.params)),
          (m = h.stringify(g)));
      }
      const p = [];
      let b = h;
      for (; b; ) (p.unshift(b.record), (b = b.parent));
      return {name: y, path: m, params: g, matched: p, meta: I8(p)};
    }
    t.forEach((d) => s(d));
    function u() {
      ((n.length = 0), r.clear());
    }
    return {
      addRoute: s,
      resolve: l,
      removeRoute: o,
      clearRoutes: u,
      getRoutes: a,
      getRecordMatcher: i
    };
  }
  function yb(t, e) {
    const n = {};
    for (const r of e) r in t && (n[r] = t[r]);
    return n;
  }
  function vb(t) {
    const e = {
      path: t.path,
      redirect: t.redirect,
      name: t.name,
      meta: t.meta || {},
      aliasOf: t.aliasOf,
      beforeEnter: t.beforeEnter,
      props: T8(t),
      children: t.children || [],
      instances: {},
      leaveGuards: new Set(),
      updateGuards: new Set(),
      enterCallbacks: {},
      components:
        'components' in t
          ? t.components || null
          : t.component && {default: t.component}
    };
    return (Object.defineProperty(e, 'mods', {value: {}}), e);
  }
  function T8(t) {
    const e = {},
      n = t.props || !1;
    if ('component' in t) e.default = n;
    else for (const r in t.components) e[r] = typeof n == 'object' ? n[r] : n;
    return e;
  }
  function bb(t) {
    for (; t; ) {
      if (t.record.aliasOf) return !0;
      t = t.parent;
    }
    return !1;
  }
  function I8(t) {
    return t.reduce((e, n) => lt(e, n.meta), {});
  }
  function wb(t, e) {
    const n = {};
    for (const r in t) n[r] = r in e ? e[r] : t[r];
    return n;
  }
  function k8(t, e) {
    let n = 0,
      r = e.length;
    for (; n !== r; ) {
      const s = (n + r) >> 1;
      HA(t, e[s]) < 0 ? (r = s) : (n = s + 1);
    }
    const i = R8(t);
    return (i && (r = e.lastIndexOf(i, r - 1)), r);
  }
  function R8(t) {
    let e = t;
    for (; (e = e.parent); ) if (jA(e) && HA(t, e) === 0) return e;
  }
  function jA({record: t}) {
    return !!(
      t.name ||
      (t.components && Object.keys(t.components).length) ||
      t.redirect
    );
  }
  function P8(t) {
    const e = {};
    if (t === '' || t === '?') return e;
    const r = (t[0] === '?' ? t.slice(1) : t).split('&');
    for (let i = 0; i < r.length; ++i) {
      const s = r[i].replace(MA, ' '),
        o = s.indexOf('='),
        a = Bl(o < 0 ? s : s.slice(0, o)),
        c = o < 0 ? null : Bl(s.slice(o + 1));
      if (a in e) {
        let l = e[a];
        (Fr(l) || (l = e[a] = [l]), l.push(c));
      } else e[a] = c;
    }
    return e;
  }
  function _b(t) {
    let e = '';
    for (let n in t) {
      const r = t[n];
      if (((n = Qk(n)), r == null)) {
        r !== void 0 && (e += (e.length ? '&' : '') + n);
        continue;
      }
      (Fr(r) ? r.map((s) => s && H0(s)) : [r && H0(r)]).forEach((s) => {
        s !== void 0 &&
          ((e += (e.length ? '&' : '') + n), s != null && (e += '=' + s));
      });
    }
    return e;
  }
  function M8(t) {
    const e = {};
    for (const n in t) {
      const r = t[n];
      r !== void 0 &&
        (e[n] = Fr(r)
          ? r.map((i) => (i == null ? null : '' + i))
          : r == null
            ? r
            : '' + r);
    }
    return e;
  }
  const O8 = Symbol(''),
    Eb = Symbol(''),
    Ly = Symbol(''),
    UA = Symbol(''),
    U0 = Symbol('');
  function jc() {
    let t = [];
    function e(r) {
      return (
        t.push(r),
        () => {
          const i = t.indexOf(r);
          i > -1 && t.splice(i, 1);
        }
      );
    }
    function n() {
      t = [];
    }
    return {add: e, list: () => t.slice(), reset: n};
  }
  function Is(t, e, n, r, i, s = (o) => o()) {
    const o = r && (r.enterCallbacks[i] = r.enterCallbacks[i] || []);
    return () =>
      new Promise((a, c) => {
        const l = (f) => {
            f === !1
              ? c(rc(4, {from: n, to: e}))
              : f instanceof Error
                ? c(f)
                : y8(f)
                  ? c(rc(2, {from: e, to: f}))
                  : (o &&
                      r.enterCallbacks[i] === o &&
                      typeof f == 'function' &&
                      o.push(f),
                    a());
          },
          u = s(() => t.call(r && r.instances[i], e, n, l));
        let d = Promise.resolve(u);
        (t.length < 3 && (d = d.then(l)), d.catch((f) => c(f)));
      });
  }
  function cm(t, e, n, r, i = (s) => s()) {
    const s = [];
    for (const o of t)
      for (const a in o.components) {
        let c = o.components[a];
        if (!(e !== 'beforeRouteEnter' && !o.instances[a]))
          if (RA(c)) {
            const u = (c.__vccOpts || c)[e];
            u && s.push(Is(u, n, r, o, a, i));
          } else {
            let l = c();
            s.push(() =>
              l.then((u) => {
                if (!u)
                  throw new Error(
                    `Couldn't resolve component "${a}" at "${o.path}"`
                  );
                const d = Hk(u) ? u.default : u;
                ((o.mods[a] = u), (o.components[a] = d));
                const h = (d.__vccOpts || d)[e];
                return h && Is(h, n, r, o, a, i)();
              })
            );
          }
      }
    return s;
  }
  function Ab(t) {
    const e = li(Ly),
      n = li(UA),
      r = ht(() => {
        const c = he(t.to);
        return e.resolve(c);
      }),
      i = ht(() => {
        const {matched: c} = r.value,
          {length: l} = c,
          u = c[l - 1],
          d = n.matched;
        if (!u || !d.length) return -1;
        const f = d.findIndex(nc.bind(null, u));
        if (f > -1) return f;
        const h = Sb(c[l - 2]);
        return l > 1 && Sb(u) === h && d[d.length - 1].path !== h
          ? d.findIndex(nc.bind(null, c[l - 2]))
          : f;
      }),
      s = ht(() => i.value > -1 && D8(n.params, r.value.params)),
      o = ht(
        () =>
          i.value > -1 &&
          i.value === n.matched.length - 1 &&
          BA(n.params, r.value.params)
      );
    function a(c = {}) {
      if (B8(c)) {
        const l = e[he(t.replace) ? 'replace' : 'push'](he(t.to)).catch(ml);
        return (
          t.viewTransition &&
            typeof document < 'u' &&
            'startViewTransition' in document &&
            document.startViewTransition(() => l),
          l
        );
      }
      return Promise.resolve();
    }
    return {
      route: r,
      href: ht(() => r.value.href),
      isActive: s,
      isExactActive: o,
      navigate: a
    };
  }
  function N8(t) {
    return t.length === 1 ? t[0] : t;
  }
  const L8 = xt({
      name: 'RouterLink',
      compatConfig: {MODE: 3},
      props: {
        to: {type: [String, Object], required: !0},
        replace: Boolean,
        activeClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {type: String, default: 'page'},
        viewTransition: Boolean
      },
      useLink: Ab,
      setup(t, {slots: e}) {
        const n = Ar(Ab(t)),
          {options: r} = li(Ly),
          i = ht(() => ({
            [xb(t.activeClass, r.linkActiveClass, 'router-link-active')]:
              n.isActive,
            [xb(
              t.exactActiveClass,
              r.linkExactActiveClass,
              'router-link-exact-active'
            )]: n.isExactActive
          }));
        return () => {
          const s = e.default && N8(e.default(n));
          return t.custom
            ? s
            : Ra(
                'a',
                {
                  'aria-current': n.isExactActive ? t.ariaCurrentValue : null,
                  href: n.href,
                  onClick: n.navigate,
                  class: i.value
                },
                s
              );
        };
      }
    }),
    KA = L8;
  function B8(t) {
    if (
      !(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) &&
      !t.defaultPrevented &&
      !(t.button !== void 0 && t.button !== 0)
    ) {
      if (t.currentTarget && t.currentTarget.getAttribute) {
        const e = t.currentTarget.getAttribute('target');
        if (/\b_blank\b/i.test(e)) return;
      }
      return (t.preventDefault && t.preventDefault(), !0);
    }
  }
  function D8(t, e) {
    for (const n in e) {
      const r = e[n],
        i = t[n];
      if (typeof r == 'string') {
        if (r !== i) return !1;
      } else if (
        !Fr(i) ||
        i.length !== r.length ||
        r.some((s, o) => s !== i[o])
      )
        return !1;
    }
    return !0;
  }
  function Sb(t) {
    return t ? (t.aliasOf ? t.aliasOf.path : t.path) : '';
  }
  const xb = (t, e, n) => t ?? e ?? n,
    F8 = xt({
      name: 'RouterView',
      inheritAttrs: !1,
      props: {name: {type: String, default: 'default'}, route: Object},
      compatConfig: {MODE: 3},
      setup(t, {attrs: e, slots: n}) {
        const r = li(U0),
          i = ht(() => t.route || r.value),
          s = li(Eb, 0),
          o = ht(() => {
            let l = he(s);
            const {matched: u} = i.value;
            let d;
            for (; (d = u[l]) && !d.components; ) l++;
            return l;
          }),
          a = ht(() => i.value.matched[o.value]);
        (Md(
          Eb,
          ht(() => o.value + 1)
        ),
          Md(O8, a),
          Md(U0, i));
        const c = Pr();
        return (
          qs(
            () => [c.value, a.value, t.name],
            ([l, u, d], [f, h, g]) => {
              (u &&
                ((u.instances[d] = l),
                h &&
                  h !== u &&
                  l &&
                  l === f &&
                  (u.leaveGuards.size || (u.leaveGuards = h.leaveGuards),
                  u.updateGuards.size || (u.updateGuards = h.updateGuards))),
                l &&
                  u &&
                  (!h || !nc(u, h) || !f) &&
                  (u.enterCallbacks[d] || []).forEach((m) => m(l)));
            },
            {flush: 'post'}
          ),
          () => {
            const l = i.value,
              u = t.name,
              d = a.value,
              f = d && d.components[u];
            if (!f) return Cb(n.default, {Component: f, route: l});
            const h = d.props[u],
              g = h
                ? h === !0
                  ? l.params
                  : typeof h == 'function'
                    ? h(l)
                    : h
                : null,
              y = Ra(
                f,
                lt({}, g, e, {
                  onVnodeUnmounted: (p) => {
                    p.component.isUnmounted && (d.instances[u] = null);
                  },
                  ref: c
                })
              );
            return Cb(n.default, {Component: y, route: l}) || y;
          }
        );
      }
    });
  function Cb(t, e) {
    if (!t) return null;
    const n = t(e);
    return n.length === 1 ? n[0] : n;
  }
  const qA = F8;
  function $8(t) {
    const e = C8(t.routes, t),
      n = t.parseQuery || P8,
      r = t.stringifyQuery || _b,
      i = t.history,
      s = jc(),
      o = jc(),
      a = jc(),
      c = V6(hs);
    let l = hs;
    Ea &&
      t.scrollBehavior &&
      'scrollRestoration' in history &&
      (history.scrollRestoration = 'manual');
    const u = om.bind(null, (M) => '' + M),
      d = om.bind(null, Xk),
      f = om.bind(null, Bl);
    function h(M, q) {
      let z, Z;
      return (
        FA(M) ? ((z = e.getRecordMatcher(M)), (Z = q)) : (Z = M),
        e.addRoute(Z, z)
      );
    }
    function g(M) {
      const q = e.getRecordMatcher(M);
      q && e.removeRoute(q);
    }
    function m() {
      return e.getRoutes().map((M) => M.record);
    }
    function y(M) {
      return !!e.getRecordMatcher(M);
    }
    function p(M, q) {
      if (((q = lt({}, q || c.value)), typeof M == 'string')) {
        const W = am(n, M, q.path),
          J = e.resolve({path: W.path}, q),
          Q = i.createHref(W.fullPath);
        return lt(W, J, {
          params: f(J.params),
          hash: Bl(W.hash),
          redirectedFrom: void 0,
          href: Q
        });
      }
      let z;
      if (M.path != null) z = lt({}, M, {path: am(n, M.path, q.path).path});
      else {
        const W = lt({}, M.params);
        for (const J in W) W[J] == null && delete W[J];
        ((z = lt({}, M, {params: d(W)})), (q.params = d(q.params)));
      }
      const Z = e.resolve(z, q),
        X = M.hash || '';
      Z.params = u(f(Z.params));
      const N = n8(r, lt({}, M, {hash: Yk(X), path: Z.path})),
        j = i.createHref(N);
      return lt(
        {fullPath: N, hash: X, query: r === _b ? M8(M.query) : M.query || {}},
        Z,
        {redirectedFrom: void 0, href: j}
      );
    }
    function b(M) {
      return typeof M == 'string' ? am(n, M, c.value.path) : lt({}, M);
    }
    function v(M, q) {
      if (l !== M) return rc(8, {from: q, to: M});
    }
    function x(M) {
      return G(M);
    }
    function C(M) {
      return x(lt(b(M), {replace: !0}));
    }
    function $(M) {
      const q = M.matched[M.matched.length - 1];
      if (q && q.redirect) {
        const {redirect: z} = q;
        let Z = typeof z == 'function' ? z(M) : z;
        return (
          typeof Z == 'string' &&
            ((Z = Z.includes('?') || Z.includes('#') ? (Z = b(Z)) : {path: Z}),
            (Z.params = {})),
          lt(
            {
              query: M.query,
              hash: M.hash,
              params: Z.path != null ? {} : M.params
            },
            Z
          )
        );
      }
    }
    function G(M, q) {
      const z = (l = p(M)),
        Z = c.value,
        X = M.state,
        N = M.force,
        j = M.replace === !0,
        W = $(z);
      if (W)
        return G(
          lt(b(W), {
            state: typeof W == 'object' ? lt({}, X, W.state) : X,
            force: N,
            replace: j
          }),
          q || z
        );
      const J = z;
      J.redirectedFrom = q;
      let Q;
      return (
        !N && r8(r, Z, z) && ((Q = rc(16, {to: J, from: Z})), R(Z, Z, !0, !1)),
        (Q ? Promise.resolve(Q) : k(J, Z))
          .catch((Y) => (xi(Y) ? (xi(Y, 2) ? Y : T(Y)) : w(Y, J, Z)))
          .then((Y) => {
            if (Y) {
              if (xi(Y, 2))
                return G(
                  lt({replace: j}, b(Y.to), {
                    state: typeof Y.to == 'object' ? lt({}, X, Y.to.state) : X,
                    force: N
                  }),
                  q || J
                );
            } else Y = K(J, Z, !0, j, X);
            return (V(J, Z, Y), Y);
          })
      );
    }
    function L(M, q) {
      const z = v(M, q);
      return z ? Promise.reject(z) : Promise.resolve();
    }
    function F(M) {
      const q = I.values().next().value;
      return q && typeof q.runWithContext == 'function'
        ? q.runWithContext(M)
        : M();
    }
    function k(M, q) {
      let z;
      const [Z, X, N] = H8(M, q);
      z = cm(Z.reverse(), 'beforeRouteLeave', M, q);
      for (const W of Z)
        W.leaveGuards.forEach((J) => {
          z.push(Is(J, M, q));
        });
      const j = L.bind(null, M, q);
      return (
        z.push(j),
        H(z)
          .then(() => {
            z = [];
            for (const W of s.list()) z.push(Is(W, M, q));
            return (z.push(j), H(z));
          })
          .then(() => {
            z = cm(X, 'beforeRouteUpdate', M, q);
            for (const W of X)
              W.updateGuards.forEach((J) => {
                z.push(Is(J, M, q));
              });
            return (z.push(j), H(z));
          })
          .then(() => {
            z = [];
            for (const W of N)
              if (W.beforeEnter)
                if (Fr(W.beforeEnter))
                  for (const J of W.beforeEnter) z.push(Is(J, M, q));
                else z.push(Is(W.beforeEnter, M, q));
            return (z.push(j), H(z));
          })
          .then(
            () => (
              M.matched.forEach((W) => (W.enterCallbacks = {})),
              (z = cm(N, 'beforeRouteEnter', M, q, F)),
              z.push(j),
              H(z)
            )
          )
          .then(() => {
            z = [];
            for (const W of o.list()) z.push(Is(W, M, q));
            return (z.push(j), H(z));
          })
          .catch((W) => (xi(W, 8) ? W : Promise.reject(W)))
      );
    }
    function V(M, q, z) {
      a.list().forEach((Z) => F(() => Z(M, q, z)));
    }
    function K(M, q, z, Z, X) {
      const N = v(M, q);
      if (N) return N;
      const j = q === hs,
        W = Ea ? history.state : {};
      (z &&
        (Z || j
          ? i.replace(M.fullPath, lt({scroll: j && W && W.scroll}, X))
          : i.push(M.fullPath, X)),
        (c.value = M),
        R(M, q, z, j),
        T());
    }
    let B;
    function D() {
      B ||
        (B = i.listen((M, q, z) => {
          if (!O.listening) return;
          const Z = p(M),
            X = $(Z);
          if (X) {
            G(lt(X, {replace: !0, force: !0}), Z).catch(ml);
            return;
          }
          l = Z;
          const N = c.value;
          (Ea && d8(fb(N.fullPath, z.delta), cp()),
            k(Z, N)
              .catch((j) =>
                xi(j, 12)
                  ? j
                  : xi(j, 2)
                    ? (G(lt(b(j.to), {force: !0}), Z)
                        .then((W) => {
                          xi(W, 20) &&
                            !z.delta &&
                            z.type === Dl.pop &&
                            i.go(-1, !1);
                        })
                        .catch(ml),
                      Promise.reject())
                    : (z.delta && i.go(-z.delta, !1), w(j, Z, N))
              )
              .then((j) => {
                ((j = j || K(Z, N, !1)),
                  j &&
                    (z.delta && !xi(j, 8)
                      ? i.go(-z.delta, !1)
                      : z.type === Dl.pop && xi(j, 20) && i.go(-1, !1)),
                  V(Z, N, j));
              })
              .catch(ml));
        }));
    }
    let E = jc(),
      P = jc(),
      U;
    function w(M, q, z) {
      T(M);
      const Z = P.list();
      return (
        Z.length ? Z.forEach((X) => X(M, q, z)) : console.error(M),
        Promise.reject(M)
      );
    }
    function A() {
      return U && c.value !== hs
        ? Promise.resolve()
        : new Promise((M, q) => {
            E.add([M, q]);
          });
    }
    function T(M) {
      return (
        U ||
          ((U = !M),
          D(),
          E.list().forEach(([q, z]) => (M ? z(M) : q())),
          E.reset()),
        M
      );
    }
    function R(M, q, z, Z) {
      const {scrollBehavior: X} = t;
      if (!Ea || !X) return Promise.resolve();
      const N =
        (!z && f8(fb(M.fullPath, 0))) ||
        ((Z || !z) && history.state && history.state.scroll) ||
        null;
      return ia()
        .then(() => X(M, q, N))
        .then((j) => j && u8(j))
        .catch((j) => w(j, M, q));
    }
    const _ = (M) => i.go(M);
    let S;
    const I = new Set(),
      O = {
        currentRoute: c,
        listening: !0,
        addRoute: h,
        removeRoute: g,
        clearRoutes: e.clearRoutes,
        hasRoute: y,
        getRoutes: m,
        resolve: p,
        options: t,
        push: x,
        replace: C,
        go: _,
        back: () => _(-1),
        forward: () => _(1),
        beforeEach: s.add,
        beforeResolve: o.add,
        afterEach: a.add,
        onError: P.add,
        isReady: A,
        install(M) {
          const q = this;
          (M.component('RouterLink', KA),
            M.component('RouterView', qA),
            (M.config.globalProperties.$router = q),
            Object.defineProperty(M.config.globalProperties, '$route', {
              enumerable: !0,
              get: () => he(c)
            }),
            Ea &&
              !S &&
              c.value === hs &&
              ((S = !0), x(i.location).catch((X) => {})));
          const z = {};
          for (const X in hs)
            Object.defineProperty(z, X, {
              get: () => c.value[X],
              enumerable: !0
            });
          (M.provide(Ly, q), M.provide(UA, KE(z)), M.provide(U0, c));
          const Z = M.unmount;
          (I.add(M),
            (M.unmount = function () {
              (I.delete(M),
                I.size < 1 &&
                  ((l = hs),
                  B && B(),
                  (B = null),
                  (c.value = hs),
                  (S = !1),
                  (U = !1)),
                Z());
            }));
        }
      };
    function H(M) {
      return M.reduce((q, z) => q.then(() => F(z)), Promise.resolve());
    }
    return O;
  }
  function H8(t, e) {
    const n = [],
      r = [],
      i = [],
      s = Math.max(e.matched.length, t.matched.length);
    for (let o = 0; o < s; o++) {
      const a = e.matched[o];
      a && (t.matched.find((l) => nc(l, a)) ? r.push(a) : n.push(a));
      const c = t.matched[o];
      c && (e.matched.find((l) => nc(l, c)) || i.push(c));
    }
    return [n, r, i];
  }
  var wr;
  (function (t) {
    ((t.NUMBER = 'NUMBER_NUMBER'),
      (t.HEX = 'NUMBER_HEX'),
      (t.STR = 'NUMBER_STR'),
      (t.BIGINT = 'NUMBER_BIGINT'));
  })(wr || (wr = {}));
  var ts;
  (function (t) {
    ((t.HEX = 'BYTES_HEX'), (t.UINT8ARRAY = 'BYTES_UINT8ARRAY'));
  })(ts || (ts = {}));
  const Tn = {number: wr.BIGINT, bytes: ts.HEX},
    Be = {number: wr.HEX, bytes: ts.HEX};
  var qi;
  (function (t) {
    ((t.EARLIEST = 'earliest'),
      (t.LATEST = 'latest'),
      (t.PENDING = 'pending'),
      (t.SAFE = 'safe'),
      (t.FINALIZED = 'finalized'),
      (t.COMMITTED = 'committed'));
  })(qi || (qi = {}));
  var yl;
  (function (t) {
    ((t.chainstart = 'chainstart'),
      (t.frontier = 'frontier'),
      (t.homestead = 'homestead'),
      (t.dao = 'dao'),
      (t.tangerineWhistle = 'tangerineWhistle'),
      (t.spuriousDragon = 'spuriousDragon'),
      (t.byzantium = 'byzantium'),
      (t.constantinople = 'constantinople'),
      (t.petersburg = 'petersburg'),
      (t.istanbul = 'istanbul'),
      (t.muirGlacier = 'muirGlacier'),
      (t.berlin = 'berlin'),
      (t.london = 'london'),
      (t.altair = 'altair'),
      (t.arrowGlacier = 'arrowGlacier'),
      (t.grayGlacier = 'grayGlacier'),
      (t.bellatrix = 'bellatrix'),
      (t.merge = 'merge'),
      (t.capella = 'capella'),
      (t.shanghai = 'shanghai'));
  })(yl || (yl = {}));
  const By = Object.getPrototypeOf(Uint8Array);
  var Tb = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  const Ib = Symbol.for('web3/base-provider');
  class ku {
    static isWeb3Provider(e) {
      return e instanceof ku || !!(e && e[Ib]);
    }
    get [Ib]() {
      return !0;
    }
    send(e, n) {
      this.request(e)
        .then((r) => {
          n(null, r);
        })
        .catch((r) => {
          n(r);
        });
    }
    sendAsync(e) {
      return Tb(this, void 0, void 0, function* () {
        return this.request(e);
      });
    }
    asEIP1193Provider() {
      const e = Object.create(this),
        n = e.request;
      return (
        (e.request = function (i) {
          return Tb(this, void 0, void 0, function* () {
            return (yield n(i)).result;
          });
        }),
        (e.asEIP1193Provider = void 0),
        e
      );
    }
  }
  class j8 extends Array {
    constructor(e) {
      (super(), (this._accountProvider = e));
    }
  }
  const U8 = 100,
    K8 = 101,
    q8 = 201,
    V8 = 202,
    G8 = 203,
    z8 = 204,
    W8 = 205,
    Z8 = 206,
    Y8 = 207,
    Q8 = 208,
    J8 = 300,
    X8 = 301,
    e4 = 310,
    t4 = 311,
    n4 = 400,
    r4 = 402,
    i4 = 405,
    s4 = 407,
    o4 = 408,
    a4 = 410,
    c4 = 411,
    l4 = 412,
    u4 = 413,
    d4 = 414,
    f4 = 415,
    h4 = 416,
    p4 = 417,
    m4 = 418,
    g4 = 419,
    y4 = 420,
    v4 = 421,
    b4 = 422,
    w4 = 423,
    _4 = 424,
    E4 = 425,
    A4 = 426,
    S4 = 427,
    x4 = 428,
    C4 = 429,
    T4 = 430,
    I4 = 431,
    k4 = 432,
    R4 = 433,
    P4 = 434,
    M4 = 435,
    O4 = 436,
    N4 = 437,
    L4 = 438,
    B4 = 439,
    D4 = 440,
    F4 = 441,
    $4 = 500,
    H4 = 503,
    j4 = 505,
    U4 = 506,
    K4 = 507,
    q4 = 600,
    V4 = 602,
    G4 = 603,
    z4 = 604,
    W4 = 701,
    Z4 = 702,
    Y4 = 703,
    Q4 = 704,
    J4 = 705,
    X4 = 706,
    eR = 707,
    tR = 709,
    nR = 801,
    rR = 802,
    iR = 4001,
    sR = 4100,
    oR = 4200,
    aR = 4900,
    cR = 4901,
    lR = 902,
    uR = 903,
    dR = 1001,
    fR = 1002,
    hR = 1003,
    pR = 1004,
    mR = 1005,
    gR = 1006,
    yR = 1008,
    vR = 1009,
    bR = 1010,
    wR = 1011,
    _R = 1012,
    ER = 1014,
    AR = 1015,
    SR = 1100,
    VA = 1101,
    xR = 1200,
    If = -32700,
    kf = -32600,
    Rf = -32601,
    Pf = -32602,
    Mf = -32603,
    Of = -32e3,
    Nf = -32001,
    Lf = -32002,
    Bf = -32003,
    Df = -32004,
    Ff = -32005,
    $f = -32006;
  class Ne extends Error {
    get innerError() {
      return this.cause instanceof vl ? this.cause.errors : this.cause;
    }
    set innerError(e) {
      Array.isArray(e) ? (this.cause = new vl(e)) : (this.cause = e);
    }
    constructor(e, n) {
      (super(e),
        Array.isArray(n) ? (this.cause = new vl(n)) : (this.cause = n),
        (this.name = this.constructor.name),
        typeof Error.captureStackTrace == 'function'
          ? Error.captureStackTrace(new.target.constructor)
          : (this.stack = new Error().stack));
    }
    static convertToString(e, n = !1) {
      if (e == null) return 'undefined';
      const r = JSON.stringify(e, (i, s) =>
        typeof s == 'bigint' ? s.toString() : s
      );
      return n && ['bigint', 'string'].includes(typeof e)
        ? r.replace(/['\\"]+/g, '')
        : r;
    }
    toJSON() {
      return {
        name: this.name,
        code: this.code,
        message: this.message,
        cause: this.cause,
        innerError: this.cause
      };
    }
  }
  class vl extends Ne {
    constructor(e) {
      (super(
        `Multiple errors occurred: [${e.map((n) => n.message).join('], [')}]`
      ),
        (this.code = Q8),
        (this.errors = e));
    }
  }
  class ze extends Ne {
    constructor(e, n) {
      (super(
        `Invalid value given "${Ne.convertToString(e, !0)}". Error: ${n}.`
      ),
        (this.name = this.constructor.name));
    }
  }
  class kb extends Ne {
    constructor() {
      (super('Private key must be 32 bytes.'), (this.code = W4));
    }
  }
  class CR extends Ne {
    constructor() {
      (super('Invalid Private Key, Not a valid string or uint8Array'),
        (this.code = Z4));
    }
  }
  class TR extends Ne {
    constructor(e) {
      (super(`"${e}"`), (this.code = rR));
    }
  }
  class GA extends Ne {
    constructor() {
      (super('Invalid key derivation function'), (this.code = Y4));
    }
  }
  class IR extends Ne {
    constructor() {
      (super('Key derivation failed - possibly wrong password'),
        (this.code = Q4));
    }
  }
  class kR extends Ne {
    constructor() {
      (super('Unsupported key store version'), (this.code = J4));
    }
  }
  class RR extends Ne {
    constructor() {
      (super('Password cannot be empty'), (this.code = X4));
    }
  }
  class PR extends Ne {
    constructor() {
      (super('Initialization vector must be 16 bytes'), (this.code = eR));
    }
  }
  class MR extends Ne {
    constructor() {
      (super('c > 1000, pbkdf2 is less secure with less iterations'),
        (this.code = tR));
    }
  }
  class Ru extends Ne {
    constructor(e, n) {
      (super(e),
        (this.code = $4),
        n && ((this.errorCode = n.code), (this.errorReason = n.reason)));
    }
    toJSON() {
      return Object.assign(Object.assign({}, super.toJSON()), {
        errorCode: this.errorCode,
        errorReason: this.errorReason
      });
    }
  }
  class K0 extends Ru {
    constructor(e) {
      (super('Connection not open', e), (this.code = H4));
    }
  }
  class OR extends Ru {
    constructor(e) {
      (super(`Maximum number of reconnect attempts reached! (${e})`),
        (this.code = j4));
    }
  }
  class NR extends Ru {
    constructor() {
      (super(
        'CONNECTION ERROR: Provider started to reconnect before the response got received!'
      ),
        (this.code = U4));
    }
  }
  class LR extends Ru {
    constructor(e) {
      (super(`Request already sent with following id: ${e}`), (this.code = K4));
    }
  }
  class In extends Ne {
    constructor(e, n) {
      (super(e), (this.code = J8), (this.receipt = n));
    }
  }
  class Rb extends Ne {
    constructor(e, n) {
      (super(
        `The resolver at ${e} does not implement requested method: "${n}".`
      ),
        (this.address = e),
        (this.name = n),
        (this.code = X8));
    }
    toJSON() {
      return Object.assign(Object.assign({}, super.toJSON()), {
        address: this.address,
        name: this.name
      });
    }
  }
  class lp extends In {
    constructor(e) {
      if (
        (super(e.message || 'Error'),
        (this.name = ('name' in e && e.name) || this.constructor.name),
        (this.stack = ('stack' in e && e.stack) || void 0),
        (this.code = e.code),
        typeof e.data == 'object')
      ) {
        let n;
        (e.data && 'originalError' in e.data
          ? (n = e.data.originalError)
          : (n = e.data),
          (this.data = n.data),
          (this.cause = new lp(n)));
      } else this.data = e.data;
    }
    setDecodedProperties(e, n, r) {
      ((this.errorName = e), (this.errorSignature = n), (this.errorArgs = r));
    }
    toJSON() {
      let e = Object.assign(Object.assign({}, super.toJSON()), {
        data: this.data
      });
      return (
        this.errorName &&
          (e = Object.assign(Object.assign({}, e), {
            errorName: this.errorName,
            errorSignature: this.errorSignature,
            errorArgs: this.errorArgs
          })),
        e
      );
    }
  }
  class Bo extends In {
    constructor(e) {
      (super(
        'Error happened while trying to execute a function inside a smart contract'
      ),
        (this.code = e4),
        (this.cause = new lp(e)));
    }
  }
  class BR extends ze {
    constructor(e) {
      var n, r;
      (super(
        `data: ${(n = e.data) !== null && n !== void 0 ? n : 'undefined'}, input: ${(r = e.input) !== null && r !== void 0 ? r : 'undefined'}`,
        `You can't have "data" and "input" as properties of a contract at the same time, please use either "data" or "input" instead.`
      ),
        (this.code = t4));
    }
  }
  class DR extends Ne {
    constructor(e) {
      (super(`ENS is not supported on network ${e}`), (this.code = lR));
    }
  }
  class FR extends Ne {
    constructor() {
      (super('Network not synced'), (this.code = uR));
    }
  }
  class Pb extends Ne {
    constructor(e) {
      (super(`Invalid parameters passed. "${typeof e < 'u' ? e : ''}"`),
        (this.hint = e),
        (this.code = Y8));
    }
    toJSON() {
      return Object.assign(Object.assign({}, super.toJSON()), {
        hint: this.hint
      });
    }
  }
  class q0 extends Ne {
    constructor() {
      (super(...arguments), (this.code = q8));
    }
  }
  class Ci extends Ne {
    constructor() {
      (super("The method you're trying to call is not implemented."),
        (this.code = V8));
    }
  }
  class zA extends Ne {
    constructor() {
      (super(...arguments), (this.code = G8));
    }
  }
  class $R extends Ne {
    constructor() {
      (super(...arguments), (this.code = z8));
    }
  }
  class Ze extends Ne {
    constructor(e, n) {
      (super(e), (this.code = W8), (this.props = n ?? {}));
    }
  }
  class HR extends Ne {
    constructor(e) {
      (super(`A plugin with the namespace: ${e} has already been registered.`),
        (this.code = Z8));
    }
  }
  class Dd extends Ne {
    constructor() {
      (super(...arguments), (this.code = q4));
    }
  }
  class V0 extends Ne {
    constructor(e) {
      (super(`Client URL "${e}" is invalid.`), (this.code = V4));
    }
  }
  class Li extends Ne {
    constructor() {
      (super(...arguments), (this.code = G4));
    }
  }
  class jR extends Ne {
    constructor() {
      (super(...arguments), (this.code = z4));
    }
  }
  class UR extends ze {
    constructor() {
      (super(...arguments), (this.code = nR));
    }
  }
  class Dy extends Ne {
    constructor(e, n) {
      (super(e), (this.receipt = n), (this.code = n4));
    }
    toJSON() {
      return Object.assign(Object.assign({}, super.toJSON()), {
        receipt: this.receipt
      });
    }
  }
  class Hf extends Ne {
    constructor(e, n, r, i) {
      (super(
        `Transaction has been reverted by the EVM${
          r === void 0
            ? ''
            : `:
 ${Ne.convertToString(r)}`
        }`
      ),
        (this.reason = e),
        (this.signature = n),
        (this.receipt = r),
        (this.data = i),
        (this.code = r4));
    }
    toJSON() {
      return Object.assign(Object.assign({}, super.toJSON()), {
        reason: this.reason,
        signature: this.signature,
        receipt: this.receipt,
        data: this.data
      });
    }
  }
  class WA extends Hf {
    constructor(e, n, r, i, s, o, a) {
      (super(e),
        (this.reason = e),
        (this.customErrorName = n),
        (this.customErrorDecodedSignature = r),
        (this.customErrorArguments = i),
        (this.signature = s),
        (this.receipt = o),
        (this.data = a),
        (this.code = L4));
    }
    toJSON() {
      return Object.assign(Object.assign({}, super.toJSON()), {
        reason: this.reason,
        customErrorName: this.customErrorName,
        customErrorDecodedSignature: this.customErrorDecodedSignature,
        customErrorArguments: this.customErrorArguments,
        signature: this.signature,
        receipt: this.receipt,
        data: this.data
      });
    }
  }
  class ZA extends Dy {
    constructor(e) {
      (super(
        `Transaction has been reverted by the EVM${
          e === void 0
            ? ''
            : `:
 ${Ne.convertToString(e)}`
        }`,
        e
      ),
        (this.code = i4));
    }
  }
  class KR extends Dy {
    constructor() {
      (super('Raw transaction undefined'), (this.code = s4));
    }
  }
  class Mb extends Dy {
    constructor() {
      (super('Transaction not found'), (this.code = T4));
    }
  }
  class qR extends ze {
    constructor(e) {
      (super(e, 'invalid transaction with invalid sender'), (this.code = o4));
    }
  }
  class VR extends ze {
    constructor(e) {
      (super(e, 'invalid transaction with invalid receiver'), (this.code = N4));
    }
  }
  class GR extends ze {
    constructor() {
      (super(
        'MissingCustomChainError',
        'If tx.common is provided it must have tx.common.customChain'
      ),
        (this.code = a4));
    }
  }
  class zR extends ze {
    constructor() {
      (super(
        'MissingCustomChainIdError',
        'If tx.common is provided it must have tx.common.customChain and tx.common.customChain.chainId'
      ),
        (this.code = c4));
    }
  }
  class WR extends ze {
    constructor(e) {
      (super(
        JSON.stringify(e),
        'Chain Id doesnt match in tx.chainId tx.common.customChain.chainId'
      ),
        (this.code = l4));
    }
  }
  class ZR extends ze {
    constructor(e) {
      (super(
        JSON.stringify(e),
        'Chain doesnt match in tx.chain tx.common.basechain'
      ),
        (this.code = M4));
    }
  }
  class YR extends ze {
    constructor(e) {
      (super(
        JSON.stringify(e),
        'hardfork doesnt match in tx.hardfork tx.common.hardfork'
      ),
        (this.code = O4));
    }
  }
  class QR extends ze {
    constructor() {
      (super(
        'CommonOrChainAndHardforkError',
        'Please provide the common object or the chain and hardfork property but not all together.'
      ),
        (this.code = u4));
    }
  }
  class JR extends ze {
    constructor(e) {
      var n, r;
      (super(
        'MissingChainOrHardforkError',
        `When specifying chain and hardfork, both values must be defined. Received "chain": ${(n = e.chain) !== null && n !== void 0 ? n : 'undefined'}, "hardfork": ${(r = e.hardfork) !== null && r !== void 0 ? r : 'undefined'}`
      ),
        (this.code = d4));
    }
  }
  class XR extends Ne {
    constructor() {
      (super(
        'Missing properties in transaction, either define "gas" and "gasPrice" for type 0 transactions or "gas", "maxPriorityFeePerGas" and "maxFeePerGas" for type 2 transactions'
      ),
        (this.code = D4));
    }
  }
  class eP extends ze {
    constructor(e) {
      var n, r, i, s;
      (super(
        `gas: ${(n = e.gas) !== null && n !== void 0 ? n : 'undefined'}, gasPrice: ${(r = e.gasPrice) !== null && r !== void 0 ? r : 'undefined'}, maxPriorityFeePerGas: ${(i = e.maxPriorityFeePerGas) !== null && i !== void 0 ? i : 'undefined'}, maxFeePerGas: ${(s = e.maxFeePerGas) !== null && s !== void 0 ? s : 'undefined'}`,
        '"gas" is missing'
      ),
        (this.code = f4),
        (this.cause = new XR()));
    }
  }
  class tP extends Ne {
    constructor() {
      (super(
        'Missing properties in transaction, either define "gas" and "gasPrice" for type 0 transactions or "gas", "maxPriorityFeePerGas" and "maxFeePerGas" for type 2 transactions, not both'
      ),
        (this.code = F4));
    }
  }
  class nP extends ze {
    constructor(e) {
      var n, r, i, s;
      (super(
        `gas: ${(n = e.gas) !== null && n !== void 0 ? n : 'undefined'}, gasPrice: ${(r = e.gasPrice) !== null && r !== void 0 ? r : 'undefined'}, maxPriorityFeePerGas: ${(i = e.maxPriorityFeePerGas) !== null && i !== void 0 ? i : 'undefined'}, maxFeePerGas: ${(s = e.maxFeePerGas) !== null && s !== void 0 ? s : 'undefined'}`,
        'transaction must specify legacy or fee market gas properties, not both'
      ),
        (this.code = P4),
        (this.cause = new tP()));
    }
  }
  class rP extends ze {
    constructor(e) {
      var n, r;
      (super(
        `gas: ${(n = e.gas) !== null && n !== void 0 ? n : 'undefined'}, gasPrice: ${(r = e.gasPrice) !== null && r !== void 0 ? r : 'undefined'}`,
        'Gas or gasPrice is lower than 0'
      ),
        (this.code = h4));
    }
  }
  class iP extends ze {
    constructor(e) {
      var n, r;
      (super(
        `maxPriorityFeePerGas: ${(n = e.maxPriorityFeePerGas) !== null && n !== void 0 ? n : 'undefined'}, maxFeePerGas: ${(r = e.maxFeePerGas) !== null && r !== void 0 ? r : 'undefined'}`,
        'maxPriorityFeePerGas or maxFeePerGas is lower than 0'
      ),
        (this.code = p4));
    }
  }
  class sP extends ze {
    constructor(e) {
      (super(e, "eip-1559 transactions don't support gasPrice"),
        (this.code = m4));
    }
  }
  class YA extends ze {
    constructor(e) {
      var n, r;
      (super(
        `maxPriorityFeePerGas: ${(n = e.maxPriorityFeePerGas) !== null && n !== void 0 ? n : 'undefined'}, maxFeePerGas: ${(r = e.maxFeePerGas) !== null && r !== void 0 ? r : 'undefined'}`,
        "pre-eip-1559 transaction don't support maxFeePerGas/maxPriorityFeePerGas"
      ),
        (this.code = g4));
    }
  }
  class oP extends ze {
    constructor(e) {
      (super(e, 'invalid transaction object'), (this.code = y4));
    }
  }
  class aP extends ze {
    constructor(e) {
      var n, r;
      (super(
        `nonce: ${(n = e.nonce) !== null && n !== void 0 ? n : 'undefined'}, chainId: ${(r = e.chainId) !== null && r !== void 0 ? r : 'undefined'}`,
        'Nonce or chainId is lower than 0'
      ),
        (this.code = v4));
    }
  }
  class cP extends ze {
    constructor() {
      (super(
        'UnableToPopulateNonceError',
        'unable to populate nonce, no from address available'
      ),
        (this.code = b4));
    }
  }
  class lP extends ze {
    constructor() {
      (super('Eip1559NotSupportedError', "Network doesn't support eip-1559"),
        (this.code = w4));
    }
  }
  class Ob extends ze {
    constructor(e) {
      (super(e, 'unsupported transaction type'), (this.code = _4));
    }
  }
  class QA extends ze {
    constructor(e) {
      var n, r;
      (super(
        `data: ${(n = e.data) !== null && n !== void 0 ? n : 'undefined'}, input: ${(r = e.input) !== null && r !== void 0 ? r : 'undefined'}`,
        `You can't have "data" and "input" as properties of transactions at the same time, please use either "data" or "input" instead.`
      ),
        (this.code = E4));
    }
  }
  class uP extends Ne {
    constructor(e) {
      (super(`The connected Ethereum Node did not respond within ${e.numberOfSeconds} seconds, please make sure your transaction was properly sent and you are connected to a healthy Node. Be aware that transaction might still be pending or mined!
	Transaction Hash: ${e.transactionHash ? e.transactionHash.toString() : 'not available'}`),
        (this.code = I4));
    }
  }
  function JA(t) {
    return `Please make sure your transaction was properly sent and there are no previous pending transaction for the same account. However, be aware that it might still be mined!
	Transaction Hash: ${t ? t.toString() : 'not available'}`;
  }
  class XA extends Ne {
    constructor(e) {
      (super(
        `Transaction was not mined within ${e.numberOfSeconds} seconds. ${JA(e.transactionHash)}`
      ),
        (this.code = A4));
    }
  }
  class e3 extends Ne {
    constructor(e) {
      (super(
        `Transaction started at ${e.starterBlockNumber} but was not mined within ${e.numberOfBlocks} blocks. ${JA(e.transactionHash)}`
      ),
        (this.code = k4));
    }
  }
  class dP extends ze {
    constructor(e) {
      var n, r;
      (super(
        `receipt: ${JSON.stringify(e.receipt)}, blockHash: ${(n = e.blockHash) === null || n === void 0 ? void 0 : n.toString()}, transactionHash: ${(r = e.transactionHash) === null || r === void 0 ? void 0 : r.toString()}`,
        'Receipt missing or blockHash null'
      ),
        (this.code = S4));
    }
  }
  class fP extends ze {
    constructor(e) {
      (super(
        `receipt: ${JSON.stringify(e.receipt)}`,
        'Receipt missing block number'
      ),
        (this.code = x4));
    }
  }
  class G0 extends Ne {
    constructor(e) {
      (super(`Invalid signature. "${e}"`), (this.code = R4));
    }
  }
  class Nb extends ze {
    constructor() {
      (super(
        'LocalWalletNotAvailableError',
        'Attempted to index account in local wallet, but no wallet is available'
      ),
        (this.code = C4));
    }
  }
  class hP extends Ne {
    constructor(e, n) {
      const r = [];
      (e.forEach((i) => r.push(i.keyword)),
        super(
          `The following properties are invalid for the transaction type ${n}: ${r.join(', ')}`
        ),
        (this.code = B4));
    }
  }
  class Ga extends ze {
    constructor(e) {
      (super(e, 'can not parse as byte data'), (this.code = fR));
    }
  }
  class Fy extends ze {
    constructor(e) {
      (super(e, 'can not parse as number data'), (this.code = hR));
    }
  }
  class $y extends ze {
    constructor(e) {
      (super(e, 'invalid ethereum address'), (this.code = mR));
    }
  }
  class pP extends ze {
    constructor(e) {
      (super(e, 'not a valid string'), (this.code = dR));
    }
  }
  class t3 extends ze {
    constructor(e) {
      (super(e, 'invalid unit'), (this.code = pR));
    }
  }
  class n3 extends ze {
    constructor(e) {
      (super(e, 'not a valid unit. Must be a positive integer'),
        (this.code = AR));
    }
  }
  class mP extends ze {
    constructor(e) {
      (super(e, 'can not be converted to hex'), (this.code = gR));
    }
  }
  class r3 extends ze {
    constructor(e) {
      (super(e, 'value greater than the nibble width'), (this.code = ER));
    }
  }
  class Hy extends ze {
    constructor(e) {
      (super(e, 'not a valid boolean.'), (this.code = yR));
    }
  }
  class gP extends ze {
    constructor(e) {
      (super(e, 'not a valid unsigned integer.'), (this.code = vR));
    }
  }
  class Lb extends ze {
    constructor(e) {
      (super(e, 'invalid size given.'), (this.code = bR));
    }
  }
  class Bb extends ze {
    constructor(e) {
      (super(e, 'value is larger than size.'), (this.code = wR));
    }
  }
  class yP extends ze {
    constructor(e) {
      (super(e, 'invalid string given'), (this.code = _R));
    }
  }
  const vP = (t) =>
      !Array.isArray(t) &&
      t.jsonrpc === '2.0' &&
      !!t &&
      (t.result === void 0 || t.result === null) &&
      'error' in t &&
      (typeof t.id == 'number' || typeof t.id == 'string'),
    Db = (t) => (vP(t) ? t.error.message : '');
  class Qr extends Ne {
    constructor(e, n, r, i) {
      var s;
      (super(
        n ??
          `Returned error: ${Array.isArray(e) ? e.map((a) => Db(a)).join(',') : Db(e)}`
      ),
        (this.code = U8),
        n ||
          (this.data = Array.isArray(e)
            ? e.map((a) => {
                var c;
                return (c = a.error) === null || c === void 0 ? void 0 : c.data;
              })
            : (s = e == null ? void 0 : e.error) === null || s === void 0
              ? void 0
              : s.data),
        (this.statusCode = i),
        (this.request = r));
      let o;
      ('error' in e
        ? (o = e.error)
        : e instanceof Array &&
          (o = e.filter((a) => a.error).map((a) => a.error)),
        Array.isArray(o) && o.length > 0
          ? (this.cause = new vl(o))
          : (this.cause = o));
    }
    toJSON() {
      return Object.assign(Object.assign({}, super.toJSON()), {
        data: this.data,
        request: this.request,
        statusCode: this.statusCode
      });
    }
  }
  class up extends Qr {
    constructor(e, n) {
      (super(e, void 0, n), (this.code = K8));
      let r;
      ('error' in e
        ? (r = e.error)
        : e instanceof Array && (r = e.map((i) => i.error)),
        Array.isArray(r) ? (this.cause = new vl(r)) : (this.cause = r));
    }
  }
  class Fb extends Ne {
    constructor(e, n) {
      (super(
        `Web3Config hardfork doesnt match in defaultHardfork ${e} and common.hardfork ${n}`
      ),
        (this.code = VA));
    }
  }
  class $b extends Ne {
    constructor(e, n) {
      (super(
        `Web3Config chain doesnt match in defaultHardfork ${e} and common.hardfork ${n}`
      ),
        (this.code = VA));
    }
  }
  const i3 = 'An Rpc error has occured with a code of *code*',
    mn = {
      [If]: {message: 'Parse error', description: 'Invalid JSON'},
      [kf]: {
        message: 'Invalid request',
        description: 'JSON is not a valid request object	'
      },
      [Rf]: {message: 'Method not found', description: 'Method does not exist	'},
      [Pf]: {
        message: 'Invalid params',
        description: 'Invalid method parameters'
      },
      [Mf]: {message: 'Internal error', description: 'Internal JSON-RPC error'},
      [Of]: {
        message: 'Invalid input',
        description: 'Missing or invalid parameters'
      },
      [Nf]: {
        message: 'Resource not found',
        description: 'Requested resource not found'
      },
      [Lf]: {
        message: 'Resource unavailable',
        description: 'Requested resource not available'
      },
      [Bf]: {
        message: 'Transaction rejected',
        description: 'Transaction creation failed'
      },
      [Df]: {
        message: 'Method not supported',
        description: 'Method is not implemented'
      },
      [Ff]: {
        message: 'Limit exceeded',
        description: 'Request exceeds defined limit'
      },
      [$f]: {
        message: 'JSON-RPC version not supported',
        description: 'Version of JSON-RPC protocol is not supported'
      },
      [iR]: {
        name: 'User Rejected Request',
        message: 'The user rejected the request.'
      },
      [sR]: {
        name: 'Unauthorized',
        message:
          'The requested method and/or account has not been authorized by the user.'
      },
      [oR]: {
        name: 'Unsupported Method',
        message: 'The Provider does not support the requested method.'
      },
      [aR]: {
        name: 'Disconnected',
        message: 'The Provider is disconnected from all chains.'
      },
      [cR]: {
        name: 'Chain Disconnected',
        message: 'The Provider is not connected to the requested chain.'
      },
      '0-999': {name: '', message: 'Not used.'},
      1e3: {
        name: 'Normal Closure',
        message:
          'The connection successfully completed the purpose for which it was created.'
      },
      1001: {
        name: 'Going Away',
        message:
          'The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection.'
      },
      1002: {
        name: 'Protocol error',
        message:
          'The endpoint is terminating the connection due to a protocol error.'
      },
      1003: {
        name: 'Unsupported Data',
        message:
          'The connection is being terminated because the endpoint received data of a type it cannot accept. (For example, a text-only endpoint received binary data.)'
      },
      1004: {
        name: 'Reserved',
        message: 'Reserved. A meaning might be defined in the future.'
      },
      1005: {
        name: 'No Status Rcvd',
        message:
          'Reserved. Indicates that no status code was provided even though one was expected.'
      },
      1006: {
        name: 'Abnormal Closure',
        message:
          'Reserved. Indicates that a connection was closed abnormally (that is, with no close frame being sent) when a status code is expected.'
      },
      1007: {
        name: 'Invalid frame payload data',
        message:
          'The endpoint is terminating the connection because a message was received that contained inconsistent data (e.g., non-UTF-8 data within a text message).'
      },
      1008: {
        name: 'Policy Violation',
        message:
          'The endpoint is terminating the connection because it received a message that violates its policy. This is a generic status code, used when codes 1003 and 1009 are not suitable.'
      },
      1009: {
        name: 'Message Too Big',
        message:
          'The endpoint is terminating the connection because a data frame was received that is too large.'
      },
      1010: {
        name: 'Mandatory Ext.',
        message:
          "The client is terminating the connection because it expected the server to negotiate one or more extension, but the server didn't."
      },
      1011: {
        name: 'Internal Error',
        message:
          'The server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.'
      },
      1012: {
        name: 'Service Restart',
        message:
          'The server is terminating the connection because it is restarting.'
      },
      1013: {
        name: 'Try Again Later',
        message:
          'The server is terminating the connection due to a temporary condition, e.g. it is overloaded and is casting off some of its clients.'
      },
      1014: {
        name: 'Bad Gateway',
        message:
          'The server was acting as a gateway or proxy and received an invalid response from the upstream server. This is similar to 502 HTTP Status Code.'
      },
      1015: {
        name: 'TLS handshake',
        message:
          "Reserved. Indicates that the connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified)."
      },
      '1016-2999': {
        name: '',
        message:
          'For definition by future revisions of the WebSocket Protocol specification, and for definition by extension specifications.'
      },
      '3000-3999': {
        name: '',
        message:
          'For use by libraries, frameworks, and applications. These status codes are registered directly with IANA. The interpretation of these codes is undefined by the WebSocket protocol.'
      },
      '4000-4999': {
        name: '',
        message:
          "For private use, and thus can't be registered. Such codes can be used by prior agreements between WebSocket applications. The interpretation of these codes is undefined by the WebSocket protocol."
      }
    };
  class ir extends Ne {
    constructor(e, n) {
      (super(n ?? i3.replace('*code*', e.error.code.toString())),
        (this.code = e.error.code),
        (this.id = e.id),
        (this.jsonrpc = e.jsonrpc),
        (this.jsonRpcError = e.error));
    }
    toJSON() {
      return Object.assign(Object.assign({}, super.toJSON()), {
        error: this.jsonRpcError,
        id: this.id,
        jsonRpc: this.jsonrpc
      });
    }
  }
  class bP extends Ne {
    constructor(e, n) {
      var r, i, s, o;
      if (!e) super();
      else if (!((r = mn[e]) === null || r === void 0) && r.message)
        super(mn[e].message);
      else {
        const a = Object.keys(mn).find(
          (c) =>
            typeof c == 'string' &&
            e >= parseInt(c.split('-')[0], 10) &&
            e <= parseInt(c.split('-')[1], 10)
        );
        super(
          (s =
            (i = mn[a ?? '']) === null || i === void 0 ? void 0 : i.message) !==
            null && s !== void 0
            ? s
            : i3.replace(
                '*code*',
                (o = e == null ? void 0 : e.toString()) !== null && o !== void 0
                  ? o
                  : '""'
              )
        );
      }
      ((this.code = e), (this.data = n));
    }
  }
  class wP extends ir {
    constructor(e) {
      (super(e, mn[If].message), (this.code = If));
    }
  }
  class _P extends ir {
    constructor(e) {
      (super(e, mn[kf].message), (this.code = kf));
    }
  }
  class EP extends ir {
    constructor(e) {
      (super(e, mn[Rf].message), (this.code = Rf));
    }
  }
  class AP extends ir {
    constructor(e) {
      (super(e, mn[Pf].message), (this.code = Pf));
    }
  }
  class SP extends ir {
    constructor(e) {
      (super(e, mn[Mf].message), (this.code = Mf));
    }
  }
  class xP extends ir {
    constructor(e) {
      (super(e, mn[Of].message), (this.code = Of));
    }
  }
  class CP extends ir {
    constructor(e) {
      (super(e, mn[Df].message), (this.code = Df));
    }
  }
  class TP extends ir {
    constructor(e) {
      (super(e, mn[Lf].message), (this.code = Lf));
    }
  }
  class IP extends ir {
    constructor(e) {
      (super(e, mn[Nf].message), (this.code = Nf));
    }
  }
  class kP extends ir {
    constructor(e) {
      (super(e, mn[$f].message), (this.code = $f));
    }
  }
  class RP extends ir {
    constructor(e) {
      (super(e, mn[Bf].message), (this.code = Bf));
    }
  }
  class PP extends ir {
    constructor(e) {
      (super(e, mn[Ff].message), (this.code = Ff));
    }
  }
  const Rn = new Map();
  Rn.set(If, {error: wP});
  Rn.set(kf, {error: _P});
  Rn.set(Rf, {error: EP});
  Rn.set(Pf, {error: AP});
  Rn.set(Mf, {error: SP});
  Rn.set(Of, {error: xP});
  Rn.set(Df, {error: CP});
  Rn.set(Lf, {error: TP});
  Rn.set(Bf, {error: RP});
  Rn.set(Nf, {error: IP});
  Rn.set($f, {error: kP});
  Rn.set(Ff, {error: PP});
  class MP extends Ne {
    constructor(e) {
      (super(`Format for the type ${e} is unsupported`),
        (this.type = e),
        (this.code = xR));
    }
    toJSON() {
      return Object.assign(Object.assign({}, super.toJSON()), {
        type: this.type
      });
    }
  }
  function $n(t) {
    if (!Number.isSafeInteger(t) || t < 0)
      throw new Error(`positive integer expected, not ${t}`);
  }
  function OP(t) {
    if (typeof t != 'boolean') throw new Error(`boolean expected, not ${t}`);
  }
  function NP(t) {
    return (
      t instanceof Uint8Array ||
      (t != null && typeof t == 'object' && t.constructor.name === 'Uint8Array')
    );
  }
  function kc(t, ...e) {
    if (!NP(t)) throw new Error('Uint8Array expected');
    if (e.length > 0 && !e.includes(t.length))
      throw new Error(
        `Uint8Array expected of length ${e}, not of length=${t.length}`
      );
  }
  function jy(t) {
    if (typeof t != 'function' || typeof t.create != 'function')
      throw new Error('Hash should be wrapped by utils.wrapConstructor');
    ($n(t.outputLen), $n(t.blockLen));
  }
  function Vo(t, e = !0) {
    if (t.destroyed) throw new Error('Hash instance has been destroyed');
    if (e && t.finished)
      throw new Error('Hash#digest() has already been called');
  }
  function Uy(t, e) {
    kc(t);
    const n = e.outputLen;
    if (t.length < n)
      throw new Error(
        `digestInto() expects output buffer of length at least ${n}`
      );
  }
  const s3 = {
      number: $n,
      bool: OP,
      bytes: kc,
      hash: jy,
      exists: Vo,
      output: Uy
    },
    Qu = BigInt(2 ** 32 - 1),
    Hb = BigInt(32);
  function LP(t, e = !1) {
    return e
      ? {h: Number(t & Qu), l: Number((t >> Hb) & Qu)}
      : {h: Number((t >> Hb) & Qu) | 0, l: Number(t & Qu) | 0};
  }
  function BP(t, e = !1) {
    let n = new Uint32Array(t.length),
      r = new Uint32Array(t.length);
    for (let i = 0; i < t.length; i++) {
      const {h: s, l: o} = LP(t[i], e);
      [n[i], r[i]] = [s, o];
    }
    return [n, r];
  }
  const DP = (t, e, n) => (t << n) | (e >>> (32 - n)),
    FP = (t, e, n) => (e << n) | (t >>> (32 - n)),
    $P = (t, e, n) => (e << (n - 32)) | (t >>> (64 - n)),
    HP = (t, e, n) => (t << (n - 32)) | (e >>> (64 - n)),
    Fd =
      typeof globalThis == 'object' && 'crypto' in globalThis
        ? globalThis.crypto
        : void 0;
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const $d =
      (t) =>
        new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)),
    Hd = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength),
    Kr = (t, e) => (t << (32 - e)) | (t >>> e),
    nt = (t, e) => (t << e) | ((t >>> (32 - e)) >>> 0),
    jf = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68,
    jP = (t) =>
      ((t << 24) & 4278190080) |
      ((t << 8) & 16711680) |
      ((t >>> 8) & 65280) |
      ((t >>> 24) & 255);
  function Uf(t) {
    for (let e = 0; e < t.length; e++) t[e] = jP(t[e]);
  }
  function ic(t) {
    if (typeof t != 'string')
      throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
    return new Uint8Array(new TextEncoder().encode(t));
  }
  function sc(t) {
    return (typeof t == 'string' && (t = ic(t)), kc(t), t);
  }
  function Kf(...t) {
    let e = 0;
    for (let r = 0; r < t.length; r++) {
      const i = t[r];
      (kc(i), (e += i.length));
    }
    const n = new Uint8Array(e);
    for (let r = 0, i = 0; r < t.length; r++) {
      const s = t[r];
      (n.set(s, i), (i += s.length));
    }
    return n;
  }
  class Ky {
    clone() {
      return this._cloneInto();
    }
  }
  const UP = {}.toString;
  function o3(t, e) {
    if (e !== void 0 && UP.call(e) !== '[object Object]')
      throw new Error('Options should be object or undefined');
    return Object.assign(t, e);
  }
  function a3(t) {
    const e = (r) => t().update(sc(r)).digest(),
      n = t();
    return (
      (e.outputLen = n.outputLen),
      (e.blockLen = n.blockLen),
      (e.create = () => t()),
      e
    );
  }
  function c3(t = 32) {
    if (Fd && typeof Fd.getRandomValues == 'function')
      return Fd.getRandomValues(new Uint8Array(t));
    throw new Error('crypto.getRandomValues must be defined');
  }
  const l3 = [],
    u3 = [],
    d3 = [],
    KP = BigInt(0),
    Uc = BigInt(1),
    qP = BigInt(2),
    VP = BigInt(7),
    GP = BigInt(256),
    zP = BigInt(113);
  for (let t = 0, e = Uc, n = 1, r = 0; t < 24; t++) {
    (([n, r] = [r, (2 * n + 3 * r) % 5]),
      l3.push(2 * (5 * r + n)),
      u3.push((((t + 1) * (t + 2)) / 2) % 64));
    let i = KP;
    for (let s = 0; s < 7; s++)
      ((e = ((e << Uc) ^ ((e >> VP) * zP)) % GP),
        e & qP && (i ^= Uc << ((Uc << BigInt(s)) - Uc)));
    d3.push(i);
  }
  const [WP, ZP] = BP(d3, !0),
    jb = (t, e, n) => (n > 32 ? $P(t, e, n) : DP(t, e, n)),
    Ub = (t, e, n) => (n > 32 ? HP(t, e, n) : FP(t, e, n));
  function YP(t, e = 24) {
    const n = new Uint32Array(10);
    for (let r = 24 - e; r < 24; r++) {
      for (let o = 0; o < 10; o++)
        n[o] = t[o] ^ t[o + 10] ^ t[o + 20] ^ t[o + 30] ^ t[o + 40];
      for (let o = 0; o < 10; o += 2) {
        const a = (o + 8) % 10,
          c = (o + 2) % 10,
          l = n[c],
          u = n[c + 1],
          d = jb(l, u, 1) ^ n[a],
          f = Ub(l, u, 1) ^ n[a + 1];
        for (let h = 0; h < 50; h += 10) ((t[o + h] ^= d), (t[o + h + 1] ^= f));
      }
      let i = t[2],
        s = t[3];
      for (let o = 0; o < 24; o++) {
        const a = u3[o],
          c = jb(i, s, a),
          l = Ub(i, s, a),
          u = l3[o];
        ((i = t[u]), (s = t[u + 1]), (t[u] = c), (t[u + 1] = l));
      }
      for (let o = 0; o < 50; o += 10) {
        for (let a = 0; a < 10; a++) n[a] = t[o + a];
        for (let a = 0; a < 10; a++)
          t[o + a] ^= ~n[(a + 2) % 10] & n[(a + 4) % 10];
      }
      ((t[0] ^= WP[r]), (t[1] ^= ZP[r]));
    }
    n.fill(0);
  }
  class qy extends Ky {
    constructor(e, n, r, i = !1, s = 24) {
      if (
        (super(),
        (this.blockLen = e),
        (this.suffix = n),
        (this.outputLen = r),
        (this.enableXOF = i),
        (this.rounds = s),
        (this.pos = 0),
        (this.posOut = 0),
        (this.finished = !1),
        (this.destroyed = !1),
        $n(r),
        0 >= this.blockLen || this.blockLen >= 200)
      )
        throw new Error('Sha3 supports only keccak-f1600 function');
      ((this.state = new Uint8Array(200)), (this.state32 = $d(this.state)));
    }
    keccak() {
      (jf || Uf(this.state32),
        YP(this.state32, this.rounds),
        jf || Uf(this.state32),
        (this.posOut = 0),
        (this.pos = 0));
    }
    update(e) {
      Vo(this);
      const {blockLen: n, state: r} = this;
      e = sc(e);
      const i = e.length;
      for (let s = 0; s < i; ) {
        const o = Math.min(n - this.pos, i - s);
        for (let a = 0; a < o; a++) r[this.pos++] ^= e[s++];
        this.pos === n && this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished) return;
      this.finished = !0;
      const {state: e, suffix: n, pos: r, blockLen: i} = this;
      ((e[r] ^= n),
        (n & 128) !== 0 && r === i - 1 && this.keccak(),
        (e[i - 1] ^= 128),
        this.keccak());
    }
    writeInto(e) {
      (Vo(this, !1), kc(e), this.finish());
      const n = this.state,
        {blockLen: r} = this;
      for (let i = 0, s = e.length; i < s; ) {
        this.posOut >= r && this.keccak();
        const o = Math.min(r - this.posOut, s - i);
        (e.set(n.subarray(this.posOut, this.posOut + o), i),
          (this.posOut += o),
          (i += o));
      }
      return e;
    }
    xofInto(e) {
      if (!this.enableXOF)
        throw new Error('XOF is not possible for this instance');
      return this.writeInto(e);
    }
    xof(e) {
      return ($n(e), this.xofInto(new Uint8Array(e)));
    }
    digestInto(e) {
      if ((Uy(e, this), this.finished))
        throw new Error('digest() was already called');
      return (this.writeInto(e), this.destroy(), e);
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      ((this.destroyed = !0), this.state.fill(0));
    }
    _cloneInto(e) {
      const {
        blockLen: n,
        suffix: r,
        outputLen: i,
        rounds: s,
        enableXOF: o
      } = this;
      return (
        e || (e = new qy(n, r, i, o, s)),
        e.state32.set(this.state32),
        (e.pos = this.pos),
        (e.posOut = this.posOut),
        (e.finished = this.finished),
        (e.rounds = s),
        (e.suffix = r),
        (e.outputLen = i),
        (e.enableXOF = o),
        (e.destroyed = this.destroyed),
        e
      );
    }
  }
  const QP = (t, e, n) => a3(() => new qy(e, t, n)),
    Kb = QP(1, 136, 256 / 8),
    qf = s3.bytes;
  function f3(t) {
    if (!(t instanceof Uint8Array))
      throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof t}`);
    return new TextDecoder().decode(t);
  }
  function JP(t, e) {
    if (t.length !== e.length) return !1;
    for (let n = 0; n < t.length; n++) if (t[n] !== e[n]) return !1;
    return !0;
  }
  function XP(t) {
    return (e) => (s3.bytes(e), t(e));
  }
  (() => {
    const t =
        typeof globalThis == 'object' && 'crypto' in globalThis
          ? globalThis.crypto
          : void 0,
      e =
        typeof al < 'u' &&
        typeof al.require == 'function' &&
        al.require.bind(al);
    return {node: e && !t ? e('crypto') : void 0, web: t};
  })();
  const xn = (() => {
    const t = XP(Kb);
    return ((t.create = Kb.create), t);
  })();
  var Xe;
  (function (t) {
    t.assertEqual = (i) => {};
    function e(i) {}
    t.assertIs = e;
    function n(i) {
      throw new Error();
    }
    ((t.assertNever = n),
      (t.arrayToEnum = (i) => {
        const s = {};
        for (const o of i) s[o] = o;
        return s;
      }),
      (t.getValidEnumValues = (i) => {
        const s = t.objectKeys(i).filter((a) => typeof i[i[a]] != 'number'),
          o = {};
        for (const a of s) o[a] = i[a];
        return t.objectValues(o);
      }),
      (t.objectValues = (i) =>
        t.objectKeys(i).map(function (s) {
          return i[s];
        })),
      (t.objectKeys =
        typeof Object.keys == 'function'
          ? (i) => Object.keys(i)
          : (i) => {
              const s = [];
              for (const o in i)
                Object.prototype.hasOwnProperty.call(i, o) && s.push(o);
              return s;
            }),
      (t.find = (i, s) => {
        for (const o of i) if (s(o)) return o;
      }),
      (t.isInteger =
        typeof Number.isInteger == 'function'
          ? (i) => Number.isInteger(i)
          : (i) =>
              typeof i == 'number' &&
              Number.isFinite(i) &&
              Math.floor(i) === i));
    function r(i, s = ' | ') {
      return i.map((o) => (typeof o == 'string' ? `'${o}'` : o)).join(s);
    }
    ((t.joinValues = r),
      (t.jsonStringifyReplacer = (i, s) =>
        typeof s == 'bigint' ? s.toString() : s));
  })(Xe || (Xe = {}));
  var z0;
  (function (t) {
    t.mergeShapes = (e, n) => ({...e, ...n});
  })(z0 || (z0 = {}));
  const Ee = Xe.arrayToEnum([
      'string',
      'nan',
      'number',
      'integer',
      'float',
      'boolean',
      'date',
      'bigint',
      'symbol',
      'function',
      'undefined',
      'null',
      'array',
      'object',
      'unknown',
      'promise',
      'void',
      'never',
      'map',
      'set'
    ]),
    Bi = (t) => {
      switch (typeof t) {
        case 'undefined':
          return Ee.undefined;
        case 'string':
          return Ee.string;
        case 'number':
          return Number.isNaN(t) ? Ee.nan : Ee.number;
        case 'boolean':
          return Ee.boolean;
        case 'function':
          return Ee.function;
        case 'bigint':
          return Ee.bigint;
        case 'symbol':
          return Ee.symbol;
        case 'object':
          return Array.isArray(t)
            ? Ee.array
            : t === null
              ? Ee.null
              : t.then &&
                  typeof t.then == 'function' &&
                  t.catch &&
                  typeof t.catch == 'function'
                ? Ee.promise
                : typeof Map < 'u' && t instanceof Map
                  ? Ee.map
                  : typeof Set < 'u' && t instanceof Set
                    ? Ee.set
                    : typeof Date < 'u' && t instanceof Date
                      ? Ee.date
                      : Ee.object;
        default:
          return Ee.unknown;
      }
    },
    ye = Xe.arrayToEnum([
      'invalid_type',
      'invalid_literal',
      'custom',
      'invalid_union',
      'invalid_union_discriminator',
      'invalid_enum_value',
      'unrecognized_keys',
      'invalid_arguments',
      'invalid_return_type',
      'invalid_date',
      'invalid_string',
      'too_small',
      'too_big',
      'invalid_intersection_types',
      'not_multiple_of',
      'not_finite'
    ]),
    eM = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, '$1:');
  class tr extends Error {
    get errors() {
      return this.issues;
    }
    constructor(e) {
      (super(),
        (this.issues = []),
        (this.addIssue = (r) => {
          this.issues = [...this.issues, r];
        }),
        (this.addIssues = (r = []) => {
          this.issues = [...this.issues, ...r];
        }));
      const n = new.target.prototype;
      (Object.setPrototypeOf
        ? Object.setPrototypeOf(this, n)
        : (this.__proto__ = n),
        (this.name = 'ZodError'),
        (this.issues = e));
    }
    format(e) {
      const n =
          e ||
          function (s) {
            return s.message;
          },
        r = {_errors: []},
        i = (s) => {
          for (const o of s.issues)
            if (o.code === 'invalid_union') o.unionErrors.map(i);
            else if (o.code === 'invalid_return_type') i(o.returnTypeError);
            else if (o.code === 'invalid_arguments') i(o.argumentsError);
            else if (o.path.length === 0) r._errors.push(n(o));
            else {
              let a = r,
                c = 0;
              for (; c < o.path.length; ) {
                const l = o.path[c];
                (c === o.path.length - 1
                  ? ((a[l] = a[l] || {_errors: []}), a[l]._errors.push(n(o)))
                  : (a[l] = a[l] || {_errors: []}),
                  (a = a[l]),
                  c++);
              }
            }
        };
      return (i(this), r);
    }
    static assert(e) {
      if (!(e instanceof tr)) throw new Error(`Not a ZodError: ${e}`);
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, Xe.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(e = (n) => n.message) {
      const n = {},
        r = [];
      for (const i of this.issues)
        if (i.path.length > 0) {
          const s = i.path[0];
          ((n[s] = n[s] || []), n[s].push(e(i)));
        } else r.push(e(i));
      return {formErrors: r, fieldErrors: n};
    }
    get formErrors() {
      return this.flatten();
    }
  }
  tr.create = (t) => new tr(t);
  const oc = (t, e) => {
    let n;
    switch (t.code) {
      case ye.invalid_type:
        t.received === Ee.undefined
          ? (n = 'Required')
          : (n = `Expected ${t.expected}, received ${t.received}`);
        break;
      case ye.invalid_literal:
        n = `Invalid literal value, expected ${JSON.stringify(t.expected, Xe.jsonStringifyReplacer)}`;
        break;
      case ye.unrecognized_keys:
        n = `Unrecognized key(s) in object: ${Xe.joinValues(t.keys, ', ')}`;
        break;
      case ye.invalid_union:
        n = 'Invalid input';
        break;
      case ye.invalid_union_discriminator:
        n = `Invalid discriminator value. Expected ${Xe.joinValues(t.options)}`;
        break;
      case ye.invalid_enum_value:
        n = `Invalid enum value. Expected ${Xe.joinValues(t.options)}, received '${t.received}'`;
        break;
      case ye.invalid_arguments:
        n = 'Invalid function arguments';
        break;
      case ye.invalid_return_type:
        n = 'Invalid function return type';
        break;
      case ye.invalid_date:
        n = 'Invalid date';
        break;
      case ye.invalid_string:
        typeof t.validation == 'object'
          ? 'includes' in t.validation
            ? ((n = `Invalid input: must include "${t.validation.includes}"`),
              typeof t.validation.position == 'number' &&
                (n = `${n} at one or more positions greater than or equal to ${t.validation.position}`))
            : 'startsWith' in t.validation
              ? (n = `Invalid input: must start with "${t.validation.startsWith}"`)
              : 'endsWith' in t.validation
                ? (n = `Invalid input: must end with "${t.validation.endsWith}"`)
                : Xe.assertNever(t.validation)
          : t.validation !== 'regex'
            ? (n = `Invalid ${t.validation}`)
            : (n = 'Invalid');
        break;
      case ye.too_small:
        t.type === 'array'
          ? (n = `Array must contain ${t.exact ? 'exactly' : t.inclusive ? 'at least' : 'more than'} ${t.minimum} element(s)`)
          : t.type === 'string'
            ? (n = `String must contain ${t.exact ? 'exactly' : t.inclusive ? 'at least' : 'over'} ${t.minimum} character(s)`)
            : t.type === 'number'
              ? (n = `Number must be ${t.exact ? 'exactly equal to ' : t.inclusive ? 'greater than or equal to ' : 'greater than '}${t.minimum}`)
              : t.type === 'bigint'
                ? (n = `Number must be ${t.exact ? 'exactly equal to ' : t.inclusive ? 'greater than or equal to ' : 'greater than '}${t.minimum}`)
                : t.type === 'date'
                  ? (n = `Date must be ${t.exact ? 'exactly equal to ' : t.inclusive ? 'greater than or equal to ' : 'greater than '}${new Date(Number(t.minimum))}`)
                  : (n = 'Invalid input');
        break;
      case ye.too_big:
        t.type === 'array'
          ? (n = `Array must contain ${t.exact ? 'exactly' : t.inclusive ? 'at most' : 'less than'} ${t.maximum} element(s)`)
          : t.type === 'string'
            ? (n = `String must contain ${t.exact ? 'exactly' : t.inclusive ? 'at most' : 'under'} ${t.maximum} character(s)`)
            : t.type === 'number'
              ? (n = `Number must be ${t.exact ? 'exactly' : t.inclusive ? 'less than or equal to' : 'less than'} ${t.maximum}`)
              : t.type === 'bigint'
                ? (n = `BigInt must be ${t.exact ? 'exactly' : t.inclusive ? 'less than or equal to' : 'less than'} ${t.maximum}`)
                : t.type === 'date'
                  ? (n = `Date must be ${t.exact ? 'exactly' : t.inclusive ? 'smaller than or equal to' : 'smaller than'} ${new Date(Number(t.maximum))}`)
                  : (n = 'Invalid input');
        break;
      case ye.custom:
        n = 'Invalid input';
        break;
      case ye.invalid_intersection_types:
        n = 'Intersection results could not be merged';
        break;
      case ye.not_multiple_of:
        n = `Number must be a multiple of ${t.multipleOf}`;
        break;
      case ye.not_finite:
        n = 'Number must be finite';
        break;
      default:
        ((n = e.defaultError), Xe.assertNever(t));
    }
    return {message: n};
  };
  let h3 = oc;
  function tM(t) {
    h3 = t;
  }
  function Vf() {
    return h3;
  }
  const Gf = (t) => {
      const {data: e, path: n, errorMaps: r, issueData: i} = t,
        s = [...n, ...(i.path || [])],
        o = {...i, path: s};
      if (i.message !== void 0) return {...i, path: s, message: i.message};
      let a = '';
      const c = r
        .filter((l) => !!l)
        .slice()
        .reverse();
      for (const l of c) a = l(o, {data: e, defaultError: a}).message;
      return {...i, path: s, message: a};
    },
    nM = [];
  function be(t, e) {
    const n = Vf(),
      r = Gf({
        issueData: e,
        data: t.data,
        path: t.path,
        errorMaps: [
          t.common.contextualErrorMap,
          t.schemaErrorMap,
          n,
          n === oc ? void 0 : oc
        ].filter((i) => !!i)
      });
    t.common.issues.push(r);
  }
  class yn {
    constructor() {
      this.value = 'valid';
    }
    dirty() {
      this.value === 'valid' && (this.value = 'dirty');
    }
    abort() {
      this.value !== 'aborted' && (this.value = 'aborted');
    }
    static mergeArray(e, n) {
      const r = [];
      for (const i of n) {
        if (i.status === 'aborted') return Pe;
        (i.status === 'dirty' && e.dirty(), r.push(i.value));
      }
      return {status: e.value, value: r};
    }
    static async mergeObjectAsync(e, n) {
      const r = [];
      for (const i of n) {
        const s = await i.key,
          o = await i.value;
        r.push({key: s, value: o});
      }
      return yn.mergeObjectSync(e, r);
    }
    static mergeObjectSync(e, n) {
      const r = {};
      for (const i of n) {
        const {key: s, value: o} = i;
        if (s.status === 'aborted' || o.status === 'aborted') return Pe;
        (s.status === 'dirty' && e.dirty(),
          o.status === 'dirty' && e.dirty(),
          s.value !== '__proto__' &&
            (typeof o.value < 'u' || i.alwaysSet) &&
            (r[s.value] = o.value));
      }
      return {status: e.value, value: r};
    }
  }
  const Pe = Object.freeze({status: 'aborted'}),
    Pa = (t) => ({status: 'dirty', value: t}),
    Pn = (t) => ({status: 'valid', value: t}),
    W0 = (t) => t.status === 'aborted',
    Z0 = (t) => t.status === 'dirty',
    Go = (t) => t.status === 'valid',
    Fl = (t) => typeof Promise < 'u' && t instanceof Promise;
  var Se;
  (function (t) {
    ((t.errToObj = (e) => (typeof e == 'string' ? {message: e} : e || {})),
      (t.toString = (e) =>
        typeof e == 'string' ? e : e == null ? void 0 : e.message));
  })(Se || (Se = {}));
  class mi {
    constructor(e, n, r, i) {
      ((this._cachedPath = []),
        (this.parent = e),
        (this.data = n),
        (this._path = r),
        (this._key = i));
    }
    get path() {
      return (
        this._cachedPath.length ||
          (Array.isArray(this._key)
            ? this._cachedPath.push(...this._path, ...this._key)
            : this._cachedPath.push(...this._path, this._key)),
        this._cachedPath
      );
    }
  }
  const qb = (t, e) => {
    if (Go(e)) return {success: !0, data: e.value};
    if (!t.common.issues.length)
      throw new Error('Validation failed but no issues detected.');
    return {
      success: !1,
      get error() {
        if (this._error) return this._error;
        const n = new tr(t.common.issues);
        return ((this._error = n), this._error);
      }
    };
  };
  function Ue(t) {
    if (!t) return {};
    const {
      errorMap: e,
      invalid_type_error: n,
      required_error: r,
      description: i
    } = t;
    if (e && (n || r))
      throw new Error(
        `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`
      );
    return e
      ? {errorMap: e, description: i}
      : {
          errorMap: (o, a) => {
            const {message: c} = t;
            return o.code === 'invalid_enum_value'
              ? {message: c ?? a.defaultError}
              : typeof a.data > 'u'
                ? {message: c ?? r ?? a.defaultError}
                : o.code !== 'invalid_type'
                  ? {message: a.defaultError}
                  : {message: c ?? n ?? a.defaultError};
          },
          description: i
        };
  }
  class Ve {
    get description() {
      return this._def.description;
    }
    _getType(e) {
      return Bi(e.data);
    }
    _getOrReturnCtx(e, n) {
      return (
        n || {
          common: e.parent.common,
          data: e.data,
          parsedType: Bi(e.data),
          schemaErrorMap: this._def.errorMap,
          path: e.path,
          parent: e.parent
        }
      );
    }
    _processInputParams(e) {
      return {
        status: new yn(),
        ctx: {
          common: e.parent.common,
          data: e.data,
          parsedType: Bi(e.data),
          schemaErrorMap: this._def.errorMap,
          path: e.path,
          parent: e.parent
        }
      };
    }
    _parseSync(e) {
      const n = this._parse(e);
      if (Fl(n)) throw new Error('Synchronous parse encountered promise.');
      return n;
    }
    _parseAsync(e) {
      const n = this._parse(e);
      return Promise.resolve(n);
    }
    parse(e, n) {
      const r = this.safeParse(e, n);
      if (r.success) return r.data;
      throw r.error;
    }
    safeParse(e, n) {
      const r = {
          common: {
            issues: [],
            async: (n == null ? void 0 : n.async) ?? !1,
            contextualErrorMap: n == null ? void 0 : n.errorMap
          },
          path: (n == null ? void 0 : n.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data: e,
          parsedType: Bi(e)
        },
        i = this._parseSync({data: e, path: r.path, parent: r});
      return qb(r, i);
    }
    '~validate'(e) {
      var r, i;
      const n = {
        common: {issues: [], async: !!this['~standard'].async},
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: e,
        parsedType: Bi(e)
      };
      if (!this['~standard'].async)
        try {
          const s = this._parseSync({data: e, path: [], parent: n});
          return Go(s) ? {value: s.value} : {issues: n.common.issues};
        } catch (s) {
          ((i =
            (r = s == null ? void 0 : s.message) == null
              ? void 0
              : r.toLowerCase()) != null &&
            i.includes('encountered') &&
            (this['~standard'].async = !0),
            (n.common = {issues: [], async: !0}));
        }
      return this._parseAsync({data: e, path: [], parent: n}).then((s) =>
        Go(s) ? {value: s.value} : {issues: n.common.issues}
      );
    }
    async parseAsync(e, n) {
      const r = await this.safeParseAsync(e, n);
      if (r.success) return r.data;
      throw r.error;
    }
    async safeParseAsync(e, n) {
      const r = {
          common: {
            issues: [],
            contextualErrorMap: n == null ? void 0 : n.errorMap,
            async: !0
          },
          path: (n == null ? void 0 : n.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data: e,
          parsedType: Bi(e)
        },
        i = this._parse({data: e, path: r.path, parent: r}),
        s = await (Fl(i) ? i : Promise.resolve(i));
      return qb(r, s);
    }
    refine(e, n) {
      const r = (i) =>
        typeof n == 'string' || typeof n > 'u'
          ? {message: n}
          : typeof n == 'function'
            ? n(i)
            : n;
      return this._refinement((i, s) => {
        const o = e(i),
          a = () => s.addIssue({code: ye.custom, ...r(i)});
        return typeof Promise < 'u' && o instanceof Promise
          ? o.then((c) => (c ? !0 : (a(), !1)))
          : o
            ? !0
            : (a(), !1);
      });
    }
    refinement(e, n) {
      return this._refinement((r, i) =>
        e(r) ? !0 : (i.addIssue(typeof n == 'function' ? n(r, i) : n), !1)
      );
    }
    _refinement(e) {
      return new $r({
        schema: this,
        typeName: Oe.ZodEffects,
        effect: {type: 'refinement', refinement: e}
      });
    }
    superRefine(e) {
      return this._refinement(e);
    }
    constructor(e) {
      ((this.spa = this.safeParseAsync),
        (this._def = e),
        (this.parse = this.parse.bind(this)),
        (this.safeParse = this.safeParse.bind(this)),
        (this.parseAsync = this.parseAsync.bind(this)),
        (this.safeParseAsync = this.safeParseAsync.bind(this)),
        (this.spa = this.spa.bind(this)),
        (this.refine = this.refine.bind(this)),
        (this.refinement = this.refinement.bind(this)),
        (this.superRefine = this.superRefine.bind(this)),
        (this.optional = this.optional.bind(this)),
        (this.nullable = this.nullable.bind(this)),
        (this.nullish = this.nullish.bind(this)),
        (this.array = this.array.bind(this)),
        (this.promise = this.promise.bind(this)),
        (this.or = this.or.bind(this)),
        (this.and = this.and.bind(this)),
        (this.transform = this.transform.bind(this)),
        (this.brand = this.brand.bind(this)),
        (this.default = this.default.bind(this)),
        (this.catch = this.catch.bind(this)),
        (this.describe = this.describe.bind(this)),
        (this.pipe = this.pipe.bind(this)),
        (this.readonly = this.readonly.bind(this)),
        (this.isNullable = this.isNullable.bind(this)),
        (this.isOptional = this.isOptional.bind(this)),
        (this['~standard'] = {
          version: 1,
          vendor: 'zod',
          validate: (n) => this['~validate'](n)
        }));
    }
    optional() {
      return ui.create(this, this._def);
    }
    nullable() {
      return no.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return Lr.create(this);
    }
    promise() {
      return cc.create(this, this._def);
    }
    or(e) {
      return Ul.create([this, e], this._def);
    }
    and(e) {
      return Kl.create(this, e, this._def);
    }
    transform(e) {
      return new $r({
        ...Ue(this._def),
        schema: this,
        typeName: Oe.ZodEffects,
        effect: {type: 'transform', transform: e}
      });
    }
    default(e) {
      const n = typeof e == 'function' ? e : () => e;
      return new Wl({
        ...Ue(this._def),
        innerType: this,
        defaultValue: n,
        typeName: Oe.ZodDefault
      });
    }
    brand() {
      return new Vy({typeName: Oe.ZodBranded, type: this, ...Ue(this._def)});
    }
    catch(e) {
      const n = typeof e == 'function' ? e : () => e;
      return new Zl({
        ...Ue(this._def),
        innerType: this,
        catchValue: n,
        typeName: Oe.ZodCatch
      });
    }
    describe(e) {
      const n = this.constructor;
      return new n({...this._def, description: e});
    }
    pipe(e) {
      return Pu.create(this, e);
    }
    readonly() {
      return Yl.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  const rM = /^c[^\s-]{8,}$/i,
    iM = /^[0-9a-z]+$/,
    sM = /^[0-9A-HJKMNP-TV-Z]{26}$/i,
    oM =
      /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
    aM = /^[a-z0-9_-]{21}$/i,
    cM = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
    lM =
      /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
    uM =
      /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
    dM = '^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$';
  let lm;
  const fM =
      /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    hM =
      /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
    pM =
      /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,
    mM =
      /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    gM = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    yM =
      /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
    p3 =
      '((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))',
    vM = new RegExp(`^${p3}$`);
  function m3(t) {
    let e = '[0-5]\\d';
    t.precision
      ? (e = `${e}\\.\\d{${t.precision}}`)
      : t.precision == null && (e = `${e}(\\.\\d+)?`);
    const n = t.precision ? '+' : '?';
    return `([01]\\d|2[0-3]):[0-5]\\d(:${e})${n}`;
  }
  function bM(t) {
    return new RegExp(`^${m3(t)}$`);
  }
  function g3(t) {
    let e = `${p3}T${m3(t)}`;
    const n = [];
    return (
      n.push(t.local ? 'Z?' : 'Z'),
      t.offset && n.push('([+-]\\d{2}:?\\d{2})'),
      (e = `${e}(${n.join('|')})`),
      new RegExp(`^${e}$`)
    );
  }
  function wM(t, e) {
    return !!(
      ((e === 'v4' || !e) && fM.test(t)) ||
      ((e === 'v6' || !e) && pM.test(t))
    );
  }
  function _M(t, e) {
    if (!cM.test(t)) return !1;
    try {
      const [n] = t.split('.');
      if (!n) return !1;
      const r = n
          .replace(/-/g, '+')
          .replace(/_/g, '/')
          .padEnd(n.length + ((4 - (n.length % 4)) % 4), '='),
        i = JSON.parse(atob(r));
      return !(
        typeof i != 'object' ||
        i === null ||
        ('typ' in i && (i == null ? void 0 : i.typ) !== 'JWT') ||
        !i.alg ||
        (e && i.alg !== e)
      );
    } catch {
      return !1;
    }
  }
  function EM(t, e) {
    return !!(
      ((e === 'v4' || !e) && hM.test(t)) ||
      ((e === 'v6' || !e) && mM.test(t))
    );
  }
  class Or extends Ve {
    _parse(e) {
      if (
        (this._def.coerce && (e.data = String(e.data)),
        this._getType(e) !== Ee.string)
      ) {
        const s = this._getOrReturnCtx(e);
        return (
          be(s, {
            code: ye.invalid_type,
            expected: Ee.string,
            received: s.parsedType
          }),
          Pe
        );
      }
      const r = new yn();
      let i;
      for (const s of this._def.checks)
        if (s.kind === 'min')
          e.data.length < s.value &&
            ((i = this._getOrReturnCtx(e, i)),
            be(i, {
              code: ye.too_small,
              minimum: s.value,
              type: 'string',
              inclusive: !0,
              exact: !1,
              message: s.message
            }),
            r.dirty());
        else if (s.kind === 'max')
          e.data.length > s.value &&
            ((i = this._getOrReturnCtx(e, i)),
            be(i, {
              code: ye.too_big,
              maximum: s.value,
              type: 'string',
              inclusive: !0,
              exact: !1,
              message: s.message
            }),
            r.dirty());
        else if (s.kind === 'length') {
          const o = e.data.length > s.value,
            a = e.data.length < s.value;
          (o || a) &&
            ((i = this._getOrReturnCtx(e, i)),
            o
              ? be(i, {
                  code: ye.too_big,
                  maximum: s.value,
                  type: 'string',
                  inclusive: !0,
                  exact: !0,
                  message: s.message
                })
              : a &&
                be(i, {
                  code: ye.too_small,
                  minimum: s.value,
                  type: 'string',
                  inclusive: !0,
                  exact: !0,
                  message: s.message
                }),
            r.dirty());
        } else if (s.kind === 'email')
          uM.test(e.data) ||
            ((i = this._getOrReturnCtx(e, i)),
            be(i, {
              validation: 'email',
              code: ye.invalid_string,
              message: s.message
            }),
            r.dirty());
        else if (s.kind === 'emoji')
          (lm || (lm = new RegExp(dM, 'u')),
            lm.test(e.data) ||
              ((i = this._getOrReturnCtx(e, i)),
              be(i, {
                validation: 'emoji',
                code: ye.invalid_string,
                message: s.message
              }),
              r.dirty()));
        else if (s.kind === 'uuid')
          oM.test(e.data) ||
            ((i = this._getOrReturnCtx(e, i)),
            be(i, {
              validation: 'uuid',
              code: ye.invalid_string,
              message: s.message
            }),
            r.dirty());
        else if (s.kind === 'nanoid')
          aM.test(e.data) ||
            ((i = this._getOrReturnCtx(e, i)),
            be(i, {
              validation: 'nanoid',
              code: ye.invalid_string,
              message: s.message
            }),
            r.dirty());
        else if (s.kind === 'cuid')
          rM.test(e.data) ||
            ((i = this._getOrReturnCtx(e, i)),
            be(i, {
              validation: 'cuid',
              code: ye.invalid_string,
              message: s.message
            }),
            r.dirty());
        else if (s.kind === 'cuid2')
          iM.test(e.data) ||
            ((i = this._getOrReturnCtx(e, i)),
            be(i, {
              validation: 'cuid2',
              code: ye.invalid_string,
              message: s.message
            }),
            r.dirty());
        else if (s.kind === 'ulid')
          sM.test(e.data) ||
            ((i = this._getOrReturnCtx(e, i)),
            be(i, {
              validation: 'ulid',
              code: ye.invalid_string,
              message: s.message
            }),
            r.dirty());
        else if (s.kind === 'url')
          try {
            new URL(e.data);
          } catch {
            ((i = this._getOrReturnCtx(e, i)),
              be(i, {
                validation: 'url',
                code: ye.invalid_string,
                message: s.message
              }),
              r.dirty());
          }
        else
          s.kind === 'regex'
            ? ((s.regex.lastIndex = 0),
              s.regex.test(e.data) ||
                ((i = this._getOrReturnCtx(e, i)),
                be(i, {
                  validation: 'regex',
                  code: ye.invalid_string,
                  message: s.message
                }),
                r.dirty()))
            : s.kind === 'trim'
              ? (e.data = e.data.trim())
              : s.kind === 'includes'
                ? e.data.includes(s.value, s.position) ||
                  ((i = this._getOrReturnCtx(e, i)),
                  be(i, {
                    code: ye.invalid_string,
                    validation: {includes: s.value, position: s.position},
                    message: s.message
                  }),
                  r.dirty())
                : s.kind === 'toLowerCase'
                  ? (e.data = e.data.toLowerCase())
                  : s.kind === 'toUpperCase'
                    ? (e.data = e.data.toUpperCase())
                    : s.kind === 'startsWith'
                      ? e.data.startsWith(s.value) ||
                        ((i = this._getOrReturnCtx(e, i)),
                        be(i, {
                          code: ye.invalid_string,
                          validation: {startsWith: s.value},
                          message: s.message
                        }),
                        r.dirty())
                      : s.kind === 'endsWith'
                        ? e.data.endsWith(s.value) ||
                          ((i = this._getOrReturnCtx(e, i)),
                          be(i, {
                            code: ye.invalid_string,
                            validation: {endsWith: s.value},
                            message: s.message
                          }),
                          r.dirty())
                        : s.kind === 'datetime'
                          ? g3(s).test(e.data) ||
                            ((i = this._getOrReturnCtx(e, i)),
                            be(i, {
                              code: ye.invalid_string,
                              validation: 'datetime',
                              message: s.message
                            }),
                            r.dirty())
                          : s.kind === 'date'
                            ? vM.test(e.data) ||
                              ((i = this._getOrReturnCtx(e, i)),
                              be(i, {
                                code: ye.invalid_string,
                                validation: 'date',
                                message: s.message
                              }),
                              r.dirty())
                            : s.kind === 'time'
                              ? bM(s).test(e.data) ||
                                ((i = this._getOrReturnCtx(e, i)),
                                be(i, {
                                  code: ye.invalid_string,
                                  validation: 'time',
                                  message: s.message
                                }),
                                r.dirty())
                              : s.kind === 'duration'
                                ? lM.test(e.data) ||
                                  ((i = this._getOrReturnCtx(e, i)),
                                  be(i, {
                                    validation: 'duration',
                                    code: ye.invalid_string,
                                    message: s.message
                                  }),
                                  r.dirty())
                                : s.kind === 'ip'
                                  ? wM(e.data, s.version) ||
                                    ((i = this._getOrReturnCtx(e, i)),
                                    be(i, {
                                      validation: 'ip',
                                      code: ye.invalid_string,
                                      message: s.message
                                    }),
                                    r.dirty())
                                  : s.kind === 'jwt'
                                    ? _M(e.data, s.alg) ||
                                      ((i = this._getOrReturnCtx(e, i)),
                                      be(i, {
                                        validation: 'jwt',
                                        code: ye.invalid_string,
                                        message: s.message
                                      }),
                                      r.dirty())
                                    : s.kind === 'cidr'
                                      ? EM(e.data, s.version) ||
                                        ((i = this._getOrReturnCtx(e, i)),
                                        be(i, {
                                          validation: 'cidr',
                                          code: ye.invalid_string,
                                          message: s.message
                                        }),
                                        r.dirty())
                                      : s.kind === 'base64'
                                        ? gM.test(e.data) ||
                                          ((i = this._getOrReturnCtx(e, i)),
                                          be(i, {
                                            validation: 'base64',
                                            code: ye.invalid_string,
                                            message: s.message
                                          }),
                                          r.dirty())
                                        : s.kind === 'base64url'
                                          ? yM.test(e.data) ||
                                            ((i = this._getOrReturnCtx(e, i)),
                                            be(i, {
                                              validation: 'base64url',
                                              code: ye.invalid_string,
                                              message: s.message
                                            }),
                                            r.dirty())
                                          : Xe.assertNever(s);
      return {status: r.value, value: e.data};
    }
    _regex(e, n, r) {
      return this.refinement((i) => e.test(i), {
        validation: n,
        code: ye.invalid_string,
        ...Se.errToObj(r)
      });
    }
    _addCheck(e) {
      return new Or({...this._def, checks: [...this._def.checks, e]});
    }
    email(e) {
      return this._addCheck({kind: 'email', ...Se.errToObj(e)});
    }
    url(e) {
      return this._addCheck({kind: 'url', ...Se.errToObj(e)});
    }
    emoji(e) {
      return this._addCheck({kind: 'emoji', ...Se.errToObj(e)});
    }
    uuid(e) {
      return this._addCheck({kind: 'uuid', ...Se.errToObj(e)});
    }
    nanoid(e) {
      return this._addCheck({kind: 'nanoid', ...Se.errToObj(e)});
    }
    cuid(e) {
      return this._addCheck({kind: 'cuid', ...Se.errToObj(e)});
    }
    cuid2(e) {
      return this._addCheck({kind: 'cuid2', ...Se.errToObj(e)});
    }
    ulid(e) {
      return this._addCheck({kind: 'ulid', ...Se.errToObj(e)});
    }
    base64(e) {
      return this._addCheck({kind: 'base64', ...Se.errToObj(e)});
    }
    base64url(e) {
      return this._addCheck({kind: 'base64url', ...Se.errToObj(e)});
    }
    jwt(e) {
      return this._addCheck({kind: 'jwt', ...Se.errToObj(e)});
    }
    ip(e) {
      return this._addCheck({kind: 'ip', ...Se.errToObj(e)});
    }
    cidr(e) {
      return this._addCheck({kind: 'cidr', ...Se.errToObj(e)});
    }
    datetime(e) {
      return typeof e == 'string'
        ? this._addCheck({
            kind: 'datetime',
            precision: null,
            offset: !1,
            local: !1,
            message: e
          })
        : this._addCheck({
            kind: 'datetime',
            precision:
              typeof (e == null ? void 0 : e.precision) > 'u'
                ? null
                : e == null
                  ? void 0
                  : e.precision,
            offset: (e == null ? void 0 : e.offset) ?? !1,
            local: (e == null ? void 0 : e.local) ?? !1,
            ...Se.errToObj(e == null ? void 0 : e.message)
          });
    }
    date(e) {
      return this._addCheck({kind: 'date', message: e});
    }
    time(e) {
      return typeof e == 'string'
        ? this._addCheck({kind: 'time', precision: null, message: e})
        : this._addCheck({
            kind: 'time',
            precision:
              typeof (e == null ? void 0 : e.precision) > 'u'
                ? null
                : e == null
                  ? void 0
                  : e.precision,
            ...Se.errToObj(e == null ? void 0 : e.message)
          });
    }
    duration(e) {
      return this._addCheck({kind: 'duration', ...Se.errToObj(e)});
    }
    regex(e, n) {
      return this._addCheck({kind: 'regex', regex: e, ...Se.errToObj(n)});
    }
    includes(e, n) {
      return this._addCheck({
        kind: 'includes',
        value: e,
        position: n == null ? void 0 : n.position,
        ...Se.errToObj(n == null ? void 0 : n.message)
      });
    }
    startsWith(e, n) {
      return this._addCheck({kind: 'startsWith', value: e, ...Se.errToObj(n)});
    }
    endsWith(e, n) {
      return this._addCheck({kind: 'endsWith', value: e, ...Se.errToObj(n)});
    }
    min(e, n) {
      return this._addCheck({kind: 'min', value: e, ...Se.errToObj(n)});
    }
    max(e, n) {
      return this._addCheck({kind: 'max', value: e, ...Se.errToObj(n)});
    }
    length(e, n) {
      return this._addCheck({kind: 'length', value: e, ...Se.errToObj(n)});
    }
    nonempty(e) {
      return this.min(1, Se.errToObj(e));
    }
    trim() {
      return new Or({
        ...this._def,
        checks: [...this._def.checks, {kind: 'trim'}]
      });
    }
    toLowerCase() {
      return new Or({
        ...this._def,
        checks: [...this._def.checks, {kind: 'toLowerCase'}]
      });
    }
    toUpperCase() {
      return new Or({
        ...this._def,
        checks: [...this._def.checks, {kind: 'toUpperCase'}]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((e) => e.kind === 'datetime');
    }
    get isDate() {
      return !!this._def.checks.find((e) => e.kind === 'date');
    }
    get isTime() {
      return !!this._def.checks.find((e) => e.kind === 'time');
    }
    get isDuration() {
      return !!this._def.checks.find((e) => e.kind === 'duration');
    }
    get isEmail() {
      return !!this._def.checks.find((e) => e.kind === 'email');
    }
    get isURL() {
      return !!this._def.checks.find((e) => e.kind === 'url');
    }
    get isEmoji() {
      return !!this._def.checks.find((e) => e.kind === 'emoji');
    }
    get isUUID() {
      return !!this._def.checks.find((e) => e.kind === 'uuid');
    }
    get isNANOID() {
      return !!this._def.checks.find((e) => e.kind === 'nanoid');
    }
    get isCUID() {
      return !!this._def.checks.find((e) => e.kind === 'cuid');
    }
    get isCUID2() {
      return !!this._def.checks.find((e) => e.kind === 'cuid2');
    }
    get isULID() {
      return !!this._def.checks.find((e) => e.kind === 'ulid');
    }
    get isIP() {
      return !!this._def.checks.find((e) => e.kind === 'ip');
    }
    get isCIDR() {
      return !!this._def.checks.find((e) => e.kind === 'cidr');
    }
    get isBase64() {
      return !!this._def.checks.find((e) => e.kind === 'base64');
    }
    get isBase64url() {
      return !!this._def.checks.find((e) => e.kind === 'base64url');
    }
    get minLength() {
      let e = null;
      for (const n of this._def.checks)
        n.kind === 'min' && (e === null || n.value > e) && (e = n.value);
      return e;
    }
    get maxLength() {
      let e = null;
      for (const n of this._def.checks)
        n.kind === 'max' && (e === null || n.value < e) && (e = n.value);
      return e;
    }
  }
  Or.create = (t) =>
    new Or({
      checks: [],
      typeName: Oe.ZodString,
      coerce: (t == null ? void 0 : t.coerce) ?? !1,
      ...Ue(t)
    });
  function AM(t, e) {
    const n = (t.toString().split('.')[1] || '').length,
      r = (e.toString().split('.')[1] || '').length,
      i = n > r ? n : r,
      s = Number.parseInt(t.toFixed(i).replace('.', '')),
      o = Number.parseInt(e.toFixed(i).replace('.', ''));
    return (s % o) / 10 ** i;
  }
  class Xs extends Ve {
    constructor() {
      (super(...arguments),
        (this.min = this.gte),
        (this.max = this.lte),
        (this.step = this.multipleOf));
    }
    _parse(e) {
      if (
        (this._def.coerce && (e.data = Number(e.data)),
        this._getType(e) !== Ee.number)
      ) {
        const s = this._getOrReturnCtx(e);
        return (
          be(s, {
            code: ye.invalid_type,
            expected: Ee.number,
            received: s.parsedType
          }),
          Pe
        );
      }
      let r;
      const i = new yn();
      for (const s of this._def.checks)
        s.kind === 'int'
          ? Xe.isInteger(e.data) ||
            ((r = this._getOrReturnCtx(e, r)),
            be(r, {
              code: ye.invalid_type,
              expected: 'integer',
              received: 'float',
              message: s.message
            }),
            i.dirty())
          : s.kind === 'min'
            ? (s.inclusive ? e.data < s.value : e.data <= s.value) &&
              ((r = this._getOrReturnCtx(e, r)),
              be(r, {
                code: ye.too_small,
                minimum: s.value,
                type: 'number',
                inclusive: s.inclusive,
                exact: !1,
                message: s.message
              }),
              i.dirty())
            : s.kind === 'max'
              ? (s.inclusive ? e.data > s.value : e.data >= s.value) &&
                ((r = this._getOrReturnCtx(e, r)),
                be(r, {
                  code: ye.too_big,
                  maximum: s.value,
                  type: 'number',
                  inclusive: s.inclusive,
                  exact: !1,
                  message: s.message
                }),
                i.dirty())
              : s.kind === 'multipleOf'
                ? AM(e.data, s.value) !== 0 &&
                  ((r = this._getOrReturnCtx(e, r)),
                  be(r, {
                    code: ye.not_multiple_of,
                    multipleOf: s.value,
                    message: s.message
                  }),
                  i.dirty())
                : s.kind === 'finite'
                  ? Number.isFinite(e.data) ||
                    ((r = this._getOrReturnCtx(e, r)),
                    be(r, {code: ye.not_finite, message: s.message}),
                    i.dirty())
                  : Xe.assertNever(s);
      return {status: i.value, value: e.data};
    }
    gte(e, n) {
      return this.setLimit('min', e, !0, Se.toString(n));
    }
    gt(e, n) {
      return this.setLimit('min', e, !1, Se.toString(n));
    }
    lte(e, n) {
      return this.setLimit('max', e, !0, Se.toString(n));
    }
    lt(e, n) {
      return this.setLimit('max', e, !1, Se.toString(n));
    }
    setLimit(e, n, r, i) {
      return new Xs({
        ...this._def,
        checks: [
          ...this._def.checks,
          {kind: e, value: n, inclusive: r, message: Se.toString(i)}
        ]
      });
    }
    _addCheck(e) {
      return new Xs({...this._def, checks: [...this._def.checks, e]});
    }
    int(e) {
      return this._addCheck({kind: 'int', message: Se.toString(e)});
    }
    positive(e) {
      return this._addCheck({
        kind: 'min',
        value: 0,
        inclusive: !1,
        message: Se.toString(e)
      });
    }
    negative(e) {
      return this._addCheck({
        kind: 'max',
        value: 0,
        inclusive: !1,
        message: Se.toString(e)
      });
    }
    nonpositive(e) {
      return this._addCheck({
        kind: 'max',
        value: 0,
        inclusive: !0,
        message: Se.toString(e)
      });
    }
    nonnegative(e) {
      return this._addCheck({
        kind: 'min',
        value: 0,
        inclusive: !0,
        message: Se.toString(e)
      });
    }
    multipleOf(e, n) {
      return this._addCheck({
        kind: 'multipleOf',
        value: e,
        message: Se.toString(n)
      });
    }
    finite(e) {
      return this._addCheck({kind: 'finite', message: Se.toString(e)});
    }
    safe(e) {
      return this._addCheck({
        kind: 'min',
        inclusive: !0,
        value: Number.MIN_SAFE_INTEGER,
        message: Se.toString(e)
      })._addCheck({
        kind: 'max',
        inclusive: !0,
        value: Number.MAX_SAFE_INTEGER,
        message: Se.toString(e)
      });
    }
    get minValue() {
      let e = null;
      for (const n of this._def.checks)
        n.kind === 'min' && (e === null || n.value > e) && (e = n.value);
      return e;
    }
    get maxValue() {
      let e = null;
      for (const n of this._def.checks)
        n.kind === 'max' && (e === null || n.value < e) && (e = n.value);
      return e;
    }
    get isInt() {
      return !!this._def.checks.find(
        (e) =>
          e.kind === 'int' || (e.kind === 'multipleOf' && Xe.isInteger(e.value))
      );
    }
    get isFinite() {
      let e = null,
        n = null;
      for (const r of this._def.checks) {
        if (r.kind === 'finite' || r.kind === 'int' || r.kind === 'multipleOf')
          return !0;
        r.kind === 'min'
          ? (n === null || r.value > n) && (n = r.value)
          : r.kind === 'max' && (e === null || r.value < e) && (e = r.value);
      }
      return Number.isFinite(n) && Number.isFinite(e);
    }
  }
  Xs.create = (t) =>
    new Xs({
      checks: [],
      typeName: Oe.ZodNumber,
      coerce: (t == null ? void 0 : t.coerce) || !1,
      ...Ue(t)
    });
  class eo extends Ve {
    constructor() {
      (super(...arguments), (this.min = this.gte), (this.max = this.lte));
    }
    _parse(e) {
      if (this._def.coerce)
        try {
          e.data = BigInt(e.data);
        } catch {
          return this._getInvalidInput(e);
        }
      if (this._getType(e) !== Ee.bigint) return this._getInvalidInput(e);
      let r;
      const i = new yn();
      for (const s of this._def.checks)
        s.kind === 'min'
          ? (s.inclusive ? e.data < s.value : e.data <= s.value) &&
            ((r = this._getOrReturnCtx(e, r)),
            be(r, {
              code: ye.too_small,
              type: 'bigint',
              minimum: s.value,
              inclusive: s.inclusive,
              message: s.message
            }),
            i.dirty())
          : s.kind === 'max'
            ? (s.inclusive ? e.data > s.value : e.data >= s.value) &&
              ((r = this._getOrReturnCtx(e, r)),
              be(r, {
                code: ye.too_big,
                type: 'bigint',
                maximum: s.value,
                inclusive: s.inclusive,
                message: s.message
              }),
              i.dirty())
            : s.kind === 'multipleOf'
              ? e.data % s.value !== BigInt(0) &&
                ((r = this._getOrReturnCtx(e, r)),
                be(r, {
                  code: ye.not_multiple_of,
                  multipleOf: s.value,
                  message: s.message
                }),
                i.dirty())
              : Xe.assertNever(s);
      return {status: i.value, value: e.data};
    }
    _getInvalidInput(e) {
      const n = this._getOrReturnCtx(e);
      return (
        be(n, {
          code: ye.invalid_type,
          expected: Ee.bigint,
          received: n.parsedType
        }),
        Pe
      );
    }
    gte(e, n) {
      return this.setLimit('min', e, !0, Se.toString(n));
    }
    gt(e, n) {
      return this.setLimit('min', e, !1, Se.toString(n));
    }
    lte(e, n) {
      return this.setLimit('max', e, !0, Se.toString(n));
    }
    lt(e, n) {
      return this.setLimit('max', e, !1, Se.toString(n));
    }
    setLimit(e, n, r, i) {
      return new eo({
        ...this._def,
        checks: [
          ...this._def.checks,
          {kind: e, value: n, inclusive: r, message: Se.toString(i)}
        ]
      });
    }
    _addCheck(e) {
      return new eo({...this._def, checks: [...this._def.checks, e]});
    }
    positive(e) {
      return this._addCheck({
        kind: 'min',
        value: BigInt(0),
        inclusive: !1,
        message: Se.toString(e)
      });
    }
    negative(e) {
      return this._addCheck({
        kind: 'max',
        value: BigInt(0),
        inclusive: !1,
        message: Se.toString(e)
      });
    }
    nonpositive(e) {
      return this._addCheck({
        kind: 'max',
        value: BigInt(0),
        inclusive: !0,
        message: Se.toString(e)
      });
    }
    nonnegative(e) {
      return this._addCheck({
        kind: 'min',
        value: BigInt(0),
        inclusive: !0,
        message: Se.toString(e)
      });
    }
    multipleOf(e, n) {
      return this._addCheck({
        kind: 'multipleOf',
        value: e,
        message: Se.toString(n)
      });
    }
    get minValue() {
      let e = null;
      for (const n of this._def.checks)
        n.kind === 'min' && (e === null || n.value > e) && (e = n.value);
      return e;
    }
    get maxValue() {
      let e = null;
      for (const n of this._def.checks)
        n.kind === 'max' && (e === null || n.value < e) && (e = n.value);
      return e;
    }
  }
  eo.create = (t) =>
    new eo({
      checks: [],
      typeName: Oe.ZodBigInt,
      coerce: (t == null ? void 0 : t.coerce) ?? !1,
      ...Ue(t)
    });
  class $l extends Ve {
    _parse(e) {
      if (
        (this._def.coerce && (e.data = !!e.data),
        this._getType(e) !== Ee.boolean)
      ) {
        const r = this._getOrReturnCtx(e);
        return (
          be(r, {
            code: ye.invalid_type,
            expected: Ee.boolean,
            received: r.parsedType
          }),
          Pe
        );
      }
      return Pn(e.data);
    }
  }
  $l.create = (t) =>
    new $l({
      typeName: Oe.ZodBoolean,
      coerce: (t == null ? void 0 : t.coerce) || !1,
      ...Ue(t)
    });
  class zo extends Ve {
    _parse(e) {
      if (
        (this._def.coerce && (e.data = new Date(e.data)),
        this._getType(e) !== Ee.date)
      ) {
        const s = this._getOrReturnCtx(e);
        return (
          be(s, {
            code: ye.invalid_type,
            expected: Ee.date,
            received: s.parsedType
          }),
          Pe
        );
      }
      if (Number.isNaN(e.data.getTime())) {
        const s = this._getOrReturnCtx(e);
        return (be(s, {code: ye.invalid_date}), Pe);
      }
      const r = new yn();
      let i;
      for (const s of this._def.checks)
        s.kind === 'min'
          ? e.data.getTime() < s.value &&
            ((i = this._getOrReturnCtx(e, i)),
            be(i, {
              code: ye.too_small,
              message: s.message,
              inclusive: !0,
              exact: !1,
              minimum: s.value,
              type: 'date'
            }),
            r.dirty())
          : s.kind === 'max'
            ? e.data.getTime() > s.value &&
              ((i = this._getOrReturnCtx(e, i)),
              be(i, {
                code: ye.too_big,
                message: s.message,
                inclusive: !0,
                exact: !1,
                maximum: s.value,
                type: 'date'
              }),
              r.dirty())
            : Xe.assertNever(s);
      return {status: r.value, value: new Date(e.data.getTime())};
    }
    _addCheck(e) {
      return new zo({...this._def, checks: [...this._def.checks, e]});
    }
    min(e, n) {
      return this._addCheck({
        kind: 'min',
        value: e.getTime(),
        message: Se.toString(n)
      });
    }
    max(e, n) {
      return this._addCheck({
        kind: 'max',
        value: e.getTime(),
        message: Se.toString(n)
      });
    }
    get minDate() {
      let e = null;
      for (const n of this._def.checks)
        n.kind === 'min' && (e === null || n.value > e) && (e = n.value);
      return e != null ? new Date(e) : null;
    }
    get maxDate() {
      let e = null;
      for (const n of this._def.checks)
        n.kind === 'max' && (e === null || n.value < e) && (e = n.value);
      return e != null ? new Date(e) : null;
    }
  }
  zo.create = (t) =>
    new zo({
      checks: [],
      coerce: (t == null ? void 0 : t.coerce) || !1,
      typeName: Oe.ZodDate,
      ...Ue(t)
    });
  class zf extends Ve {
    _parse(e) {
      if (this._getType(e) !== Ee.symbol) {
        const r = this._getOrReturnCtx(e);
        return (
          be(r, {
            code: ye.invalid_type,
            expected: Ee.symbol,
            received: r.parsedType
          }),
          Pe
        );
      }
      return Pn(e.data);
    }
  }
  zf.create = (t) => new zf({typeName: Oe.ZodSymbol, ...Ue(t)});
  class Hl extends Ve {
    _parse(e) {
      if (this._getType(e) !== Ee.undefined) {
        const r = this._getOrReturnCtx(e);
        return (
          be(r, {
            code: ye.invalid_type,
            expected: Ee.undefined,
            received: r.parsedType
          }),
          Pe
        );
      }
      return Pn(e.data);
    }
  }
  Hl.create = (t) => new Hl({typeName: Oe.ZodUndefined, ...Ue(t)});
  class jl extends Ve {
    _parse(e) {
      if (this._getType(e) !== Ee.null) {
        const r = this._getOrReturnCtx(e);
        return (
          be(r, {
            code: ye.invalid_type,
            expected: Ee.null,
            received: r.parsedType
          }),
          Pe
        );
      }
      return Pn(e.data);
    }
  }
  jl.create = (t) => new jl({typeName: Oe.ZodNull, ...Ue(t)});
  class ac extends Ve {
    constructor() {
      (super(...arguments), (this._any = !0));
    }
    _parse(e) {
      return Pn(e.data);
    }
  }
  ac.create = (t) => new ac({typeName: Oe.ZodAny, ...Ue(t)});
  class Do extends Ve {
    constructor() {
      (super(...arguments), (this._unknown = !0));
    }
    _parse(e) {
      return Pn(e.data);
    }
  }
  Do.create = (t) => new Do({typeName: Oe.ZodUnknown, ...Ue(t)});
  class ns extends Ve {
    _parse(e) {
      const n = this._getOrReturnCtx(e);
      return (
        be(n, {
          code: ye.invalid_type,
          expected: Ee.never,
          received: n.parsedType
        }),
        Pe
      );
    }
  }
  ns.create = (t) => new ns({typeName: Oe.ZodNever, ...Ue(t)});
  class Wf extends Ve {
    _parse(e) {
      if (this._getType(e) !== Ee.undefined) {
        const r = this._getOrReturnCtx(e);
        return (
          be(r, {
            code: ye.invalid_type,
            expected: Ee.void,
            received: r.parsedType
          }),
          Pe
        );
      }
      return Pn(e.data);
    }
  }
  Wf.create = (t) => new Wf({typeName: Oe.ZodVoid, ...Ue(t)});
  class Lr extends Ve {
    _parse(e) {
      const {ctx: n, status: r} = this._processInputParams(e),
        i = this._def;
      if (n.parsedType !== Ee.array)
        return (
          be(n, {
            code: ye.invalid_type,
            expected: Ee.array,
            received: n.parsedType
          }),
          Pe
        );
      if (i.exactLength !== null) {
        const o = n.data.length > i.exactLength.value,
          a = n.data.length < i.exactLength.value;
        (o || a) &&
          (be(n, {
            code: o ? ye.too_big : ye.too_small,
            minimum: a ? i.exactLength.value : void 0,
            maximum: o ? i.exactLength.value : void 0,
            type: 'array',
            inclusive: !0,
            exact: !0,
            message: i.exactLength.message
          }),
          r.dirty());
      }
      if (
        (i.minLength !== null &&
          n.data.length < i.minLength.value &&
          (be(n, {
            code: ye.too_small,
            minimum: i.minLength.value,
            type: 'array',
            inclusive: !0,
            exact: !1,
            message: i.minLength.message
          }),
          r.dirty()),
        i.maxLength !== null &&
          n.data.length > i.maxLength.value &&
          (be(n, {
            code: ye.too_big,
            maximum: i.maxLength.value,
            type: 'array',
            inclusive: !0,
            exact: !1,
            message: i.maxLength.message
          }),
          r.dirty()),
        n.common.async)
      )
        return Promise.all(
          [...n.data].map((o, a) => i.type._parseAsync(new mi(n, o, n.path, a)))
        ).then((o) => yn.mergeArray(r, o));
      const s = [...n.data].map((o, a) =>
        i.type._parseSync(new mi(n, o, n.path, a))
      );
      return yn.mergeArray(r, s);
    }
    get element() {
      return this._def.type;
    }
    min(e, n) {
      return new Lr({
        ...this._def,
        minLength: {value: e, message: Se.toString(n)}
      });
    }
    max(e, n) {
      return new Lr({
        ...this._def,
        maxLength: {value: e, message: Se.toString(n)}
      });
    }
    length(e, n) {
      return new Lr({
        ...this._def,
        exactLength: {value: e, message: Se.toString(n)}
      });
    }
    nonempty(e) {
      return this.min(1, e);
    }
  }
  Lr.create = (t, e) =>
    new Lr({
      type: t,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: Oe.ZodArray,
      ...Ue(e)
    });
  function Aa(t) {
    if (t instanceof At) {
      const e = {};
      for (const n in t.shape) {
        const r = t.shape[n];
        e[n] = ui.create(Aa(r));
      }
      return new At({...t._def, shape: () => e});
    } else
      return t instanceof Lr
        ? new Lr({...t._def, type: Aa(t.element)})
        : t instanceof ui
          ? ui.create(Aa(t.unwrap()))
          : t instanceof no
            ? no.create(Aa(t.unwrap()))
            : t instanceof gi
              ? gi.create(t.items.map((e) => Aa(e)))
              : t;
  }
  class At extends Ve {
    constructor() {
      (super(...arguments),
        (this._cached = null),
        (this.nonstrict = this.passthrough),
        (this.augment = this.extend));
    }
    _getCached() {
      if (this._cached !== null) return this._cached;
      const e = this._def.shape(),
        n = Xe.objectKeys(e);
      return ((this._cached = {shape: e, keys: n}), this._cached);
    }
    _parse(e) {
      if (this._getType(e) !== Ee.object) {
        const l = this._getOrReturnCtx(e);
        return (
          be(l, {
            code: ye.invalid_type,
            expected: Ee.object,
            received: l.parsedType
          }),
          Pe
        );
      }
      const {status: r, ctx: i} = this._processInputParams(e),
        {shape: s, keys: o} = this._getCached(),
        a = [];
      if (
        !(this._def.catchall instanceof ns && this._def.unknownKeys === 'strip')
      )
        for (const l in i.data) o.includes(l) || a.push(l);
      const c = [];
      for (const l of o) {
        const u = s[l],
          d = i.data[l];
        c.push({
          key: {status: 'valid', value: l},
          value: u._parse(new mi(i, d, i.path, l)),
          alwaysSet: l in i.data
        });
      }
      if (this._def.catchall instanceof ns) {
        const l = this._def.unknownKeys;
        if (l === 'passthrough')
          for (const u of a)
            c.push({
              key: {status: 'valid', value: u},
              value: {status: 'valid', value: i.data[u]}
            });
        else if (l === 'strict')
          a.length > 0 &&
            (be(i, {code: ye.unrecognized_keys, keys: a}), r.dirty());
        else if (l !== 'strip')
          throw new Error(
            'Internal ZodObject error: invalid unknownKeys value.'
          );
      } else {
        const l = this._def.catchall;
        for (const u of a) {
          const d = i.data[u];
          c.push({
            key: {status: 'valid', value: u},
            value: l._parse(new mi(i, d, i.path, u)),
            alwaysSet: u in i.data
          });
        }
      }
      return i.common.async
        ? Promise.resolve()
            .then(async () => {
              const l = [];
              for (const u of c) {
                const d = await u.key,
                  f = await u.value;
                l.push({key: d, value: f, alwaysSet: u.alwaysSet});
              }
              return l;
            })
            .then((l) => yn.mergeObjectSync(r, l))
        : yn.mergeObjectSync(r, c);
    }
    get shape() {
      return this._def.shape();
    }
    strict(e) {
      return (
        Se.errToObj,
        new At({
          ...this._def,
          unknownKeys: 'strict',
          ...(e !== void 0
            ? {
                errorMap: (n, r) => {
                  var s, o;
                  const i =
                    ((o = (s = this._def).errorMap) == null
                      ? void 0
                      : o.call(s, n, r).message) ?? r.defaultError;
                  return n.code === 'unrecognized_keys'
                    ? {message: Se.errToObj(e).message ?? i}
                    : {message: i};
                }
              }
            : {})
        })
      );
    }
    strip() {
      return new At({...this._def, unknownKeys: 'strip'});
    }
    passthrough() {
      return new At({...this._def, unknownKeys: 'passthrough'});
    }
    extend(e) {
      return new At({
        ...this._def,
        shape: () => ({...this._def.shape(), ...e})
      });
    }
    merge(e) {
      return new At({
        unknownKeys: e._def.unknownKeys,
        catchall: e._def.catchall,
        shape: () => ({...this._def.shape(), ...e._def.shape()}),
        typeName: Oe.ZodObject
      });
    }
    setKey(e, n) {
      return this.augment({[e]: n});
    }
    catchall(e) {
      return new At({...this._def, catchall: e});
    }
    pick(e) {
      const n = {};
      for (const r of Xe.objectKeys(e))
        e[r] && this.shape[r] && (n[r] = this.shape[r]);
      return new At({...this._def, shape: () => n});
    }
    omit(e) {
      const n = {};
      for (const r of Xe.objectKeys(this.shape)) e[r] || (n[r] = this.shape[r]);
      return new At({...this._def, shape: () => n});
    }
    deepPartial() {
      return Aa(this);
    }
    partial(e) {
      const n = {};
      for (const r of Xe.objectKeys(this.shape)) {
        const i = this.shape[r];
        e && !e[r] ? (n[r] = i) : (n[r] = i.optional());
      }
      return new At({...this._def, shape: () => n});
    }
    required(e) {
      const n = {};
      for (const r of Xe.objectKeys(this.shape))
        if (e && !e[r]) n[r] = this.shape[r];
        else {
          let s = this.shape[r];
          for (; s instanceof ui; ) s = s._def.innerType;
          n[r] = s;
        }
      return new At({...this._def, shape: () => n});
    }
    keyof() {
      return y3(Xe.objectKeys(this.shape));
    }
  }
  At.create = (t, e) =>
    new At({
      shape: () => t,
      unknownKeys: 'strip',
      catchall: ns.create(),
      typeName: Oe.ZodObject,
      ...Ue(e)
    });
  At.strictCreate = (t, e) =>
    new At({
      shape: () => t,
      unknownKeys: 'strict',
      catchall: ns.create(),
      typeName: Oe.ZodObject,
      ...Ue(e)
    });
  At.lazycreate = (t, e) =>
    new At({
      shape: t,
      unknownKeys: 'strip',
      catchall: ns.create(),
      typeName: Oe.ZodObject,
      ...Ue(e)
    });
  class Ul extends Ve {
    _parse(e) {
      const {ctx: n} = this._processInputParams(e),
        r = this._def.options;
      function i(s) {
        for (const a of s) if (a.result.status === 'valid') return a.result;
        for (const a of s)
          if (a.result.status === 'dirty')
            return (n.common.issues.push(...a.ctx.common.issues), a.result);
        const o = s.map((a) => new tr(a.ctx.common.issues));
        return (be(n, {code: ye.invalid_union, unionErrors: o}), Pe);
      }
      if (n.common.async)
        return Promise.all(
          r.map(async (s) => {
            const o = {...n, common: {...n.common, issues: []}, parent: null};
            return {
              result: await s._parseAsync({
                data: n.data,
                path: n.path,
                parent: o
              }),
              ctx: o
            };
          })
        ).then(i);
      {
        let s;
        const o = [];
        for (const c of r) {
          const l = {...n, common: {...n.common, issues: []}, parent: null},
            u = c._parseSync({data: n.data, path: n.path, parent: l});
          if (u.status === 'valid') return u;
          (u.status === 'dirty' && !s && (s = {result: u, ctx: l}),
            l.common.issues.length && o.push(l.common.issues));
        }
        if (s) return (n.common.issues.push(...s.ctx.common.issues), s.result);
        const a = o.map((c) => new tr(c));
        return (be(n, {code: ye.invalid_union, unionErrors: a}), Pe);
      }
    }
    get options() {
      return this._def.options;
    }
  }
  Ul.create = (t, e) => new Ul({options: t, typeName: Oe.ZodUnion, ...Ue(e)});
  const Oi = (t) =>
    t instanceof Vl
      ? Oi(t.schema)
      : t instanceof $r
        ? Oi(t.innerType())
        : t instanceof Gl
          ? [t.value]
          : t instanceof to
            ? t.options
            : t instanceof zl
              ? Xe.objectValues(t.enum)
              : t instanceof Wl
                ? Oi(t._def.innerType)
                : t instanceof Hl
                  ? [void 0]
                  : t instanceof jl
                    ? [null]
                    : t instanceof ui
                      ? [void 0, ...Oi(t.unwrap())]
                      : t instanceof no
                        ? [null, ...Oi(t.unwrap())]
                        : t instanceof Vy || t instanceof Yl
                          ? Oi(t.unwrap())
                          : t instanceof Zl
                            ? Oi(t._def.innerType)
                            : [];
  class dp extends Ve {
    _parse(e) {
      const {ctx: n} = this._processInputParams(e);
      if (n.parsedType !== Ee.object)
        return (
          be(n, {
            code: ye.invalid_type,
            expected: Ee.object,
            received: n.parsedType
          }),
          Pe
        );
      const r = this.discriminator,
        i = n.data[r],
        s = this.optionsMap.get(i);
      return s
        ? n.common.async
          ? s._parseAsync({data: n.data, path: n.path, parent: n})
          : s._parseSync({data: n.data, path: n.path, parent: n})
        : (be(n, {
            code: ye.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [r]
          }),
          Pe);
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    static create(e, n, r) {
      const i = new Map();
      for (const s of n) {
        const o = Oi(s.shape[e]);
        if (!o.length)
          throw new Error(
            `A discriminator value for key \`${e}\` could not be extracted from all schema options`
          );
        for (const a of o) {
          if (i.has(a))
            throw new Error(
              `Discriminator property ${String(e)} has duplicate value ${String(a)}`
            );
          i.set(a, s);
        }
      }
      return new dp({
        typeName: Oe.ZodDiscriminatedUnion,
        discriminator: e,
        options: n,
        optionsMap: i,
        ...Ue(r)
      });
    }
  }
  function Y0(t, e) {
    const n = Bi(t),
      r = Bi(e);
    if (t === e) return {valid: !0, data: t};
    if (n === Ee.object && r === Ee.object) {
      const i = Xe.objectKeys(e),
        s = Xe.objectKeys(t).filter((a) => i.indexOf(a) !== -1),
        o = {...t, ...e};
      for (const a of s) {
        const c = Y0(t[a], e[a]);
        if (!c.valid) return {valid: !1};
        o[a] = c.data;
      }
      return {valid: !0, data: o};
    } else if (n === Ee.array && r === Ee.array) {
      if (t.length !== e.length) return {valid: !1};
      const i = [];
      for (let s = 0; s < t.length; s++) {
        const o = t[s],
          a = e[s],
          c = Y0(o, a);
        if (!c.valid) return {valid: !1};
        i.push(c.data);
      }
      return {valid: !0, data: i};
    } else
      return n === Ee.date && r === Ee.date && +t == +e
        ? {valid: !0, data: t}
        : {valid: !1};
  }
  class Kl extends Ve {
    _parse(e) {
      const {status: n, ctx: r} = this._processInputParams(e),
        i = (s, o) => {
          if (W0(s) || W0(o)) return Pe;
          const a = Y0(s.value, o.value);
          return a.valid
            ? ((Z0(s) || Z0(o)) && n.dirty(), {status: n.value, value: a.data})
            : (be(r, {code: ye.invalid_intersection_types}), Pe);
        };
      return r.common.async
        ? Promise.all([
            this._def.left._parseAsync({data: r.data, path: r.path, parent: r}),
            this._def.right._parseAsync({data: r.data, path: r.path, parent: r})
          ]).then(([s, o]) => i(s, o))
        : i(
            this._def.left._parseSync({data: r.data, path: r.path, parent: r}),
            this._def.right._parseSync({data: r.data, path: r.path, parent: r})
          );
    }
  }
  Kl.create = (t, e, n) =>
    new Kl({left: t, right: e, typeName: Oe.ZodIntersection, ...Ue(n)});
  class gi extends Ve {
    _parse(e) {
      const {status: n, ctx: r} = this._processInputParams(e);
      if (r.parsedType !== Ee.array)
        return (
          be(r, {
            code: ye.invalid_type,
            expected: Ee.array,
            received: r.parsedType
          }),
          Pe
        );
      if (r.data.length < this._def.items.length)
        return (
          be(r, {
            code: ye.too_small,
            minimum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: 'array'
          }),
          Pe
        );
      !this._def.rest &&
        r.data.length > this._def.items.length &&
        (be(r, {
          code: ye.too_big,
          maximum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: 'array'
        }),
        n.dirty());
      const s = [...r.data]
        .map((o, a) => {
          const c = this._def.items[a] || this._def.rest;
          return c ? c._parse(new mi(r, o, r.path, a)) : null;
        })
        .filter((o) => !!o);
      return r.common.async
        ? Promise.all(s).then((o) => yn.mergeArray(n, o))
        : yn.mergeArray(n, s);
    }
    get items() {
      return this._def.items;
    }
    rest(e) {
      return new gi({...this._def, rest: e});
    }
  }
  gi.create = (t, e) => {
    if (!Array.isArray(t))
      throw new Error('You must pass an array of schemas to z.tuple([ ... ])');
    return new gi({items: t, typeName: Oe.ZodTuple, rest: null, ...Ue(e)});
  };
  class ql extends Ve {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(e) {
      const {status: n, ctx: r} = this._processInputParams(e);
      if (r.parsedType !== Ee.object)
        return (
          be(r, {
            code: ye.invalid_type,
            expected: Ee.object,
            received: r.parsedType
          }),
          Pe
        );
      const i = [],
        s = this._def.keyType,
        o = this._def.valueType;
      for (const a in r.data)
        i.push({
          key: s._parse(new mi(r, a, r.path, a)),
          value: o._parse(new mi(r, r.data[a], r.path, a)),
          alwaysSet: a in r.data
        });
      return r.common.async
        ? yn.mergeObjectAsync(n, i)
        : yn.mergeObjectSync(n, i);
    }
    get element() {
      return this._def.valueType;
    }
    static create(e, n, r) {
      return n instanceof Ve
        ? new ql({keyType: e, valueType: n, typeName: Oe.ZodRecord, ...Ue(r)})
        : new ql({
            keyType: Or.create(),
            valueType: e,
            typeName: Oe.ZodRecord,
            ...Ue(n)
          });
    }
  }
  class Zf extends Ve {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(e) {
      const {status: n, ctx: r} = this._processInputParams(e);
      if (r.parsedType !== Ee.map)
        return (
          be(r, {
            code: ye.invalid_type,
            expected: Ee.map,
            received: r.parsedType
          }),
          Pe
        );
      const i = this._def.keyType,
        s = this._def.valueType,
        o = [...r.data.entries()].map(([a, c], l) => ({
          key: i._parse(new mi(r, a, r.path, [l, 'key'])),
          value: s._parse(new mi(r, c, r.path, [l, 'value']))
        }));
      if (r.common.async) {
        const a = new Map();
        return Promise.resolve().then(async () => {
          for (const c of o) {
            const l = await c.key,
              u = await c.value;
            if (l.status === 'aborted' || u.status === 'aborted') return Pe;
            ((l.status === 'dirty' || u.status === 'dirty') && n.dirty(),
              a.set(l.value, u.value));
          }
          return {status: n.value, value: a};
        });
      } else {
        const a = new Map();
        for (const c of o) {
          const l = c.key,
            u = c.value;
          if (l.status === 'aborted' || u.status === 'aborted') return Pe;
          ((l.status === 'dirty' || u.status === 'dirty') && n.dirty(),
            a.set(l.value, u.value));
        }
        return {status: n.value, value: a};
      }
    }
  }
  Zf.create = (t, e, n) =>
    new Zf({valueType: e, keyType: t, typeName: Oe.ZodMap, ...Ue(n)});
  class Wo extends Ve {
    _parse(e) {
      const {status: n, ctx: r} = this._processInputParams(e);
      if (r.parsedType !== Ee.set)
        return (
          be(r, {
            code: ye.invalid_type,
            expected: Ee.set,
            received: r.parsedType
          }),
          Pe
        );
      const i = this._def;
      (i.minSize !== null &&
        r.data.size < i.minSize.value &&
        (be(r, {
          code: ye.too_small,
          minimum: i.minSize.value,
          type: 'set',
          inclusive: !0,
          exact: !1,
          message: i.minSize.message
        }),
        n.dirty()),
        i.maxSize !== null &&
          r.data.size > i.maxSize.value &&
          (be(r, {
            code: ye.too_big,
            maximum: i.maxSize.value,
            type: 'set',
            inclusive: !0,
            exact: !1,
            message: i.maxSize.message
          }),
          n.dirty()));
      const s = this._def.valueType;
      function o(c) {
        const l = new Set();
        for (const u of c) {
          if (u.status === 'aborted') return Pe;
          (u.status === 'dirty' && n.dirty(), l.add(u.value));
        }
        return {status: n.value, value: l};
      }
      const a = [...r.data.values()].map((c, l) =>
        s._parse(new mi(r, c, r.path, l))
      );
      return r.common.async ? Promise.all(a).then((c) => o(c)) : o(a);
    }
    min(e, n) {
      return new Wo({
        ...this._def,
        minSize: {value: e, message: Se.toString(n)}
      });
    }
    max(e, n) {
      return new Wo({
        ...this._def,
        maxSize: {value: e, message: Se.toString(n)}
      });
    }
    size(e, n) {
      return this.min(e, n).max(e, n);
    }
    nonempty(e) {
      return this.min(1, e);
    }
  }
  Wo.create = (t, e) =>
    new Wo({
      valueType: t,
      minSize: null,
      maxSize: null,
      typeName: Oe.ZodSet,
      ...Ue(e)
    });
  class za extends Ve {
    constructor() {
      (super(...arguments), (this.validate = this.implement));
    }
    _parse(e) {
      const {ctx: n} = this._processInputParams(e);
      if (n.parsedType !== Ee.function)
        return (
          be(n, {
            code: ye.invalid_type,
            expected: Ee.function,
            received: n.parsedType
          }),
          Pe
        );
      function r(a, c) {
        return Gf({
          data: a,
          path: n.path,
          errorMaps: [
            n.common.contextualErrorMap,
            n.schemaErrorMap,
            Vf(),
            oc
          ].filter((l) => !!l),
          issueData: {code: ye.invalid_arguments, argumentsError: c}
        });
      }
      function i(a, c) {
        return Gf({
          data: a,
          path: n.path,
          errorMaps: [
            n.common.contextualErrorMap,
            n.schemaErrorMap,
            Vf(),
            oc
          ].filter((l) => !!l),
          issueData: {code: ye.invalid_return_type, returnTypeError: c}
        });
      }
      const s = {errorMap: n.common.contextualErrorMap},
        o = n.data;
      if (this._def.returns instanceof cc) {
        const a = this;
        return Pn(async function (...c) {
          const l = new tr([]),
            u = await a._def.args.parseAsync(c, s).catch((h) => {
              throw (l.addIssue(r(c, h)), l);
            }),
            d = await Reflect.apply(o, this, u);
          return await a._def.returns._def.type.parseAsync(d, s).catch((h) => {
            throw (l.addIssue(i(d, h)), l);
          });
        });
      } else {
        const a = this;
        return Pn(function (...c) {
          const l = a._def.args.safeParse(c, s);
          if (!l.success) throw new tr([r(c, l.error)]);
          const u = Reflect.apply(o, this, l.data),
            d = a._def.returns.safeParse(u, s);
          if (!d.success) throw new tr([i(u, d.error)]);
          return d.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...e) {
      return new za({...this._def, args: gi.create(e).rest(Do.create())});
    }
    returns(e) {
      return new za({...this._def, returns: e});
    }
    implement(e) {
      return this.parse(e);
    }
    strictImplement(e) {
      return this.parse(e);
    }
    static create(e, n, r) {
      return new za({
        args: e || gi.create([]).rest(Do.create()),
        returns: n || Do.create(),
        typeName: Oe.ZodFunction,
        ...Ue(r)
      });
    }
  }
  class Vl extends Ve {
    get schema() {
      return this._def.getter();
    }
    _parse(e) {
      const {ctx: n} = this._processInputParams(e);
      return this._def.getter()._parse({data: n.data, path: n.path, parent: n});
    }
  }
  Vl.create = (t, e) => new Vl({getter: t, typeName: Oe.ZodLazy, ...Ue(e)});
  class Gl extends Ve {
    _parse(e) {
      if (e.data !== this._def.value) {
        const n = this._getOrReturnCtx(e);
        return (
          be(n, {
            received: n.data,
            code: ye.invalid_literal,
            expected: this._def.value
          }),
          Pe
        );
      }
      return {status: 'valid', value: e.data};
    }
    get value() {
      return this._def.value;
    }
  }
  Gl.create = (t, e) => new Gl({value: t, typeName: Oe.ZodLiteral, ...Ue(e)});
  function y3(t, e) {
    return new to({values: t, typeName: Oe.ZodEnum, ...Ue(e)});
  }
  class to extends Ve {
    _parse(e) {
      if (typeof e.data != 'string') {
        const n = this._getOrReturnCtx(e),
          r = this._def.values;
        return (
          be(n, {
            expected: Xe.joinValues(r),
            received: n.parsedType,
            code: ye.invalid_type
          }),
          Pe
        );
      }
      if (
        (this._cache || (this._cache = new Set(this._def.values)),
        !this._cache.has(e.data))
      ) {
        const n = this._getOrReturnCtx(e),
          r = this._def.values;
        return (
          be(n, {received: n.data, code: ye.invalid_enum_value, options: r}),
          Pe
        );
      }
      return Pn(e.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const e = {};
      for (const n of this._def.values) e[n] = n;
      return e;
    }
    get Values() {
      const e = {};
      for (const n of this._def.values) e[n] = n;
      return e;
    }
    get Enum() {
      const e = {};
      for (const n of this._def.values) e[n] = n;
      return e;
    }
    extract(e, n = this._def) {
      return to.create(e, {...this._def, ...n});
    }
    exclude(e, n = this._def) {
      return to.create(
        this.options.filter((r) => !e.includes(r)),
        {...this._def, ...n}
      );
    }
  }
  to.create = y3;
  class zl extends Ve {
    _parse(e) {
      const n = Xe.getValidEnumValues(this._def.values),
        r = this._getOrReturnCtx(e);
      if (r.parsedType !== Ee.string && r.parsedType !== Ee.number) {
        const i = Xe.objectValues(n);
        return (
          be(r, {
            expected: Xe.joinValues(i),
            received: r.parsedType,
            code: ye.invalid_type
          }),
          Pe
        );
      }
      if (
        (this._cache ||
          (this._cache = new Set(Xe.getValidEnumValues(this._def.values))),
        !this._cache.has(e.data))
      ) {
        const i = Xe.objectValues(n);
        return (
          be(r, {received: r.data, code: ye.invalid_enum_value, options: i}),
          Pe
        );
      }
      return Pn(e.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  zl.create = (t, e) =>
    new zl({values: t, typeName: Oe.ZodNativeEnum, ...Ue(e)});
  class cc extends Ve {
    unwrap() {
      return this._def.type;
    }
    _parse(e) {
      const {ctx: n} = this._processInputParams(e);
      if (n.parsedType !== Ee.promise && n.common.async === !1)
        return (
          be(n, {
            code: ye.invalid_type,
            expected: Ee.promise,
            received: n.parsedType
          }),
          Pe
        );
      const r = n.parsedType === Ee.promise ? n.data : Promise.resolve(n.data);
      return Pn(
        r.then((i) =>
          this._def.type.parseAsync(i, {
            path: n.path,
            errorMap: n.common.contextualErrorMap
          })
        )
      );
    }
  }
  cc.create = (t, e) => new cc({type: t, typeName: Oe.ZodPromise, ...Ue(e)});
  class $r extends Ve {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === Oe.ZodEffects
        ? this._def.schema.sourceType()
        : this._def.schema;
    }
    _parse(e) {
      const {status: n, ctx: r} = this._processInputParams(e),
        i = this._def.effect || null,
        s = {
          addIssue: (o) => {
            (be(r, o), o.fatal ? n.abort() : n.dirty());
          },
          get path() {
            return r.path;
          }
        };
      if (((s.addIssue = s.addIssue.bind(s)), i.type === 'preprocess')) {
        const o = i.transform(r.data, s);
        if (r.common.async)
          return Promise.resolve(o).then(async (a) => {
            if (n.value === 'aborted') return Pe;
            const c = await this._def.schema._parseAsync({
              data: a,
              path: r.path,
              parent: r
            });
            return c.status === 'aborted'
              ? Pe
              : c.status === 'dirty' || n.value === 'dirty'
                ? Pa(c.value)
                : c;
          });
        {
          if (n.value === 'aborted') return Pe;
          const a = this._def.schema._parseSync({
            data: o,
            path: r.path,
            parent: r
          });
          return a.status === 'aborted'
            ? Pe
            : a.status === 'dirty' || n.value === 'dirty'
              ? Pa(a.value)
              : a;
        }
      }
      if (i.type === 'refinement') {
        const o = (a) => {
          const c = i.refinement(a, s);
          if (r.common.async) return Promise.resolve(c);
          if (c instanceof Promise)
            throw new Error(
              'Async refinement encountered during synchronous parse operation. Use .parseAsync instead.'
            );
          return a;
        };
        if (r.common.async === !1) {
          const a = this._def.schema._parseSync({
            data: r.data,
            path: r.path,
            parent: r
          });
          return a.status === 'aborted'
            ? Pe
            : (a.status === 'dirty' && n.dirty(),
              o(a.value),
              {status: n.value, value: a.value});
        } else
          return this._def.schema
            ._parseAsync({data: r.data, path: r.path, parent: r})
            .then((a) =>
              a.status === 'aborted'
                ? Pe
                : (a.status === 'dirty' && n.dirty(),
                  o(a.value).then(() => ({status: n.value, value: a.value})))
            );
      }
      if (i.type === 'transform')
        if (r.common.async === !1) {
          const o = this._def.schema._parseSync({
            data: r.data,
            path: r.path,
            parent: r
          });
          if (!Go(o)) return Pe;
          const a = i.transform(o.value, s);
          if (a instanceof Promise)
            throw new Error(
              'Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.'
            );
          return {status: n.value, value: a};
        } else
          return this._def.schema
            ._parseAsync({data: r.data, path: r.path, parent: r})
            .then((o) =>
              Go(o)
                ? Promise.resolve(i.transform(o.value, s)).then((a) => ({
                    status: n.value,
                    value: a
                  }))
                : Pe
            );
      Xe.assertNever(i);
    }
  }
  $r.create = (t, e, n) =>
    new $r({schema: t, typeName: Oe.ZodEffects, effect: e, ...Ue(n)});
  $r.createWithPreprocess = (t, e, n) =>
    new $r({
      schema: e,
      effect: {type: 'preprocess', transform: t},
      typeName: Oe.ZodEffects,
      ...Ue(n)
    });
  class ui extends Ve {
    _parse(e) {
      return this._getType(e) === Ee.undefined
        ? Pn(void 0)
        : this._def.innerType._parse(e);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ui.create = (t, e) =>
    new ui({innerType: t, typeName: Oe.ZodOptional, ...Ue(e)});
  class no extends Ve {
    _parse(e) {
      return this._getType(e) === Ee.null
        ? Pn(null)
        : this._def.innerType._parse(e);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  no.create = (t, e) =>
    new no({innerType: t, typeName: Oe.ZodNullable, ...Ue(e)});
  class Wl extends Ve {
    _parse(e) {
      const {ctx: n} = this._processInputParams(e);
      let r = n.data;
      return (
        n.parsedType === Ee.undefined && (r = this._def.defaultValue()),
        this._def.innerType._parse({data: r, path: n.path, parent: n})
      );
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  Wl.create = (t, e) =>
    new Wl({
      innerType: t,
      typeName: Oe.ZodDefault,
      defaultValue:
        typeof e.default == 'function' ? e.default : () => e.default,
      ...Ue(e)
    });
  class Zl extends Ve {
    _parse(e) {
      const {ctx: n} = this._processInputParams(e),
        r = {...n, common: {...n.common, issues: []}},
        i = this._def.innerType._parse({
          data: r.data,
          path: r.path,
          parent: {...r}
        });
      return Fl(i)
        ? i.then((s) => ({
            status: 'valid',
            value:
              s.status === 'valid'
                ? s.value
                : this._def.catchValue({
                    get error() {
                      return new tr(r.common.issues);
                    },
                    input: r.data
                  })
          }))
        : {
            status: 'valid',
            value:
              i.status === 'valid'
                ? i.value
                : this._def.catchValue({
                    get error() {
                      return new tr(r.common.issues);
                    },
                    input: r.data
                  })
          };
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  Zl.create = (t, e) =>
    new Zl({
      innerType: t,
      typeName: Oe.ZodCatch,
      catchValue: typeof e.catch == 'function' ? e.catch : () => e.catch,
      ...Ue(e)
    });
  class Yf extends Ve {
    _parse(e) {
      if (this._getType(e) !== Ee.nan) {
        const r = this._getOrReturnCtx(e);
        return (
          be(r, {
            code: ye.invalid_type,
            expected: Ee.nan,
            received: r.parsedType
          }),
          Pe
        );
      }
      return {status: 'valid', value: e.data};
    }
  }
  Yf.create = (t) => new Yf({typeName: Oe.ZodNaN, ...Ue(t)});
  const SM = Symbol('zod_brand');
  class Vy extends Ve {
    _parse(e) {
      const {ctx: n} = this._processInputParams(e),
        r = n.data;
      return this._def.type._parse({data: r, path: n.path, parent: n});
    }
    unwrap() {
      return this._def.type;
    }
  }
  class Pu extends Ve {
    _parse(e) {
      const {status: n, ctx: r} = this._processInputParams(e);
      if (r.common.async)
        return (async () => {
          const s = await this._def.in._parseAsync({
            data: r.data,
            path: r.path,
            parent: r
          });
          return s.status === 'aborted'
            ? Pe
            : s.status === 'dirty'
              ? (n.dirty(), Pa(s.value))
              : this._def.out._parseAsync({
                  data: s.value,
                  path: r.path,
                  parent: r
                });
        })();
      {
        const i = this._def.in._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return i.status === 'aborted'
          ? Pe
          : i.status === 'dirty'
            ? (n.dirty(), {status: 'dirty', value: i.value})
            : this._def.out._parseSync({
                data: i.value,
                path: r.path,
                parent: r
              });
      }
    }
    static create(e, n) {
      return new Pu({in: e, out: n, typeName: Oe.ZodPipeline});
    }
  }
  class Yl extends Ve {
    _parse(e) {
      const n = this._def.innerType._parse(e),
        r = (i) => (Go(i) && (i.value = Object.freeze(i.value)), i);
      return Fl(n) ? n.then((i) => r(i)) : r(n);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  Yl.create = (t, e) =>
    new Yl({innerType: t, typeName: Oe.ZodReadonly, ...Ue(e)});
  function Vb(t, e) {
    const n =
      typeof t == 'function' ? t(e) : typeof t == 'string' ? {message: t} : t;
    return typeof n == 'string' ? {message: n} : n;
  }
  function v3(t, e = {}, n) {
    return t
      ? ac.create().superRefine((r, i) => {
          const s = t(r);
          if (s instanceof Promise)
            return s.then((o) => {
              if (!o) {
                const a = Vb(e, r),
                  c = a.fatal ?? n ?? !0;
                i.addIssue({code: 'custom', ...a, fatal: c});
              }
            });
          if (!s) {
            const o = Vb(e, r),
              a = o.fatal ?? n ?? !0;
            i.addIssue({code: 'custom', ...o, fatal: a});
          }
        })
      : ac.create();
  }
  const xM = {object: At.lazycreate};
  var Oe;
  (function (t) {
    ((t.ZodString = 'ZodString'),
      (t.ZodNumber = 'ZodNumber'),
      (t.ZodNaN = 'ZodNaN'),
      (t.ZodBigInt = 'ZodBigInt'),
      (t.ZodBoolean = 'ZodBoolean'),
      (t.ZodDate = 'ZodDate'),
      (t.ZodSymbol = 'ZodSymbol'),
      (t.ZodUndefined = 'ZodUndefined'),
      (t.ZodNull = 'ZodNull'),
      (t.ZodAny = 'ZodAny'),
      (t.ZodUnknown = 'ZodUnknown'),
      (t.ZodNever = 'ZodNever'),
      (t.ZodVoid = 'ZodVoid'),
      (t.ZodArray = 'ZodArray'),
      (t.ZodObject = 'ZodObject'),
      (t.ZodUnion = 'ZodUnion'),
      (t.ZodDiscriminatedUnion = 'ZodDiscriminatedUnion'),
      (t.ZodIntersection = 'ZodIntersection'),
      (t.ZodTuple = 'ZodTuple'),
      (t.ZodRecord = 'ZodRecord'),
      (t.ZodMap = 'ZodMap'),
      (t.ZodSet = 'ZodSet'),
      (t.ZodFunction = 'ZodFunction'),
      (t.ZodLazy = 'ZodLazy'),
      (t.ZodLiteral = 'ZodLiteral'),
      (t.ZodEnum = 'ZodEnum'),
      (t.ZodEffects = 'ZodEffects'),
      (t.ZodNativeEnum = 'ZodNativeEnum'),
      (t.ZodOptional = 'ZodOptional'),
      (t.ZodNullable = 'ZodNullable'),
      (t.ZodDefault = 'ZodDefault'),
      (t.ZodCatch = 'ZodCatch'),
      (t.ZodPromise = 'ZodPromise'),
      (t.ZodBranded = 'ZodBranded'),
      (t.ZodPipeline = 'ZodPipeline'),
      (t.ZodReadonly = 'ZodReadonly'));
  })(Oe || (Oe = {}));
  const CM = (t, e = {message: `Input not instance of ${t.name}`}) =>
      v3((n) => n instanceof t, e),
    b3 = Or.create,
    w3 = Xs.create,
    TM = Yf.create,
    IM = eo.create,
    _3 = $l.create,
    kM = zo.create,
    RM = zf.create,
    PM = Hl.create,
    MM = jl.create,
    Q0 = ac.create,
    OM = Do.create,
    NM = ns.create,
    LM = Wf.create,
    E3 = Lr.create,
    jd = At.create,
    BM = At.strictCreate,
    A3 = Ul.create,
    DM = dp.create,
    FM = Kl.create,
    S3 = gi.create,
    $M = ql.create,
    HM = Zf.create,
    jM = Wo.create,
    UM = za.create,
    KM = Vl.create,
    qM = Gl.create,
    VM = to.create,
    GM = zl.create,
    zM = cc.create,
    Gb = $r.create,
    WM = ui.create,
    ZM = no.create,
    YM = $r.createWithPreprocess,
    QM = Pu.create,
    JM = () => b3().optional(),
    XM = () => w3().optional(),
    e9 = () => _3().optional(),
    t9 = {
      string: (t) => Or.create({...t, coerce: !0}),
      number: (t) => Xs.create({...t, coerce: !0}),
      boolean: (t) => $l.create({...t, coerce: !0}),
      bigint: (t) => eo.create({...t, coerce: !0}),
      date: (t) => zo.create({...t, coerce: !0})
    },
    n9 = Pe,
    zb = Object.freeze(
      Object.defineProperty(
        {
          __proto__: null,
          BRAND: SM,
          DIRTY: Pa,
          EMPTY_PATH: nM,
          INVALID: Pe,
          NEVER: n9,
          OK: Pn,
          ParseStatus: yn,
          Schema: Ve,
          ZodAny: ac,
          ZodArray: Lr,
          ZodBigInt: eo,
          ZodBoolean: $l,
          ZodBranded: Vy,
          ZodCatch: Zl,
          ZodDate: zo,
          ZodDefault: Wl,
          ZodDiscriminatedUnion: dp,
          ZodEffects: $r,
          ZodEnum: to,
          ZodError: tr,
          get ZodFirstPartyTypeKind() {
            return Oe;
          },
          ZodFunction: za,
          ZodIntersection: Kl,
          ZodIssueCode: ye,
          ZodLazy: Vl,
          ZodLiteral: Gl,
          ZodMap: Zf,
          ZodNaN: Yf,
          ZodNativeEnum: zl,
          ZodNever: ns,
          ZodNull: jl,
          ZodNullable: no,
          ZodNumber: Xs,
          ZodObject: At,
          ZodOptional: ui,
          ZodParsedType: Ee,
          ZodPipeline: Pu,
          ZodPromise: cc,
          ZodReadonly: Yl,
          ZodRecord: ql,
          ZodSchema: Ve,
          ZodSet: Wo,
          ZodString: Or,
          ZodSymbol: zf,
          ZodTransformer: $r,
          ZodTuple: gi,
          ZodType: Ve,
          ZodUndefined: Hl,
          ZodUnion: Ul,
          ZodUnknown: Do,
          ZodVoid: Wf,
          addIssueToContext: be,
          any: Q0,
          array: E3,
          bigint: IM,
          boolean: _3,
          coerce: t9,
          custom: v3,
          date: kM,
          datetimeRegex: g3,
          defaultErrorMap: oc,
          discriminatedUnion: DM,
          effect: Gb,
          enum: VM,
          function: UM,
          getErrorMap: Vf,
          getParsedType: Bi,
          instanceof: CM,
          intersection: FM,
          isAborted: W0,
          isAsync: Fl,
          isDirty: Z0,
          isValid: Go,
          late: xM,
          lazy: KM,
          literal: qM,
          makeIssue: Gf,
          map: HM,
          nan: TM,
          nativeEnum: GM,
          never: NM,
          null: MM,
          nullable: ZM,
          number: w3,
          object: jd,
          get objectUtil() {
            return z0;
          },
          oboolean: e9,
          onumber: XM,
          optional: WM,
          ostring: JM,
          pipeline: QM,
          preprocess: YM,
          promise: zM,
          quotelessJson: eM,
          record: $M,
          set: jM,
          setErrorMap: tM,
          strictObject: BM,
          string: b3,
          symbol: RM,
          transformer: Gb,
          tuple: S3,
          undefined: PM,
          union: A3,
          unknown: OM,
          get util() {
            return Xe;
          },
          void: LM
        },
        Symbol.toStringTag,
        {value: 'Module'}
      )
    ),
    r9 = (t) => (t.message ? t.message : 'unspecified error');
  class lc extends Ne {
    constructor(e) {
      (super(),
        (this.code = SR),
        (this.errors = e),
        (super.message = `Web3 validator found ${e.length} error[s]:
${this._compileErrors().join(`
`)}`));
    }
    _compileErrors() {
      return this.errors.map(r9);
    }
  }
  const i9 = ['bool', 'int', 'uint', 'bytes', 'string', 'address', 'tuple'],
    x3 = (t) => typeof t == 'object' && 'type' in t && 'name' in t,
    Gy = (t) => typeof t == 'string',
    it = (t) => typeof t == 'string' && /^((-)?0x[0-9a-f]+|(0x))$/i.test(t);
  function C3(t, e) {
    return !(typeof t != 'string' || !t.match(/^0x[0-9A-Fa-f]*$/));
  }
  const Qf = (t) =>
    typeof t == 'number' ||
    typeof t == 'bigint' ||
    (typeof t == 'string' && /^((-0x|0x|-)?[0-9a-f]+|(0x))$/i.test(t));
  function zy(t) {
    if (typeof t != 'string')
      throw new Error(
        `[isHexPrefixed] input must be type 'string', received type ${typeof t}`
      );
    return t.startsWith('0x');
  }
  const Wy = function (t) {
      for (const [e, n] of Object.entries(t))
        if (n !== void 0 && n.length > 0 && n[0] === 0)
          throw new Error(
            `${e} cannot have leading zeroes, received: ${n.toString()}`
          );
    },
    s9 = [
      'hex',
      'number',
      'blockNumber',
      'blockNumberOrTag',
      'filter',
      'bloom'
    ],
    sa = (t) => {
      let e = t.replace(/ /, ''),
        n,
        r = !1,
        i = [];
      if (
        (t.includes('[') &&
          ((e = e.slice(0, e.indexOf('['))),
          (i = [...t.matchAll(/(?:\[(\d*)\])/g)]
            .map((s) => parseInt(s[1], 10))
            .map((s) => (Number.isNaN(s) ? -1 : s))),
          (r = i.length > 0)),
        i9.includes(e))
      )
        return {baseType: e, isArray: r, baseTypeSize: n, arraySizes: i};
      if (e.startsWith('int'))
        ((n = parseInt(e.substring(3), 10)), (e = 'int'));
      else if (e.startsWith('uint'))
        ((n = parseInt(t.substring(4), 10)), (e = 'uint'));
      else if (e.startsWith('bytes'))
        ((n = parseInt(e.substring(5), 10)), (e = 'bytes'));
      else
        return {
          baseType: void 0,
          isArray: !1,
          baseTypeSize: void 0,
          arraySizes: i
        };
      return {baseType: e, isArray: r, baseTypeSize: n, arraySizes: i};
    },
    um = (t, e = {}) => {
      if (Object.keys(e).includes('type'))
        throw new lc([
          {
            keyword: 'eth',
            message: 'Either "eth" or "type" can be presented in schema',
            params: {eth: t},
            instancePath: '',
            schemaPath: ''
          }
        ]);
      const {baseType: r, baseTypeSize: i} = sa(t);
      if (!r && !s9.includes(t))
        throw new lc([
          {
            keyword: 'eth',
            message: `Eth data type "${t}" is not valid`,
            params: {eth: t},
            instancePath: '',
            schemaPath: ''
          }
        ]);
      if (r) {
        if (r === 'tuple')
          throw new Error('"tuple" type is not implemented directly.');
        return {format: `${r}${i ?? ''}`, required: !0};
      }
      return t ? {format: t, required: !0} : {};
    },
    Jf = (t, e = '/0') => {
      const n = {
        type: 'array',
        items: [],
        maxItems: t.length,
        minItems: t.length
      };
      for (const [r, i] of t.entries()) {
        let s,
          o,
          a = [];
        x3(i)
          ? ((s = i.type), (o = i.name || `${e}/${r}`), (a = i.components))
          : typeof i == 'string'
            ? ((s = i), (o = `${e}/${r}`))
            : Array.isArray(i) &&
              (i[0] &&
              typeof i[0] == 'string' &&
              i[0].startsWith('tuple') &&
              !Array.isArray(i[0]) &&
              i[1] &&
              Array.isArray(i[1])
                ? ((s = i[0]), (o = `${e}/${r}`), (a = i[1]))
                : ((s = 'tuple'), (o = `${e}/${r}`), (a = i)));
        const {baseType: c, isArray: l, arraySizes: u} = sa(s);
        let d,
          f = n;
        for (let h = u.length - 1; h > 0; h -= 1)
          ((d = {
            type: 'array',
            $id: o,
            items: [],
            maxItems: u[h],
            minItems: u[h]
          }),
            u[h] < 0 && (delete d.maxItems, delete d.minItems),
            Array.isArray(f.items)
              ? f.items.length === 0
                ? (f.items = [d])
                : f.items.push(d)
              : (f.items = [f.items, d]),
            (f = d));
        if (c === 'tuple' && !l) {
          const h = Jf(a, o);
          ((h.$id = o), f.items.push(h));
        } else if (c === 'tuple' && l) {
          const h = u[0],
            g = Object.assign(
              {type: 'array', $id: o, items: Jf(a, o)},
              h >= 0 && {minItems: h, maxItems: h}
            );
          f.items.push(g);
        } else if (l) {
          const h = u[0],
            g = Object.assign(
              {type: 'array', $id: o, items: um(s)},
              h >= 0 && {minItems: h, maxItems: h}
            );
          f.items.push(g);
        } else
          Array.isArray(f.items)
            ? f.items.push(Object.assign({$id: o}, um(s)))
            : f.items.push(Object.assign({$id: o}, um(s)));
        f = n;
      }
      return n;
    },
    Zy = (t) => Jf(t),
    Yy = (t, e) => (e === 1 ? t : Yy(t[0], e - 1)),
    bl = (t, e, n) => {
      const r = [];
      for (const [i, s] of t.entries()) {
        let o,
          a,
          c = [];
        x3(s)
          ? ((o = s.type), (a = s.name), (c = s.components))
          : typeof s == 'string'
            ? (o = s)
            : Array.isArray(s) &&
              (s[1] && Array.isArray(s[1])
                ? ((o = s[0]), (c = s[1]))
                : ((o = 'tuple'), (c = s)));
        const {baseType: l, isArray: u, arraySizes: d} = sa(o),
          f = Array.isArray(e) ? e[i] : e[a];
        if (l === 'tuple' && !u) r.push(bl(c, f, n));
        else if (l === 'tuple' && u) {
          const h = [];
          for (const g of f)
            if (d.length > 1) {
              const m = Yy(g, d.length - 1),
                y = [];
              for (const p of m) y.push(bl(c, p, n));
              h.push(y);
            } else h.push(bl(c, g, n));
          r.push(h);
        } else r.push(f);
      }
      return ((n = n ?? []), n.push(...r), n);
    },
    T3 = (t) => {
      if (t >= 48 && t <= 57) return t - 48;
      if (t >= 65 && t <= 70) return t - 55;
      if (t >= 97 && t <= 102) return t - 87;
      throw new Error(`Invalid code point: ${t}`);
    },
    fp = (t) => {
      if (!it(t)) throw new Error('Invalid hex string');
      const [e, n] = t.startsWith('-') ? [!0, t.slice(1)] : [!1, t],
        r = BigInt(n);
      return r > Number.MAX_SAFE_INTEGER
        ? e
          ? -r
          : r
        : r < Number.MIN_SAFE_INTEGER
          ? r
          : e
            ? -1 * Number(r)
            : Number(r);
    },
    hp = (t) => {
      if ((typeof t == 'number' || typeof t == 'bigint') && t < 0)
        return `-0x${t.toString(16).slice(1)}`;
      if ((typeof t == 'number' || typeof t == 'bigint') && t >= 0)
        return `0x${t.toString(16)}`;
      if (typeof t == 'string' && it(t)) {
        const [e, n] = t.startsWith('-') ? [!0, t.slice(1)] : [!1, t],
          r = n.split(/^(-)?0(x|X)/).slice(-1)[0];
        return `${e ? '-' : ''}0x${r.replace(/^0+/, '').toLowerCase()}`;
      }
      if (typeof t == 'string' && !it(t)) return hp(BigInt(t));
      throw new Fy(t);
    },
    Xf = (t, e, n = '0') => {
      if (typeof t == 'string' && !it(t)) return t.padStart(e, n);
      const r = typeof t == 'string' && it(t) ? t : hp(t),
        [i, s] = r.startsWith('-') ? ['-0x', r.slice(3)] : ['0x', r.slice(2)];
      return `${i}${s.padStart(e, n)}`;
    };
  function cs(t) {
    let e = '0x';
    for (const n of t) {
      const r = n.toString(16);
      e += r.length === 1 ? `0${r}` : r;
    }
    return e;
  }
  const Ti = {zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102};
  function Wb(t) {
    if (t >= Ti.zero && t <= Ti.nine) return t - Ti.zero;
    if (t >= Ti.A && t <= Ti.F) return t - (Ti.A - 10);
    if (t >= Ti.a && t <= Ti.f) return t - (Ti.a - 10);
  }
  function oa(t) {
    let e = 0;
    if (
      (t.startsWith('0') && (t[1] === 'x' || t[1] === 'X') && (e = 2),
      t.length % 2 !== 0)
    )
      throw new Ga(`hex string has odd length: ${t}`);
    const n = (t.length - e) / 2,
      r = new Uint8Array(n);
    for (let i = 0, s = e; i < n; i += 1) {
      const o = Wb(t.charCodeAt(s++)),
        a = Wb(t.charCodeAt(s++));
      if (o === void 0 || a === void 0)
        throw new Ga(
          `Invalid byte sequence ("${t[s - 2]}${t[s - 1]}" in "${t}").`
        );
      r[i] = o * 16 + a;
    }
    return r;
  }
  function pp(t) {
    var e;
    return !(t instanceof Uint8Array) &&
      ((e = t == null ? void 0 : t.constructor) === null || e === void 0
        ? void 0
        : e.name) === 'Uint8Array'
      ? Uint8Array.from(t)
      : t;
  }
  const I3 = Object.freeze(
      Object.defineProperty(
        {
          __proto__: null,
          abiSchemaToJsonSchema: Jf,
          codePointToInt: T3,
          ensureIfUint8Array: pp,
          ethAbiToJsonSchema: Zy,
          fetchArrayElement: Yy,
          hexToNumber: fp,
          hexToUint8Array: oa,
          numberToHex: hp,
          padLeft: Xf,
          parseBaseType: sa,
          transformJsonDataToAbiFormat: bl,
          uint8ArrayToHexString: cs
        },
        Symbol.toStringTag,
        {value: 'Module'}
      )
    ),
    J0 = (t) => {
      var e, n;
      return (
        t instanceof Uint8Array ||
        ((e = t == null ? void 0 : t.constructor) === null || e === void 0
          ? void 0
          : e.name) === 'Uint8Array' ||
        ((n = t == null ? void 0 : t.constructor) === null || n === void 0
          ? void 0
          : n.name) === 'Buffer'
      );
    },
    ao = (t, e = {abiType: 'bytes'}) => {
      if (
        (typeof t != 'string' && !Array.isArray(t) && !J0(t)) ||
        (typeof t == 'string' && it(t) && t.startsWith('-')) ||
        (typeof t == 'string' && !it(t))
      )
        return !1;
      let n;
      if (typeof t == 'string') {
        if (t.length % 2 !== 0) return !1;
        n = oa(t);
      } else if (Array.isArray(t)) {
        if (t.some((r) => r < 0 || r > 255 || !Number.isInteger(r))) return !1;
        n = new Uint8Array(t);
      } else n = t;
      if (e != null && e.abiType) {
        const {baseTypeSize: r} = sa(e.abiType);
        return r ? n.length === r : !0;
      }
      return e != null && e.size
        ? n.length === (e == null ? void 0 : e.size)
        : !0;
    },
    k3 = (t) => {
      if (!/^(0x)?[0-9a-f]{40}$/i.test(t)) return !1;
      const e = t.slice(2),
        n = ic(e.toLowerCase()),
        r = cs(xn(pp(n))).slice(2);
      for (let i = 0; i < 40; i += 1)
        if (
          (parseInt(r[i], 16) > 7 && e[i].toUpperCase() !== e[i]) ||
          (parseInt(r[i], 16) <= 7 && e[i].toLowerCase() !== e[i])
        )
          return !1;
      return !0;
    },
    nr = (t, e = !0) => {
      if (typeof t != 'string' && !J0(t)) return !1;
      let n;
      return (
        J0(t)
          ? (n = cs(t))
          : typeof t == 'string' && !it(t)
            ? (n = t.toLowerCase().startsWith('0x') ? t : `0x${t}`)
            : (n = t),
        /^(0x)?[0-9a-f]{40}$/i.test(n)
          ? /^(0x|0X)?[0-9a-f]{40}$/.test(n) || /^(0x|0X)?[0-9A-F]{40}$/.test(n)
            ? !0
            : e
              ? k3(n)
              : !0
          : !1
      );
    },
    Zo = (t, e) => {
      if (e === BigInt(0)) return BigInt(1);
      let n = t;
      for (let r = 1; r < e; r += 1) n *= t;
      return n;
    },
    rs = (t, e = {abiType: 'uint'}) => {
      if (
        !['number', 'string', 'bigint'].includes(typeof t) ||
        (typeof t == 'string' && t.length === 0)
      )
        return !1;
      let n;
      if (e != null && e.abiType) {
        const {baseTypeSize: i} = sa(e.abiType);
        i && (n = i);
      } else e.bitSize && (n = e.bitSize);
      const r = Zo(BigInt(2), BigInt(n ?? 256)) - BigInt(1);
      try {
        const i = typeof t == 'string' && it(t) ? BigInt(fp(t)) : BigInt(t);
        return i >= 0 && i <= r;
      } catch {
        return !1;
      }
    },
    Ql = (t, e = {abiType: 'int'}) => {
      if (
        !['number', 'string', 'bigint'].includes(typeof t) ||
        (typeof t == 'number' && t > Number.MAX_SAFE_INTEGER)
      )
        return !1;
      let n;
      if (e != null && e.abiType) {
        const {baseTypeSize: s, baseType: o} = sa(e.abiType);
        if (o !== 'int') return !1;
        s && (n = s);
      } else e.bitSize && (n = e.bitSize);
      const r = Zo(BigInt(2), BigInt((n ?? 256) - 1)),
        i = BigInt(-1) * Zo(BigInt(2), BigInt((n ?? 256) - 1));
      try {
        const s = typeof t == 'string' && it(t) ? BigInt(fp(t)) : BigInt(t);
        return s >= i && s <= r;
      } catch {
        return !1;
      }
    },
    R3 = (t) =>
      !!(
        Ql(t) ||
        (typeof t == 'string' &&
          /[0-9.]/.test(t) &&
          t.indexOf('.') === t.lastIndexOf('.')) ||
        typeof t == 'number'
      ),
    P3 = (t) => rs(t),
    Gt = (t) => Object.values(qi).includes(t),
    X0 = (t) => Gt(t) || P3(t),
    Rc = (t) =>
      typeof t != 'string' || !/^(0x)?[0-9a-f]{512}$/i.test(t)
        ? !1
        : !!(/^(0x)?[0-9a-f]{512}$/.test(t) || /^(0x)?[0-9A-F]{512}$/.test(t)),
    mp = (t, e) => {
      if ((typeof e == 'string' && !it(e)) || !Rc(t)) return !1;
      const n = typeof e == 'string' ? oa(e) : e,
        r = cs(xn(n)).slice(2);
      for (let i = 0; i < 12; i += 4) {
        const s =
            ((parseInt(r.slice(i, i + 2), 16) << 8) +
              parseInt(r.slice(i + 2, i + 4), 16)) &
            2047,
          o = T3(t.charCodeAt(t.length - 1 - Math.floor(s / 4))),
          a = 1 << s % 4;
        if ((o & a) !== a) return !1;
      }
      return !0;
    },
    o9 = (t, e) => {
      if (!Rc(t) || !nr(e)) return !1;
      const n = Xf(e, 64);
      return mp(t, n);
    },
    a9 = (t, e) => (!Rc(t) || !nr(e) ? !1 : mp(t, e)),
    c9 = (t) =>
      ['number', 'string', 'boolean'].includes(typeof t)
        ? typeof t == 'boolean'
          ? !0
          : typeof t == 'string' && !it(t)
            ? t === '1' || t === '0'
            : typeof t == 'string' && it(t)
              ? t === '0x1' || t === '0x0'
              : t === 1 || t === 0
        : !1,
    ie = (t) => t == null,
    uc = (t) =>
      typeof t == 'object' && !ie(t) && !Array.isArray(t) && !(t instanceof By),
    eh = (t) =>
      typeof t != 'string' || !/^(0x)?[0-9a-f]{64}$/i.test(t)
        ? !1
        : !!(/^(0x)?[0-9a-f]{64}$/.test(t) || /^(0x)?[0-9A-F]{64}$/.test(t)),
    l9 = (t, e) => (!Rc(t) || !eh(e) ? !1 : mp(t, e)),
    u9 = (t) => {
      const e = ['fromBlock', 'toBlock', 'address', 'topics', 'blockHash'];
      if (
        ie(t) ||
        typeof t != 'object' ||
        !Object.keys(t).every((n) => e.includes(n)) ||
        (!ie(t.fromBlock) && !X0(t.fromBlock)) ||
        (!ie(t.toBlock) && !X0(t.toBlock))
      )
        return !1;
      if (!ie(t.address)) {
        if (Array.isArray(t.address)) {
          if (!t.address.every((n) => nr(n))) return !1;
        } else if (!nr(t.address)) return !1;
      }
      return !(
        !ie(t.topics) &&
        !t.topics.every((n) =>
          ie(n) ? !0 : Array.isArray(n) ? n.every((r) => eh(r)) : !!eh(n)
        )
      );
    },
    Yo = {
      address: (t) => nr(t),
      bloom: (t) => Rc(t),
      blockNumber: (t) => P3(t),
      blockTag: (t) => Gt(t),
      blockNumberOrTag: (t) => X0(t),
      bool: (t) => c9(t),
      bytes: (t) => ao(t),
      filter: (t) => u9(t),
      hex: (t) => it(t),
      uint: (t) => rs(t),
      int: (t) => Ql(t),
      number: (t) => R3(t),
      string: (t) => Gy(t)
    };
  for (let t = 8; t <= 256; t += 8)
    ((Yo[`int${t}`] = (e) => Ql(e, {bitSize: t})),
      (Yo[`uint${t}`] = (e) => rs(e, {bitSize: t})));
  for (let t = 1; t <= 32; t += 1) Yo[`bytes${t}`] = (e) => ao(e, {size: t});
  Yo.bytes256 = Yo.bytes;
  const el = (t) => {
    if (
      (!(t != null && t.type) || (t == null ? void 0 : t.type) === 'object') &&
      t != null &&
      t.properties
    ) {
      const e = {};
      for (const n of Object.keys(t.properties)) {
        const r = el(t.properties[n]);
        r && (e[n] = r);
      }
      return Array.isArray(t.required)
        ? jd(e)
            .partial()
            .required(
              t.required.reduce(
                (n, r) => Object.assign(Object.assign({}, n), {[r]: !0}),
                {}
              )
            )
        : jd(e).partial();
    }
    if ((t == null ? void 0 : t.type) === 'array' && t != null && t.items) {
      if (
        Array.isArray(t.items) &&
        t.items.length > 1 &&
        t.maxItems !== void 0 &&
        new Set(t.items.map((r) => r.$id)).size === t.items.length
      ) {
        const r = [];
        for (const i of t.items) {
          const s = el(i);
          s && r.push(s);
        }
        return S3(r);
      }
      const e = Array.isArray(t.items) ? t.items[0] : t.items;
      let n = E3(el(e));
      return (
        (n = t.minItems !== void 0 ? n.min(t.minItems) : n),
        (n = t.maxItems !== void 0 ? n.max(t.maxItems) : n),
        n
      );
    }
    if (t.oneOf && Array.isArray(t.oneOf)) return A3(t.oneOf.map((e) => el(e)));
    if (t != null && t.format) {
      if (!Yo[t.format]) throw new MP(t.format);
      return Q0().refine(Yo[t.format], (e) => ({
        params: {value: e, format: t.format}
      }));
    }
    return t != null &&
      t.type &&
      (t == null ? void 0 : t.type) !== 'object' &&
      typeof zb[String(t.type)] == 'function'
      ? zb[String(t.type)]()
      : jd({data: Q0()}).partial();
  };
  class Ma {
    static factory() {
      return (
        Ma.validatorInstance || (Ma.validatorInstance = new Ma()),
        Ma.validatorInstance
      );
    }
    validate(e, n, r) {
      var i, s;
      const a = el(e).safeParse(n);
      if (!a.success) {
        const c = this.convertErrors(
          (s = (i = a.error) === null || i === void 0 ? void 0 : i.issues) !==
            null && s !== void 0
            ? s
            : []
        );
        if (c) {
          if (r != null && r.silent) return c;
          throw new lc(c);
        }
      }
    }
    convertErrors(e) {
      if (e && Array.isArray(e) && e.length > 0)
        return e.map((n) => {
          var r;
          let i, s, o, a;
          a = n.path.join('/');
          const c = String(n.path[n.path.length - 1]),
            l = n.path.join('/');
          if (n.code === ye.too_big)
            ((s = 'maxItems'),
              (a = `${l}/maxItems`),
              (o = {limit: n.maximum}),
              (i = `must NOT have more than ${n.maximum} items`));
          else if (n.code === ye.too_small)
            ((s = 'minItems'),
              (a = `${l}/minItems`),
              (o = {limit: n.minimum}),
              (i = `must NOT have fewer than ${n.minimum} items`));
          else if (n.code === ye.custom) {
            const {value: u, format: d} =
              (r = n.params) !== null && r !== void 0 ? r : {};
            (typeof u > 'u'
              ? (i = `value at "/${a}" is required`)
              : (i = `value "${typeof u == 'object' ? JSON.stringify(u) : u}" at "/${a}" must pass "${d}" validation`),
              (o = {value: u}));
          }
          return {
            keyword: s ?? c,
            instancePath: l ? `/${l}` : '',
            schemaPath: a ? `#${a}` : '#',
            params: o ?? {value: n.message},
            message: i ?? n.message
          };
        });
    }
  }
  class d9 {
    constructor() {
      this._validator = Ma.factory();
    }
    validateJSONSchema(e, n, r) {
      return this._validator.validate(e, n, r);
    }
    validate(e, n, r = {silent: !1}) {
      var i, s;
      const o = Zy(e);
      if (
        !(
          Array.isArray(o.items) &&
          ((i = o.items) === null || i === void 0 ? void 0 : i.length) === 0 &&
          n.length === 0
        )
      ) {
        if (
          Array.isArray(o.items) &&
          ((s = o.items) === null || s === void 0 ? void 0 : s.length) === 0 &&
          n.length !== 0
        )
          throw new lc([
            {
              instancePath: '/0',
              schemaPath: '/',
              keyword: 'required',
              message: 'empty schema against data can not be validated',
              params: n
            }
          ]);
        return this._validator.validate(o, n, r);
      }
    }
  }
  const Ie = new d9();
  function co(t) {
    var e, n;
    return (
      t instanceof Uint8Array ||
      ((e = t == null ? void 0 : t.constructor) === null || e === void 0
        ? void 0
        : e.name) === 'Uint8Array' ||
      ((n = t == null ? void 0 : t.constructor) === null || n === void 0
        ? void 0
        : n.name) === 'Buffer'
    );
  }
  function Mn(...t) {
    const e = t.reduce((i, s) => i + s.length, 0),
      n = new Uint8Array(e);
    let r = 0;
    for (const i of t) (n.set(i, r), (r += i.length));
    return n;
  }
  function gp(t, e) {
    if (t === e) return !0;
    if (t.byteLength !== e.byteLength) return !1;
    for (let n = 0; n < t.byteLength; n += 1) if (t[n] !== e[n]) return !1;
    return !0;
  }
  const yp = {
      noether: BigInt(0),
      wei: BigInt(1),
      kwei: BigInt(1e3),
      Kwei: BigInt(1e3),
      babbage: BigInt(1e3),
      femtoether: BigInt(1e3),
      mwei: BigInt(1e6),
      Mwei: BigInt(1e6),
      lovelace: BigInt(1e6),
      picoether: BigInt(1e6),
      gwei: BigInt(1e9),
      Gwei: BigInt(1e9),
      shannon: BigInt(1e9),
      nanoether: BigInt(1e9),
      nano: BigInt(1e9),
      szabo: BigInt(1e12),
      microether: BigInt(1e12),
      micro: BigInt(1e12),
      finney: BigInt(1e15),
      milliether: BigInt(1e15),
      milli: BigInt(1e15),
      ether: BigInt('1000000000000000000'),
      kether: BigInt('1000000000000000000000'),
      grand: BigInt('1000000000000000000000'),
      mether: BigInt('1000000000000000000000000'),
      gether: BigInt('1000000000000000000000000000'),
      tether: BigInt('1000000000000000000000000000000')
    },
    eg =
      'Warning: Using type `number` with values that are large or contain many decimals may cause loss of precision, it is recommended to use type `string` or `BigInt` when using conversion methods',
    yi = (t) => {
      if ((Ie.validate(['bytes'], [t]), co(t))) return t;
      if (Array.isArray(t)) return new Uint8Array(t);
      if (typeof t == 'string') return oa(t);
      throw new Ga(t);
    },
    {uint8ArrayToHexString: f9} = I3,
    We = (t) => f9(yi(t)),
    bt = (t) =>
      typeof t == 'string' && t.slice(0, 2).toLowerCase() !== '0x'
        ? yi(`0x${t}`)
        : yi(t),
    Mu = (t) => (Ie.validate(['hex'], [t]), fp(t)),
    h9 = Mu,
    $t = (t, e) => {
      typeof t != 'bigint' && Ie.validate(['int'], [t]);
      let n = hp(t);
      return (
        e &&
          (!n.startsWith('-') && n.length % 2 === 1
            ? (n = '0x0'.concat(n.slice(2)))
            : n.length % 2 === 0 &&
              n.startsWith('-') &&
              (n = '-0x0'.concat(n.slice(3)))),
        n
      );
    },
    p9 = $t,
    m9 = (t) => Mu(t).toString(),
    Hr = (t) => {
      Ie.validate(['string'], [t]);
      let e = t.replace(/^(?:\u0000)/, '');
      return (
        (e = e.replace(/(?:\u0000)$/, '')),
        We(new TextEncoder().encode(e))
      );
    },
    M3 = Hr,
    g9 = Hr,
    vp = (t) => f3(bt(t)),
    y9 = (t) =>
      typeof t == 'string' ? vp(t) : (Ie.validate(['bytes'], [t]), f3(t)),
    Qy = ic,
    v9 = vp,
    O3 = (t) => {
      Ie.validate(['string'], [t]);
      let e = '';
      for (let n = 0; n < t.length; n += 1) {
        const r = t.charCodeAt(n).toString(16);
        e += r.length % 2 !== 0 ? `0${r}` : r;
      }
      return `0x${e}`;
    },
    b9 = O3,
    N3 = (t) => new TextDecoder('ascii').decode(bt(t)),
    w9 = N3,
    is = (t, e) => {
      if (typeof t == 'string' && nr(t))
        return e ? 'address' : `0x${t.toLowerCase().replace(/^0x/i, '')}`;
      if (typeof t == 'boolean') return e ? 'bool' : t ? '0x01' : '0x00';
      if (typeof t == 'number')
        return e ? (t < 0 ? 'int256' : 'uint256') : $t(t);
      if (typeof t == 'bigint') return e ? 'bigint' : $t(t);
      if (co(t)) return e ? 'bytes' : We(t);
      if (typeof t == 'object' && t)
        return e ? 'string' : Hr(JSON.stringify(t));
      if (typeof t == 'string') {
        if (t.startsWith('-0x') || t.startsWith('-0X'))
          return e ? 'int256' : $t(t);
        if (it(t)) return e ? 'bytes' : t;
        if (Qf(t) && !Ql(t) && !rs(t)) return e ? 'bytes' : `0x${t}`;
        if (Qf(t) && !Ql(t) && rs(t)) return e ? 'uint' : $t(t);
        if (!Number.isFinite(t)) return e ? 'string' : Hr(t);
      }
      throw new mP(t);
    },
    jn = (t) => {
      if (typeof t == 'number')
        return t > 1e20 ? (console.warn(eg), BigInt(t)) : t;
      if (typeof t == 'bigint')
        return t >= Number.MIN_SAFE_INTEGER && t <= Number.MAX_SAFE_INTEGER
          ? Number(t)
          : t;
      if (typeof t == 'string' && it(t)) return Mu(t);
      try {
        return jn(BigInt(t));
      } catch {
        throw new Fy(t);
      }
    },
    xo = (t) => {
      if (typeof t == 'number') return BigInt(t);
      if (typeof t == 'bigint') return t;
      if (typeof t == 'string' && Qf(t))
        return t.startsWith('-') ? -BigInt(t.substring(1)) : BigInt(t);
      throw new Fy(t);
    },
    _9 = (t, e) => {
      let n;
      if (typeof e == 'string') {
        if (((n = yp[e]), !n)) throw new t3(e);
      } else {
        if (e < 0 || !Number.isInteger(e)) throw new n3(e);
        n = Zo(BigInt(10), BigInt(e));
      }
      const r = String(jn(t)),
        i = n.toString().length - 1;
      if (i <= 0) return r.toString();
      const s = r.padStart(i, '0'),
        o = s.slice(0, -i),
        a = s.slice(-i).replace(/\.?0+$/, '');
      return o === ''
        ? a
          ? `0.${a}`
          : '0'
        : a === ''
          ? o
          : `${o}.${a}`.slice(0, o.length + i + 1);
    },
    E9 = (t, e) => {
      Ie.validate(['number'], [t]);
      let n;
      if (typeof e == 'string') {
        if (((n = yp[e]), !n)) throw new t3(e);
      } else {
        if (e < 0 || !Number.isInteger(e)) throw new n3(e);
        n = Zo(BigInt(10), BigInt(e));
      }
      let r = t;
      typeof r == 'number' &&
        (r < 1e-15 && console.warn(eg),
        r > 1e20
          ? (console.warn(eg), (r = BigInt(r)))
          : (r = r.toLocaleString('fullwide', {
              useGrouping: !1,
              maximumFractionDigits: 20
            })));
      const [i, s] = String(typeof r == 'string' && !it(r) ? r : jn(r))
          .split('.')
          .concat(''),
        a = BigInt(`${i}${s}`) * n,
        c = s.length;
      return c === 0 ? a.toString() : a.toString().slice(0, -c);
    },
    _i = (t) => {
      if (!nr(t, !1)) throw new $y(t);
      const e = t.toLowerCase().replace(/^0x/i, ''),
        n = cs(xn(pp(Qy(e))));
      if (
        ie(n) ||
        n ===
          '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'
      )
        return '';
      let r = '0x';
      const i = n.replace(/^0x/i, '');
      for (let s = 0; s < e.length; s += 1)
        parseInt(i[s], 16) > 7 ? (r += e[s].toUpperCase()) : (r += e[s]);
      return r;
    },
    L3 = (t) => {
      if (typeof t == 'boolean') return t;
      if (
        (typeof t == 'number' && (t === 0 || t === 1)) ||
        (typeof t == 'bigint' && (t === BigInt(0) || t === BigInt(1)))
      )
        return !!t;
      if (
        typeof t == 'string' &&
        !it(t) &&
        (t === '1' || t === '0' || t === 'false' || t === 'true')
      )
        return t === 'true' ? !0 : t === 'false' ? !1 : !!Number(t);
      if (typeof t == 'string' && it(t) && (t === '0x1' || t === '0x0'))
        return !!jn(t);
      throw new Hy(t);
    };
  var Oa =
    typeof globalThis < 'u'
      ? globalThis
      : typeof window < 'u'
        ? window
        : typeof global < 'u'
          ? global
          : typeof self < 'u'
            ? self
            : {};
  function Ou(t) {
    return t &&
      t.__esModule &&
      Object.prototype.hasOwnProperty.call(t, 'default')
      ? t.default
      : t;
  }
  var dm = {exports: {}},
    Zb;
  function A9() {
    return (
      Zb ||
        ((Zb = 1),
        (function (t) {
          var e = Object.prototype.hasOwnProperty,
            n = '~';
          function r() {}
          Object.create &&
            ((r.prototype = Object.create(null)),
            new r().__proto__ || (n = !1));
          function i(c, l, u) {
            ((this.fn = c), (this.context = l), (this.once = u || !1));
          }
          function s(c, l, u, d, f) {
            if (typeof u != 'function')
              throw new TypeError('The listener must be a function');
            var h = new i(u, d || c, f),
              g = n ? n + l : l;
            return (
              c._events[g]
                ? c._events[g].fn
                  ? (c._events[g] = [c._events[g], h])
                  : c._events[g].push(h)
                : ((c._events[g] = h), c._eventsCount++),
              c
            );
          }
          function o(c, l) {
            --c._eventsCount === 0
              ? (c._events = new r())
              : delete c._events[l];
          }
          function a() {
            ((this._events = new r()), (this._eventsCount = 0));
          }
          ((a.prototype.eventNames = function () {
            var l = [],
              u,
              d;
            if (this._eventsCount === 0) return l;
            for (d in (u = this._events))
              e.call(u, d) && l.push(n ? d.slice(1) : d);
            return Object.getOwnPropertySymbols
              ? l.concat(Object.getOwnPropertySymbols(u))
              : l;
          }),
            (a.prototype.listeners = function (l) {
              var u = n ? n + l : l,
                d = this._events[u];
              if (!d) return [];
              if (d.fn) return [d.fn];
              for (var f = 0, h = d.length, g = new Array(h); f < h; f++)
                g[f] = d[f].fn;
              return g;
            }),
            (a.prototype.listenerCount = function (l) {
              var u = n ? n + l : l,
                d = this._events[u];
              return d ? (d.fn ? 1 : d.length) : 0;
            }),
            (a.prototype.emit = function (l, u, d, f, h, g) {
              var m = n ? n + l : l;
              if (!this._events[m]) return !1;
              var y = this._events[m],
                p = arguments.length,
                b,
                v;
              if (y.fn) {
                switch (
                  (y.once && this.removeListener(l, y.fn, void 0, !0), p)
                ) {
                  case 1:
                    return (y.fn.call(y.context), !0);
                  case 2:
                    return (y.fn.call(y.context, u), !0);
                  case 3:
                    return (y.fn.call(y.context, u, d), !0);
                  case 4:
                    return (y.fn.call(y.context, u, d, f), !0);
                  case 5:
                    return (y.fn.call(y.context, u, d, f, h), !0);
                  case 6:
                    return (y.fn.call(y.context, u, d, f, h, g), !0);
                }
                for (v = 1, b = new Array(p - 1); v < p; v++)
                  b[v - 1] = arguments[v];
                y.fn.apply(y.context, b);
              } else {
                var x = y.length,
                  C;
                for (v = 0; v < x; v++)
                  switch (
                    (y[v].once && this.removeListener(l, y[v].fn, void 0, !0),
                    p)
                  ) {
                    case 1:
                      y[v].fn.call(y[v].context);
                      break;
                    case 2:
                      y[v].fn.call(y[v].context, u);
                      break;
                    case 3:
                      y[v].fn.call(y[v].context, u, d);
                      break;
                    case 4:
                      y[v].fn.call(y[v].context, u, d, f);
                      break;
                    default:
                      if (!b)
                        for (C = 1, b = new Array(p - 1); C < p; C++)
                          b[C - 1] = arguments[C];
                      y[v].fn.apply(y[v].context, b);
                  }
              }
              return !0;
            }),
            (a.prototype.on = function (l, u, d) {
              return s(this, l, u, d, !1);
            }),
            (a.prototype.once = function (l, u, d) {
              return s(this, l, u, d, !0);
            }),
            (a.prototype.removeListener = function (l, u, d, f) {
              var h = n ? n + l : l;
              if (!this._events[h]) return this;
              if (!u) return (o(this, h), this);
              var g = this._events[h];
              if (g.fn)
                g.fn === u &&
                  (!f || g.once) &&
                  (!d || g.context === d) &&
                  o(this, h);
              else {
                for (var m = 0, y = [], p = g.length; m < p; m++)
                  (g[m].fn !== u ||
                    (f && !g[m].once) ||
                    (d && g[m].context !== d)) &&
                    y.push(g[m]);
                y.length
                  ? (this._events[h] = y.length === 1 ? y[0] : y)
                  : o(this, h);
              }
              return this;
            }),
            (a.prototype.removeAllListeners = function (l) {
              var u;
              return (
                l
                  ? ((u = n ? n + l : l), this._events[u] && o(this, u))
                  : ((this._events = new r()), (this._eventsCount = 0)),
                this
              );
            }),
            (a.prototype.off = a.prototype.removeListener),
            (a.prototype.addListener = a.prototype.on),
            (a.prefixed = n),
            (a.EventEmitter = a),
            (t.exports = a));
        })(dm)),
      dm.exports
    );
  }
  var S9 = A9();
  const B3 = Ou(S9);
  class Jy extends B3 {
    constructor() {
      (super(...arguments), (this.maxListeners = Number.MAX_SAFE_INTEGER));
    }
    setMaxListeners(e) {
      return ((this.maxListeners = e), this);
    }
    getMaxListeners() {
      return this.maxListeners;
    }
  }
  const x9 = it,
    C9 = Qf,
    T9 = k3,
    I9 = nr,
    k9 = Rc,
    R9 = mp,
    P9 = o9,
    M9 = a9,
    O9 = eh,
    N9 = l9,
    L9 = (t, e) => {
      const n = typeof t == 'string' && Gt(t),
        r = typeof e == 'string' && Gt(e);
      if (
        t === e ||
        ((t === 'earliest' || t === 0) && (e === 'earliest' || e === 0))
      )
        return 0;
      if (t === 'earliest') return -1;
      if (e === 'earliest') return 1;
      if (n && r) {
        const o = {
          [qi.EARLIEST]: 1,
          [qi.FINALIZED]: 2,
          [qi.SAFE]: 3,
          [qi.LATEST]: 4,
          [qi.PENDING]: 5
        };
        return o[t] < o[e] ? -1 : 1;
      }
      if ((n && !r) || (!n && r))
        throw new yP(
          'Cannot compare blocktag with provided non-blocktag input.'
        );
      const i = BigInt(t),
        s = BigInt(e);
      return i < s ? -1 : i === s ? 0 : 1;
    },
    Fs = (t) =>
      typeof t == 'object' &&
      !ie(t) &&
      Object.keys(t).length !== 0 &&
      [
        'input',
        'data',
        'from',
        'gas',
        'gasPrice',
        'gasLimit',
        'address',
        'jsonInterface',
        'syncWithContext',
        'dataInputFill'
      ].some((e) => e in t),
    Re = ie,
    Yb = (t) =>
      typeof t == 'object' && !ie(t) && !Array.isArray(t) && !(t instanceof By),
    lo = (t, ...e) => {
      if (!Yb(t)) return t;
      const n = Object.assign({}, t);
      for (const r of e)
        for (const i in r)
          Yb(r[i])
            ? (n[i] || (n[i] = {}), (n[i] = lo(n[i], r[i])))
            : !ie(r[i]) &&
              Object.hasOwnProperty.call(r, i) &&
              (Array.isArray(r[i]) || r[i] instanceof By
                ? (n[i] = r[i].slice(0))
                : (n[i] = r[i]));
      return n;
    },
    dc = (t, e, n = '0') =>
      typeof t == 'string'
        ? it(t)
          ? Xf(t, e, n)
          : t.padStart(e, n)
        : (Ie.validate(['int'], [t]), Xf(t, e, n)),
    D3 = (t, e, n = '0') => {
      if (typeof t == 'string' && !it(t)) return t.padEnd(e, n);
      const r = typeof t == 'string' && it(t) ? t : $t(t),
        i = r.startsWith('-') ? 3 : 2;
      return (
        Ie.validate([r.startsWith('-') ? 'int' : 'uint'], [t]),
        r.padEnd(e + i, n)
      );
    },
    F3 = D3,
    Jl = dc,
    $3 = (t, e = 64) => {
      Ie.validate(['int'], [t]);
      const n = jn(t);
      if (n >= 0) return dc(is(n), e);
      const r = Zo(BigInt(2), BigInt(e * 4));
      if (-n >= r) throw new r3(`value: ${t}, nibbleWidth: ${e}`);
      const s = BigInt(n) + r;
      return dc($t(s), e);
    },
    B9 = (t, e = 64) => {
      Ie.validate(['int'], [t]);
      const n = jn(t);
      if (n < 0) return n;
      const r = Math.ceil(Math.log(Number(n)) / Math.log(2));
      if (r > e * 4) throw new r3(`value: "${t}", nibbleWidth: "${e}"`);
      if (e * 4 !== r) return n;
      const i = Zo(BigInt(2), BigInt(e) * BigInt(4));
      return jn(BigInt(n) - i);
    },
    {parseBaseType: D9} = I3,
    Di = (t) => typeof t == 'object' && !ie(t) && 'number' in t && 'bytes' in t,
    F9 = (t, e, n = []) => {
      let r = Object.assign({}, t),
        i;
      for (const s of e) {
        if (r.oneOf && i) {
          const o = i,
            a = n.find(([c]) => c === o);
          a && a[0] === i && (r = r.oneOf[a[1]]);
        }
        if (!r.properties && !r.items) return;
        (r.properties
          ? (r = r.properties[s])
          : r.items && r.items.properties
            ? (r = r.items.properties[s])
            : r.items && uc(r.items)
              ? (r = r.items)
              : r.items &&
                Array.isArray(r.items) &&
                (r = r.items[parseInt(s, 10)]),
          r && s && (i = s));
      }
      return r;
    },
    Xl = (t, e, n) => {
      try {
        const {baseType: r, baseTypeSize: i} = D9(e);
        if (r === 'int' || r === 'uint')
          switch (n.number) {
            case wr.NUMBER:
              return Number(xo(t));
            case wr.HEX:
              return $t(xo(t));
            case wr.STR:
              return xo(t).toString();
            case wr.BIGINT:
              return xo(t);
            default:
              throw new q0(`Invalid format: ${String(n.number)}`);
          }
        if (r === 'bytes') {
          let s;
          switch (
            (i
              ? typeof t == 'string'
                ? (s = dc(t, i * 2))
                : co(t) && (s = Mn(new Uint8Array(i - t.length), t))
              : (s = t),
            n.bytes)
          ) {
            case ts.HEX:
              return We(yi(s));
            case ts.UINT8ARRAY:
              return yi(s);
            default:
              throw new q0(`Invalid format: ${String(n.bytes)}`);
          }
        }
        if (r === 'string') return String(t);
      } catch {
        return t;
      }
      return t;
    },
    Qb = ({
      value: t,
      schemaProp: e,
      schema: n,
      object: r,
      key: i,
      dataPath: s,
      format: o,
      oneOfPath: a = []
    }) => {
      var c, l;
      if (Array.isArray(t)) {
        let u = e;
        if (
          ((e == null ? void 0 : e.oneOf) !== void 0 &&
            e.oneOf.forEach((d, f) => {
              var h, g;
              !Array.isArray(e == null ? void 0 : e.items) &&
                ((typeof t[0] == 'object' &&
                  ((h = d == null ? void 0 : d.items) === null || h === void 0
                    ? void 0
                    : h.type) === 'object') ||
                  (typeof t[0] == 'string' &&
                    ((g = d == null ? void 0 : d.items) === null || g === void 0
                      ? void 0
                      : g.type) !== 'object')) &&
                ((u = d), a.push([i, f]));
            }),
          ie(u == null ? void 0 : u.items))
        )
          return (delete r[i], s.pop(), !0);
        if (uc(u.items) && !ie(u.items.format)) {
          for (let d = 0; d < t.length; d += 1)
            r[i][d] = Xl(
              t[d],
              (c = u == null ? void 0 : u.items) === null || c === void 0
                ? void 0
                : c.format,
              o
            );
          return (s.pop(), !0);
        }
        if (
          !Array.isArray(u == null ? void 0 : u.items) &&
          ((l = u == null ? void 0 : u.items) === null || l === void 0
            ? void 0
            : l.type) === 'object'
        ) {
          for (const d of t) bp(d, n, s, o, a);
          return (s.pop(), !0);
        }
        if (Array.isArray(u == null ? void 0 : u.items)) {
          for (let d = 0; d < t.length; d += 1)
            r[i][d] = Xl(t[d], u.items[d].format, o);
          return (s.pop(), !0);
        }
      }
      return !1;
    },
    bp = (t, e, n, r, i = []) => {
      var s;
      if (!uc(t) && !Array.isArray(t))
        return Xl(t, e == null ? void 0 : e.format, r);
      const o = t;
      if (
        Array.isArray(o) &&
        (e == null ? void 0 : e.type) === 'array' &&
        ((s = e == null ? void 0 : e.items) === null || s === void 0
          ? void 0
          : s.type) === 'object'
      )
        Qb({
          value: o,
          schemaProp: e,
          schema: e,
          object: o,
          key: '',
          dataPath: n,
          format: r,
          oneOfPath: i
        });
      else
        for (const [a, c] of Object.entries(o)) {
          n.push(a);
          let l = F9(e, n, i);
          if (ie(l)) {
            (delete o[a], n.pop());
            continue;
          }
          if (uc(c)) {
            (bp(c, e, n, r, i), n.pop());
            continue;
          }
          if (
            !Qb({
              value: c,
              schemaProp: l,
              schema: e,
              object: o,
              key: a,
              dataPath: n,
              format: r,
              oneOfPath: i
            })
          ) {
            if (
              (l == null ? void 0 : l.format) === void 0 &&
              (l == null ? void 0 : l.oneOf) !== void 0
            ) {
              for (const [u, d] of l.oneOf.entries())
                if ((d == null ? void 0 : d.format) !== void 0) {
                  l = d;
                  break;
                }
            }
            ((o[a] = Xl(c, l.format, r)), n.pop());
          }
        }
      return o;
    },
    ge = (t, e, n = Tn) => {
      let r;
      uc(e) ? (r = lo({}, e)) : Array.isArray(e) ? (r = [...e]) : (r = e);
      const i = uc(t) ? t : Zy(t);
      if (!i.properties && !i.items && !i.format)
        throw new q0('Invalid json schema for formatting');
      return bp(r, i, [], n);
    },
    H3 = '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470',
    fc = (t) => {
      let e;
      return (
        typeof t == 'bigint' || typeof t == 'number'
          ? (e = ic(t.toString()))
          : Array.isArray(t)
            ? (e = new Uint8Array(t))
            : typeof t == 'string' && !it(t)
              ? (e = ic(t))
              : (e = yi(t)),
        We(xn(pp(e)))
      );
    },
    Nu = (t) => {
      let e;
      typeof t == 'string'
        ? t.startsWith('0x') && it(t)
          ? (e = bt(t))
          : (e = ic(t))
        : (e = t);
      const n = fc(e);
      return n === H3 ? void 0 : n;
    },
    rr = (t) => {
      const e = Nu(t);
      return ie(e) ? H3 : e;
    },
    $9 = (t) => {
      if (Array.isArray(t))
        throw new Error('Autodetection of array types is not supported.');
      let e, n;
      if (
        typeof t == 'object' &&
        ('t' in t || 'type' in t) &&
        ('v' in t || 'value' in t)
      )
        ((e = 't' in t ? t.t : t.type),
          (n = 'v' in t ? t.v : t.value),
          (e = e.toLowerCase() === 'bigint' ? 'int' : e));
      else {
        if (typeof t == 'bigint') return ['int', t];
        ((e = is(t, !0)),
          (n = is(t)),
          !e.startsWith('int') && !e.startsWith('uint') && (e = 'bytes'));
      }
      return (
        (e.startsWith('int') || e.startsWith('uint')) &&
          typeof n == 'string' &&
          !/^(-)?0x/i.test(n) &&
          (n = xo(n)),
        [e, n]
      );
    },
    H9 = (t) =>
      t.startsWith('int[')
        ? `int256${t.slice(3)}`
        : t === 'int'
          ? 'int256'
          : t.startsWith('uint[')
            ? `uint256'${t.slice(4)}`
            : t === 'uint'
              ? 'uint256'
              : t,
    fm = (t, e) => {
      const n = /^(\d+).*$/.exec(t.slice(e));
      return n ? parseInt(n[1], 10) : 0;
    },
    Jb = (t) => t.toString(2).length,
    Xb = (t, e) => {
      const n = e.toString();
      if (t === 'string') {
        if (typeof e == 'string') return Hr(e);
        throw new pP(e);
      }
      if (t === 'bool' || t === 'boolean') {
        if (typeof e == 'boolean') return e ? '01' : '00';
        throw new Hy(e);
      }
      if (t === 'address') {
        if (!nr(n)) throw new $y(n);
        return n;
      }
      const r = H9(t);
      if (t.startsWith('uint')) {
        const i = fm(r, 4);
        if (i % 8 || i < 8 || i > 256) throw new Lb(n);
        const s = jn(n);
        if (Jb(s) > i) throw new Bb(n);
        if (s < BigInt(0)) throw new gP(n);
        return i ? Jl(s.toString(16), (i / 8) * 2) : s.toString(16);
      }
      if (t.startsWith('int')) {
        const i = fm(r, 3);
        if (i % 8 || i < 8 || i > 256) throw new Lb(t);
        const s = jn(n);
        if (Jb(s) > i) throw new Bb(n);
        return s < BigInt(0)
          ? $3(s.toString(), (i / 8) * 2)
          : i
            ? Jl(s.toString(16), i / 4)
            : s.toString(16);
      }
      if (r === 'bytes') {
        if (n.replace(/^0x/i, '').length % 2 !== 0) throw new Ga(n);
        return n;
      }
      if (t.startsWith('bytes')) {
        if (n.replace(/^0x/i, '').length % 2 !== 0) throw new Ga(n);
        const i = fm(t, 5);
        if (!i || i < 1 || i > 64 || i < n.replace(/^0x/i, '').length / 2)
          throw new Ga(n);
        return F3(n, i * 2);
      }
      return '';
    },
    j3 = (t) => {
      const [e, n] = $9(t);
      return Array.isArray(n)
        ? n.map((s) => Xb(e, s).replace('0x', '')).join('')
        : Xb(e, n).replace('0x', '');
    },
    Xy = (...t) => `0x${t.map(j3).join('').toLowerCase()}`,
    j9 = (...t) => Nu(Xy(...t)),
    U9 = (...t) => rr(Xy(...t)),
    K9 = (t) =>
      Nu(`0x${(typeof t == 'number' ? t.toString() : t).padStart(64, '0')}`);
  function q9(t) {
    return c3(t);
  }
  const eu = (t) => q9(t),
    V9 = (t) => We(eu(t));
  var wp = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  function U3(t) {
    return (
      (typeof t == 'object' || typeof t == 'function') &&
      typeof t.then == 'function'
    );
  }
  function K3(t, e, n) {
    return wp(this, void 0, void 0, function* () {
      let r;
      const i = yield Promise.race([
        t instanceof Promise ? t : t(),
        new Promise((s, o) => {
          r = setTimeout(() => (n ? o(n) : s(void 0)), e);
        })
      ]);
      if ((r && clearTimeout(r), i instanceof Error)) throw i;
      return i;
    });
  }
  function ev(t, e) {
    let n;
    return [
      new Promise((i, s) => {
        n = setInterval(
          (function o() {
            return (
              wp(this, void 0, void 0, function* () {
                try {
                  const a = yield K3(t, e);
                  ie(a) || (clearInterval(n), i(a));
                } catch (a) {
                  (clearInterval(n), s(a));
                }
              }),
              o
            );
          })(),
          e
        );
      }),
      n
    ];
  }
  function G9(t, e) {
    return wp(this, void 0, void 0, function* () {
      return ev(t, e)[0];
    });
  }
  function tv(t, e) {
    let n;
    const r = new Promise((i, s) => {
      n = setTimeout(() => {
        s(e);
      }, t);
    });
    return [n, r];
  }
  function q3(t, e) {
    let n;
    const r = new Promise((i, s) => {
      n = setInterval(() => {
        wp(this, void 0, void 0, function* () {
          const o = yield t();
          o && (clearInterval(n), s(o));
        });
      }, e);
    });
    return [n, r];
  }
  const nv = () => {
      const t = eu(16);
      ((t[6] = (t[6] & 15) | 64), (t[8] = (t[8] & 63) | 128));
      const e = We(t);
      return [
        e.substring(2, 10),
        e.substring(10, 14),
        e.substring(14, 18),
        e.substring(18, 22),
        e.substring(22, 34)
      ].join('-');
    },
    rv = (t) => {
      const e = t.error.code;
      return Rn.has(e) || (e >= -32099 && e <= -32e3);
    },
    Vs = (t) =>
      !Array.isArray(t) &&
      !!t &&
      t.jsonrpc === '2.0' &&
      'result' in t &&
      ie(t.error) &&
      (typeof t.id == 'number' || typeof t.id == 'string'),
    Gs = (t) =>
      !Array.isArray(t) &&
      t.jsonrpc === '2.0' &&
      !!t &&
      ie(t.result) &&
      'error' in t &&
      (typeof t.id == 'number' || typeof t.id == 'string'),
    _p = (t) =>
      !Array.isArray(t) &&
      !!t &&
      t.jsonrpc === '2.0' &&
      !ie(t.params) &&
      !ie(t.method),
    V3 = (t) =>
      !Array.isArray(t) &&
      !!t &&
      t.jsonrpc === '2.0' &&
      'id' in t &&
      'result' in t,
    th = (t) => Vs(t) || Gs(t),
    iv = (t) => (Array.isArray(t) ? t.every(th) : th(t)),
    tu = (t) => Array.isArray(t) && t.length > 0 && iv(t);
  let Ud;
  const G3 = (t) => {
      Ud = t;
    },
    Qo = (t) => {
      var e, n, r, i;
      return (
        typeof Ud < 'u' && (Ud += 1),
        {
          jsonrpc: (e = t.jsonrpc) !== null && e !== void 0 ? e : '2.0',
          id:
            (r = (n = t.id) !== null && n !== void 0 ? n : Ud) !== null &&
            r !== void 0
              ? r
              : nv(),
          method: t.method,
          params: (i = t.params) !== null && i !== void 0 ? i : void 0
        }
      );
    },
    sv = (t) => t.map((e) => Qo(e)),
    Wr = (t) => Array.isArray(t) && t.length > 0,
    z9 = Object.freeze(
      Object.defineProperty(
        {
          __proto__: null,
          isBatchRequest: Wr,
          isBatchResponse: tu,
          isResponseRpcError: rv,
          isResponseWithError: Gs,
          isResponseWithNotification: _p,
          isResponseWithResult: Vs,
          isSubscriptionResult: V3,
          isValidResponse: iv,
          setRequestIdStart: G3,
          toBatchPayload: sv,
          toPayload: Qo,
          validateResponse: th
        },
        Symbol.toStringTag,
        {value: 'Module'}
      )
    );
  var hm = function (t, e, n, r) {
      function i(s) {
        return s instanceof n
          ? s
          : new n(function (o) {
              o(s);
            });
      }
      return new (n || (n = Promise))(function (s, o) {
        function a(u) {
          try {
            l(r.next(u));
          } catch (d) {
            o(d);
          }
        }
        function c(u) {
          try {
            l(r.throw(u));
          } catch (d) {
            o(d);
          }
        }
        function l(u) {
          u.done ? s(u.value) : i(u.value).then(a, c);
        }
        l((r = r.apply(t, e || [])).next());
      });
    },
    z3;
  class nh {
    constructor(
      {timeout: e, eagerStart: n, timeoutMessage: r} = {
        timeout: 0,
        eagerStart: !1,
        timeoutMessage: 'DeferredPromise timed out'
      }
    ) {
      ((this[z3] = 'Promise'),
        (this._state = 'pending'),
        (this._promise = new Promise((i, s) => {
          ((this._resolve = i), (this._reject = s));
        })),
        (this._timeoutMessage = r),
        (this._timeoutInterval = e),
        n && this.startTimer());
    }
    get state() {
      return this._state;
    }
    then(e, n) {
      return hm(this, void 0, void 0, function* () {
        return this._promise.then(e, n);
      });
    }
    catch(e) {
      return hm(this, void 0, void 0, function* () {
        return this._promise.catch(e);
      });
    }
    finally(e) {
      return hm(this, void 0, void 0, function* () {
        return this._promise.finally(e);
      });
    }
    resolve(e) {
      (this._resolve(e), (this._state = 'fulfilled'), this._clearTimeout());
    }
    reject(e) {
      (this._reject(e), (this._state = 'rejected'), this._clearTimeout());
    }
    startTimer() {
      this._timeoutInterval &&
        this._timeoutInterval > 0 &&
        (this._timeoutId = setTimeout(
          this._checkTimeout.bind(this),
          this._timeoutInterval
        ));
    }
    _checkTimeout() {
      this._state === 'pending' &&
        this._timeoutId &&
        this.reject(new zA(this._timeoutMessage));
    }
    _clearTimeout() {
      this._timeoutId && clearTimeout(this._timeoutId);
    }
  }
  z3 = Symbol.toStringTag;
  class W3 {
    constructor(e, n) {
      ((this.eventEmitter = e),
        (this.autoReconnect = n),
        (this.chunkTimeout = 1e3 * 15));
    }
    clearQueues() {
      typeof this._clearQueues == 'function' && this._clearQueues();
    }
    onError(e) {
      this._clearQueues = e;
    }
    parseResponse(e) {
      const n = [];
      return (
        e
          .replace(/\}[\n\r]?\{/g, '}|--|{')
          .replace(/\}\][\n\r]?\[\{/g, '}]|--|[{')
          .replace(/\}[\n\r]?\[\{/g, '}|--|[{')
          .replace(/\}\][\n\r]?\{/g, '}]|--|{')
          .split('|--|')
          .forEach((i) => {
            let s = i;
            this.lastChunk && (s = this.lastChunk + s);
            let o;
            try {
              o = JSON.parse(s);
            } catch {
              ((this.lastChunk = s),
                this.lastChunkTimeout && clearTimeout(this.lastChunkTimeout),
                (this.lastChunkTimeout = setTimeout(() => {
                  this.autoReconnect ||
                    (this.clearQueues(),
                    this.eventEmitter.emit(
                      'error',
                      new up({
                        id: 1,
                        jsonrpc: '2.0',
                        error: {code: 2, message: 'Chunk timeout'}
                      })
                    ));
                }, this.chunkTimeout)));
              return;
            }
            (clearTimeout(this.lastChunkTimeout),
              (this.lastChunk = void 0),
              o && n.push(o));
          }),
        n
      );
    }
  }
  var ew = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  class ov extends ku {
    constructor() {
      (super(...arguments),
        (this._eventEmitter = new B3()),
        (this._chainId = ''),
        (this._accounts = []));
    }
    _getChainId() {
      return ew(this, void 0, void 0, function* () {
        var e;
        const n = yield this.request(Qo({method: 'eth_chainId', params: []}));
        return (e = n == null ? void 0 : n.result) !== null && e !== void 0
          ? e
          : '';
      });
    }
    _getAccounts() {
      return ew(this, void 0, void 0, function* () {
        var e;
        const n = yield this.request(Qo({method: 'eth_accounts', params: []}));
        return (e = n == null ? void 0 : n.result) !== null && e !== void 0
          ? e
          : [];
      });
    }
    _onConnect() {
      Promise.all([
        this._getChainId()
          .then((e) => {
            e !== this._chainId &&
              ((this._chainId = e),
              this._eventEmitter.emit('chainChanged', this._chainId));
          })
          .catch((e) => {
            console.error(e);
          }),
        this._getAccounts()
          .then((e) => {
            (this._accounts.length === e.length &&
              e.every((n) => e.includes(n))) ||
              ((this._accounts = e), this._onAccountsChanged());
          })
          .catch((e) => {
            console.error(e);
          })
      ])
        .then(() =>
          this._eventEmitter.emit('connect', {chainId: this._chainId})
        )
        .catch((e) => {
          console.error(e);
        });
    }
    _onDisconnect(e, n) {
      this._eventEmitter.emit('disconnect', new bP(e, n));
    }
    _onAccountsChanged() {
      this._eventEmitter.emit('accountsChanged', this._accounts);
    }
  }
  var pm = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  const W9 = {autoReconnect: !0, delay: 5e3, maxAttempts: 5},
    Z9 = 1e3;
  class Z3 extends ov {
    get SocketConnection() {
      return this._socketConnection;
    }
    constructor(e, n, r) {
      if (
        (super(),
        (this._connectionStatus = 'connecting'),
        (this._onMessageHandler = this._onMessage.bind(this)),
        (this._onOpenHandler = this._onConnect.bind(this)),
        (this._onCloseHandler = this._onCloseEvent.bind(this)),
        (this._onErrorHandler = this._onError.bind(this)),
        !this._validateProviderPath(e))
      )
        throw new V0(e);
      ((this._socketPath = e),
        (this._socketOptions = n),
        (this._reconnectOptions = Object.assign(
          Object.assign({}, W9),
          r ?? {}
        )),
        (this._pendingRequestsQueue = new Map()),
        (this._sentRequestsQueue = new Map()),
        this._init(),
        this.connect(),
        (this.chunkResponseParser = new W3(
          this._eventEmitter,
          this._reconnectOptions.autoReconnect
        )),
        this.chunkResponseParser.onError(() => {
          this._clearQueues();
        }),
        (this.isReconnecting = !1));
    }
    _init() {
      this._reconnectAttempts = 0;
    }
    connect() {
      try {
        (this._openSocketConnection(),
          (this._connectionStatus = 'connecting'),
          this._addSocketListeners());
      } catch (e) {
        if (this.isReconnecting)
          setImmediate(() => {
            this._reconnect();
          });
        else
          throw (
            (this._connectionStatus = 'disconnected'),
            e && e.message
              ? new Ru(
                  `Error while connecting to ${this._socketPath}. Reason: ${e.message}`
                )
              : new V0(this._socketPath)
          );
      }
    }
    _validateProviderPath(e) {
      return !!e;
    }
    getPendingRequestQueueSize() {
      return this._pendingRequestsQueue.size;
    }
    getSentRequestsQueueSize() {
      return this._sentRequestsQueue.size;
    }
    supportsSubscriptions() {
      return !0;
    }
    on(e, n) {
      this._eventEmitter.on(e, n);
    }
    once(e, n) {
      this._eventEmitter.once(e, n);
    }
    removeListener(e, n) {
      this._eventEmitter.removeListener(e, n);
    }
    _onDisconnect(e, n) {
      ((this._connectionStatus = 'disconnected'), super._onDisconnect(e, n));
    }
    disconnect(e, n) {
      const r = e ?? Z9;
      (this._removeSocketListeners(),
        this.getStatus() !== 'disconnected' &&
          this._closeSocketConnection(r, n),
        this._onDisconnect(r, n));
    }
    safeDisconnect(e, n) {
      return pm(this, arguments, void 0, function* (r, i, s = !1, o = 1e3) {
        let a = 0;
        (yield pm(this, void 0, void 0, function* () {
          return new Promise((l) => {
            const u = setInterval(() => {
              (s && a >= 5 && this.clearQueues(),
                this.getPendingRequestQueueSize() === 0 &&
                  this.getSentRequestsQueueSize() === 0 &&
                  (clearInterval(u), l(!0)),
                (a += 1));
            }, o);
          });
        }),
          this.disconnect(r, i));
      });
    }
    removeAllListeners(e) {
      this._eventEmitter.removeAllListeners(e);
    }
    _onError(e) {
      this.isReconnecting
        ? this._reconnect()
        : this._eventEmitter.emit('error', e);
    }
    reset() {
      (this._sentRequestsQueue.clear(),
        this._pendingRequestsQueue.clear(),
        this._init(),
        this._removeSocketListeners(),
        this._addSocketListeners());
    }
    _reconnect() {
      this.isReconnecting ||
        ((this.isReconnecting = !0),
        this._sentRequestsQueue.size > 0 &&
          this._sentRequestsQueue.forEach((e, n) => {
            (e.deferredPromise.reject(new NR()),
              this._sentRequestsQueue.delete(n));
          }),
        this._reconnectAttempts < this._reconnectOptions.maxAttempts
          ? ((this._reconnectAttempts += 1),
            setTimeout(() => {
              (this._removeSocketListeners(),
                this.connect(),
                (this.isReconnecting = !1));
            }, this._reconnectOptions.delay))
          : ((this.isReconnecting = !1),
            this._clearQueues(),
            this._removeSocketListeners(),
            this._eventEmitter.emit(
              'error',
              new OR(this._reconnectOptions.maxAttempts)
            )));
    }
    request(e) {
      return pm(this, void 0, void 0, function* () {
        if (Re(this._socketConnection))
          throw new Error('Connection is undefined');
        this.getStatus() === 'disconnected' && this.connect();
        const n = Wr(e) ? e[0].id : e.id;
        if (!n) throw new jR('Request Id not defined');
        if (this._sentRequestsQueue.has(n)) throw new LR(n);
        const r = new nh();
        r.catch((s) => {
          this._eventEmitter.emit('error', s);
        });
        const i = {payload: e, deferredPromise: r};
        if (this.getStatus() === 'connecting')
          return (this._pendingRequestsQueue.set(n, i), i.deferredPromise);
        this._sentRequestsQueue.set(n, i);
        try {
          this._sendToSocket(i.payload);
        } catch (s) {
          (this._sentRequestsQueue.delete(n),
            this._eventEmitter.emit('error', s));
        }
        return r;
      });
    }
    _onConnect() {
      ((this._connectionStatus = 'connected'),
        (this._reconnectAttempts = 0),
        super._onConnect(),
        this._sendPendingRequests());
    }
    _sendPendingRequests() {
      for (const [e, n] of this._pendingRequestsQueue.entries())
        try {
          (this._sendToSocket(n.payload),
            this._pendingRequestsQueue.delete(e),
            this._sentRequestsQueue.set(e, n));
        } catch (r) {
          (this._pendingRequestsQueue.delete(e),
            this._eventEmitter.emit('error', r));
        }
    }
    _onMessage(e) {
      const n = this._parseResponses(e);
      if (!(Re(n) || n.length === 0))
        for (const r of n) {
          if (_p(r) && r.method.endsWith('_subscription')) {
            this._eventEmitter.emit('message', r);
            return;
          }
          const i = tu(r) ? r[0].id : r.id,
            s = this._sentRequestsQueue.get(i);
          if (!s) return;
          ((tu(r) || Vs(r) || Gs(r)) &&
            (this._eventEmitter.emit('message', r),
            s.deferredPromise.resolve(r)),
            this._sentRequestsQueue.delete(i));
        }
    }
    clearQueues(e) {
      this._clearQueues(e);
    }
    _clearQueues(e) {
      (this._pendingRequestsQueue.size > 0 &&
        this._pendingRequestsQueue.forEach((n, r) => {
          (n.deferredPromise.reject(new K0(e)),
            this._pendingRequestsQueue.delete(r));
        }),
        this._sentRequestsQueue.size > 0 &&
          this._sentRequestsQueue.forEach((n, r) => {
            (n.deferredPromise.reject(new K0(e)),
              this._sentRequestsQueue.delete(r));
          }),
        this._removeSocketListeners());
    }
  }
  const Y3 = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        ChunkResponseParser: W3,
        Eip1193Provider: ov,
        EventEmitter: Jy,
        SocketProvider: Z3,
        Web3DeferredPromise: nh,
        asciiToHex: O3,
        bytesToHex: We,
        bytesToUint8Array: yi,
        checkAddressCheckSum: T9,
        compareBlockNumbers: L9,
        convert: bp,
        convertScalarValue: Xl,
        encodePacked: Xy,
        ethUnitMap: yp,
        format: ge,
        fromAscii: b9,
        fromDecimal: p9,
        fromTwosComplement: B9,
        fromUtf8: M3,
        fromWei: _9,
        getStorageSlotNumForLongString: K9,
        hexToAscii: N3,
        hexToBytes: bt,
        hexToNumber: Mu,
        hexToNumberString: m9,
        hexToString: v9,
        hexToUtf8: vp,
        isAddress: I9,
        isBatchRequest: Wr,
        isBatchResponse: tu,
        isBloom: k9,
        isContractAddressInBloom: M9,
        isContractInitOptions: Fs,
        isDataFormat: Di,
        isHex: C9,
        isHexStrict: x9,
        isInBloom: R9,
        isNullish: Re,
        isPromise: U3,
        isResponseRpcError: rv,
        isResponseWithError: Gs,
        isResponseWithNotification: _p,
        isResponseWithResult: Vs,
        isSubscriptionResult: V3,
        isTopic: O9,
        isTopicInBloom: N9,
        isUint8Array: co,
        isUserEthereumAddressInBloom: P9,
        isValidResponse: iv,
        jsonRpc: z9,
        keccak256: fc,
        keccak256Wrapper: fc,
        leftPad: Jl,
        mergeDeep: lo,
        numberToHex: $t,
        padLeft: dc,
        padRight: D3,
        pollTillDefined: G9,
        pollTillDefinedAndReturnIntervalId: ev,
        processSolidityEncodePackedArgs: j3,
        randomBytes: eu,
        randomHex: V9,
        rejectIfConditionAtInterval: q3,
        rejectIfTimeout: tv,
        rightPad: F3,
        setRequestIdStart: G3,
        sha3: Nu,
        sha3Raw: rr,
        soliditySha3: j9,
        soliditySha3Raw: U9,
        stringToHex: g9,
        toAscii: w9,
        toBatchPayload: sv,
        toBigInt: xo,
        toBool: L3,
        toChecksumAddress: _i,
        toDecimal: h9,
        toHex: is,
        toNumber: jn,
        toPayload: Qo,
        toTwosComplement: $3,
        toUtf8: y9,
        toWei: E9,
        uint8ArrayConcat: Mn,
        uint8ArrayEquals: gp,
        utf8ToBytes: Qy,
        utf8ToHex: Hr,
        uuidV4: nv,
        validateResponse: th,
        waitWithTimeout: K3
      },
      Symbol.toStringTag,
      {value: 'Module'}
    )
  );
  class Ep {
    constructor() {
      this._emitter = new Jy();
    }
    on(e, n) {
      this._emitter.on(e, n);
    }
    once(e, n) {
      this._emitter.once(e, n);
    }
    off(e, n) {
      this._emitter.off(e, n);
    }
    emit(e, n) {
      this._emitter.emit(e, n);
    }
    listenerCount(e) {
      return this._emitter.listenerCount(e);
    }
    listeners(e) {
      return this._emitter.listeners(e);
    }
    eventNames() {
      return this._emitter.eventNames();
    }
    removeAllListeners() {
      return this._emitter.removeAllListeners();
    }
    setMaxListenerWarningThreshold(e) {
      this._emitter.setMaxListeners(e);
    }
    getMaxListeners() {
      return this._emitter.getMaxListeners();
    }
  }
  var Jo;
  (function (t) {
    t.CONFIG_CHANGE = 'CONFIG_CHANGE';
  })(Jo || (Jo = {}));
  class Y9 extends Ep {
    constructor(e) {
      (super(),
        (this.config = {
          handleRevert: !1,
          defaultAccount: void 0,
          defaultBlock: 'latest',
          transactionBlockTimeout: 50,
          transactionConfirmationBlocks: 24,
          transactionPollingInterval: 1e3,
          transactionPollingTimeout: 750 * 1e3,
          transactionReceiptPollingInterval: void 0,
          transactionSendTimeout: 750 * 1e3,
          transactionConfirmationPollingInterval: void 0,
          blockHeaderTimeout: 10,
          maxListenersWarningThreshold: 100,
          contractDataInputFill: 'data',
          defaultNetworkId: void 0,
          defaultChain: 'mainnet',
          defaultHardfork: 'london',
          defaultCommon: void 0,
          defaultTransactionType: '0x2',
          defaultMaxPriorityFeePerGas: is(25e8),
          enableExperimentalFeatures: {
            useSubscriptionWhenCheckingBlockTimeout: !1,
            useRpcCallSpecification: !1
          },
          transactionBuilder: void 0,
          transactionTypeParser: void 0,
          customTransactionSchema: void 0,
          defaultReturnFormat: Tn,
          ignoreGasPricing: !1
        }),
        this.setConfig(e ?? {}));
    }
    setConfig(e) {
      const n = Object.keys(e);
      for (const r of n)
        (this._triggerConfigChange(r, e[r]),
          !Re(e[r]) &&
            typeof e[r] == 'number' &&
            r === 'maxListenersWarningThreshold' &&
            this.setMaxListenerWarningThreshold(Number(e[r])));
      Object.assign(this.config, e);
    }
    get handleRevert() {
      return this.config.handleRevert;
    }
    set handleRevert(e) {
      (this._triggerConfigChange('handleRevert', e),
        (this.config.handleRevert = e));
    }
    get contractDataInputFill() {
      return this.config.contractDataInputFill;
    }
    set contractDataInputFill(e) {
      (this._triggerConfigChange('contractDataInputFill', e),
        (this.config.contractDataInputFill = e));
    }
    get defaultAccount() {
      return this.config.defaultAccount;
    }
    set defaultAccount(e) {
      (this._triggerConfigChange('defaultAccount', e),
        (this.config.defaultAccount = e));
    }
    get defaultBlock() {
      return this.config.defaultBlock;
    }
    set defaultBlock(e) {
      (this._triggerConfigChange('defaultBlock', e),
        (this.config.defaultBlock = e));
    }
    get transactionSendTimeout() {
      return this.config.transactionSendTimeout;
    }
    set transactionSendTimeout(e) {
      (this._triggerConfigChange('transactionSendTimeout', e),
        (this.config.transactionSendTimeout = e));
    }
    get transactionBlockTimeout() {
      return this.config.transactionBlockTimeout;
    }
    set transactionBlockTimeout(e) {
      (this._triggerConfigChange('transactionBlockTimeout', e),
        (this.config.transactionBlockTimeout = e));
    }
    get transactionConfirmationBlocks() {
      return this.config.transactionConfirmationBlocks;
    }
    set transactionConfirmationBlocks(e) {
      (this._triggerConfigChange('transactionConfirmationBlocks', e),
        (this.config.transactionConfirmationBlocks = e));
    }
    get transactionPollingInterval() {
      return this.config.transactionPollingInterval;
    }
    set transactionPollingInterval(e) {
      (this._triggerConfigChange('transactionPollingInterval', e),
        (this.config.transactionPollingInterval = e),
        (this.transactionReceiptPollingInterval = e),
        (this.transactionConfirmationPollingInterval = e));
    }
    get transactionPollingTimeout() {
      return this.config.transactionPollingTimeout;
    }
    set transactionPollingTimeout(e) {
      (this._triggerConfigChange('transactionPollingTimeout', e),
        (this.config.transactionPollingTimeout = e));
    }
    get transactionReceiptPollingInterval() {
      return this.config.transactionReceiptPollingInterval;
    }
    set transactionReceiptPollingInterval(e) {
      (this._triggerConfigChange('transactionReceiptPollingInterval', e),
        (this.config.transactionReceiptPollingInterval = e));
    }
    get transactionConfirmationPollingInterval() {
      return this.config.transactionConfirmationPollingInterval;
    }
    set transactionConfirmationPollingInterval(e) {
      (this._triggerConfigChange('transactionConfirmationPollingInterval', e),
        (this.config.transactionConfirmationPollingInterval = e));
    }
    get blockHeaderTimeout() {
      return this.config.blockHeaderTimeout;
    }
    set blockHeaderTimeout(e) {
      (this._triggerConfigChange('blockHeaderTimeout', e),
        (this.config.blockHeaderTimeout = e));
    }
    get enableExperimentalFeatures() {
      return this.config.enableExperimentalFeatures;
    }
    set enableExperimentalFeatures(e) {
      (this._triggerConfigChange('enableExperimentalFeatures', e),
        (this.config.enableExperimentalFeatures = e));
    }
    get maxListenersWarningThreshold() {
      return this.config.maxListenersWarningThreshold;
    }
    set maxListenersWarningThreshold(e) {
      (this._triggerConfigChange('maxListenersWarningThreshold', e),
        this.setMaxListenerWarningThreshold(e),
        (this.config.maxListenersWarningThreshold = e));
    }
    get defaultReturnFormat() {
      return this.config.defaultReturnFormat;
    }
    set defaultReturnFormat(e) {
      (this._triggerConfigChange('defaultReturnFormat', e),
        (this.config.defaultReturnFormat = e));
    }
    get defaultNetworkId() {
      return this.config.defaultNetworkId;
    }
    set defaultNetworkId(e) {
      (this._triggerConfigChange('defaultNetworkId', e),
        (this.config.defaultNetworkId = e));
    }
    get defaultChain() {
      return this.config.defaultChain;
    }
    set defaultChain(e) {
      if (
        !Re(this.config.defaultCommon) &&
        !Re(this.config.defaultCommon.baseChain) &&
        e !== this.config.defaultCommon.baseChain
      )
        throw new $b(this.config.defaultChain, e);
      (this._triggerConfigChange('defaultChain', e),
        (this.config.defaultChain = e));
    }
    get defaultHardfork() {
      return this.config.defaultHardfork;
    }
    set defaultHardfork(e) {
      if (
        !Re(this.config.defaultCommon) &&
        !Re(this.config.defaultCommon.hardfork) &&
        e !== this.config.defaultCommon.hardfork
      )
        throw new Fb(this.config.defaultCommon.hardfork, e);
      (this._triggerConfigChange('defaultHardfork', e),
        (this.config.defaultHardfork = e));
    }
    get defaultCommon() {
      return this.config.defaultCommon;
    }
    set defaultCommon(e) {
      if (
        !Re(this.config.defaultHardfork) &&
        !Re(e) &&
        !Re(e.hardfork) &&
        this.config.defaultHardfork !== e.hardfork
      )
        throw new Fb(this.config.defaultHardfork, e.hardfork);
      if (
        !Re(this.config.defaultChain) &&
        !Re(e) &&
        !Re(e.baseChain) &&
        this.config.defaultChain !== e.baseChain
      )
        throw new $b(this.config.defaultChain, e.baseChain);
      (this._triggerConfigChange('defaultCommon', e),
        (this.config.defaultCommon = e));
    }
    get ignoreGasPricing() {
      return this.config.ignoreGasPricing;
    }
    set ignoreGasPricing(e) {
      (this._triggerConfigChange('ignoreGasPricing', e),
        (this.config.ignoreGasPricing = e));
    }
    get defaultTransactionType() {
      return this.config.defaultTransactionType;
    }
    set defaultTransactionType(e) {
      (this._triggerConfigChange('defaultTransactionType', e),
        (this.config.defaultTransactionType = e));
    }
    get defaultMaxPriorityFeePerGas() {
      return this.config.defaultMaxPriorityFeePerGas;
    }
    set defaultMaxPriorityFeePerGas(e) {
      (this._triggerConfigChange('defaultMaxPriorityFeePerGas', e),
        (this.config.defaultMaxPriorityFeePerGas = e));
    }
    get transactionBuilder() {
      return this.config.transactionBuilder;
    }
    set transactionBuilder(e) {
      (this._triggerConfigChange('transactionBuilder', e),
        (this.config.transactionBuilder = e));
    }
    get transactionTypeParser() {
      return this.config.transactionTypeParser;
    }
    set transactionTypeParser(e) {
      (this._triggerConfigChange('transactionTypeParser', e),
        (this.config.transactionTypeParser = e));
    }
    get customTransactionSchema() {
      return this.config.customTransactionSchema;
    }
    set customTransactionSchema(e) {
      (this._triggerConfigChange('customTransactionSchema', e),
        (this.config.customTransactionSchema = e));
    }
    _triggerConfigChange(e, n) {
      this.emit(Jo.CONFIG_CHANGE, {
        name: e,
        oldValue: this.config[e],
        newValue: n
      });
    }
  }
  var Ju = {exports: {}},
    tw;
  function Q9() {
    return (
      tw ||
        ((tw = 1),
        (function (t, e) {
          var n =
              (typeof globalThis < 'u' && globalThis) ||
              (typeof self < 'u' && self) ||
              (typeof Oa < 'u' && Oa),
            r = (function () {
              function s() {
                ((this.fetch = !1), (this.DOMException = n.DOMException));
              }
              return ((s.prototype = n), new s());
            })();
          ((function (s) {
            (function (o) {
              var a =
                  (typeof s < 'u' && s) ||
                  (typeof self < 'u' && self) ||
                  (typeof Oa < 'u' && Oa) ||
                  {},
                c = {
                  searchParams: 'URLSearchParams' in a,
                  iterable: 'Symbol' in a && 'iterator' in Symbol,
                  blob:
                    'FileReader' in a &&
                    'Blob' in a &&
                    (function () {
                      try {
                        return (new Blob(), !0);
                      } catch {
                        return !1;
                      }
                    })(),
                  formData: 'FormData' in a,
                  arrayBuffer: 'ArrayBuffer' in a
                };
              function l(E) {
                return E && DataView.prototype.isPrototypeOf(E);
              }
              if (c.arrayBuffer)
                var u = [
                    '[object Int8Array]',
                    '[object Uint8Array]',
                    '[object Uint8ClampedArray]',
                    '[object Int16Array]',
                    '[object Uint16Array]',
                    '[object Int32Array]',
                    '[object Uint32Array]',
                    '[object Float32Array]',
                    '[object Float64Array]'
                  ],
                  d =
                    ArrayBuffer.isView ||
                    function (E) {
                      return (
                        E && u.indexOf(Object.prototype.toString.call(E)) > -1
                      );
                    };
              function f(E) {
                if (
                  (typeof E != 'string' && (E = String(E)),
                  /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(E) || E === '')
                )
                  throw new TypeError(
                    'Invalid character in header field name: "' + E + '"'
                  );
                return E.toLowerCase();
              }
              function h(E) {
                return (typeof E != 'string' && (E = String(E)), E);
              }
              function g(E) {
                var P = {
                  next: function () {
                    var U = E.shift();
                    return {done: U === void 0, value: U};
                  }
                };
                return (
                  c.iterable &&
                    (P[Symbol.iterator] = function () {
                      return P;
                    }),
                  P
                );
              }
              function m(E) {
                ((this.map = {}),
                  E instanceof m
                    ? E.forEach(function (P, U) {
                        this.append(U, P);
                      }, this)
                    : Array.isArray(E)
                      ? E.forEach(function (P) {
                          if (P.length != 2)
                            throw new TypeError(
                              'Headers constructor: expected name/value pair to be length 2, found' +
                                P.length
                            );
                          this.append(P[0], P[1]);
                        }, this)
                      : E &&
                        Object.getOwnPropertyNames(E).forEach(function (P) {
                          this.append(P, E[P]);
                        }, this));
              }
              ((m.prototype.append = function (E, P) {
                ((E = f(E)), (P = h(P)));
                var U = this.map[E];
                this.map[E] = U ? U + ', ' + P : P;
              }),
                (m.prototype.delete = function (E) {
                  delete this.map[f(E)];
                }),
                (m.prototype.get = function (E) {
                  return ((E = f(E)), this.has(E) ? this.map[E] : null);
                }),
                (m.prototype.has = function (E) {
                  return this.map.hasOwnProperty(f(E));
                }),
                (m.prototype.set = function (E, P) {
                  this.map[f(E)] = h(P);
                }),
                (m.prototype.forEach = function (E, P) {
                  for (var U in this.map)
                    this.map.hasOwnProperty(U) &&
                      E.call(P, this.map[U], U, this);
                }),
                (m.prototype.keys = function () {
                  var E = [];
                  return (
                    this.forEach(function (P, U) {
                      E.push(U);
                    }),
                    g(E)
                  );
                }),
                (m.prototype.values = function () {
                  var E = [];
                  return (
                    this.forEach(function (P) {
                      E.push(P);
                    }),
                    g(E)
                  );
                }),
                (m.prototype.entries = function () {
                  var E = [];
                  return (
                    this.forEach(function (P, U) {
                      E.push([U, P]);
                    }),
                    g(E)
                  );
                }),
                c.iterable &&
                  (m.prototype[Symbol.iterator] = m.prototype.entries));
              function y(E) {
                if (!E._noBody) {
                  if (E.bodyUsed)
                    return Promise.reject(new TypeError('Already read'));
                  E.bodyUsed = !0;
                }
              }
              function p(E) {
                return new Promise(function (P, U) {
                  ((E.onload = function () {
                    P(E.result);
                  }),
                    (E.onerror = function () {
                      U(E.error);
                    }));
                });
              }
              function b(E) {
                var P = new FileReader(),
                  U = p(P);
                return (P.readAsArrayBuffer(E), U);
              }
              function v(E) {
                var P = new FileReader(),
                  U = p(P),
                  w = /charset=([A-Za-z0-9_-]+)/.exec(E.type),
                  A = w ? w[1] : 'utf-8';
                return (P.readAsText(E, A), U);
              }
              function x(E) {
                for (
                  var P = new Uint8Array(E), U = new Array(P.length), w = 0;
                  w < P.length;
                  w++
                )
                  U[w] = String.fromCharCode(P[w]);
                return U.join('');
              }
              function C(E) {
                if (E.slice) return E.slice(0);
                var P = new Uint8Array(E.byteLength);
                return (P.set(new Uint8Array(E)), P.buffer);
              }
              function $() {
                return (
                  (this.bodyUsed = !1),
                  (this._initBody = function (E) {
                    ((this.bodyUsed = this.bodyUsed),
                      (this._bodyInit = E),
                      E
                        ? typeof E == 'string'
                          ? (this._bodyText = E)
                          : c.blob && Blob.prototype.isPrototypeOf(E)
                            ? (this._bodyBlob = E)
                            : c.formData && FormData.prototype.isPrototypeOf(E)
                              ? (this._bodyFormData = E)
                              : c.searchParams &&
                                  URLSearchParams.prototype.isPrototypeOf(E)
                                ? (this._bodyText = E.toString())
                                : c.arrayBuffer && c.blob && l(E)
                                  ? ((this._bodyArrayBuffer = C(E.buffer)),
                                    (this._bodyInit = new Blob([
                                      this._bodyArrayBuffer
                                    ])))
                                  : c.arrayBuffer &&
                                      (ArrayBuffer.prototype.isPrototypeOf(E) ||
                                        d(E))
                                    ? (this._bodyArrayBuffer = C(E))
                                    : (this._bodyText = E =
                                        Object.prototype.toString.call(E))
                        : ((this._noBody = !0), (this._bodyText = '')),
                      this.headers.get('content-type') ||
                        (typeof E == 'string'
                          ? this.headers.set(
                              'content-type',
                              'text/plain;charset=UTF-8'
                            )
                          : this._bodyBlob && this._bodyBlob.type
                            ? this.headers.set(
                                'content-type',
                                this._bodyBlob.type
                              )
                            : c.searchParams &&
                              URLSearchParams.prototype.isPrototypeOf(E) &&
                              this.headers.set(
                                'content-type',
                                'application/x-www-form-urlencoded;charset=UTF-8'
                              )));
                  }),
                  c.blob &&
                    (this.blob = function () {
                      var E = y(this);
                      if (E) return E;
                      if (this._bodyBlob)
                        return Promise.resolve(this._bodyBlob);
                      if (this._bodyArrayBuffer)
                        return Promise.resolve(
                          new Blob([this._bodyArrayBuffer])
                        );
                      if (this._bodyFormData)
                        throw new Error('could not read FormData body as blob');
                      return Promise.resolve(new Blob([this._bodyText]));
                    }),
                  (this.arrayBuffer = function () {
                    if (this._bodyArrayBuffer) {
                      var E = y(this);
                      return (
                        E ||
                        (ArrayBuffer.isView(this._bodyArrayBuffer)
                          ? Promise.resolve(
                              this._bodyArrayBuffer.buffer.slice(
                                this._bodyArrayBuffer.byteOffset,
                                this._bodyArrayBuffer.byteOffset +
                                  this._bodyArrayBuffer.byteLength
                              )
                            )
                          : Promise.resolve(this._bodyArrayBuffer))
                      );
                    } else {
                      if (c.blob) return this.blob().then(b);
                      throw new Error('could not read as ArrayBuffer');
                    }
                  }),
                  (this.text = function () {
                    var E = y(this);
                    if (E) return E;
                    if (this._bodyBlob) return v(this._bodyBlob);
                    if (this._bodyArrayBuffer)
                      return Promise.resolve(x(this._bodyArrayBuffer));
                    if (this._bodyFormData)
                      throw new Error('could not read FormData body as text');
                    return Promise.resolve(this._bodyText);
                  }),
                  c.formData &&
                    (this.formData = function () {
                      return this.text().then(k);
                    }),
                  (this.json = function () {
                    return this.text().then(JSON.parse);
                  }),
                  this
                );
              }
              var G = [
                'CONNECT',
                'DELETE',
                'GET',
                'HEAD',
                'OPTIONS',
                'PATCH',
                'POST',
                'PUT',
                'TRACE'
              ];
              function L(E) {
                var P = E.toUpperCase();
                return G.indexOf(P) > -1 ? P : E;
              }
              function F(E, P) {
                if (!(this instanceof F))
                  throw new TypeError(
                    'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
                  );
                P = P || {};
                var U = P.body;
                if (E instanceof F) {
                  if (E.bodyUsed) throw new TypeError('Already read');
                  ((this.url = E.url),
                    (this.credentials = E.credentials),
                    P.headers || (this.headers = new m(E.headers)),
                    (this.method = E.method),
                    (this.mode = E.mode),
                    (this.signal = E.signal),
                    !U &&
                      E._bodyInit != null &&
                      ((U = E._bodyInit), (E.bodyUsed = !0)));
                } else this.url = String(E);
                if (
                  ((this.credentials =
                    P.credentials || this.credentials || 'same-origin'),
                  (P.headers || !this.headers) &&
                    (this.headers = new m(P.headers)),
                  (this.method = L(P.method || this.method || 'GET')),
                  (this.mode = P.mode || this.mode || null),
                  (this.signal =
                    P.signal ||
                    this.signal ||
                    (function () {
                      if ('AbortController' in a) {
                        var T = new AbortController();
                        return T.signal;
                      }
                    })()),
                  (this.referrer = null),
                  (this.method === 'GET' || this.method === 'HEAD') && U)
                )
                  throw new TypeError(
                    'Body not allowed for GET or HEAD requests'
                  );
                if (
                  (this._initBody(U),
                  (this.method === 'GET' || this.method === 'HEAD') &&
                    (P.cache === 'no-store' || P.cache === 'no-cache'))
                ) {
                  var w = /([?&])_=[^&]*/;
                  if (w.test(this.url))
                    this.url = this.url.replace(
                      w,
                      '$1_=' + new Date().getTime()
                    );
                  else {
                    var A = /\?/;
                    this.url +=
                      (A.test(this.url) ? '&' : '?') +
                      '_=' +
                      new Date().getTime();
                  }
                }
              }
              F.prototype.clone = function () {
                return new F(this, {body: this._bodyInit});
              };
              function k(E) {
                var P = new FormData();
                return (
                  E.trim()
                    .split('&')
                    .forEach(function (U) {
                      if (U) {
                        var w = U.split('='),
                          A = w.shift().replace(/\+/g, ' '),
                          T = w.join('=').replace(/\+/g, ' ');
                        P.append(decodeURIComponent(A), decodeURIComponent(T));
                      }
                    }),
                  P
                );
              }
              function V(E) {
                var P = new m(),
                  U = E.replace(/\r?\n[\t ]+/g, ' ');
                return (
                  U.split('\r')
                    .map(function (w) {
                      return w.indexOf(`
`) === 0
                        ? w.substr(1, w.length)
                        : w;
                    })
                    .forEach(function (w) {
                      var A = w.split(':'),
                        T = A.shift().trim();
                      if (T) {
                        var R = A.join(':').trim();
                        try {
                          P.append(T, R);
                        } catch (_) {
                          console.warn('Response ' + _.message);
                        }
                      }
                    }),
                  P
                );
              }
              $.call(F.prototype);
              function K(E, P) {
                if (!(this instanceof K))
                  throw new TypeError(
                    'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
                  );
                if (
                  (P || (P = {}),
                  (this.type = 'default'),
                  (this.status = P.status === void 0 ? 200 : P.status),
                  this.status < 200 || this.status > 599)
                )
                  throw new RangeError(
                    "Failed to construct 'Response': The status provided (0) is outside the range [200, 599]."
                  );
                ((this.ok = this.status >= 200 && this.status < 300),
                  (this.statusText =
                    P.statusText === void 0 ? '' : '' + P.statusText),
                  (this.headers = new m(P.headers)),
                  (this.url = P.url || ''),
                  this._initBody(E));
              }
              ($.call(K.prototype),
                (K.prototype.clone = function () {
                  return new K(this._bodyInit, {
                    status: this.status,
                    statusText: this.statusText,
                    headers: new m(this.headers),
                    url: this.url
                  });
                }),
                (K.error = function () {
                  var E = new K(null, {status: 200, statusText: ''});
                  return ((E.ok = !1), (E.status = 0), (E.type = 'error'), E);
                }));
              var B = [301, 302, 303, 307, 308];
              ((K.redirect = function (E, P) {
                if (B.indexOf(P) === -1)
                  throw new RangeError('Invalid status code');
                return new K(null, {status: P, headers: {location: E}});
              }),
                (o.DOMException = a.DOMException));
              try {
                new o.DOMException();
              } catch {
                ((o.DOMException = function (P, U) {
                  ((this.message = P), (this.name = U));
                  var w = Error(P);
                  this.stack = w.stack;
                }),
                  (o.DOMException.prototype = Object.create(Error.prototype)),
                  (o.DOMException.prototype.constructor = o.DOMException));
              }
              function D(E, P) {
                return new Promise(function (U, w) {
                  var A = new F(E, P);
                  if (A.signal && A.signal.aborted)
                    return w(new o.DOMException('Aborted', 'AbortError'));
                  var T = new XMLHttpRequest();
                  function R() {
                    T.abort();
                  }
                  ((T.onload = function () {
                    var I = {
                      statusText: T.statusText,
                      headers: V(T.getAllResponseHeaders() || '')
                    };
                    (A.url.indexOf('file://') === 0 &&
                    (T.status < 200 || T.status > 599)
                      ? (I.status = 200)
                      : (I.status = T.status),
                      (I.url =
                        'responseURL' in T
                          ? T.responseURL
                          : I.headers.get('X-Request-URL')));
                    var O = 'response' in T ? T.response : T.responseText;
                    setTimeout(function () {
                      U(new K(O, I));
                    }, 0);
                  }),
                    (T.onerror = function () {
                      setTimeout(function () {
                        w(new TypeError('Network request failed'));
                      }, 0);
                    }),
                    (T.ontimeout = function () {
                      setTimeout(function () {
                        w(new TypeError('Network request timed out'));
                      }, 0);
                    }),
                    (T.onabort = function () {
                      setTimeout(function () {
                        w(new o.DOMException('Aborted', 'AbortError'));
                      }, 0);
                    }));
                  function _(I) {
                    try {
                      return I === '' && a.location.href ? a.location.href : I;
                    } catch {
                      return I;
                    }
                  }
                  if (
                    (T.open(A.method, _(A.url), !0),
                    A.credentials === 'include'
                      ? (T.withCredentials = !0)
                      : A.credentials === 'omit' && (T.withCredentials = !1),
                    'responseType' in T &&
                      (c.blob
                        ? (T.responseType = 'blob')
                        : c.arrayBuffer && (T.responseType = 'arraybuffer')),
                    P &&
                      typeof P.headers == 'object' &&
                      !(
                        P.headers instanceof m ||
                        (a.Headers && P.headers instanceof a.Headers)
                      ))
                  ) {
                    var S = [];
                    (Object.getOwnPropertyNames(P.headers).forEach(
                      function (I) {
                        (S.push(f(I)), T.setRequestHeader(I, h(P.headers[I])));
                      }
                    ),
                      A.headers.forEach(function (I, O) {
                        S.indexOf(O) === -1 && T.setRequestHeader(O, I);
                      }));
                  } else
                    A.headers.forEach(function (I, O) {
                      T.setRequestHeader(O, I);
                    });
                  (A.signal &&
                    (A.signal.addEventListener('abort', R),
                    (T.onreadystatechange = function () {
                      T.readyState === 4 &&
                        A.signal.removeEventListener('abort', R);
                    })),
                    T.send(typeof A._bodyInit > 'u' ? null : A._bodyInit));
                });
              }
              return (
                (D.polyfill = !0),
                a.fetch ||
                  ((a.fetch = D),
                  (a.Headers = m),
                  (a.Request = F),
                  (a.Response = K)),
                (o.Headers = m),
                (o.Request = F),
                (o.Response = K),
                (o.fetch = D),
                o
              );
            })({});
          })(r),
            (r.fetch.ponyfill = !0),
            delete r.fetch.polyfill);
          var i = n.fetch ? n : r;
          ((e = i.fetch),
            (e.default = i.fetch),
            (e.fetch = i.fetch),
            (e.Headers = i.Headers),
            (e.Request = i.Request),
            (e.Response = i.Response),
            (t.exports = e));
        })(Ju, Ju.exports)),
      Ju.exports
    );
  }
  var J9 = Q9();
  const av = Ou(J9);
  var X9 = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  class Ap extends ku {
    constructor(e, n) {
      if ((super(), !Ap.validateClientUrl(e))) throw new V0(e);
      ((this.clientUrl = e), (this.httpProviderOptions = n));
    }
    static validateClientUrl(e) {
      return typeof e == 'string' ? /^http(s)?:\/\//i.test(e) : !1;
    }
    getStatus() {
      throw new Ci();
    }
    supportsSubscriptions() {
      return !1;
    }
    request(e, n) {
      var r;
      return X9(this, void 0, void 0, function* () {
        const i = Object.assign(
            Object.assign(
              {},
              (r = this.httpProviderOptions) === null || r === void 0
                ? void 0
                : r.providerOptions
            ),
            n
          ),
          s = yield av(
            this.clientUrl,
            Object.assign(Object.assign({}, i), {
              method: 'POST',
              headers: Object.assign(Object.assign({}, i.headers), {
                'Content-Type': 'application/json'
              }),
              body: JSON.stringify(e)
            })
          );
        if (!s.ok) throw new Qr(yield s.json(), void 0, void 0, s.status);
        return yield s.json();
      });
    }
    on() {
      throw new Ci();
    }
    removeListener() {
      throw new Ci();
    }
    once() {
      throw new Ci();
    }
    removeAllListeners() {
      throw new Ci();
    }
    connect() {
      throw new Ci();
    }
    disconnect() {
      throw new Ci();
    }
    reset() {
      throw new Ci();
    }
    reconnect() {
      throw new Ci();
    }
  }
  var Sa = null;
  typeof WebSocket < 'u'
    ? (Sa = WebSocket)
    : typeof MozWebSocket < 'u'
      ? (Sa = MozWebSocket)
      : typeof global < 'u'
        ? (Sa = global.WebSocket || global.MozWebSocket)
        : typeof window < 'u'
          ? (Sa = window.WebSocket || window.MozWebSocket)
          : typeof self < 'u' && (Sa = self.WebSocket || self.MozWebSocket);
  const eO = Sa;
  class Q3 extends Z3 {
    constructor(e, n, r) {
      super(e, n, r);
    }
    _validateProviderPath(e) {
      return typeof e == 'string' ? /^ws(s)?:\/\//i.test(e) : !1;
    }
    getStatus() {
      if (this._socketConnection && !Re(this._socketConnection))
        switch (this._socketConnection.readyState) {
          case this._socketConnection.CONNECTING:
            return 'connecting';
          case this._socketConnection.OPEN:
            return 'connected';
          default:
            return 'disconnected';
        }
      return 'disconnected';
    }
    _openSocketConnection() {
      this._socketConnection = new eO(
        this._socketPath,
        void 0,
        this._socketOptions && Object.keys(this._socketOptions).length === 0
          ? void 0
          : this._socketOptions
      );
    }
    _closeSocketConnection(e, n) {
      var r;
      (r = this._socketConnection) === null || r === void 0 || r.close(e, n);
    }
    _sendToSocket(e) {
      var n;
      if (this.getStatus() === 'disconnected') throw new K0();
      (n = this._socketConnection) === null ||
        n === void 0 ||
        n.send(JSON.stringify(e));
    }
    _parseResponses(e) {
      return this.chunkResponseParser.parseResponse(e.data);
    }
    _addSocketListeners() {
      var e, n, r, i;
      ((e = this._socketConnection) === null ||
        e === void 0 ||
        e.addEventListener('open', this._onOpenHandler),
        (n = this._socketConnection) === null ||
          n === void 0 ||
          n.addEventListener('message', this._onMessageHandler),
        (r = this._socketConnection) === null ||
          r === void 0 ||
          r.addEventListener('close', (s) => this._onCloseHandler(s)),
        (i = this._socketConnection) === null ||
          i === void 0 ||
          i.addEventListener('error', this._onErrorHandler));
    }
    _removeSocketListeners() {
      var e, n, r;
      ((e = this._socketConnection) === null ||
        e === void 0 ||
        e.removeEventListener('message', this._onMessageHandler),
        (n = this._socketConnection) === null ||
          n === void 0 ||
          n.removeEventListener('open', this._onOpenHandler),
        (r = this._socketConnection) === null ||
          r === void 0 ||
          r.removeEventListener('close', this._onCloseHandler));
    }
    _onCloseEvent(e) {
      var n;
      if (
        this._reconnectOptions.autoReconnect &&
        (![1e3, 1001].includes(e.code) || !e.wasClean)
      ) {
        this._reconnect();
        return;
      }
      (this._clearQueues(e),
        this._removeSocketListeners(),
        this._onDisconnect(e.code, e.reason),
        (n = this._socketConnection) === null ||
          n === void 0 ||
          n.removeEventListener('error', this._onErrorHandler));
    }
  }
  const J3 = (t) => ku.isWeb3Provider(t),
    X3 = (t) =>
      typeof t != 'string' &&
      'request' in t &&
      t.request.constructor.name === 'Function',
    eS = (t) =>
      typeof t != 'string' &&
      'request' in t &&
      t.request.constructor.name === 'AsyncFunction',
    tS = (t) => typeof t != 'string' && 'send' in t,
    nS = (t) => typeof t != 'string' && 'sendAsync' in t,
    rh = (t) => t && (J3(t) || eS(t) || X3(t) || nS(t) || tS(t)),
    tO = (t) =>
      t && 'supportsSubscriptions' in t
        ? t.supportsSubscriptions()
        : !!(t && typeof t != 'string' && 'on' in t);
  var mm = function (t, e, n, r) {
      function i(s) {
        return s instanceof n
          ? s
          : new n(function (o) {
              o(s);
            });
      }
      return new (n || (n = Promise))(function (s, o) {
        function a(u) {
          try {
            l(r.next(u));
          } catch (d) {
            o(d);
          }
        }
        function c(u) {
          try {
            l(r.throw(u));
          } catch (d) {
            o(d);
          }
        }
        function l(u) {
          u.done ? s(u.value) : i(u.value).then(a, c);
        }
        l((r = r.apply(t, e || [])).next());
      });
    },
    hc;
  (function (t) {
    ((t.PROVIDER_CHANGED = 'PROVIDER_CHANGED'),
      (t.BEFORE_PROVIDER_CHANGE = 'BEFORE_PROVIDER_CHANGE'));
  })(hc || (hc = {}));
  const nw = {HttpProvider: Ap, WebsocketProvider: Q3};
  class Fo extends Ep {
    constructor(e, n, r) {
      (super(),
        Re(e) || this.setProvider(e),
        (this.useRpcCallSpecification = n),
        Re(r) || (this.middleware = r));
    }
    static get providers() {
      return nw;
    }
    get provider() {
      return this._provider;
    }
    get providers() {
      return nw;
    }
    setProvider(e) {
      let n;
      if (e && typeof e == 'string' && this.providers)
        if (/^http(s)?:\/\//i.test(e)) n = new this.providers.HttpProvider(e);
        else if (/^ws(s)?:\/\//i.test(e))
          n = new this.providers.WebsocketProvider(e);
        else throw new Dd(`Can't autodetect provider for "${e}"`);
      else Re(e) ? (n = void 0) : (n = e);
      return (
        this.emit(hc.BEFORE_PROVIDER_CHANGE, this._provider),
        (this._provider = n),
        this.emit(hc.PROVIDER_CHANGED, this._provider),
        !0
      );
    }
    setMiddleware(e) {
      this.middleware = e;
    }
    send(e) {
      return mm(this, void 0, void 0, function* () {
        const n = Object.assign({}, e);
        let r = yield this._sendRequest(n);
        if (
          (Re(this.middleware) ||
            (r = yield this.middleware.processResponse(r)),
          Vs(r))
        )
          return r.result;
        throw new Qr(r);
      });
    }
    sendBatch(e) {
      return mm(this, void 0, void 0, function* () {
        return yield this._sendRequest(e);
      });
    }
    _sendRequest(e) {
      return mm(this, void 0, void 0, function* () {
        const {provider: n} = this;
        if (Re(n))
          throw new Dd(
            'Provider not available. Use `.setProvider` or `.provider=` to initialize the provider.'
          );
        let r = Wr(e) ? sv(e) : Qo(e);
        if (
          (Re(this.middleware) || (r = yield this.middleware.processRequest(r)),
          J3(n))
        ) {
          let i;
          try {
            i = yield n.request(r);
          } catch (s) {
            i = s;
          }
          return this._processJsonRpcResponse(r, i, {legacy: !1, error: !1});
        }
        if (eS(n))
          return n
            .request(r)
            .then((i) =>
              this._processJsonRpcResponse(r, i, {legacy: !0, error: !1})
            )
            .catch((i) =>
              this._processJsonRpcResponse(r, i, {legacy: !0, error: !0})
            );
        if (X3(n))
          return new Promise((i, s) => {
            const o = (l) => {
                s(this._processJsonRpcResponse(r, l, {legacy: !0, error: !0}));
              },
              a = (l) =>
                i(this._processJsonRpcResponse(r, l, {legacy: !0, error: !1})),
              c = n.request(r, (l, u) => (l ? o(l) : a(u)));
            U3(c) &&
              c.then(a).catch((u) => {
                try {
                  const d = this._processJsonRpcResponse(r, u, {
                    legacy: !0,
                    error: !0
                  });
                  s(d);
                } catch (d) {
                  s(d);
                }
              });
          });
        if (tS(n))
          return new Promise((i, s) => {
            n.send(r, (o, a) => {
              if (o)
                return s(
                  this._processJsonRpcResponse(r, o, {legacy: !0, error: !0})
                );
              if (Re(a))
                throw new Qr({}, 'Got a "nullish" response from provider.');
              return i(
                this._processJsonRpcResponse(r, a, {legacy: !0, error: !1})
              );
            });
          });
        if (nS(n))
          return n
            .sendAsync(r)
            .then((i) =>
              this._processJsonRpcResponse(r, i, {legacy: !0, error: !1})
            )
            .catch((i) =>
              this._processJsonRpcResponse(r, i, {legacy: !0, error: !0})
            );
        throw new Dd('Provider does not have a request or send method to use.');
      });
    }
    _processJsonRpcResponse(e, n, {legacy: r, error: i}) {
      if (Re(n)) return this._buildResponse(e, null, i);
      if (Gs(n)) {
        if (this.useRpcCallSpecification && rv(n)) {
          const s = n;
          if (Rn.get(s.error.code)) {
            const o = Rn.get(s.error.code).error;
            throw new o(s);
          } else throw new ir(s);
        } else if (!Fo._isReverted(n)) throw new up(n, e);
      }
      if (Vs(n)) return n;
      if (n instanceof Error) throw (Fo._isReverted(n), n);
      if ((!r && Wr(e) && tu(n)) || (r && !i && Wr(e))) return n;
      if (r && i && Wr(e)) throw n;
      if (r && !Gs(n) && !Vs(n)) return this._buildResponse(e, n, i);
      throw Wr(e) && !Array.isArray(n)
        ? new Qr(n, 'Got normal response for a batch request.')
        : !Wr(e) && Array.isArray(n)
          ? new Qr(n, 'Got batch response for a normal request.')
          : new Qr(n, 'Invalid response');
    }
    static _isReverted(e) {
      let n;
      if (
        (Gs(e) ? (n = e.error) : e instanceof Error && (n = e),
        n != null && n.message.includes('revert'))
      )
        throw new Bo(n);
      return !1;
    }
    _buildResponse(e, n, r) {
      const i = {jsonrpc: '2.0', id: Wr(e) ? e[0].id : 'id' in e ? e.id : null};
      return r
        ? Object.assign(Object.assign({}, i), {error: n})
        : Object.assign(Object.assign({}, i), {result: n});
    }
  }
  var Kc = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  class ih {
    constructor(e, n, r = !1) {
      ((this.requestManager = e),
        (this.registeredSubscriptions = n),
        (this.tolerateUnlinkedSubscription = r),
        (this._subscriptions = new Map()),
        this.requestManager.on(hc.BEFORE_PROVIDER_CHANGE, () =>
          Kc(this, void 0, void 0, function* () {
            yield this.unsubscribe();
          })
        ),
        this.requestManager.on(hc.PROVIDER_CHANGED, () => {
          (this.clear(), this.listenToProviderEvents());
        }),
        this.listenToProviderEvents());
    }
    listenToProviderEvents() {
      const e = this.requestManager.provider;
      !this.requestManager.provider ||
        (typeof (e == null ? void 0 : e.supportsSubscriptions) == 'function' &&
          !(e != null && e.supportsSubscriptions())) ||
        (typeof this.requestManager.provider.on == 'function' &&
          (typeof this.requestManager.provider.request == 'function'
            ? this.requestManager.provider.on('message', (n) =>
                this.messageListener(n)
              )
            : e.on('data', (n) => this.messageListener(n))));
    }
    messageListener(e) {
      var n, r, i;
      if (!e)
        throw new Li('Should not call messageListener with no data. Type was');
      const s =
        ((n = e.params) === null || n === void 0 ? void 0 : n.subscription) ||
        ((r = e.data) === null || r === void 0 ? void 0 : r.subscription) ||
        ((i = e.id) === null || i === void 0 ? void 0 : i.toString(16));
      if (s) {
        const o = this._subscriptions.get(s);
        o == null || o.processSubscriptionData(e);
      }
    }
    subscribe(e, n) {
      return Kc(this, arguments, void 0, function* (r, i, s = Tn) {
        const o = this.registeredSubscriptions[r];
        if (!o) throw new Li('Invalid subscription type');
        const a = new o(i ?? void 0, {
          subscriptionManager: this,
          returnFormat: s
        });
        return (yield this.addSubscription(a), a);
      });
    }
    get subscriptions() {
      return this._subscriptions;
    }
    addSubscription(e) {
      return Kc(this, void 0, void 0, function* () {
        if (!this.requestManager.provider)
          throw new Dd('Provider not available');
        if (!this.supportsSubscriptions())
          throw new Li('The current provider does not support subscriptions');
        if (e.id && this._subscriptions.has(e.id))
          throw new Li(`Subscription with id "${e.id}" already exists`);
        if ((yield e.sendSubscriptionRequest(), Re(e.id)))
          throw new Li('Subscription is not subscribed yet.');
        return (this._subscriptions.set(e.id, e), e.id);
      });
    }
    removeSubscription(e) {
      return Kc(this, void 0, void 0, function* () {
        const {id: n} = e;
        if (Re(n))
          throw new Li(
            'Subscription is not subscribed yet. Or, had already been unsubscribed but not through the Subscription Manager.'
          );
        if (!this._subscriptions.has(n) && !this.tolerateUnlinkedSubscription)
          throw new Li(
            `Subscription with id "${n.toString()}" does not exists`
          );
        return (
          yield e.sendUnsubscribeRequest(),
          this._subscriptions.delete(n),
          n
        );
      });
    }
    unsubscribe(e) {
      return Kc(this, void 0, void 0, function* () {
        const n = [];
        for (const [r, i] of this.subscriptions.entries())
          (!e || (typeof e == 'function' && e({id: r, sub: i}))) &&
            n.push(this.removeSubscription(i));
        return Promise.all(n);
      });
    }
    clear() {
      this._subscriptions.clear();
    }
    supportsSubscriptions() {
      return Re(this.requestManager.provider)
        ? !1
        : tO(this.requestManager.provider);
    }
  }
  var qc = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  class Lu extends Ep {
    constructor(e, n) {
      var r;
      (super(), (this.args = e));
      const {requestManager: i} = n,
        {subscriptionManager: s} = n;
      (i
        ? (this._subscriptionManager = new ih(i, {}, !0))
        : (this._subscriptionManager = s),
        (this._returnFormat =
          (r = n == null ? void 0 : n.returnFormat) !== null && r !== void 0
            ? r
            : Tn));
    }
    get id() {
      return this._id;
    }
    get lastBlock() {
      return this._lastBlock;
    }
    subscribe() {
      return qc(this, void 0, void 0, function* () {
        return this._subscriptionManager.addSubscription(this);
      });
    }
    processSubscriptionData(e) {
      var n, r;
      e != null && e.data
        ? this._processSubscriptionResult(
            (r =
              (n = e == null ? void 0 : e.data) === null || n === void 0
                ? void 0
                : n.result) !== null && r !== void 0
              ? r
              : e == null
                ? void 0
                : e.data
          )
        : e &&
          _p(e) &&
          this._processSubscriptionResult(e == null ? void 0 : e.params.result);
    }
    sendSubscriptionRequest() {
      return qc(this, void 0, void 0, function* () {
        return (
          (this._id = yield this._subscriptionManager.requestManager.send({
            method: 'eth_subscribe',
            params: this._buildSubscriptionParams()
          })),
          this.emit('connected', this._id),
          this._id
        );
      });
    }
    get returnFormat() {
      return this._returnFormat;
    }
    get subscriptionManager() {
      return this._subscriptionManager;
    }
    resubscribe() {
      return qc(this, void 0, void 0, function* () {
        (yield this.unsubscribe(), yield this.subscribe());
      });
    }
    unsubscribe() {
      return qc(this, void 0, void 0, function* () {
        this.id && (yield this._subscriptionManager.removeSubscription(this));
      });
    }
    sendUnsubscribeRequest() {
      return qc(this, void 0, void 0, function* () {
        (yield this._subscriptionManager.requestManager.send({
          method: 'eth_unsubscribe',
          params: [this.id]
        }),
          (this._id = void 0));
      });
    }
    formatSubscriptionResult(e) {
      return e;
    }
    _processSubscriptionResult(e) {
      this.emit('data', this.formatSubscriptionResult(e));
    }
    _processSubscriptionError(e) {
      this.emit('error', e);
    }
    _buildSubscriptionParams() {
      throw new Error('Implement in the child class');
    }
  }
  var ha = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  class sh extends j8 {
    constructor() {
      (super(...arguments),
        (this._addressMap = new Map()),
        (this._defaultKeyName = 'web3js_wallet'));
    }
    static getStorage() {
      let e;
      try {
        e = window.localStorage;
        const n = '__storage_test__';
        return (e.setItem(n, n), e.removeItem(n), e);
      } catch (n) {
        return n &&
          (n.code === 22 ||
            n.code === 1014 ||
            n.name === 'QuotaExceededError' ||
            n.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&
          !ie(e) &&
          e.length !== 0
          ? e
          : void 0;
      }
    }
    create(e) {
      for (let n = 0; n < e; n += 1) this.add(this._accountProvider.create());
      return this;
    }
    add(e) {
      var n;
      if (typeof e == 'string')
        return this.add(this._accountProvider.privateKeyToAccount(e));
      let r = this.length;
      return (
        this.get(e.address) &&
          (console.warn(`Account ${e.address.toLowerCase()} already exists.`),
          (r =
            (n = this._addressMap.get(e.address.toLowerCase())) !== null &&
            n !== void 0
              ? n
              : r)),
        this._addressMap.set(e.address.toLowerCase(), r),
        (this[r] = e),
        this
      );
    }
    get(e) {
      if (typeof e == 'string') {
        const n = this._addressMap.get(e.toLowerCase());
        return ie(n) ? void 0 : this[n];
      }
      return this[e];
    }
    remove(e) {
      if (typeof e == 'string') {
        const n = this._addressMap.get(e.toLowerCase());
        return ie(n)
          ? !1
          : (this._addressMap.delete(e.toLowerCase()), this.splice(n, 1), !0);
      }
      return this[e] ? (this.splice(e, 1), !0) : !1;
    }
    clear() {
      return (this._addressMap.clear(), (this.length = 0), this);
    }
    encrypt(e, n) {
      return ha(this, void 0, void 0, function* () {
        return Promise.all(
          this.map((r) =>
            ha(this, void 0, void 0, function* () {
              return r.encrypt(e, n);
            })
          )
        );
      });
    }
    decrypt(e, n, r) {
      return ha(this, void 0, void 0, function* () {
        const i = yield Promise.all(
          e.map((s) =>
            ha(this, void 0, void 0, function* () {
              return this._accountProvider.decrypt(s, n, r);
            })
          )
        );
        for (const s of i) this.add(s);
        return this;
      });
    }
    save(e, n) {
      return ha(this, void 0, void 0, function* () {
        const r = sh.getStorage();
        if (!r) throw new Error('Local storage not available.');
        return (
          r.setItem(
            n ?? this._defaultKeyName,
            JSON.stringify(yield this.encrypt(e))
          ),
          !0
        );
      });
    }
    load(e, n) {
      return ha(this, void 0, void 0, function* () {
        const r = sh.getStorage();
        if (!r) throw new Error('Local storage not available.');
        const i = r.getItem(n ?? this._defaultKeyName);
        return (i && (yield this.decrypt(JSON.parse(i) || [], e)), this);
      });
    }
  }
  const ii = {web: Fd};
  function rS(t, e, n) {
    if (!n.startsWith('aes-'))
      throw new Error(`AES submodule doesn't support mode ${n}`);
    if (e.length !== 16) throw new Error('AES: wrong IV length');
    if (
      (n.startsWith('aes-128') && t.length !== 16) ||
      (n.startsWith('aes-256') && t.length !== 32)
    )
      throw new Error('AES: wrong key length');
  }
  async function iS(t, e, n) {
    if (!ii.web) throw new Error('Browser crypto not available.');
    let r;
    if (
      (['aes-128-cbc', 'aes-256-cbc'].includes(t) && (r = 'cbc'),
      ['aes-128-ctr', 'aes-256-ctr'].includes(t) && (r = 'ctr'),
      !r)
    )
      throw new Error('AES: unsupported mode');
    return [
      await ii.web.subtle.importKey(
        'raw',
        e,
        {name: `AES-${r.toUpperCase()}`, length: e.length * 8},
        !0,
        ['encrypt', 'decrypt']
      ),
      {name: `aes-${r}`, iv: n, counter: n, length: 128}
    ];
  }
  async function cv(t, e, n, r = 'aes-128-ctr', i = !0) {
    if ((rS(e, n, r), ii.web)) {
      const [s, o] = await iS(r, e, n),
        a = await ii.web.subtle.encrypt(o, s, t);
      let c = new Uint8Array(a);
      return (
        !i && o.name === 'aes-cbc' && !(t.length % 16) && (c = c.slice(0, -16)),
        c
      );
    } else if (ii.node) {
      const s = ii.node.createCipheriv(r, e, n);
      return (s.setAutoPadding(i), Kf(s.update(t), s.final()));
    } else throw new Error("The environment doesn't have AES module");
  }
  async function nO(t, e, n, r) {
    const i = t.slice(-16);
    for (let o = 0; o < 16; o++) i[o] ^= n[o] ^ 16;
    return (await cv(i, e, n, r)).slice(0, 16);
  }
  async function rO(t, e, n, r = 'aes-128-ctr', i = !0) {
    if ((rS(e, n, r), ii.web)) {
      const [s, o] = await iS(r, e, n);
      if (!i && o.name === 'aes-cbc') {
        const l = await nO(t, e, n, r);
        t = Kf(t, l);
      }
      const a = await ii.web.subtle.decrypt(o, s, t),
        c = new Uint8Array(a);
      if (o.name === 'aes-cbc') {
        const l = await cv(c, e, n, r);
        if (!JP(l, t)) throw new Error('AES: wrong padding');
      }
      return c;
    } else if (ii.node) {
      const s = ii.node.createDecipheriv(r, e, n);
      return (s.setAutoPadding(i), Kf(s.update(t), s.final()));
    } else throw new Error("The environment doesn't have AES module");
  }
  class sS extends Ky {
    constructor(e, n) {
      (super(), (this.finished = !1), (this.destroyed = !1), jy(e));
      const r = sc(n);
      if (((this.iHash = e.create()), typeof this.iHash.update != 'function'))
        throw new Error('Expected instance of class which extends utils.Hash');
      ((this.blockLen = this.iHash.blockLen),
        (this.outputLen = this.iHash.outputLen));
      const i = this.blockLen,
        s = new Uint8Array(i);
      s.set(r.length > i ? e.create().update(r).digest() : r);
      for (let o = 0; o < s.length; o++) s[o] ^= 54;
      (this.iHash.update(s), (this.oHash = e.create()));
      for (let o = 0; o < s.length; o++) s[o] ^= 106;
      (this.oHash.update(s), s.fill(0));
    }
    update(e) {
      return (Vo(this), this.iHash.update(e), this);
    }
    digestInto(e) {
      (Vo(this),
        kc(e, this.outputLen),
        (this.finished = !0),
        this.iHash.digestInto(e),
        this.oHash.update(e),
        this.oHash.digestInto(e),
        this.destroy());
    }
    digest() {
      const e = new Uint8Array(this.oHash.outputLen);
      return (this.digestInto(e), e);
    }
    _cloneInto(e) {
      e || (e = Object.create(Object.getPrototypeOf(this), {}));
      const {
        oHash: n,
        iHash: r,
        finished: i,
        destroyed: s,
        blockLen: o,
        outputLen: a
      } = this;
      return (
        (e = e),
        (e.finished = i),
        (e.destroyed = s),
        (e.blockLen = o),
        (e.outputLen = a),
        (e.oHash = n._cloneInto(e.oHash)),
        (e.iHash = r._cloneInto(e.iHash)),
        e
      );
    }
    destroy() {
      ((this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy());
    }
  }
  const lv = (t, e, n) => new sS(t, e).update(n).digest();
  lv.create = (t, e) => new sS(t, e);
  function iO(t, e, n, r) {
    jy(t);
    const i = o3({dkLen: 32, asyncTick: 10}, r),
      {c: s, dkLen: o, asyncTick: a} = i;
    if (($n(s), $n(o), $n(a), s < 1))
      throw new Error('PBKDF2: iterations (c) should be >= 1');
    const c = sc(e),
      l = sc(n),
      u = new Uint8Array(o),
      d = lv.create(t, c),
      f = d._cloneInto().update(l);
    return {c: s, dkLen: o, asyncTick: a, DK: u, PRF: d, PRFSalt: f};
  }
  function sO(t, e, n, r, i) {
    return (t.destroy(), e.destroy(), r && r.destroy(), i.fill(0), n);
  }
  function uv(t, e, n, r) {
    const {c: i, dkLen: s, DK: o, PRF: a, PRFSalt: c} = iO(t, e, n, r);
    let l;
    const u = new Uint8Array(4),
      d = Hd(u),
      f = new Uint8Array(a.outputLen);
    for (let h = 1, g = 0; g < s; h++, g += a.outputLen) {
      const m = o.subarray(g, g + a.outputLen);
      (d.setInt32(0, h, !1),
        (l = c._cloneInto(l)).update(u).digestInto(f),
        m.set(f.subarray(0, m.length)));
      for (let y = 1; y < i; y++) {
        a._cloneInto(l).update(f).digestInto(f);
        for (let p = 0; p < m.length; p++) m[p] ^= f[p];
      }
    }
    return sO(a, c, o, l, f);
  }
  function oO(t, e, n, r) {
    if (typeof t.setBigUint64 == 'function') return t.setBigUint64(e, n, r);
    const i = BigInt(32),
      s = BigInt(4294967295),
      o = Number((n >> i) & s),
      a = Number(n & s),
      c = r ? 4 : 0,
      l = r ? 0 : 4;
    (t.setUint32(e + c, o, r), t.setUint32(e + l, a, r));
  }
  const aO = (t, e, n) => (t & e) ^ (~t & n),
    cO = (t, e, n) => (t & e) ^ (t & n) ^ (e & n);
  class lO extends Ky {
    constructor(e, n, r, i) {
      (super(),
        (this.blockLen = e),
        (this.outputLen = n),
        (this.padOffset = r),
        (this.isLE = i),
        (this.finished = !1),
        (this.length = 0),
        (this.pos = 0),
        (this.destroyed = !1),
        (this.buffer = new Uint8Array(e)),
        (this.view = Hd(this.buffer)));
    }
    update(e) {
      Vo(this);
      const {view: n, buffer: r, blockLen: i} = this;
      e = sc(e);
      const s = e.length;
      for (let o = 0; o < s; ) {
        const a = Math.min(i - this.pos, s - o);
        if (a === i) {
          const c = Hd(e);
          for (; i <= s - o; o += i) this.process(c, o);
          continue;
        }
        (r.set(e.subarray(o, o + a), this.pos),
          (this.pos += a),
          (o += a),
          this.pos === i && (this.process(n, 0), (this.pos = 0)));
      }
      return ((this.length += e.length), this.roundClean(), this);
    }
    digestInto(e) {
      (Vo(this), Uy(e, this), (this.finished = !0));
      const {buffer: n, view: r, blockLen: i, isLE: s} = this;
      let {pos: o} = this;
      ((n[o++] = 128),
        this.buffer.subarray(o).fill(0),
        this.padOffset > i - o && (this.process(r, 0), (o = 0)));
      for (let d = o; d < i; d++) n[d] = 0;
      (oO(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0));
      const a = Hd(e),
        c = this.outputLen;
      if (c % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
      const l = c / 4,
        u = this.get();
      if (l > u.length) throw new Error('_sha2: outputLen bigger than state');
      for (let d = 0; d < l; d++) a.setUint32(4 * d, u[d], s);
    }
    digest() {
      const {buffer: e, outputLen: n} = this;
      this.digestInto(e);
      const r = e.slice(0, n);
      return (this.destroy(), r);
    }
    _cloneInto(e) {
      (e || (e = new this.constructor()), e.set(...this.get()));
      const {
        blockLen: n,
        buffer: r,
        length: i,
        finished: s,
        destroyed: o,
        pos: a
      } = this;
      return (
        (e.length = i),
        (e.pos = a),
        (e.finished = s),
        (e.destroyed = o),
        i % n && e.buffer.set(r),
        e
      );
    }
  }
  const uO = new Uint32Array([
      1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
      2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
      1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
      264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
      2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
      113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
      1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
      3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
      430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
      1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
      2428436474, 2756734187, 3204031479, 3329325298
    ]),
    ps = new Uint32Array([
      1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
      528734635, 1541459225
    ]),
    ms = new Uint32Array(64);
  class dO extends lO {
    constructor() {
      (super(64, 32, 8, !1),
        (this.A = ps[0] | 0),
        (this.B = ps[1] | 0),
        (this.C = ps[2] | 0),
        (this.D = ps[3] | 0),
        (this.E = ps[4] | 0),
        (this.F = ps[5] | 0),
        (this.G = ps[6] | 0),
        (this.H = ps[7] | 0));
    }
    get() {
      const {A: e, B: n, C: r, D: i, E: s, F: o, G: a, H: c} = this;
      return [e, n, r, i, s, o, a, c];
    }
    set(e, n, r, i, s, o, a, c) {
      ((this.A = e | 0),
        (this.B = n | 0),
        (this.C = r | 0),
        (this.D = i | 0),
        (this.E = s | 0),
        (this.F = o | 0),
        (this.G = a | 0),
        (this.H = c | 0));
    }
    process(e, n) {
      for (let d = 0; d < 16; d++, n += 4) ms[d] = e.getUint32(n, !1);
      for (let d = 16; d < 64; d++) {
        const f = ms[d - 15],
          h = ms[d - 2],
          g = Kr(f, 7) ^ Kr(f, 18) ^ (f >>> 3),
          m = Kr(h, 17) ^ Kr(h, 19) ^ (h >>> 10);
        ms[d] = (m + ms[d - 7] + g + ms[d - 16]) | 0;
      }
      let {A: r, B: i, C: s, D: o, E: a, F: c, G: l, H: u} = this;
      for (let d = 0; d < 64; d++) {
        const f = Kr(a, 6) ^ Kr(a, 11) ^ Kr(a, 25),
          h = (u + f + aO(a, c, l) + uO[d] + ms[d]) | 0,
          m = ((Kr(r, 2) ^ Kr(r, 13) ^ Kr(r, 22)) + cO(r, i, s)) | 0;
        ((u = l),
          (l = c),
          (c = a),
          (a = (o + h) | 0),
          (o = s),
          (s = i),
          (i = r),
          (r = (h + m) | 0));
      }
      ((r = (r + this.A) | 0),
        (i = (i + this.B) | 0),
        (s = (s + this.C) | 0),
        (o = (o + this.D) | 0),
        (a = (a + this.E) | 0),
        (c = (c + this.F) | 0),
        (l = (l + this.G) | 0),
        (u = (u + this.H) | 0),
        this.set(r, i, s, o, a, c, l, u));
    }
    roundClean() {
      ms.fill(0);
    }
    destroy() {
      (this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0));
    }
  }
  const Sp = a3(() => new dO());
  function oS(t, e, n, r, i) {
    if (!['sha256', 'sha512'].includes(i))
      throw new Error('Only sha256 and sha512 are supported');
    return (qf(t), qf(e), uv(Sp, t, e, {c: n, dkLen: r}));
  }
  function rw(t, e, n, r, i, s) {
    let o = t[e++] ^ n[r++],
      a = t[e++] ^ n[r++],
      c = t[e++] ^ n[r++],
      l = t[e++] ^ n[r++],
      u = t[e++] ^ n[r++],
      d = t[e++] ^ n[r++],
      f = t[e++] ^ n[r++],
      h = t[e++] ^ n[r++],
      g = t[e++] ^ n[r++],
      m = t[e++] ^ n[r++],
      y = t[e++] ^ n[r++],
      p = t[e++] ^ n[r++],
      b = t[e++] ^ n[r++],
      v = t[e++] ^ n[r++],
      x = t[e++] ^ n[r++],
      C = t[e++] ^ n[r++],
      $ = o,
      G = a,
      L = c,
      F = l,
      k = u,
      V = d,
      K = f,
      B = h,
      D = g,
      E = m,
      P = y,
      U = p,
      w = b,
      A = v,
      T = x,
      R = C;
    for (let _ = 0; _ < 8; _ += 2)
      ((k ^= nt(($ + w) | 0, 7)),
        (D ^= nt((k + $) | 0, 9)),
        (w ^= nt((D + k) | 0, 13)),
        ($ ^= nt((w + D) | 0, 18)),
        (E ^= nt((V + G) | 0, 7)),
        (A ^= nt((E + V) | 0, 9)),
        (G ^= nt((A + E) | 0, 13)),
        (V ^= nt((G + A) | 0, 18)),
        (T ^= nt((P + K) | 0, 7)),
        (L ^= nt((T + P) | 0, 9)),
        (K ^= nt((L + T) | 0, 13)),
        (P ^= nt((K + L) | 0, 18)),
        (F ^= nt((R + U) | 0, 7)),
        (B ^= nt((F + R) | 0, 9)),
        (U ^= nt((B + F) | 0, 13)),
        (R ^= nt((U + B) | 0, 18)),
        (G ^= nt(($ + F) | 0, 7)),
        (L ^= nt((G + $) | 0, 9)),
        (F ^= nt((L + G) | 0, 13)),
        ($ ^= nt((F + L) | 0, 18)),
        (K ^= nt((V + k) | 0, 7)),
        (B ^= nt((K + V) | 0, 9)),
        (k ^= nt((B + K) | 0, 13)),
        (V ^= nt((k + B) | 0, 18)),
        (U ^= nt((P + E) | 0, 7)),
        (D ^= nt((U + P) | 0, 9)),
        (E ^= nt((D + U) | 0, 13)),
        (P ^= nt((E + D) | 0, 18)),
        (w ^= nt((R + T) | 0, 7)),
        (A ^= nt((w + R) | 0, 9)),
        (T ^= nt((A + w) | 0, 13)),
        (R ^= nt((T + A) | 0, 18)));
    ((i[s++] = (o + $) | 0),
      (i[s++] = (a + G) | 0),
      (i[s++] = (c + L) | 0),
      (i[s++] = (l + F) | 0),
      (i[s++] = (u + k) | 0),
      (i[s++] = (d + V) | 0),
      (i[s++] = (f + K) | 0),
      (i[s++] = (h + B) | 0),
      (i[s++] = (g + D) | 0),
      (i[s++] = (m + E) | 0),
      (i[s++] = (y + P) | 0),
      (i[s++] = (p + U) | 0),
      (i[s++] = (b + w) | 0),
      (i[s++] = (v + A) | 0),
      (i[s++] = (x + T) | 0),
      (i[s++] = (C + R) | 0));
  }
  function gm(t, e, n, r, i) {
    let s = r + 0,
      o = r + 16 * i;
    for (let a = 0; a < 16; a++) n[o + a] = t[e + (2 * i - 1) * 16 + a];
    for (let a = 0; a < i; a++, s += 16, e += 16)
      (rw(n, o, t, e, n, s), a > 0 && (o += 16), rw(n, s, t, (e += 16), n, o));
  }
  function fO(t, e, n) {
    const r = o3({dkLen: 32, asyncTick: 10, maxmem: 1073742848}, n),
      {N: i, r: s, p: o, dkLen: a, asyncTick: c, maxmem: l, onProgress: u} = r;
    if (
      ($n(i),
      $n(s),
      $n(o),
      $n(a),
      $n(c),
      $n(l),
      u !== void 0 && typeof u != 'function')
    )
      throw new Error('progressCb should be function');
    const d = 128 * s,
      f = d / 4;
    if (i <= 1 || (i & (i - 1)) !== 0 || i >= 2 ** (d / 8) || i > 2 ** 32)
      throw new Error(
        'Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32'
      );
    if (o < 0 || o > ((2 ** 32 - 1) * 32) / d)
      throw new Error(
        'Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)'
      );
    if (a < 0 || a > (2 ** 32 - 1) * 32)
      throw new Error(
        'Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32'
      );
    const h = d * (i + o);
    if (h > l)
      throw new Error(
        `Scrypt: parameters too large, ${h} (128 * r * (N + p)) > ${l} (maxmem)`
      );
    const g = uv(Sp, t, e, {c: 1, dkLen: d * o}),
      m = $d(g),
      y = $d(new Uint8Array(d * i)),
      p = $d(new Uint8Array(d));
    let b = () => {};
    if (u) {
      const v = 2 * i * o,
        x = Math.max(Math.floor(v / 1e4), 1);
      let C = 0;
      b = () => {
        (C++, u && (!(C % x) || C === v) && u(C / v));
      };
    }
    return {
      N: i,
      r: s,
      p: o,
      dkLen: a,
      blockSize32: f,
      V: y,
      B32: m,
      B: g,
      tmp: p,
      blockMixCb: b,
      asyncTick: c
    };
  }
  function hO(t, e, n, r, i) {
    const s = uv(Sp, t, n, {c: 1, dkLen: e});
    return (n.fill(0), r.fill(0), i.fill(0), s);
  }
  function pO(t, e, n) {
    const {
      N: r,
      r: i,
      p: s,
      dkLen: o,
      blockSize32: a,
      V: c,
      B32: l,
      B: u,
      tmp: d,
      blockMixCb: f
    } = fO(t, e, n);
    jf || Uf(l);
    for (let h = 0; h < s; h++) {
      const g = a * h;
      for (let m = 0; m < a; m++) c[m] = l[g + m];
      for (let m = 0, y = 0; m < r - 1; m++) (gm(c, y, c, (y += a), i), f());
      (gm(c, (r - 1) * a, l, g, i), f());
      for (let m = 0; m < r; m++) {
        const y = l[g + a - 16] % r;
        for (let p = 0; p < a; p++) d[p] = l[g + p] ^ c[y * a + p];
        (gm(d, 0, l, g, i), f());
      }
    }
    return (jf || Uf(l), hO(t, o, u, c, d));
  }
  function aS(t, e, n, r, i, s, o) {
    return (
      qf(t),
      qf(e),
      pO(t, e, {N: n, r: i, p: r, dkLen: s, onProgress: o})
    );
  }
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const cS =
      BigInt(0),
    xp = BigInt(1),
    mO = BigInt(2);
  function Xo(t) {
    return (
      t instanceof Uint8Array ||
      (t != null && typeof t == 'object' && t.constructor.name === 'Uint8Array')
    );
  }
  function Bu(t) {
    if (!Xo(t)) throw new Error('Uint8Array expected');
  }
  const gO = Array.from({length: 256}, (t, e) =>
    e.toString(16).padStart(2, '0')
  );
  function pc(t) {
    Bu(t);
    let e = '';
    for (let n = 0; n < t.length; n++) e += gO[t[n]];
    return e;
  }
  function lS(t) {
    const e = t.toString(16);
    return e.length & 1 ? `0${e}` : e;
  }
  function dv(t) {
    if (typeof t != 'string')
      throw new Error('hex string expected, got ' + typeof t);
    return BigInt(t === '' ? '0' : `0x${t}`);
  }
  const Ii = {_0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102};
  function iw(t) {
    if (t >= Ii._0 && t <= Ii._9) return t - Ii._0;
    if (t >= Ii._A && t <= Ii._F) return t - (Ii._A - 10);
    if (t >= Ii._a && t <= Ii._f) return t - (Ii._a - 10);
  }
  function mc(t) {
    if (typeof t != 'string')
      throw new Error('hex string expected, got ' + typeof t);
    const e = t.length,
      n = e / 2;
    if (e % 2)
      throw new Error(
        'padded hex string expected, got unpadded hex of length ' + e
      );
    const r = new Uint8Array(n);
    for (let i = 0, s = 0; i < n; i++, s += 2) {
      const o = iw(t.charCodeAt(s)),
        a = iw(t.charCodeAt(s + 1));
      if (o === void 0 || a === void 0) {
        const c = t[s] + t[s + 1];
        throw new Error(
          'hex string expected, got non-hex character "' + c + '" at index ' + s
        );
      }
      r[i] = o * 16 + a;
    }
    return r;
  }
  function $o(t) {
    return dv(pc(t));
  }
  function fv(t) {
    return (Bu(t), dv(pc(Uint8Array.from(t).reverse())));
  }
  function gc(t, e) {
    return mc(t.toString(16).padStart(e * 2, '0'));
  }
  function hv(t, e) {
    return gc(t, e).reverse();
  }
  function yO(t) {
    return mc(lS(t));
  }
  function Tr(t, e, n) {
    let r;
    if (typeof e == 'string')
      try {
        r = mc(e);
      } catch (s) {
        throw new Error(
          `${t} must be valid hex string, got "${e}". Cause: ${s}`
        );
      }
    else if (Xo(e)) r = Uint8Array.from(e);
    else throw new Error(`${t} must be hex string or Uint8Array`);
    const i = r.length;
    if (typeof n == 'number' && i !== n)
      throw new Error(`${t} expected ${n} bytes, got ${i}`);
    return r;
  }
  function nu(...t) {
    let e = 0;
    for (let r = 0; r < t.length; r++) {
      const i = t[r];
      (Bu(i), (e += i.length));
    }
    const n = new Uint8Array(e);
    for (let r = 0, i = 0; r < t.length; r++) {
      const s = t[r];
      (n.set(s, i), (i += s.length));
    }
    return n;
  }
  function vO(t, e) {
    if (t.length !== e.length) return !1;
    let n = 0;
    for (let r = 0; r < t.length; r++) n |= t[r] ^ e[r];
    return n === 0;
  }
  function bO(t) {
    if (typeof t != 'string')
      throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
    return new Uint8Array(new TextEncoder().encode(t));
  }
  function wO(t) {
    let e;
    for (e = 0; t > cS; t >>= xp, e += 1);
    return e;
  }
  function _O(t, e) {
    return (t >> BigInt(e)) & xp;
  }
  function EO(t, e, n) {
    return t | ((n ? xp : cS) << BigInt(e));
  }
  const pv = (t) => (mO << BigInt(t - 1)) - xp,
    ym = (t) => new Uint8Array(t),
    sw = (t) => Uint8Array.from(t);
  function uS(t, e, n) {
    if (typeof t != 'number' || t < 2)
      throw new Error('hashLen must be a number');
    if (typeof e != 'number' || e < 2)
      throw new Error('qByteLen must be a number');
    if (typeof n != 'function') throw new Error('hmacFn must be a function');
    let r = ym(t),
      i = ym(t),
      s = 0;
    const o = () => {
        (r.fill(1), i.fill(0), (s = 0));
      },
      a = (...d) => n(i, r, ...d),
      c = (d = ym()) => {
        ((i = a(sw([0]), d)),
          (r = a()),
          d.length !== 0 && ((i = a(sw([1]), d)), (r = a())));
      },
      l = () => {
        if (s++ >= 1e3) throw new Error('drbg: tried 1000 values');
        let d = 0;
        const f = [];
        for (; d < e; ) {
          r = a();
          const h = r.slice();
          (f.push(h), (d += r.length));
        }
        return nu(...f);
      };
    return (d, f) => {
      (o(), c(d));
      let h;
      for (; !(h = f(l())); ) c();
      return (o(), h);
    };
  }
  const AO = {
    bigint: (t) => typeof t == 'bigint',
    function: (t) => typeof t == 'function',
    boolean: (t) => typeof t == 'boolean',
    string: (t) => typeof t == 'string',
    stringOrUint8Array: (t) => typeof t == 'string' || Xo(t),
    isSafeInteger: (t) => Number.isSafeInteger(t),
    array: (t) => Array.isArray(t),
    field: (t, e) => e.Fp.isValid(t),
    hash: (t) => typeof t == 'function' && Number.isSafeInteger(t.outputLen)
  };
  function Du(t, e, n = {}) {
    const r = (i, s, o) => {
      const a = AO[s];
      if (typeof a != 'function')
        throw new Error(`Invalid validator "${s}", expected function`);
      const c = t[i];
      if (!(o && c === void 0) && !a(c, t))
        throw new Error(
          `Invalid param ${String(i)}=${c} (${typeof c}), expected ${s}`
        );
    };
    for (const [i, s] of Object.entries(e)) r(i, s, !1);
    for (const [i, s] of Object.entries(n)) r(i, s, !0);
    return t;
  }
  const SO = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        abytes: Bu,
        bitGet: _O,
        bitLen: wO,
        bitMask: pv,
        bitSet: EO,
        bytesToHex: pc,
        bytesToNumberBE: $o,
        bytesToNumberLE: fv,
        concatBytes: nu,
        createHmacDrbg: uS,
        ensureBytes: Tr,
        equalBytes: vO,
        hexToBytes: mc,
        hexToNumber: dv,
        isBytes: Xo,
        numberToBytesBE: gc,
        numberToBytesLE: hv,
        numberToHexUnpadded: lS,
        numberToVarBytesBE: yO,
        utf8ToBytes: bO,
        validateObject: Du
      },
      Symbol.toStringTag,
      {value: 'Module'}
    )
  );
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Vt =
      BigInt(0),
    Rt = BigInt(1),
    So = BigInt(2),
    xO = BigInt(3),
    tg = BigInt(4),
    ow = BigInt(5),
    aw = BigInt(8);
  BigInt(9);
  BigInt(16);
  function Fn(t, e) {
    const n = t % e;
    return n >= Vt ? n : e + n;
  }
  function CO(t, e, n) {
    if (n <= Vt || e < Vt) throw new Error('Expected power/modulo > 0');
    if (n === Rt) return Vt;
    let r = Rt;
    for (; e > Vt; )
      (e & Rt && (r = (r * t) % n), (t = (t * t) % n), (e >>= Rt));
    return r;
  }
  function ar(t, e, n) {
    let r = t;
    for (; e-- > Vt; ) ((r *= r), (r %= n));
    return r;
  }
  function ng(t, e) {
    if (t === Vt || e <= Vt)
      throw new Error(
        `invert: expected positive integers, got n=${t} mod=${e}`
      );
    let n = Fn(t, e),
      r = e,
      i = Vt,
      s = Rt;
    for (; n !== Vt; ) {
      const a = r / n,
        c = r % n,
        l = i - s * a;
      ((r = n), (n = c), (i = s), (s = l));
    }
    if (r !== Rt) throw new Error('invert: does not exist');
    return Fn(i, e);
  }
  function TO(t) {
    const e = (t - Rt) / So;
    let n, r, i;
    for (n = t - Rt, r = 0; n % So === Vt; n /= So, r++);
    for (i = So; i < t && CO(i, e, t) !== t - Rt; i++);
    if (r === 1) {
      const o = (t + Rt) / tg;
      return function (c, l) {
        const u = c.pow(l, o);
        if (!c.eql(c.sqr(u), l)) throw new Error('Cannot find square root');
        return u;
      };
    }
    const s = (n + Rt) / So;
    return function (a, c) {
      if (a.pow(c, e) === a.neg(a.ONE))
        throw new Error('Cannot find square root');
      let l = r,
        u = a.pow(a.mul(a.ONE, i), n),
        d = a.pow(c, s),
        f = a.pow(c, n);
      for (; !a.eql(f, a.ONE); ) {
        if (a.eql(f, a.ZERO)) return a.ZERO;
        let h = 1;
        for (let m = a.sqr(f); h < l && !a.eql(m, a.ONE); h++) m = a.sqr(m);
        const g = a.pow(u, Rt << BigInt(l - h - 1));
        ((u = a.sqr(g)), (d = a.mul(d, g)), (f = a.mul(f, u)), (l = h));
      }
      return d;
    };
  }
  function IO(t) {
    if (t % tg === xO) {
      const e = (t + Rt) / tg;
      return function (r, i) {
        const s = r.pow(i, e);
        if (!r.eql(r.sqr(s), i)) throw new Error('Cannot find square root');
        return s;
      };
    }
    if (t % aw === ow) {
      const e = (t - ow) / aw;
      return function (r, i) {
        const s = r.mul(i, So),
          o = r.pow(s, e),
          a = r.mul(i, o),
          c = r.mul(r.mul(a, So), o),
          l = r.mul(a, r.sub(c, r.ONE));
        if (!r.eql(r.sqr(l), i)) throw new Error('Cannot find square root');
        return l;
      };
    }
    return TO(t);
  }
  const kO = [
    'create',
    'isValid',
    'is0',
    'neg',
    'inv',
    'sqrt',
    'sqr',
    'eql',
    'add',
    'sub',
    'mul',
    'pow',
    'div',
    'addN',
    'subN',
    'mulN',
    'sqrN'
  ];
  function RO(t) {
    const e = {
        ORDER: 'bigint',
        MASK: 'bigint',
        BYTES: 'isSafeInteger',
        BITS: 'isSafeInteger'
      },
      n = kO.reduce((r, i) => ((r[i] = 'function'), r), e);
    return Du(t, n);
  }
  function PO(t, e, n) {
    if (n < Vt) throw new Error('Expected power > 0');
    if (n === Vt) return t.ONE;
    if (n === Rt) return e;
    let r = t.ONE,
      i = e;
    for (; n > Vt; ) (n & Rt && (r = t.mul(r, i)), (i = t.sqr(i)), (n >>= Rt));
    return r;
  }
  function MO(t, e) {
    const n = new Array(e.length),
      r = e.reduce(
        (s, o, a) => (t.is0(o) ? s : ((n[a] = s), t.mul(s, o))),
        t.ONE
      ),
      i = t.inv(r);
    return (
      e.reduceRight(
        (s, o, a) => (t.is0(o) ? s : ((n[a] = t.mul(s, n[a])), t.mul(s, o))),
        i
      ),
      n
    );
  }
  function dS(t, e) {
    const n = e !== void 0 ? e : t.toString(2).length,
      r = Math.ceil(n / 8);
    return {nBitLength: n, nByteLength: r};
  }
  function OO(t, e, n = !1, r = {}) {
    if (t <= Vt) throw new Error(`Expected Field ORDER > 0, got ${t}`);
    const {nBitLength: i, nByteLength: s} = dS(t, e);
    if (s > 2048)
      throw new Error('Field lengths over 2048 bytes are not supported');
    const o = IO(t),
      a = Object.freeze({
        ORDER: t,
        BITS: i,
        BYTES: s,
        MASK: pv(i),
        ZERO: Vt,
        ONE: Rt,
        create: (c) => Fn(c, t),
        isValid: (c) => {
          if (typeof c != 'bigint')
            throw new Error(
              `Invalid field element: expected bigint, got ${typeof c}`
            );
          return Vt <= c && c < t;
        },
        is0: (c) => c === Vt,
        isOdd: (c) => (c & Rt) === Rt,
        neg: (c) => Fn(-c, t),
        eql: (c, l) => c === l,
        sqr: (c) => Fn(c * c, t),
        add: (c, l) => Fn(c + l, t),
        sub: (c, l) => Fn(c - l, t),
        mul: (c, l) => Fn(c * l, t),
        pow: (c, l) => PO(a, c, l),
        div: (c, l) => Fn(c * ng(l, t), t),
        sqrN: (c) => c * c,
        addN: (c, l) => c + l,
        subN: (c, l) => c - l,
        mulN: (c, l) => c * l,
        inv: (c) => ng(c, t),
        sqrt: r.sqrt || ((c) => o(a, c)),
        invertBatch: (c) => MO(a, c),
        cmov: (c, l, u) => (u ? l : c),
        toBytes: (c) => (n ? hv(c, s) : gc(c, s)),
        fromBytes: (c) => {
          if (c.length !== s)
            throw new Error(`Fp.fromBytes: expected ${s}, got ${c.length}`);
          return n ? fv(c) : $o(c);
        }
      });
    return Object.freeze(a);
  }
  function fS(t) {
    if (typeof t != 'bigint') throw new Error('field order must be bigint');
    const e = t.toString(2).length;
    return Math.ceil(e / 8);
  }
  function hS(t) {
    const e = fS(t);
    return e + Math.ceil(e / 2);
  }
  function NO(t, e, n = !1) {
    const r = t.length,
      i = fS(e),
      s = hS(e);
    if (r < 16 || r < s || r > 1024)
      throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);
    const o = n ? $o(t) : fv(t),
      a = Fn(o, e - Rt) + Rt;
    return n ? hv(a, i) : gc(a, i);
  }
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const LO =
      BigInt(0),
    vm = BigInt(1);
  function BO(t, e) {
    const n = (i, s) => {
        const o = s.negate();
        return i ? o : s;
      },
      r = (i) => {
        const s = Math.ceil(e / i) + 1,
          o = 2 ** (i - 1);
        return {windows: s, windowSize: o};
      };
    return {
      constTimeNegate: n,
      unsafeLadder(i, s) {
        let o = t.ZERO,
          a = i;
        for (; s > LO; )
          (s & vm && (o = o.add(a)), (a = a.double()), (s >>= vm));
        return o;
      },
      precomputeWindow(i, s) {
        const {windows: o, windowSize: a} = r(s),
          c = [];
        let l = i,
          u = l;
        for (let d = 0; d < o; d++) {
          ((u = l), c.push(u));
          for (let f = 1; f < a; f++) ((u = u.add(l)), c.push(u));
          l = u.double();
        }
        return c;
      },
      wNAF(i, s, o) {
        const {windows: a, windowSize: c} = r(i);
        let l = t.ZERO,
          u = t.BASE;
        const d = BigInt(2 ** i - 1),
          f = 2 ** i,
          h = BigInt(i);
        for (let g = 0; g < a; g++) {
          const m = g * c;
          let y = Number(o & d);
          ((o >>= h), y > c && ((y -= f), (o += vm)));
          const p = m,
            b = m + Math.abs(y) - 1,
            v = g % 2 !== 0,
            x = y < 0;
          y === 0 ? (u = u.add(n(v, s[p]))) : (l = l.add(n(x, s[b])));
        }
        return {p: l, f: u};
      },
      wNAFCached(i, s, o, a) {
        const c = i._WINDOW_SIZE || 1;
        let l = s.get(i);
        return (
          l || ((l = this.precomputeWindow(i, c)), c !== 1 && s.set(i, a(l))),
          this.wNAF(c, l, o)
        );
      }
    };
  }
  function pS(t) {
    return (
      RO(t.Fp),
      Du(
        t,
        {n: 'bigint', h: 'bigint', Gx: 'field', Gy: 'field'},
        {nBitLength: 'isSafeInteger', nByteLength: 'isSafeInteger'}
      ),
      Object.freeze({...dS(t.n, t.nBitLength), ...t, p: t.Fp.ORDER})
    );
  }
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function DO(
    t
  ) {
    const e = pS(t);
    Du(
      e,
      {a: 'field', b: 'field'},
      {
        allowedPrivateKeyLengths: 'array',
        wrapPrivateKey: 'boolean',
        isTorsionFree: 'function',
        clearCofactor: 'function',
        allowInfinityPoint: 'boolean',
        fromBytes: 'function',
        toBytes: 'function'
      }
    );
    const {endo: n, Fp: r, a: i} = e;
    if (n) {
      if (!r.eql(i, r.ZERO))
        throw new Error(
          'Endomorphism can only be defined for Koblitz curves that have a=0'
        );
      if (
        typeof n != 'object' ||
        typeof n.beta != 'bigint' ||
        typeof n.splitScalar != 'function'
      )
        throw new Error(
          'Expected endomorphism with beta: bigint and splitScalar: function'
        );
    }
    return Object.freeze({...e});
  }
  const {bytesToNumberBE: FO, hexToBytes: $O} = SO,
    Co = {
      Err: class extends Error {
        constructor(e = '') {
          super(e);
        }
      },
      _parseInt(t) {
        const {Err: e} = Co;
        if (t.length < 2 || t[0] !== 2)
          throw new e('Invalid signature integer tag');
        const n = t[1],
          r = t.subarray(2, n + 2);
        if (!n || r.length !== n)
          throw new e('Invalid signature integer: wrong length');
        if (r[0] & 128) throw new e('Invalid signature integer: negative');
        if (r[0] === 0 && !(r[1] & 128))
          throw new e('Invalid signature integer: unnecessary leading zero');
        return {d: FO(r), l: t.subarray(n + 2)};
      },
      toSig(t) {
        const {Err: e} = Co,
          n = typeof t == 'string' ? $O(t) : t;
        Bu(n);
        let r = n.length;
        if (r < 2 || n[0] != 48) throw new e('Invalid signature tag');
        if (n[1] !== r - 2) throw new e('Invalid signature: incorrect length');
        const {d: i, l: s} = Co._parseInt(n.subarray(2)),
          {d: o, l: a} = Co._parseInt(s);
        if (a.length)
          throw new e('Invalid signature: left bytes after parsing');
        return {r: i, s: o};
      },
      hexFromSig(t) {
        const e = (l) => (Number.parseInt(l[0], 16) & 8 ? '00' + l : l),
          n = (l) => {
            const u = l.toString(16);
            return u.length & 1 ? `0${u}` : u;
          },
          r = e(n(t.s)),
          i = e(n(t.r)),
          s = r.length / 2,
          o = i.length / 2,
          a = n(s),
          c = n(o);
        return `30${n(o + s + 4)}02${c}${i}02${a}${r}`;
      }
    },
    Vi = BigInt(0),
    pr = BigInt(1);
  BigInt(2);
  const cw = BigInt(3);
  BigInt(4);
  function HO(t) {
    const e = DO(t),
      {Fp: n} = e,
      r =
        e.toBytes ||
        ((g, m, y) => {
          const p = m.toAffine();
          return nu(Uint8Array.from([4]), n.toBytes(p.x), n.toBytes(p.y));
        }),
      i =
        e.fromBytes ||
        ((g) => {
          const m = g.subarray(1),
            y = n.fromBytes(m.subarray(0, n.BYTES)),
            p = n.fromBytes(m.subarray(n.BYTES, 2 * n.BYTES));
          return {x: y, y: p};
        });
    function s(g) {
      const {a: m, b: y} = e,
        p = n.sqr(g),
        b = n.mul(p, g);
      return n.add(n.add(b, n.mul(g, m)), y);
    }
    if (!n.eql(n.sqr(e.Gy), s(e.Gx)))
      throw new Error('bad generator point: equation left != right');
    function o(g) {
      return typeof g == 'bigint' && Vi < g && g < e.n;
    }
    function a(g) {
      if (!o(g)) throw new Error('Expected valid bigint: 0 < bigint < curve.n');
    }
    function c(g) {
      const {
        allowedPrivateKeyLengths: m,
        nByteLength: y,
        wrapPrivateKey: p,
        n: b
      } = e;
      if (m && typeof g != 'bigint') {
        if (
          (Xo(g) && (g = pc(g)), typeof g != 'string' || !m.includes(g.length))
        )
          throw new Error('Invalid key');
        g = g.padStart(y * 2, '0');
      }
      let v;
      try {
        v = typeof g == 'bigint' ? g : $o(Tr('private key', g, y));
      } catch {
        throw new Error(
          `private key must be ${y} bytes, hex or bigint, not ${typeof g}`
        );
      }
      return (p && (v = Fn(v, b)), a(v), v);
    }
    const l = new Map();
    function u(g) {
      if (!(g instanceof d)) throw new Error('ProjectivePoint expected');
    }
    class d {
      constructor(m, y, p) {
        if (
          ((this.px = m),
          (this.py = y),
          (this.pz = p),
          m == null || !n.isValid(m))
        )
          throw new Error('x required');
        if (y == null || !n.isValid(y)) throw new Error('y required');
        if (p == null || !n.isValid(p)) throw new Error('z required');
      }
      static fromAffine(m) {
        const {x: y, y: p} = m || {};
        if (!m || !n.isValid(y) || !n.isValid(p))
          throw new Error('invalid affine point');
        if (m instanceof d) throw new Error('projective point not allowed');
        const b = (v) => n.eql(v, n.ZERO);
        return b(y) && b(p) ? d.ZERO : new d(y, p, n.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static normalizeZ(m) {
        const y = n.invertBatch(m.map((p) => p.pz));
        return m.map((p, b) => p.toAffine(y[b])).map(d.fromAffine);
      }
      static fromHex(m) {
        const y = d.fromAffine(i(Tr('pointHex', m)));
        return (y.assertValidity(), y);
      }
      static fromPrivateKey(m) {
        return d.BASE.multiply(c(m));
      }
      _setWindowSize(m) {
        ((this._WINDOW_SIZE = m), l.delete(this));
      }
      assertValidity() {
        if (this.is0()) {
          if (e.allowInfinityPoint && !n.is0(this.py)) return;
          throw new Error('bad point: ZERO');
        }
        const {x: m, y} = this.toAffine();
        if (!n.isValid(m) || !n.isValid(y))
          throw new Error('bad point: x or y not FE');
        const p = n.sqr(y),
          b = s(m);
        if (!n.eql(p, b)) throw new Error('bad point: equation left != right');
        if (!this.isTorsionFree())
          throw new Error('bad point: not in prime-order subgroup');
      }
      hasEvenY() {
        const {y: m} = this.toAffine();
        if (n.isOdd) return !n.isOdd(m);
        throw new Error("Field doesn't support isOdd");
      }
      equals(m) {
        u(m);
        const {px: y, py: p, pz: b} = this,
          {px: v, py: x, pz: C} = m,
          $ = n.eql(n.mul(y, C), n.mul(v, b)),
          G = n.eql(n.mul(p, C), n.mul(x, b));
        return $ && G;
      }
      negate() {
        return new d(this.px, n.neg(this.py), this.pz);
      }
      double() {
        const {a: m, b: y} = e,
          p = n.mul(y, cw),
          {px: b, py: v, pz: x} = this;
        let C = n.ZERO,
          $ = n.ZERO,
          G = n.ZERO,
          L = n.mul(b, b),
          F = n.mul(v, v),
          k = n.mul(x, x),
          V = n.mul(b, v);
        return (
          (V = n.add(V, V)),
          (G = n.mul(b, x)),
          (G = n.add(G, G)),
          (C = n.mul(m, G)),
          ($ = n.mul(p, k)),
          ($ = n.add(C, $)),
          (C = n.sub(F, $)),
          ($ = n.add(F, $)),
          ($ = n.mul(C, $)),
          (C = n.mul(V, C)),
          (G = n.mul(p, G)),
          (k = n.mul(m, k)),
          (V = n.sub(L, k)),
          (V = n.mul(m, V)),
          (V = n.add(V, G)),
          (G = n.add(L, L)),
          (L = n.add(G, L)),
          (L = n.add(L, k)),
          (L = n.mul(L, V)),
          ($ = n.add($, L)),
          (k = n.mul(v, x)),
          (k = n.add(k, k)),
          (L = n.mul(k, V)),
          (C = n.sub(C, L)),
          (G = n.mul(k, F)),
          (G = n.add(G, G)),
          (G = n.add(G, G)),
          new d(C, $, G)
        );
      }
      add(m) {
        u(m);
        const {px: y, py: p, pz: b} = this,
          {px: v, py: x, pz: C} = m;
        let $ = n.ZERO,
          G = n.ZERO,
          L = n.ZERO;
        const F = e.a,
          k = n.mul(e.b, cw);
        let V = n.mul(y, v),
          K = n.mul(p, x),
          B = n.mul(b, C),
          D = n.add(y, p),
          E = n.add(v, x);
        ((D = n.mul(D, E)),
          (E = n.add(V, K)),
          (D = n.sub(D, E)),
          (E = n.add(y, b)));
        let P = n.add(v, C);
        return (
          (E = n.mul(E, P)),
          (P = n.add(V, B)),
          (E = n.sub(E, P)),
          (P = n.add(p, b)),
          ($ = n.add(x, C)),
          (P = n.mul(P, $)),
          ($ = n.add(K, B)),
          (P = n.sub(P, $)),
          (L = n.mul(F, E)),
          ($ = n.mul(k, B)),
          (L = n.add($, L)),
          ($ = n.sub(K, L)),
          (L = n.add(K, L)),
          (G = n.mul($, L)),
          (K = n.add(V, V)),
          (K = n.add(K, V)),
          (B = n.mul(F, B)),
          (E = n.mul(k, E)),
          (K = n.add(K, B)),
          (B = n.sub(V, B)),
          (B = n.mul(F, B)),
          (E = n.add(E, B)),
          (V = n.mul(K, E)),
          (G = n.add(G, V)),
          (V = n.mul(P, E)),
          ($ = n.mul(D, $)),
          ($ = n.sub($, V)),
          (V = n.mul(D, K)),
          (L = n.mul(P, L)),
          (L = n.add(L, V)),
          new d($, G, L)
        );
      }
      subtract(m) {
        return this.add(m.negate());
      }
      is0() {
        return this.equals(d.ZERO);
      }
      wNAF(m) {
        return h.wNAFCached(this, l, m, (y) => {
          const p = n.invertBatch(y.map((b) => b.pz));
          return y.map((b, v) => b.toAffine(p[v])).map(d.fromAffine);
        });
      }
      multiplyUnsafe(m) {
        const y = d.ZERO;
        if (m === Vi) return y;
        if ((a(m), m === pr)) return this;
        const {endo: p} = e;
        if (!p) return h.unsafeLadder(this, m);
        let {k1neg: b, k1: v, k2neg: x, k2: C} = p.splitScalar(m),
          $ = y,
          G = y,
          L = this;
        for (; v > Vi || C > Vi; )
          (v & pr && ($ = $.add(L)),
            C & pr && (G = G.add(L)),
            (L = L.double()),
            (v >>= pr),
            (C >>= pr));
        return (
          b && ($ = $.negate()),
          x && (G = G.negate()),
          (G = new d(n.mul(G.px, p.beta), G.py, G.pz)),
          $.add(G)
        );
      }
      multiply(m) {
        a(m);
        let y = m,
          p,
          b;
        const {endo: v} = e;
        if (v) {
          const {k1neg: x, k1: C, k2neg: $, k2: G} = v.splitScalar(y);
          let {p: L, f: F} = this.wNAF(C),
            {p: k, f: V} = this.wNAF(G);
          ((L = h.constTimeNegate(x, L)),
            (k = h.constTimeNegate($, k)),
            (k = new d(n.mul(k.px, v.beta), k.py, k.pz)),
            (p = L.add(k)),
            (b = F.add(V)));
        } else {
          const {p: x, f: C} = this.wNAF(y);
          ((p = x), (b = C));
        }
        return d.normalizeZ([p, b])[0];
      }
      multiplyAndAddUnsafe(m, y, p) {
        const b = d.BASE,
          v = (C, $) =>
            $ === Vi || $ === pr || !C.equals(b)
              ? C.multiplyUnsafe($)
              : C.multiply($),
          x = v(this, y).add(v(m, p));
        return x.is0() ? void 0 : x;
      }
      toAffine(m) {
        const {px: y, py: p, pz: b} = this,
          v = this.is0();
        m == null && (m = v ? n.ONE : n.inv(b));
        const x = n.mul(y, m),
          C = n.mul(p, m),
          $ = n.mul(b, m);
        if (v) return {x: n.ZERO, y: n.ZERO};
        if (!n.eql($, n.ONE)) throw new Error('invZ was invalid');
        return {x, y: C};
      }
      isTorsionFree() {
        const {h: m, isTorsionFree: y} = e;
        if (m === pr) return !0;
        if (y) return y(d, this);
        throw new Error(
          'isTorsionFree() has not been declared for the elliptic curve'
        );
      }
      clearCofactor() {
        const {h: m, clearCofactor: y} = e;
        return m === pr ? this : y ? y(d, this) : this.multiplyUnsafe(e.h);
      }
      toRawBytes(m = !0) {
        return (this.assertValidity(), r(d, this, m));
      }
      toHex(m = !0) {
        return pc(this.toRawBytes(m));
      }
    }
    ((d.BASE = new d(e.Gx, e.Gy, n.ONE)),
      (d.ZERO = new d(n.ZERO, n.ONE, n.ZERO)));
    const f = e.nBitLength,
      h = BO(d, e.endo ? Math.ceil(f / 2) : f);
    return {
      CURVE: e,
      ProjectivePoint: d,
      normPrivateKeyToScalar: c,
      weierstrassEquation: s,
      isWithinCurveOrder: o
    };
  }
  function jO(t) {
    const e = pS(t);
    return (
      Du(
        e,
        {hash: 'hash', hmac: 'function', randomBytes: 'function'},
        {bits2int: 'function', bits2int_modN: 'function', lowS: 'boolean'}
      ),
      Object.freeze({lowS: !0, ...e})
    );
  }
  function UO(t) {
    const e = jO(t),
      {Fp: n, n: r} = e,
      i = n.BYTES + 1,
      s = 2 * n.BYTES + 1;
    function o(E) {
      return Vi < E && E < n.ORDER;
    }
    function a(E) {
      return Fn(E, r);
    }
    function c(E) {
      return ng(E, r);
    }
    const {
        ProjectivePoint: l,
        normPrivateKeyToScalar: u,
        weierstrassEquation: d,
        isWithinCurveOrder: f
      } = HO({
        ...e,
        toBytes(E, P, U) {
          const w = P.toAffine(),
            A = n.toBytes(w.x),
            T = nu;
          return U
            ? T(Uint8Array.from([P.hasEvenY() ? 2 : 3]), A)
            : T(Uint8Array.from([4]), A, n.toBytes(w.y));
        },
        fromBytes(E) {
          const P = E.length,
            U = E[0],
            w = E.subarray(1);
          if (P === i && (U === 2 || U === 3)) {
            const A = $o(w);
            if (!o(A)) throw new Error('Point is not on curve');
            const T = d(A);
            let R;
            try {
              R = n.sqrt(T);
            } catch (I) {
              const O = I instanceof Error ? ': ' + I.message : '';
              throw new Error('Point is not on curve' + O);
            }
            const _ = (R & pr) === pr;
            return (((U & 1) === 1) !== _ && (R = n.neg(R)), {x: A, y: R});
          } else if (P === s && U === 4) {
            const A = n.fromBytes(w.subarray(0, n.BYTES)),
              T = n.fromBytes(w.subarray(n.BYTES, 2 * n.BYTES));
            return {x: A, y: T};
          } else
            throw new Error(
              `Point of length ${P} was invalid. Expected ${i} compressed bytes or ${s} uncompressed bytes`
            );
        }
      }),
      h = (E) => pc(gc(E, e.nByteLength));
    function g(E) {
      const P = r >> pr;
      return E > P;
    }
    function m(E) {
      return g(E) ? a(-E) : E;
    }
    const y = (E, P, U) => $o(E.slice(P, U));
    class p {
      constructor(P, U, w) {
        ((this.r = P),
          (this.s = U),
          (this.recovery = w),
          this.assertValidity());
      }
      static fromCompact(P) {
        const U = e.nByteLength;
        return (
          (P = Tr('compactSignature', P, U * 2)),
          new p(y(P, 0, U), y(P, U, 2 * U))
        );
      }
      static fromDER(P) {
        const {r: U, s: w} = Co.toSig(Tr('DER', P));
        return new p(U, w);
      }
      assertValidity() {
        if (!f(this.r)) throw new Error('r must be 0 < r < CURVE.n');
        if (!f(this.s)) throw new Error('s must be 0 < s < CURVE.n');
      }
      addRecoveryBit(P) {
        return new p(this.r, this.s, P);
      }
      recoverPublicKey(P) {
        const {r: U, s: w, recovery: A} = this,
          T = G(Tr('msgHash', P));
        if (A == null || ![0, 1, 2, 3].includes(A))
          throw new Error('recovery id invalid');
        const R = A === 2 || A === 3 ? U + e.n : U;
        if (R >= n.ORDER) throw new Error('recovery id 2 or 3 invalid');
        const _ = (A & 1) === 0 ? '02' : '03',
          S = l.fromHex(_ + h(R)),
          I = c(R),
          O = a(-T * I),
          H = a(w * I),
          M = l.BASE.multiplyAndAddUnsafe(S, O, H);
        if (!M) throw new Error('point at infinify');
        return (M.assertValidity(), M);
      }
      hasHighS() {
        return g(this.s);
      }
      normalizeS() {
        return this.hasHighS()
          ? new p(this.r, a(-this.s), this.recovery)
          : this;
      }
      toDERRawBytes() {
        return mc(this.toDERHex());
      }
      toDERHex() {
        return Co.hexFromSig({r: this.r, s: this.s});
      }
      toCompactRawBytes() {
        return mc(this.toCompactHex());
      }
      toCompactHex() {
        return h(this.r) + h(this.s);
      }
    }
    const b = {
      isValidPrivateKey(E) {
        try {
          return (u(E), !0);
        } catch {
          return !1;
        }
      },
      normPrivateKeyToScalar: u,
      randomPrivateKey: () => {
        const E = hS(e.n);
        return NO(e.randomBytes(E), e.n);
      },
      precompute(E = 8, P = l.BASE) {
        return (P._setWindowSize(E), P.multiply(BigInt(3)), P);
      }
    };
    function v(E, P = !0) {
      return l.fromPrivateKey(E).toRawBytes(P);
    }
    function x(E) {
      const P = Xo(E),
        U = typeof E == 'string',
        w = (P || U) && E.length;
      return P
        ? w === i || w === s
        : U
          ? w === 2 * i || w === 2 * s
          : E instanceof l;
    }
    function C(E, P, U = !0) {
      if (x(E)) throw new Error('first arg must be private key');
      if (!x(P)) throw new Error('second arg must be public key');
      return l.fromHex(P).multiply(u(E)).toRawBytes(U);
    }
    const $ =
        e.bits2int ||
        function (E) {
          const P = $o(E),
            U = E.length * 8 - e.nBitLength;
          return U > 0 ? P >> BigInt(U) : P;
        },
      G =
        e.bits2int_modN ||
        function (E) {
          return a($(E));
        },
      L = pv(e.nBitLength);
    function F(E) {
      if (typeof E != 'bigint') throw new Error('bigint expected');
      if (!(Vi <= E && E < L))
        throw new Error(`bigint expected < 2^${e.nBitLength}`);
      return gc(E, e.nByteLength);
    }
    function k(E, P, U = V) {
      if (['recovered', 'canonical'].some((z) => z in U))
        throw new Error('sign() legacy options not supported');
      const {hash: w, randomBytes: A} = e;
      let {lowS: T, prehash: R, extraEntropy: _} = U;
      (T == null && (T = !0),
        (E = Tr('msgHash', E)),
        R && (E = Tr('prehashed msgHash', w(E))));
      const S = G(E),
        I = u(P),
        O = [F(I), F(S)];
      if (_ != null && _ !== !1) {
        const z = _ === !0 ? A(n.BYTES) : _;
        O.push(Tr('extraEntropy', z));
      }
      const H = nu(...O),
        M = S;
      function q(z) {
        const Z = $(z);
        if (!f(Z)) return;
        const X = c(Z),
          N = l.BASE.multiply(Z).toAffine(),
          j = a(N.x);
        if (j === Vi) return;
        const W = a(X * a(M + j * I));
        if (W === Vi) return;
        let J = (N.x === j ? 0 : 2) | Number(N.y & pr),
          Q = W;
        return (T && g(W) && ((Q = m(W)), (J ^= 1)), new p(j, Q, J));
      }
      return {seed: H, k2sig: q};
    }
    const V = {lowS: e.lowS, prehash: !1},
      K = {lowS: e.lowS, prehash: !1};
    function B(E, P, U = V) {
      const {seed: w, k2sig: A} = k(E, P, U),
        T = e;
      return uS(T.hash.outputLen, T.nByteLength, T.hmac)(w, A);
    }
    l.BASE._setWindowSize(8);
    function D(E, P, U, w = K) {
      var N;
      const A = E;
      if (((P = Tr('msgHash', P)), (U = Tr('publicKey', U)), 'strict' in w))
        throw new Error('options.strict was renamed to lowS');
      const {lowS: T, prehash: R} = w;
      let _, S;
      try {
        if (typeof A == 'string' || Xo(A))
          try {
            _ = p.fromDER(A);
          } catch (j) {
            if (!(j instanceof Co.Err)) throw j;
            _ = p.fromCompact(A);
          }
        else if (
          typeof A == 'object' &&
          typeof A.r == 'bigint' &&
          typeof A.s == 'bigint'
        ) {
          const {r: j, s: W} = A;
          _ = new p(j, W);
        } else throw new Error('PARSE');
        S = l.fromHex(U);
      } catch (j) {
        if (j.message === 'PARSE')
          throw new Error(
            'signature must be Signature instance, Uint8Array or hex string'
          );
        return !1;
      }
      if (T && _.hasHighS()) return !1;
      R && (P = e.hash(P));
      const {r: I, s: O} = _,
        H = G(P),
        M = c(O),
        q = a(H * M),
        z = a(I * M),
        Z =
          (N = l.BASE.multiplyAndAddUnsafe(S, q, z)) == null
            ? void 0
            : N.toAffine();
      return Z ? a(Z.x) === I : !1;
    }
    return {
      CURVE: e,
      getPublicKey: v,
      getSharedSecret: C,
      sign: B,
      verify: D,
      ProjectivePoint: l,
      Signature: p,
      utils: b
    };
  }
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function KO(
    t
  ) {
    return {hash: t, hmac: (e, ...n) => lv(t, e, Kf(...n)), randomBytes: c3};
  }
  function qO(t, e) {
    const n = (r) => UO({...t, ...KO(r)});
    return Object.freeze({...n(e), create: n});
  }
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const mS =
      BigInt(
        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'
      ),
    lw = BigInt(
      '0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'
    ),
    VO = BigInt(1),
    rg = BigInt(2),
    uw = (t, e) => (t + e / rg) / e;
  function GO(t) {
    const e = mS,
      n = BigInt(3),
      r = BigInt(6),
      i = BigInt(11),
      s = BigInt(22),
      o = BigInt(23),
      a = BigInt(44),
      c = BigInt(88),
      l = (t * t * t) % e,
      u = (l * l * t) % e,
      d = (ar(u, n, e) * u) % e,
      f = (ar(d, n, e) * u) % e,
      h = (ar(f, rg, e) * l) % e,
      g = (ar(h, i, e) * h) % e,
      m = (ar(g, s, e) * g) % e,
      y = (ar(m, a, e) * m) % e,
      p = (ar(y, c, e) * y) % e,
      b = (ar(p, a, e) * m) % e,
      v = (ar(b, n, e) * u) % e,
      x = (ar(v, o, e) * g) % e,
      C = (ar(x, r, e) * l) % e,
      $ = ar(C, rg, e);
    if (!ig.eql(ig.sqr($), t)) throw new Error('Cannot find square root');
    return $;
  }
  const ig = OO(mS, void 0, void 0, {sqrt: GO}),
    mv = qO(
      {
        a: BigInt(0),
        b: BigInt(7),
        Fp: ig,
        n: lw,
        Gx: BigInt(
          '55066263022277343669578718895168534326250603453777594175500187360389116729240'
        ),
        Gy: BigInt(
          '32670510020758816978083085130507043184471273380659243275938904335757337482424'
        ),
        h: BigInt(1),
        lowS: !0,
        endo: {
          beta: BigInt(
            '0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'
          ),
          splitScalar: (t) => {
            const e = lw,
              n = BigInt('0x3086d221a7d46bcde86c90e49284eb15'),
              r = -VO * BigInt('0xe4437ed6010e88286f547fa90abfe4c3'),
              i = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'),
              s = n,
              o = BigInt('0x100000000000000000000000000000000'),
              a = uw(s * t, e),
              c = uw(-r * t, e);
            let l = Fn(t - a * n - c * i, e),
              u = Fn(-a * r - c * s, e);
            const d = l > o,
              f = u > o;
            if ((d && (l = e - l), f && (u = e - u), l > o || u > o))
              throw new Error('splitScalar: Endomorphism failed, k=' + t);
            return {k1neg: d, k1: l, k2neg: f, k2: u};
          }
        }
      },
      Sp
    );
  BigInt(0);
  mv.ProjectivePoint;
  const zO = Object.freeze(
    Object.defineProperty(
      {__proto__: null, secp256k1: mv},
      Symbol.toStringTag,
      {value: 'Module'}
    )
  );
  var bm;
  const ls = (bm = mv) !== null && bm !== void 0 ? bm : zO,
    dw = BigInt('0xffffffffffffffff'),
    ru = BigInt(
      '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'
    ),
    WO = ls.CURVE.n,
    ZO = WO / BigInt(2),
    YO = {
      type: 'object',
      required: ['crypto', 'id', 'version', 'address'],
      properties: {
        crypto: {
          type: 'object',
          required: [
            'cipher',
            'ciphertext',
            'cipherparams',
            'kdf',
            'kdfparams',
            'mac'
          ],
          properties: {
            cipher: {type: 'string'},
            ciphertext: {type: 'string'},
            cipherparams: {type: 'object'},
            kdf: {type: 'string'},
            kdfparams: {type: 'object'},
            salt: {type: 'string'},
            mac: {type: 'string'}
          }
        },
        id: {type: 'string'},
        version: {type: 'number'},
        address: {type: 'string'}
      }
    };
  var oh;
  (function (t) {
    ((t[(t.Mainnet = 1)] = 'Mainnet'),
      (t[(t.Goerli = 5)] = 'Goerli'),
      (t[(t.Sepolia = 11155111)] = 'Sepolia'));
  })(oh || (oh = {}));
  var gt;
  (function (t) {
    ((t.Chainstart = 'chainstart'),
      (t.Homestead = 'homestead'),
      (t.Dao = 'dao'),
      (t.TangerineWhistle = 'tangerineWhistle'),
      (t.SpuriousDragon = 'spuriousDragon'),
      (t.Byzantium = 'byzantium'),
      (t.Constantinople = 'constantinople'),
      (t.Petersburg = 'petersburg'),
      (t.Istanbul = 'istanbul'),
      (t.MuirGlacier = 'muirGlacier'),
      (t.Berlin = 'berlin'),
      (t.London = 'london'),
      (t.ArrowGlacier = 'arrowGlacier'),
      (t.GrayGlacier = 'grayGlacier'),
      (t.MergeForkIdTransition = 'mergeForkIdTransition'),
      (t.Merge = 'merge'),
      (t.Shanghai = 'shanghai'),
      (t.ShardingForkDev = 'shardingFork'));
  })(gt || (gt = {}));
  var fw;
  (function (t) {
    ((t.ProofOfStake = 'pos'),
      (t.ProofOfWork = 'pow'),
      (t.ProofOfAuthority = 'poa'));
  })(fw || (fw = {}));
  var hw;
  (function (t) {
    ((t.Ethash = 'ethash'), (t.Clique = 'clique'), (t.Casper = 'casper'));
  })(hw || (hw = {}));
  var an;
  (function (t) {
    ((t.PolygonMainnet = 'polygon-mainnet'),
      (t.PolygonMumbai = 'polygon-mumbai'),
      (t.ArbitrumRinkebyTestnet = 'arbitrum-rinkeby-testnet'),
      (t.ArbitrumOne = 'arbitrum-one'),
      (t.xDaiChain = 'x-dai-chain'),
      (t.OptimisticKovan = 'optimistic-kovan'),
      (t.OptimisticEthereum = 'optimistic-ethereum'));
  })(an || (an = {}));
  var yr;
  (function (t) {
    ((t[(t.Number = 0)] = 'Number'),
      (t[(t.BigInt = 1)] = 'BigInt'),
      (t[(t.Uint8Array = 2)] = 'Uint8Array'),
      (t[(t.PrefixedHexString = 3)] = 'PrefixedHexString'));
  })(yr || (yr = {}));
  const gS = (t) => {
    if (typeof t != 'string')
      throw new Error(
        `[stripHexPrefix] input must be type 'string', received ${typeof t}`
      );
    return zy(t) ? t.slice(2) : t;
  };
  function QO(t) {
    return !t || t === '0x0'
      ? '0x0000000000000000'
      : zy(t)
        ? `0x${gS(t).padStart(16, '0')}`
        : `0x${t.padStart(16, '0')}`;
  }
  const yS = function (t) {
    if (!Number.isSafeInteger(t) || t < 0)
      throw new Error(`Received an invalid integer type: ${t}`);
    return `0x${t.toString(16)}`;
  };
  function JO(t, e = !0) {
    var n, r;
    const {
      name: i,
      config: s,
      difficulty: o,
      mixHash: a,
      gasLimit: c,
      coinbase: l,
      baseFeePerGas: u
    } = t;
    let {extraData: d, timestamp: f, nonce: h} = t;
    const g = Number(f),
      {chainId: m} = s;
    if (
      (d === '' && (d = '0x'),
      zy(f) || (f = yS(parseInt(f))),
      h.length !== 18 && (h = QO(h)),
      s.eip155Block !== s.eip158Block)
    )
      throw new Error(
        'EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork'
      );
    const y = {
        name: i,
        chainId: m,
        networkId: m,
        genesis: {
          timestamp: f,
          gasLimit: parseInt(c),
          difficulty: parseInt(o),
          nonce: h,
          extraData: d,
          mixHash: a,
          coinbase: l,
          baseFeePerGas: u
        },
        hardfork: void 0,
        hardforks: [],
        bootstrapNodes: [],
        consensus:
          s.clique !== void 0
            ? {
                type: 'poa',
                algorithm: 'clique',
                clique: {
                  period:
                    (n = s.clique.period) !== null && n !== void 0
                      ? n
                      : s.clique.blockperiodseconds,
                  epoch:
                    (r = s.clique.epoch) !== null && r !== void 0
                      ? r
                      : s.clique.epochlength
                }
              }
            : {type: 'pow', algorithm: 'ethash', ethash: {}}
      },
      p = {
        [gt.Homestead]: {name: 'homesteadBlock'},
        [gt.Dao]: {name: 'daoForkBlock'},
        [gt.TangerineWhistle]: {name: 'eip150Block'},
        [gt.SpuriousDragon]: {name: 'eip155Block'},
        [gt.Byzantium]: {name: 'byzantiumBlock'},
        [gt.Constantinople]: {name: 'constantinopleBlock'},
        [gt.Petersburg]: {name: 'petersburgBlock'},
        [gt.Istanbul]: {name: 'istanbulBlock'},
        [gt.MuirGlacier]: {name: 'muirGlacierBlock'},
        [gt.Berlin]: {name: 'berlinBlock'},
        [gt.London]: {name: 'londonBlock'},
        [gt.MergeForkIdTransition]: {name: 'mergeForkBlock', postMerge: e},
        [gt.Shanghai]: {name: 'shanghaiTime', postMerge: !0, isTimestamp: !0},
        [gt.ShardingForkDev]: {
          name: 'shardingForkTime',
          postMerge: !0,
          isTimestamp: !0
        }
      },
      b = Object.keys(p).reduce((C, $) => ((C[p[$].name] = $), C), {}),
      v = Object.keys(s).filter(
        (C) => b[C] !== void 0 && s[C] !== void 0 && s[C] !== null
      );
    if (
      ((y.hardforks = v
        .map((C) => ({
          name: b[C],
          block:
            p[b[C]].isTimestamp === !0 || typeof s[C] != 'number' ? null : s[C],
          timestamp:
            p[b[C]].isTimestamp === !0 && typeof s[C] == 'number'
              ? s[C]
              : void 0
        }))
        .filter((C) => C.block !== null || C.timestamp !== void 0)),
      y.hardforks.sort((C, $) => {
        var G, L;
        return (
          ((G = C.block) !== null && G !== void 0 ? G : 1 / 0) -
          ((L = $.block) !== null && L !== void 0 ? L : 1 / 0)
        );
      }),
      y.hardforks.sort((C, $) => {
        var G, L;
        return (
          ((G = C.timestamp) !== null && G !== void 0 ? G : g) -
          ((L = $.timestamp) !== null && L !== void 0 ? L : g)
        );
      }),
      s.terminalTotalDifficulty !== void 0)
    ) {
      const C = {name: gt.Merge, ttd: s.terminalTotalDifficulty, block: null},
        $ = y.hardforks.findIndex((G) => {
          var L;
          return (
            ((L = p[G.name]) === null || L === void 0
              ? void 0
              : L.postMerge) === !0
          );
        });
      $ !== -1 ? y.hardforks.splice($, 0, C) : y.hardforks.push(C);
    }
    const x = y.hardforks.length > 0 ? y.hardforks.slice(-1)[0] : void 0;
    return (
      (y.hardfork = x == null ? void 0 : x.name),
      y.hardforks.unshift({name: gt.Chainstart, block: 0}),
      y
    );
  }
  function XO(t, e, n) {
    try {
      if (['config', 'difficulty', 'gasLimit', 'alloc'].some((r) => !(r in t)))
        throw new Error('Invalid format, expected geth genesis fields missing');
      return (e !== void 0 && (t.name = e), JO(t, n));
    } catch (r) {
      throw new Error(`Error parsing parameters file: ${r.message}`);
    }
  }
  function vS(t) {
    let e = t;
    if (typeof e != 'string')
      throw new Error(
        `[padToEven] value must be type 'string', received ${typeof e}`
      );
    return (e.length % 2 && (e = `0${e}`), e);
  }
  const e7 = function (t) {
      const e = yS(t);
      return bt(`0x${vS(e.slice(2))}`);
    },
    _t = function (t) {
      var e;
      if (t == null) return new Uint8Array();
      if (t instanceof Uint8Array) return t;
      if (
        ((e = t == null ? void 0 : t.constructor) === null || e === void 0
          ? void 0
          : e.name) === 'Uint8Array' ||
        Array.isArray(t)
      )
        return Uint8Array.from(t);
      if (typeof t == 'string') {
        if (!C3(t))
          throw new Error(
            `Cannot convert string to Uint8Array. only supports 0x-prefixed hex strings and this string was given: ${t}`
          );
        return bt(vS(gS(t)));
      }
      if (typeof t == 'number') return _t($t(t));
      if (typeof t == 'bigint') {
        if (t < BigInt(0))
          throw new Error(
            `Cannot convert negative bigint to Uint8Array. Given: ${t}`
          );
        let n = t.toString(16);
        return (n.length % 2 && (n = `0${n}`), _t(`0x${n}`));
      }
      if (t.toArray) return Uint8Array.from(t.toArray());
      throw new Error('invalid type');
    };
  function mt(t) {
    const e = We(t);
    return BigInt(e === '0x' ? 0 : e);
  }
  function t7(t) {
    return _t(`0x${t.toString(16)}`);
  }
  const bS = function (t) {
      return new Uint8Array(t).fill(0);
    },
    n7 = function (t, e, n) {
      const r = bS(e);
      return t.length < e ? (r.set(t, e - t.length), r) : t.subarray(-e);
    };
  function gv(t) {
    if (!co(t)) {
      const e = `This method only supports Uint8Array but input was: ${t}`;
      throw new Error(e);
    }
  }
  const pw = function (t, e) {
    return (gv(t), n7(t, e));
  };
  function r7(t) {
    let e = t[0];
    for (; t.length > 0 && e.toString() === '0'; )
      ((t = t.slice(1)), (e = t[0]));
    return t;
  }
  const ah = function (t) {
      return (gv(t), r7(t));
    },
    Et = (t) => `0x${t.toString(16)}`;
  function Je(t) {
    return ah(t7(t));
  }
  function i7(t, e) {
    return t === BigInt(0) || t === BigInt(1)
      ? t
      : e === void 0
        ? t - BigInt(27)
        : t - (e * BigInt(2) + BigInt(35));
  }
  function s7(t) {
    return t === BigInt(0) || t === BigInt(1);
  }
  const yv = function (t, e, n, r, i) {
    const s = i7(e, i);
    if (!s7(s)) throw new Error('Invalid signature v value');
    return new ls.Signature(mt(n), mt(r))
      .addRecoveryBit(Number(s))
      .recoverPublicKey(t)
      .toRawBytes(!1)
      .slice(1);
  };
  function pa(t, e) {
    if (t === null) return null;
    if (t === void 0) return;
    if (typeof t == 'string' && !C3(t))
      throw new Error(
        `A string must be provided with a 0x-prefix, given: ${t}`
      );
    if (typeof t == 'number' && !Number.isSafeInteger(t))
      throw new Error(
        'The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)'
      );
    const n = _t(t);
    switch (e) {
      case yr.Uint8Array:
        return n;
      case yr.BigInt:
        return mt(n);
      case yr.Number: {
        const r = mt(n);
        if (r > BigInt(Number.MAX_SAFE_INTEGER))
          throw new Error(
            'The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)'
          );
        return Number(r);
      }
      case yr.PrefixedHexString:
        return We(n);
      default:
        throw new Error('unknown outputType');
    }
  }
  var Sr = {},
    mw;
  function o7() {
    if (mw) return Sr;
    ((mw = 1),
      Object.defineProperty(Sr, '__esModule', {value: !0}),
      (Sr.RLP = Sr.utils = Sr.decode = Sr.encode = void 0));
    function t(p) {
      if (Array.isArray(p)) {
        const v = [];
        let x = 0;
        for (let C = 0; C < p.length; C++) {
          const $ = t(p[C]);
          (v.push($), (x += $.length));
        }
        return u(r(x, 192), ...v);
      }
      const b = y(p);
      return b.length === 1 && b[0] < 128 ? b : u(r(b.length, 128), b);
    }
    Sr.encode = t;
    function e(p, b, v) {
      if (v > p.length)
        throw new Error(
          'invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds'
        );
      return p.slice(b, v);
    }
    function n(p) {
      if (p[0] === 0) throw new Error('invalid RLP: extra zeros');
      return c(a(p));
    }
    function r(p, b) {
      if (p < 56) return Uint8Array.from([p + b]);
      const v = f(p),
        x = v.length / 2,
        C = f(b + 55 + x);
      return Uint8Array.from(l(C + v));
    }
    function i(p, b = !1) {
      if (typeof p > 'u' || p === null || p.length === 0)
        return Uint8Array.from([]);
      const v = y(p),
        x = s(v);
      if (b) return x;
      if (x.remainder.length !== 0)
        throw new Error('invalid RLP: remainder must be zero');
      return x.data;
    }
    Sr.decode = i;
    function s(p) {
      let b, v, x, C, $;
      const G = [],
        L = p[0];
      if (L <= 127) return {data: p.slice(0, 1), remainder: p.slice(1)};
      if (L <= 183) {
        if (
          ((b = L - 127),
          L === 128 ? (x = Uint8Array.from([])) : (x = e(p, 1, b)),
          b === 2 && x[0] < 128)
        )
          throw new Error(
            'invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed'
          );
        return {data: x, remainder: p.slice(b)};
      } else if (L <= 191) {
        if (((v = L - 182), p.length - 1 < v))
          throw new Error('invalid RLP: not enough bytes for string length');
        if (((b = n(e(p, 1, v))), b <= 55))
          throw new Error(
            'invalid RLP: expected string length to be greater than 55'
          );
        return ((x = e(p, v, b + v)), {data: x, remainder: p.slice(b + v)});
      } else if (L <= 247) {
        for (b = L - 191, C = e(p, 1, b); C.length; )
          (($ = s(C)), G.push($.data), (C = $.remainder));
        return {data: G, remainder: p.slice(b)};
      } else {
        if (((v = L - 246), (b = n(e(p, 1, v))), b < 56))
          throw new Error('invalid RLP: encoded list too short');
        const F = v + b;
        if (F > p.length)
          throw new Error('invalid RLP: total length is larger than the data');
        for (C = e(p, v, F); C.length; )
          (($ = s(C)), G.push($.data), (C = $.remainder));
        return {data: G, remainder: p.slice(F)};
      }
    }
    const o = Array.from({length: 256}, (p, b) =>
      b.toString(16).padStart(2, '0')
    );
    function a(p) {
      let b = '';
      for (let v = 0; v < p.length; v++) b += o[p[v]];
      return b;
    }
    function c(p) {
      const b = Number.parseInt(p, 16);
      if (Number.isNaN(b)) throw new Error('Invalid byte sequence');
      return b;
    }
    function l(p) {
      if (typeof p != 'string')
        throw new TypeError('hexToBytes: expected string, got ' + typeof p);
      if (p.length % 2)
        throw new Error('hexToBytes: received invalid unpadded hex');
      const b = new Uint8Array(p.length / 2);
      for (let v = 0; v < b.length; v++) {
        const x = v * 2;
        b[v] = c(p.slice(x, x + 2));
      }
      return b;
    }
    function u(...p) {
      if (p.length === 1) return p[0];
      const b = p.reduce((x, C) => x + C.length, 0),
        v = new Uint8Array(b);
      for (let x = 0, C = 0; x < p.length; x++) {
        const $ = p[x];
        (v.set($, C), (C += $.length));
      }
      return v;
    }
    function d(p) {
      return new TextEncoder().encode(p);
    }
    function f(p) {
      if (p < 0)
        throw new Error('Invalid integer as argument, must be unsigned!');
      const b = p.toString(16);
      return b.length % 2 ? `0${b}` : b;
    }
    function h(p) {
      return p.length % 2 ? `0${p}` : p;
    }
    function g(p) {
      return p.length >= 2 && p[0] === '0' && p[1] === 'x';
    }
    function m(p) {
      return typeof p != 'string' ? p : g(p) ? p.slice(2) : p;
    }
    function y(p) {
      if (p instanceof Uint8Array) return p;
      if (typeof p == 'string') return g(p) ? l(h(m(p))) : d(p);
      if (typeof p == 'number' || typeof p == 'bigint')
        return p ? l(f(p)) : Uint8Array.from([]);
      if (p == null) return Uint8Array.from([]);
      throw new Error('toBytes: received unsupported type ' + typeof p);
    }
    return (
      (Sr.utils = {
        bytesToHex: a,
        concatBytes: u,
        hexToBytes: l,
        utf8ToBytes: d
      }),
      (Sr.RLP = {encode: t, decode: i}),
      Sr
    );
  }
  var vr = o7(),
    wm = {};
  /*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */ var gw;
  function a7() {
    return (
      gw ||
        ((gw = 1),
        (function (t) {
          (function (e) {
            e(typeof DO_NOT_EXPORT_CRC > 'u' ? t : {});
          })(function (e) {
            e.version = '1.2.2';
            function n() {
              for (var L = 0, F = new Array(256), k = 0; k != 256; ++k)
                ((L = k),
                  (L = L & 1 ? -306674912 ^ (L >>> 1) : L >>> 1),
                  (L = L & 1 ? -306674912 ^ (L >>> 1) : L >>> 1),
                  (L = L & 1 ? -306674912 ^ (L >>> 1) : L >>> 1),
                  (L = L & 1 ? -306674912 ^ (L >>> 1) : L >>> 1),
                  (L = L & 1 ? -306674912 ^ (L >>> 1) : L >>> 1),
                  (L = L & 1 ? -306674912 ^ (L >>> 1) : L >>> 1),
                  (L = L & 1 ? -306674912 ^ (L >>> 1) : L >>> 1),
                  (L = L & 1 ? -306674912 ^ (L >>> 1) : L >>> 1),
                  (F[k] = L));
              return typeof Int32Array < 'u' ? new Int32Array(F) : F;
            }
            var r = n();
            function i(L) {
              var F = 0,
                k = 0,
                V = 0,
                K =
                  typeof Int32Array < 'u'
                    ? new Int32Array(4096)
                    : new Array(4096);
              for (V = 0; V != 256; ++V) K[V] = L[V];
              for (V = 0; V != 256; ++V)
                for (k = L[V], F = 256 + V; F < 4096; F += 256)
                  k = K[F] = (k >>> 8) ^ L[k & 255];
              var B = [];
              for (V = 1; V != 16; ++V)
                B[V - 1] =
                  typeof Int32Array < 'u'
                    ? K.subarray(V * 256, V * 256 + 256)
                    : K.slice(V * 256, V * 256 + 256);
              return B;
            }
            var s = i(r),
              o = s[0],
              a = s[1],
              c = s[2],
              l = s[3],
              u = s[4],
              d = s[5],
              f = s[6],
              h = s[7],
              g = s[8],
              m = s[9],
              y = s[10],
              p = s[11],
              b = s[12],
              v = s[13],
              x = s[14];
            function C(L, F) {
              for (var k = F ^ -1, V = 0, K = L.length; V < K; )
                k = (k >>> 8) ^ r[(k ^ L.charCodeAt(V++)) & 255];
              return ~k;
            }
            function $(L, F) {
              for (var k = F ^ -1, V = L.length - 15, K = 0; K < V; )
                k =
                  x[L[K++] ^ (k & 255)] ^
                  v[L[K++] ^ ((k >> 8) & 255)] ^
                  b[L[K++] ^ ((k >> 16) & 255)] ^
                  p[L[K++] ^ (k >>> 24)] ^
                  y[L[K++]] ^
                  m[L[K++]] ^
                  g[L[K++]] ^
                  h[L[K++]] ^
                  f[L[K++]] ^
                  d[L[K++]] ^
                  u[L[K++]] ^
                  l[L[K++]] ^
                  c[L[K++]] ^
                  a[L[K++]] ^
                  o[L[K++]] ^
                  r[L[K++]];
              for (V += 15; K < V; ) k = (k >>> 8) ^ r[(k ^ L[K++]) & 255];
              return ~k;
            }
            function G(L, F) {
              for (var k = F ^ -1, V = 0, K = L.length, B = 0, D = 0; V < K; )
                ((B = L.charCodeAt(V++)),
                  B < 128
                    ? (k = (k >>> 8) ^ r[(k ^ B) & 255])
                    : B < 2048
                      ? ((k =
                          (k >>> 8) ^ r[(k ^ (192 | ((B >> 6) & 31))) & 255]),
                        (k = (k >>> 8) ^ r[(k ^ (128 | (B & 63))) & 255]))
                      : B >= 55296 && B < 57344
                        ? ((B = (B & 1023) + 64),
                          (D = L.charCodeAt(V++) & 1023),
                          (k =
                            (k >>> 8) ^ r[(k ^ (240 | ((B >> 8) & 7))) & 255]),
                          (k =
                            (k >>> 8) ^ r[(k ^ (128 | ((B >> 2) & 63))) & 255]),
                          (k =
                            (k >>> 8) ^
                            r[
                              (k ^ (128 | ((D >> 6) & 15) | ((B & 3) << 4))) &
                                255
                            ]),
                          (k = (k >>> 8) ^ r[(k ^ (128 | (D & 63))) & 255]))
                        : ((k =
                            (k >>> 8) ^
                            r[(k ^ (224 | ((B >> 12) & 15))) & 255]),
                          (k =
                            (k >>> 8) ^ r[(k ^ (128 | ((B >> 6) & 63))) & 255]),
                          (k = (k >>> 8) ^ r[(k ^ (128 | (B & 63))) & 255])));
              return ~k;
            }
            ((e.table = r), (e.bstr = C), (e.buf = $), (e.str = G));
          });
        })(wm)),
      wm
    );
  }
  var c7 = a7();
  const l7 = Ou(c7),
    u7 = {
      name: 'goerli',
      chainId: 5,
      networkId: 5,
      defaultHardfork: 'merge',
      consensus: {
        type: 'poa',
        algorithm: 'clique',
        clique: {period: 15, epoch: 3e4}
      },
      comment: 'Cross-client PoA test network',
      url: 'https://github.com/goerli/testnet',
      genesis: {
        timestamp: '0x5c51a607',
        gasLimit: 10485760,
        difficulty: 1,
        nonce: '0x0000000000000000',
        extraData:
          '0x22466c6578692069732061207468696e6722202d204166726900000000000000e0a2bd4258d2768837baa26a28fe71dc079f84c70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
      },
      hardforks: [
        {name: 'chainstart', block: 0, forkHash: '0xa3f5ab08'},
        {name: 'homestead', block: 0, forkHash: '0xa3f5ab08'},
        {name: 'tangerineWhistle', block: 0, forkHash: '0xa3f5ab08'},
        {name: 'spuriousDragon', block: 0, forkHash: '0xa3f5ab08'},
        {name: 'byzantium', block: 0, forkHash: '0xa3f5ab08'},
        {name: 'constantinople', block: 0, forkHash: '0xa3f5ab08'},
        {name: 'petersburg', block: 0, forkHash: '0xa3f5ab08'},
        {name: 'istanbul', block: 1561651, forkHash: '0xc25efa5c'},
        {name: 'berlin', block: 4460644, forkHash: '0x757a1c47'},
        {name: 'london', block: 5062605, forkHash: '0xb8c6299d'},
        {
          '//_comment':
            'The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://goerli.etherscan.io/block/7382818',
          name: 'merge',
          ttd: '10790000',
          block: 7382819,
          forkHash: '0xb8c6299d'
        },
        {name: 'mergeForkIdTransition', block: null, forkHash: null},
        {name: 'shanghai', block: null, forkHash: null}
      ],
      bootstrapNodes: [],
      dnsNetworks: [
        'enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.goerli.ethdisco.net'
      ]
    },
    d7 = {
      name: 'mainnet',
      chainId: 1,
      networkId: 1,
      defaultHardfork: 'merge',
      consensus: {type: 'pow', algorithm: 'ethash', ethash: {}},
      comment: 'The Ethereum main chain',
      url: 'https://ethstats.net/',
      genesis: {
        gasLimit: 5e3,
        difficulty: 17179869184,
        nonce: '0x0000000000000042',
        extraData:
          '0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa'
      },
      hardforks: [
        {name: 'chainstart', block: 0, forkHash: '0xfc64ec04'},
        {name: 'homestead', block: 115e4, forkHash: '0x97c2c34c'},
        {name: 'dao', block: 192e4, forkHash: '0x91d1f948'},
        {name: 'tangerineWhistle', block: 2463e3, forkHash: '0x7a64da13'},
        {name: 'spuriousDragon', block: 2675e3, forkHash: '0x3edd5b10'},
        {name: 'byzantium', block: 437e4, forkHash: '0xa00bc324'},
        {name: 'constantinople', block: 728e4, forkHash: '0x668db0af'},
        {name: 'petersburg', block: 728e4, forkHash: '0x668db0af'},
        {name: 'istanbul', block: 9069e3, forkHash: '0x879d6e30'},
        {name: 'muirGlacier', block: 92e5, forkHash: '0xe029e991'},
        {name: 'berlin', block: 12244e3, forkHash: '0x0eb440f6'},
        {name: 'london', block: 12965e3, forkHash: '0xb715077d'},
        {name: 'arrowGlacier', block: 13773e3, forkHash: '0x20c327fc'},
        {name: 'grayGlacier', block: 1505e4, forkHash: '0xf0afd0e3'},
        {
          '//_comment':
            'The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://etherscan.io/block/15537393',
          name: 'merge',
          ttd: '58750000000000000000000',
          block: 15537394,
          forkHash: '0xf0afd0e3'
        },
        {name: 'mergeForkIdTransition', block: null, forkHash: null},
        {name: 'shanghai', block: null, forkHash: null}
      ],
      bootstrapNodes: [],
      dnsNetworks: [
        'enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.mainnet.ethdisco.net'
      ]
    },
    f7 = {
      name: 'sepolia',
      chainId: 11155111,
      networkId: 11155111,
      defaultHardfork: 'merge',
      consensus: {type: 'pow', algorithm: 'ethash', ethash: {}},
      comment: 'PoW test network to replace Ropsten',
      url: 'https://github.com/ethereum/go-ethereum/pull/23730',
      genesis: {
        timestamp: '0x6159af19',
        gasLimit: 3e7,
        difficulty: 131072,
        nonce: '0x0000000000000000',
        extraData:
          '0x5365706f6c69612c20417468656e732c204174746963612c2047726565636521'
      },
      hardforks: [
        {name: 'chainstart', block: 0, forkHash: '0xfe3366e7'},
        {name: 'homestead', block: 0, forkHash: '0xfe3366e7'},
        {name: 'tangerineWhistle', block: 0, forkHash: '0xfe3366e7'},
        {name: 'spuriousDragon', block: 0, forkHash: '0xfe3366e7'},
        {name: 'byzantium', block: 0, forkHash: '0xfe3366e7'},
        {name: 'constantinople', block: 0, forkHash: '0xfe3366e7'},
        {name: 'petersburg', block: 0, forkHash: '0xfe3366e7'},
        {name: 'istanbul', block: 0, forkHash: '0xfe3366e7'},
        {name: 'muirGlacier', block: 0, forkHash: '0xfe3366e7'},
        {name: 'berlin', block: 0, forkHash: '0xfe3366e7'},
        {name: 'london', block: 0, forkHash: '0xfe3366e7'},
        {
          '//_comment':
            'The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://sepolia.etherscan.io/block/1450408',
          name: 'merge',
          ttd: '17000000000000000',
          block: 1450409,
          forkHash: '0xfe3366e7'
        },
        {name: 'mergeForkIdTransition', block: 1735371, forkHash: '0xb96cbd13'},
        {
          name: 'shanghai',
          block: null,
          timestamp: '1677557088',
          forkHash: '0xf7f9bc08'
        }
      ],
      bootstrapNodes: [],
      dnsNetworks: [
        'enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.sepolia.ethdisco.net'
      ]
    },
    h7 = {
      name: 'EIP-1153',
      number: 1153,
      comment: 'Transient Storage',
      url: 'https://eips.ethereum.org/EIPS/eip-1153',
      status: 'Review',
      minimumHardfork: 'chainstart',
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {
        tstore: {v: 100, d: 'Base fee of the TSTORE opcode'},
        tload: {v: 100, d: 'Base fee of the TLOAD opcode'}
      },
      vm: {},
      pow: {}
    },
    p7 = {
      name: 'EIP-1559',
      number: 1559,
      comment: 'Fee market change for ETH 1.0 chain',
      url: 'https://eips.ethereum.org/EIPS/eip-1559',
      status: 'Final',
      minimumHardfork: 'berlin',
      requiredEIPs: [2930],
      gasConfig: {
        baseFeeMaxChangeDenominator: {
          v: 8,
          d: 'Maximum base fee change denominator'
        },
        elasticityMultiplier: {v: 2, d: 'Maximum block gas target elasticity'},
        initialBaseFee: {v: 1e9, d: 'Initial base fee on first EIP1559 block'}
      },
      gasPrices: {},
      vm: {},
      pow: {}
    },
    m7 = {
      name: 'EIP-2315',
      number: 2315,
      comment: 'Simple subroutines for the EVM',
      url: 'https://eips.ethereum.org/EIPS/eip-2315',
      status: 'Draft',
      minimumHardfork: 'istanbul',
      gasConfig: {},
      gasPrices: {
        beginsub: {v: 2, d: 'Base fee of the BEGINSUB opcode'},
        returnsub: {v: 5, d: 'Base fee of the RETURNSUB opcode'},
        jumpsub: {v: 10, d: 'Base fee of the JUMPSUB opcode'}
      },
      vm: {},
      pow: {}
    },
    g7 = {
      name: 'EIP-2537',
      number: 2537,
      comment: 'BLS12-381 precompiles',
      url: 'https://eips.ethereum.org/EIPS/eip-2537',
      status: 'Draft',
      minimumHardfork: 'chainstart',
      gasConfig: {},
      gasPrices: {
        Bls12381G1AddGas: {
          v: 600,
          d: 'Gas cost of a single BLS12-381 G1 addition precompile-call'
        },
        Bls12381G1MulGas: {
          v: 12e3,
          d: 'Gas cost of a single BLS12-381 G1 multiplication precompile-call'
        },
        Bls12381G2AddGas: {
          v: 4500,
          d: 'Gas cost of a single BLS12-381 G2 addition precompile-call'
        },
        Bls12381G2MulGas: {
          v: 55e3,
          d: 'Gas cost of a single BLS12-381 G2 multiplication precompile-call'
        },
        Bls12381PairingBaseGas: {
          v: 115e3,
          d: 'Base gas cost of BLS12-381 pairing check'
        },
        Bls12381PairingPerPairGas: {
          v: 23e3,
          d: 'Per-pair gas cost of BLS12-381 pairing check'
        },
        Bls12381MapG1Gas: {
          v: 5500,
          d: 'Gas cost of BLS12-381 map field element to G1'
        },
        Bls12381MapG2Gas: {
          v: 11e4,
          d: 'Gas cost of BLS12-381 map field element to G2'
        },
        Bls12381MultiExpGasDiscount: {
          v: [
            [1, 1200],
            [2, 888],
            [3, 764],
            [4, 641],
            [5, 594],
            [6, 547],
            [7, 500],
            [8, 453],
            [9, 438],
            [10, 423],
            [11, 408],
            [12, 394],
            [13, 379],
            [14, 364],
            [15, 349],
            [16, 334],
            [17, 330],
            [18, 326],
            [19, 322],
            [20, 318],
            [21, 314],
            [22, 310],
            [23, 306],
            [24, 302],
            [25, 298],
            [26, 294],
            [27, 289],
            [28, 285],
            [29, 281],
            [30, 277],
            [31, 273],
            [32, 269],
            [33, 268],
            [34, 266],
            [35, 265],
            [36, 263],
            [37, 262],
            [38, 260],
            [39, 259],
            [40, 257],
            [41, 256],
            [42, 254],
            [43, 253],
            [44, 251],
            [45, 250],
            [46, 248],
            [47, 247],
            [48, 245],
            [49, 244],
            [50, 242],
            [51, 241],
            [52, 239],
            [53, 238],
            [54, 236],
            [55, 235],
            [56, 233],
            [57, 232],
            [58, 231],
            [59, 229],
            [60, 228],
            [61, 226],
            [62, 225],
            [63, 223],
            [64, 222],
            [65, 221],
            [66, 220],
            [67, 219],
            [68, 219],
            [69, 218],
            [70, 217],
            [71, 216],
            [72, 216],
            [73, 215],
            [74, 214],
            [75, 213],
            [76, 213],
            [77, 212],
            [78, 211],
            [79, 211],
            [80, 210],
            [81, 209],
            [82, 208],
            [83, 208],
            [84, 207],
            [85, 206],
            [86, 205],
            [87, 205],
            [88, 204],
            [89, 203],
            [90, 202],
            [91, 202],
            [92, 201],
            [93, 200],
            [94, 199],
            [95, 199],
            [96, 198],
            [97, 197],
            [98, 196],
            [99, 196],
            [100, 195],
            [101, 194],
            [102, 193],
            [103, 193],
            [104, 192],
            [105, 191],
            [106, 191],
            [107, 190],
            [108, 189],
            [109, 188],
            [110, 188],
            [111, 187],
            [112, 186],
            [113, 185],
            [114, 185],
            [115, 184],
            [116, 183],
            [117, 182],
            [118, 182],
            [119, 181],
            [120, 180],
            [121, 179],
            [122, 179],
            [123, 178],
            [124, 177],
            [125, 176],
            [126, 176],
            [127, 175],
            [128, 174]
          ],
          d: 'Discount gas costs of calls to the MultiExp precompiles with `k` (point, scalar) pair'
        }
      },
      vm: {},
      pow: {}
    },
    y7 = {
      name: 'EIP-2565',
      number: 2565,
      comment: 'ModExp gas cost',
      url: 'https://eips.ethereum.org/EIPS/eip-2565',
      status: 'Final',
      minimumHardfork: 'byzantium',
      gasConfig: {},
      gasPrices: {
        modexpGquaddivisor: {
          v: 3,
          d: 'Gquaddivisor from modexp precompile for gas calculation'
        }
      },
      vm: {},
      pow: {}
    },
    v7 = {
      name: 'EIP-2718',
      comment: 'Typed Transaction Envelope',
      url: 'https://eips.ethereum.org/EIPS/eip-2718',
      status: 'Final',
      minimumHardfork: 'chainstart',
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    },
    b7 = {
      name: 'EIP-2929',
      comment: 'Gas cost increases for state access opcodes',
      url: 'https://eips.ethereum.org/EIPS/eip-2929',
      status: 'Final',
      minimumHardfork: 'chainstart',
      gasConfig: {},
      gasPrices: {
        coldsload: {
          v: 2100,
          d: 'Gas cost of the first read of storage from a given location (per transaction)'
        },
        coldaccountaccess: {
          v: 2600,
          d: 'Gas cost of the first read of a given address (per transaction)'
        },
        warmstorageread: {
          v: 100,
          d: "Gas cost of reading storage locations which have already loaded 'cold'"
        },
        sstoreCleanGasEIP2200: {
          v: 2900,
          d: 'Once per SSTORE operation from clean non-zero to something else'
        },
        sstoreNoopGasEIP2200: {
          v: 100,
          d: "Once per SSTORE operation if the value doesn't change"
        },
        sstoreDirtyGasEIP2200: {
          v: 100,
          d: 'Once per SSTORE operation if a dirty value is changed'
        },
        sstoreInitRefundEIP2200: {
          v: 19900,
          d: 'Once per SSTORE operation for resetting to the original zero value'
        },
        sstoreCleanRefundEIP2200: {
          v: 4900,
          d: 'Once per SSTORE operation for resetting to the original non-zero value'
        },
        call: {v: 0, d: 'Base fee of the CALL opcode'},
        callcode: {v: 0, d: 'Base fee of the CALLCODE opcode'},
        delegatecall: {v: 0, d: 'Base fee of the DELEGATECALL opcode'},
        staticcall: {v: 0, d: 'Base fee of the STATICCALL opcode'},
        balance: {v: 0, d: 'Base fee of the BALANCE opcode'},
        extcodesize: {v: 0, d: 'Base fee of the EXTCODESIZE opcode'},
        extcodecopy: {v: 0, d: 'Base fee of the EXTCODECOPY opcode'},
        extcodehash: {v: 0, d: 'Base fee of the EXTCODEHASH opcode'},
        sload: {v: 0, d: 'Base fee of the SLOAD opcode'},
        sstore: {v: 0, d: 'Base fee of the SSTORE opcode'}
      },
      vm: {},
      pow: {}
    },
    w7 = {
      name: 'EIP-2930',
      comment: 'Optional access lists',
      url: 'https://eips.ethereum.org/EIPS/eip-2930',
      status: 'Final',
      minimumHardfork: 'istanbul',
      requiredEIPs: [2718, 2929],
      gasConfig: {},
      gasPrices: {
        accessListStorageKeyCost: {
          v: 1900,
          d: 'Gas cost per storage key in an Access List transaction'
        },
        accessListAddressCost: {
          v: 2400,
          d: 'Gas cost per storage key in an Access List transaction'
        }
      },
      vm: {},
      pow: {}
    },
    _7 = {
      name: 'EIP-3198',
      number: 3198,
      comment: 'BASEFEE opcode',
      url: 'https://eips.ethereum.org/EIPS/eip-3198',
      status: 'Final',
      minimumHardfork: 'london',
      gasConfig: {},
      gasPrices: {basefee: {v: 2, d: 'Gas cost of the BASEFEE opcode'}},
      vm: {},
      pow: {}
    },
    E7 = {
      name: 'EIP-3529',
      comment: 'Reduction in refunds',
      url: 'https://eips.ethereum.org/EIPS/eip-3529',
      status: 'Final',
      minimumHardfork: 'berlin',
      requiredEIPs: [2929],
      gasConfig: {
        maxRefundQuotient: {
          v: 5,
          d: 'Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)'
        }
      },
      gasPrices: {
        selfdestructRefund: {
          v: 0,
          d: 'Refunded following a selfdestruct operation'
        },
        sstoreClearRefundEIP2200: {
          v: 4800,
          d: 'Once per SSTORE operation for clearing an originally existing storage slot'
        }
      },
      vm: {},
      pow: {}
    },
    A7 = {
      name: 'EIP-3540',
      number: 3540,
      comment: 'EVM Object Format (EOF) v1',
      url: 'https://eips.ethereum.org/EIPS/eip-3540',
      status: 'Review',
      minimumHardfork: 'london',
      requiredEIPs: [3541],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    },
    S7 = {
      name: 'EIP-3541',
      comment: 'Reject new contracts starting with the 0xEF byte',
      url: 'https://eips.ethereum.org/EIPS/eip-3541',
      status: 'Final',
      minimumHardfork: 'berlin',
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    },
    x7 = {
      name: 'EIP-3554',
      comment: 'Reduction in refunds',
      url: 'Difficulty Bomb Delay to December 1st 2021',
      status: 'Final',
      minimumHardfork: 'muirGlacier',
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {
        difficultyBombDelay: {
          v: 95e5,
          d: 'the amount of blocks to delay the difficulty bomb with'
        }
      }
    },
    C7 = {
      name: 'EIP-3607',
      number: 3607,
      comment: 'Reject transactions from senders with deployed code',
      url: 'https://eips.ethereum.org/EIPS/eip-3607',
      status: 'Final',
      minimumHardfork: 'chainstart',
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    },
    T7 = {
      name: 'EIP-3651',
      number: 3198,
      comment: 'Warm COINBASE',
      url: 'https://eips.ethereum.org/EIPS/eip-3651',
      status: 'Review',
      minimumHardfork: 'london',
      requiredEIPs: [2929],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    },
    I7 = {
      name: 'EIP-3670',
      number: 3670,
      comment: 'EOF - Code Validation',
      url: 'https://eips.ethereum.org/EIPS/eip-3670',
      status: 'Review',
      minimumHardfork: 'london',
      requiredEIPs: [3540],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    },
    k7 = {
      name: 'EIP-3675',
      number: 3675,
      comment: 'Upgrade consensus to Proof-of-Stake',
      url: 'https://eips.ethereum.org/EIPS/eip-3675',
      status: 'Final',
      minimumHardfork: 'london',
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    },
    R7 = {
      name: 'EIP-3855',
      number: 3855,
      comment: 'PUSH0 instruction',
      url: 'https://eips.ethereum.org/EIPS/eip-3855',
      status: 'Review',
      minimumHardfork: 'chainstart',
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {push0: {v: 2, d: 'Base fee of the PUSH0 opcode'}},
      vm: {},
      pow: {}
    },
    P7 = {
      name: 'EIP-3860',
      number: 3860,
      comment: 'Limit and meter initcode',
      url: 'https://eips.ethereum.org/EIPS/eip-3860',
      status: 'Review',
      minimumHardfork: 'spuriousDragon',
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {
        initCodeWordCost: {
          v: 2,
          d: 'Gas to pay for each word (32 bytes) of initcode when creating a contract'
        }
      },
      vm: {
        maxInitCodeSize: {
          v: 49152,
          d: 'Maximum length of initialization code when creating a contract'
        }
      },
      pow: {}
    },
    M7 = {
      name: 'EIP-4345',
      number: 4345,
      comment: 'Difficulty Bomb Delay to June 2022',
      url: 'https://eips.ethereum.org/EIPS/eip-4345',
      status: 'Final',
      minimumHardfork: 'london',
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {
        difficultyBombDelay: {
          v: 107e5,
          d: 'the amount of blocks to delay the difficulty bomb with'
        }
      }
    },
    O7 = {
      name: 'EIP-4399',
      number: 4399,
      comment: 'Supplant DIFFICULTY opcode with PREVRANDAO',
      url: 'https://eips.ethereum.org/EIPS/eip-4399',
      status: 'Review',
      minimumHardfork: 'london',
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    },
    N7 = {
      name: 'EIP-5133',
      number: 5133,
      comment: 'Delaying Difficulty Bomb to mid-September 2022',
      url: 'https://eips.ethereum.org/EIPS/eip-5133',
      status: 'Draft',
      minimumHardfork: 'grayGlacier',
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {
        difficultyBombDelay: {
          v: 114e5,
          d: 'the amount of blocks to delay the difficulty bomb with'
        }
      }
    },
    ma = {
      1153: h7,
      1559: p7,
      2315: m7,
      2537: g7,
      2565: y7,
      2718: v7,
      2929: b7,
      2930: w7,
      3198: _7,
      3529: E7,
      3540: A7,
      3541: S7,
      3554: x7,
      3607: C7,
      3651: T7,
      3670: I7,
      3675: k7,
      3855: R7,
      3860: P7,
      4345: M7,
      4399: O7,
      5133: N7
    },
    L7 = {
      name: 'chainstart',
      comment: 'Start of the Ethereum main chain',
      url: '',
      status: '',
      gasConfig: {
        minGasLimit: {v: 5e3, d: 'Minimum the gas limit may ever be'},
        gasLimitBoundDivisor: {
          v: 1024,
          d: 'The bound divisor of the gas limit, used in update calculations'
        },
        maxRefundQuotient: {
          v: 2,
          d: 'Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)'
        }
      },
      gasPrices: {
        base: {
          v: 2,
          d: 'Gas base cost, used e.g. for ChainID opcode (Istanbul)'
        },
        tierStep: {
          v: [0, 2, 3, 5, 8, 10, 20],
          d: 'Once per operation, for a selection of them'
        },
        exp: {v: 10, d: 'Base fee of the EXP opcode'},
        expByte: {
          v: 10,
          d: 'Times ceil(log256(exponent)) for the EXP instruction'
        },
        sha3: {v: 30, d: 'Base fee of the SHA3 opcode'},
        sha3Word: {v: 6, d: "Once per word of the SHA3 operation's data"},
        sload: {v: 50, d: 'Base fee of the SLOAD opcode'},
        sstoreSet: {
          v: 2e4,
          d: 'Once per SSTORE operation if the zeroness changes from zero'
        },
        sstoreReset: {
          v: 5e3,
          d: 'Once per SSTORE operation if the zeroness does not change from zero'
        },
        sstoreRefund: {
          v: 15e3,
          d: 'Once per SSTORE operation if the zeroness changes to zero'
        },
        jumpdest: {v: 1, d: 'Base fee of the JUMPDEST opcode'},
        log: {v: 375, d: 'Base fee of the LOG opcode'},
        logData: {v: 8, d: "Per byte in a LOG* operation's data"},
        logTopic: {
          v: 375,
          d: 'Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas'
        },
        create: {v: 32e3, d: 'Base fee of the CREATE opcode'},
        call: {v: 40, d: 'Base fee of the CALL opcode'},
        callStipend: {v: 2300, d: 'Free gas given at beginning of call'},
        callValueTransfer: {
          v: 9e3,
          d: 'Paid for CALL when the value transfor is non-zero'
        },
        callNewAccount: {
          v: 25e3,
          d: "Paid for CALL when the destination address didn't exist prior"
        },
        selfdestructRefund: {
          v: 24e3,
          d: 'Refunded following a selfdestruct operation'
        },
        memory: {
          v: 3,
          d: 'Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL'
        },
        quadCoeffDiv: {
          v: 512,
          d: 'Divisor for the quadratic particle of the memory cost equation'
        },
        createData: {v: 200, d: ''},
        tx: {
          v: 21e3,
          d: 'Per transaction. NOTE: Not payable on data of calls between transactions'
        },
        txCreation: {v: 32e3, d: 'The cost of creating a contract via tx'},
        txDataZero: {
          v: 4,
          d: 'Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions'
        },
        txDataNonZero: {
          v: 68,
          d: 'Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions'
        },
        copy: {
          v: 3,
          d: 'Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added'
        },
        ecRecover: {v: 3e3, d: ''},
        sha256: {v: 60, d: ''},
        sha256Word: {v: 12, d: ''},
        ripemd160: {v: 600, d: ''},
        ripemd160Word: {v: 120, d: ''},
        identity: {v: 15, d: ''},
        identityWord: {v: 3, d: ''},
        stop: {v: 0, d: 'Base fee of the STOP opcode'},
        add: {v: 3, d: 'Base fee of the ADD opcode'},
        mul: {v: 5, d: 'Base fee of the MUL opcode'},
        sub: {v: 3, d: 'Base fee of the SUB opcode'},
        div: {v: 5, d: 'Base fee of the DIV opcode'},
        sdiv: {v: 5, d: 'Base fee of the SDIV opcode'},
        mod: {v: 5, d: 'Base fee of the MOD opcode'},
        smod: {v: 5, d: 'Base fee of the SMOD opcode'},
        addmod: {v: 8, d: 'Base fee of the ADDMOD opcode'},
        mulmod: {v: 8, d: 'Base fee of the MULMOD opcode'},
        signextend: {v: 5, d: 'Base fee of the SIGNEXTEND opcode'},
        lt: {v: 3, d: 'Base fee of the LT opcode'},
        gt: {v: 3, d: 'Base fee of the GT opcode'},
        slt: {v: 3, d: 'Base fee of the SLT opcode'},
        sgt: {v: 3, d: 'Base fee of the SGT opcode'},
        eq: {v: 3, d: 'Base fee of the EQ opcode'},
        iszero: {v: 3, d: 'Base fee of the ISZERO opcode'},
        and: {v: 3, d: 'Base fee of the AND opcode'},
        or: {v: 3, d: 'Base fee of the OR opcode'},
        xor: {v: 3, d: 'Base fee of the XOR opcode'},
        not: {v: 3, d: 'Base fee of the NOT opcode'},
        byte: {v: 3, d: 'Base fee of the BYTE opcode'},
        address: {v: 2, d: 'Base fee of the ADDRESS opcode'},
        balance: {v: 20, d: 'Base fee of the BALANCE opcode'},
        origin: {v: 2, d: 'Base fee of the ORIGIN opcode'},
        caller: {v: 2, d: 'Base fee of the CALLER opcode'},
        callvalue: {v: 2, d: 'Base fee of the CALLVALUE opcode'},
        calldataload: {v: 3, d: 'Base fee of the CALLDATALOAD opcode'},
        calldatasize: {v: 2, d: 'Base fee of the CALLDATASIZE opcode'},
        calldatacopy: {v: 3, d: 'Base fee of the CALLDATACOPY opcode'},
        codesize: {v: 2, d: 'Base fee of the CODESIZE opcode'},
        codecopy: {v: 3, d: 'Base fee of the CODECOPY opcode'},
        gasprice: {v: 2, d: 'Base fee of the GASPRICE opcode'},
        extcodesize: {v: 20, d: 'Base fee of the EXTCODESIZE opcode'},
        extcodecopy: {v: 20, d: 'Base fee of the EXTCODECOPY opcode'},
        blockhash: {v: 20, d: 'Base fee of the BLOCKHASH opcode'},
        coinbase: {v: 2, d: 'Base fee of the COINBASE opcode'},
        timestamp: {v: 2, d: 'Base fee of the TIMESTAMP opcode'},
        number: {v: 2, d: 'Base fee of the NUMBER opcode'},
        difficulty: {v: 2, d: 'Base fee of the DIFFICULTY opcode'},
        gaslimit: {v: 2, d: 'Base fee of the GASLIMIT opcode'},
        pop: {v: 2, d: 'Base fee of the POP opcode'},
        mload: {v: 3, d: 'Base fee of the MLOAD opcode'},
        mstore: {v: 3, d: 'Base fee of the MSTORE opcode'},
        mstore8: {v: 3, d: 'Base fee of the MSTORE8 opcode'},
        sstore: {v: 0, d: 'Base fee of the SSTORE opcode'},
        jump: {v: 8, d: 'Base fee of the JUMP opcode'},
        jumpi: {v: 10, d: 'Base fee of the JUMPI opcode'},
        pc: {v: 2, d: 'Base fee of the PC opcode'},
        msize: {v: 2, d: 'Base fee of the MSIZE opcode'},
        gas: {v: 2, d: 'Base fee of the GAS opcode'},
        push: {v: 3, d: 'Base fee of the PUSH opcode'},
        dup: {v: 3, d: 'Base fee of the DUP opcode'},
        swap: {v: 3, d: 'Base fee of the SWAP opcode'},
        callcode: {v: 40, d: 'Base fee of the CALLCODE opcode'},
        return: {v: 0, d: 'Base fee of the RETURN opcode'},
        invalid: {v: 0, d: 'Base fee of the INVALID opcode'},
        selfdestruct: {v: 0, d: 'Base fee of the SELFDESTRUCT opcode'}
      },
      vm: {
        stackLimit: {v: 1024, d: 'Maximum size of VM stack allowed'},
        callCreateDepth: {v: 1024, d: 'Maximum depth of call/create stack'},
        maxExtraDataSize: {
          v: 32,
          d: 'Maximum size extra data may be after Genesis'
        }
      },
      pow: {
        minimumDifficulty: {
          v: 131072,
          d: 'The minimum that the difficulty may ever be'
        },
        difficultyBoundDivisor: {
          v: 2048,
          d: 'The bound divisor of the difficulty, used in the update calculations'
        },
        durationLimit: {
          v: 13,
          d: 'The decision boundary on the blocktime duration used to determine whether difficulty should go up or not'
        },
        epochDuration: {v: 3e4, d: 'Duration between proof-of-work epochs'},
        timebombPeriod: {v: 1e5, d: 'Exponential difficulty timebomb period'},
        minerReward: {
          v: '5000000000000000000',
          d: 'the amount a miner get rewarded for mining a block'
        },
        difficultyBombDelay: {
          v: 0,
          d: 'the amount of blocks to delay the difficulty bomb with'
        }
      }
    },
    B7 = {
      name: 'dao',
      comment: 'DAO rescue hardfork',
      url: 'https://eips.ethereum.org/EIPS/eip-779',
      status: 'Final',
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    },
    D7 = {
      name: 'homestead',
      comment: 'Homestead hardfork with protocol and network changes',
      url: 'https://eips.ethereum.org/EIPS/eip-606',
      status: 'Final',
      gasConfig: {},
      gasPrices: {
        delegatecall: {v: 40, d: 'Base fee of the DELEGATECALL opcode'}
      },
      vm: {},
      pow: {}
    },
    F7 = {
      name: 'tangerineWhistle',
      comment: 'Hardfork with gas cost changes for IO-heavy operations',
      url: 'https://eips.ethereum.org/EIPS/eip-608',
      status: 'Final',
      gasConfig: {},
      gasPrices: {
        sload: {v: 200, d: 'Once per SLOAD operation'},
        call: {v: 700, d: 'Once per CALL operation & message call transaction'},
        extcodesize: {v: 700, d: 'Base fee of the EXTCODESIZE opcode'},
        extcodecopy: {v: 700, d: 'Base fee of the EXTCODECOPY opcode'},
        balance: {v: 400, d: 'Base fee of the BALANCE opcode'},
        delegatecall: {v: 700, d: 'Base fee of the DELEGATECALL opcode'},
        callcode: {v: 700, d: 'Base fee of the CALLCODE opcode'},
        selfdestruct: {v: 5e3, d: 'Base fee of the SELFDESTRUCT opcode'}
      },
      vm: {},
      pow: {}
    },
    $7 = {
      name: 'spuriousDragon',
      comment:
        'HF with EIPs for simple replay attack protection, EXP cost increase, state trie clearing, contract code size limit',
      url: 'https://eips.ethereum.org/EIPS/eip-607',
      status: 'Final',
      gasConfig: {},
      gasPrices: {
        expByte: {
          v: 50,
          d: 'Times ceil(log256(exponent)) for the EXP instruction'
        }
      },
      vm: {maxCodeSize: {v: 24576, d: 'Maximum length of contract code'}},
      pow: {}
    },
    H7 = {
      name: 'byzantium',
      comment:
        'Hardfork with new precompiles, instructions and other protocol changes',
      url: 'https://eips.ethereum.org/EIPS/eip-609',
      status: 'Final',
      gasConfig: {},
      gasPrices: {
        modexpGquaddivisor: {
          v: 20,
          d: 'Gquaddivisor from modexp precompile for gas calculation'
        },
        ecAdd: {v: 500, d: 'Gas costs for curve addition precompile'},
        ecMul: {v: 4e4, d: 'Gas costs for curve multiplication precompile'},
        ecPairing: {v: 1e5, d: 'Base gas costs for curve pairing precompile'},
        ecPairingWord: {
          v: 8e4,
          d: 'Gas costs regarding curve pairing precompile input length'
        },
        revert: {v: 0, d: 'Base fee of the REVERT opcode'},
        staticcall: {v: 700, d: 'Base fee of the STATICCALL opcode'},
        returndatasize: {v: 2, d: 'Base fee of the RETURNDATASIZE opcode'},
        returndatacopy: {v: 3, d: 'Base fee of the RETURNDATACOPY opcode'}
      },
      vm: {},
      pow: {
        minerReward: {
          v: '3000000000000000000',
          d: 'the amount a miner get rewarded for mining a block'
        },
        difficultyBombDelay: {
          v: 3e6,
          d: 'the amount of blocks to delay the difficulty bomb with'
        }
      }
    },
    j7 = {
      name: 'constantinople',
      comment:
        'Postponed hardfork including EIP-1283 (SSTORE gas metering changes)',
      url: 'https://eips.ethereum.org/EIPS/eip-1013',
      status: 'Final',
      gasConfig: {},
      gasPrices: {
        netSstoreNoopGas: {
          v: 200,
          d: "Once per SSTORE operation if the value doesn't change"
        },
        netSstoreInitGas: {
          v: 2e4,
          d: 'Once per SSTORE operation from clean zero'
        },
        netSstoreCleanGas: {
          v: 5e3,
          d: 'Once per SSTORE operation from clean non-zero'
        },
        netSstoreDirtyGas: {v: 200, d: 'Once per SSTORE operation from dirty'},
        netSstoreClearRefund: {
          v: 15e3,
          d: 'Once per SSTORE operation for clearing an originally existing storage slot'
        },
        netSstoreResetRefund: {
          v: 4800,
          d: 'Once per SSTORE operation for resetting to the original non-zero value'
        },
        netSstoreResetClearRefund: {
          v: 19800,
          d: 'Once per SSTORE operation for resetting to the original zero value'
        },
        shl: {v: 3, d: 'Base fee of the SHL opcode'},
        shr: {v: 3, d: 'Base fee of the SHR opcode'},
        sar: {v: 3, d: 'Base fee of the SAR opcode'},
        extcodehash: {v: 400, d: 'Base fee of the EXTCODEHASH opcode'},
        create2: {v: 32e3, d: 'Base fee of the CREATE2 opcode'}
      },
      vm: {},
      pow: {
        minerReward: {
          v: '2000000000000000000',
          d: 'The amount a miner gets rewarded for mining a block'
        },
        difficultyBombDelay: {
          v: 5e6,
          d: 'the amount of blocks to delay the difficulty bomb with'
        }
      }
    },
    U7 = {
      name: 'petersburg',
      comment:
        'Aka constantinopleFix, removes EIP-1283, activate together with or after constantinople',
      url: 'https://eips.ethereum.org/EIPS/eip-1716',
      status: 'Final',
      gasConfig: {},
      gasPrices: {
        netSstoreNoopGas: {v: null, d: 'Removed along EIP-1283'},
        netSstoreInitGas: {v: null, d: 'Removed along EIP-1283'},
        netSstoreCleanGas: {v: null, d: 'Removed along EIP-1283'},
        netSstoreDirtyGas: {v: null, d: 'Removed along EIP-1283'},
        netSstoreClearRefund: {v: null, d: 'Removed along EIP-1283'},
        netSstoreResetRefund: {v: null, d: 'Removed along EIP-1283'},
        netSstoreResetClearRefund: {v: null, d: 'Removed along EIP-1283'}
      },
      vm: {},
      pow: {}
    },
    K7 = {
      name: 'istanbul',
      comment:
        'HF targeted for December 2019 following the Constantinople/Petersburg HF',
      url: 'https://eips.ethereum.org/EIPS/eip-1679',
      status: 'Final',
      gasConfig: {},
      gasPrices: {
        blake2Round: {
          v: 1,
          d: 'Gas cost per round for the Blake2 F precompile'
        },
        ecAdd: {v: 150, d: 'Gas costs for curve addition precompile'},
        ecMul: {v: 6e3, d: 'Gas costs for curve multiplication precompile'},
        ecPairing: {v: 45e3, d: 'Base gas costs for curve pairing precompile'},
        ecPairingWord: {
          v: 34e3,
          d: 'Gas costs regarding curve pairing precompile input length'
        },
        txDataNonZero: {
          v: 16,
          d: 'Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions'
        },
        sstoreSentryGasEIP2200: {
          v: 2300,
          d: 'Minimum gas required to be present for an SSTORE call, not consumed'
        },
        sstoreNoopGasEIP2200: {
          v: 800,
          d: "Once per SSTORE operation if the value doesn't change"
        },
        sstoreDirtyGasEIP2200: {
          v: 800,
          d: 'Once per SSTORE operation if a dirty value is changed'
        },
        sstoreInitGasEIP2200: {
          v: 2e4,
          d: 'Once per SSTORE operation from clean zero to non-zero'
        },
        sstoreInitRefundEIP2200: {
          v: 19200,
          d: 'Once per SSTORE operation for resetting to the original zero value'
        },
        sstoreCleanGasEIP2200: {
          v: 5e3,
          d: 'Once per SSTORE operation from clean non-zero to something else'
        },
        sstoreCleanRefundEIP2200: {
          v: 4200,
          d: 'Once per SSTORE operation for resetting to the original non-zero value'
        },
        sstoreClearRefundEIP2200: {
          v: 15e3,
          d: 'Once per SSTORE operation for clearing an originally existing storage slot'
        },
        balance: {v: 700, d: 'Base fee of the BALANCE opcode'},
        extcodehash: {v: 700, d: 'Base fee of the EXTCODEHASH opcode'},
        chainid: {v: 2, d: 'Base fee of the CHAINID opcode'},
        selfbalance: {v: 5, d: 'Base fee of the SELFBALANCE opcode'},
        sload: {v: 800, d: 'Base fee of the SLOAD opcode'}
      },
      vm: {},
      pow: {}
    },
    q7 = {
      name: 'muirGlacier',
      comment: 'HF to delay the difficulty bomb',
      url: 'https://eips.ethereum.org/EIPS/eip-2384',
      status: 'Final',
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {
        difficultyBombDelay: {
          v: 9e6,
          d: 'the amount of blocks to delay the difficulty bomb with'
        }
      }
    },
    V7 = {
      name: 'berlin',
      comment: 'HF targeted for July 2020 following the Muir Glacier HF',
      url: 'https://eips.ethereum.org/EIPS/eip-2070',
      status: 'Final',
      eips: [2565, 2929, 2718, 2930]
    },
    G7 = {
      name: 'london',
      comment: 'HF targeted for July 2021 following the Berlin fork',
      url: 'https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/london.md',
      status: 'Final',
      eips: [1559, 3198, 3529, 3541]
    },
    z7 = {
      name: 'shanghai',
      comment:
        'Next feature hardfork after the merge hardfork having withdrawals, warm coinbase, push0, limit/meter initcode',
      url: 'https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/shanghai.md',
      status: 'Final',
      eips: [3651, 3855, 3860, 4895]
    },
    W7 = {
      name: 'arrowGlacier',
      comment: 'HF to delay the difficulty bomb',
      url: 'https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/arrow-glacier.md',
      status: 'Final',
      eips: [4345],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    },
    Z7 = {
      name: 'grayGlacier',
      comment: 'Delaying the difficulty bomb to Mid September 2022',
      url: 'https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/gray-glacier.md',
      status: 'Draft',
      eips: [5133],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    },
    Y7 = {
      name: 'mergeForkIdTransition',
      comment: 'Pre-merge hardfork to fork off non-upgraded clients',
      url: 'https://eips.ethereum.org/EIPS/eip-3675',
      status: 'Draft',
      eips: []
    },
    Q7 = {
      name: 'merge',
      comment: 'Hardfork to upgrade the consensus mechanism to Proof-of-Stake',
      url: 'https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/merge.md',
      status: 'Final',
      consensus: {type: 'pos', algorithm: 'casper', casper: {}},
      eips: [3675, 4399]
    },
    J7 = {
      chainstart: L7,
      homestead: D7,
      dao: B7,
      tangerineWhistle: F7,
      spuriousDragon: $7,
      byzantium: H7,
      constantinople: j7,
      petersburg: U7,
      istanbul: K7,
      muirGlacier: q7,
      berlin: V7,
      london: G7,
      shanghai: z7,
      arrowGlacier: W7,
      grayGlacier: Z7,
      mergeForkIdTransition: Y7,
      merge: Q7
    },
    {buf: X7} = l7;
  class Bt extends Jy {
    static custom(e, n = {}) {
      var r;
      const i = (r = n.baseChain) !== null && r !== void 0 ? r : 'mainnet',
        s = Object.assign({}, Bt._getChainParams(i));
      if (((s.name = 'custom-chain'), typeof e != 'string'))
        return new Bt(
          Object.assign({chain: Object.assign(Object.assign({}, s), e)}, n)
        );
      if (e === an.PolygonMainnet)
        return Bt.custom(
          {name: an.PolygonMainnet, chainId: 137, networkId: 137},
          n
        );
      if (e === an.PolygonMumbai)
        return Bt.custom(
          {name: an.PolygonMumbai, chainId: 80001, networkId: 80001},
          n
        );
      if (e === an.ArbitrumRinkebyTestnet)
        return Bt.custom(
          {name: an.ArbitrumRinkebyTestnet, chainId: 421611, networkId: 421611},
          n
        );
      if (e === an.ArbitrumOne)
        return Bt.custom(
          {name: an.ArbitrumOne, chainId: 42161, networkId: 42161},
          n
        );
      if (e === an.xDaiChain)
        return Bt.custom({name: an.xDaiChain, chainId: 100, networkId: 100}, n);
      if (e === an.OptimisticKovan)
        return Bt.custom(
          {name: an.OptimisticKovan, chainId: 69, networkId: 69},
          Object.assign({hardfork: gt.Berlin}, n)
        );
      if (e === an.OptimisticEthereum)
        return Bt.custom(
          {name: an.OptimisticEthereum, chainId: 10, networkId: 10},
          Object.assign({hardfork: gt.Berlin}, n)
        );
      throw new Error(`Custom chain ${e} not supported`);
    }
    static fromGethGenesis(
      e,
      {chain: n, eips: r, genesisHash: i, hardfork: s, mergeForkIdPostMerge: o}
    ) {
      var a;
      const c = XO(e, n, o),
        l = new Bt({
          chain: (a = c.name) !== null && a !== void 0 ? a : 'custom',
          customChains: [c],
          eips: r,
          hardfork: s ?? c.hardfork
        });
      return (i !== void 0 && l.setForkHashes(i), l);
    }
    static isSupportedChainId(e) {
      return !!this._getInitializedChains().names[e.toString()];
    }
    static _getChainParams(e, n) {
      let r = e;
      const i = this._getInitializedChains(n);
      if (typeof r == 'number' || typeof r == 'bigint') {
        if (((r = r.toString()), i.names[r])) {
          const s = i.names[r];
          return i[s];
        }
        throw new Error(`Chain with ID ${r} not supported`);
      }
      if (i[r] !== void 0) return i[r];
      throw new Error(`Chain with name ${r} not supported`);
    }
    constructor(e) {
      var n, r;
      (super(),
        (this._eips = []),
        (this._customChains =
          (n = e.customChains) !== null && n !== void 0 ? n : []),
        (this._chainParams = this.setChain(e.chain)),
        (this.DEFAULT_HARDFORK =
          (r = this._chainParams.defaultHardfork) !== null && r !== void 0
            ? r
            : gt.Merge),
        (this.HARDFORK_CHANGES = this.hardforks().map((i) => [
          i.name,
          J7[i.name]
        ])),
        (this._hardfork = this.DEFAULT_HARDFORK),
        e.hardfork !== void 0 && this.setHardfork(e.hardfork),
        e.eips && this.setEIPs(e.eips));
    }
    setChain(e) {
      if (typeof e == 'number' || typeof e == 'bigint' || typeof e == 'string')
        this._chainParams = Bt._getChainParams(e, this._customChains);
      else if (typeof e == 'object') {
        if (this._customChains.length > 0)
          throw new Error(
            'Chain must be a string, number, or bigint when initialized with customChains passed in'
          );
        const n = ['networkId', 'genesis', 'hardforks', 'bootstrapNodes'];
        for (const r of n)
          if (!(r in e))
            throw new Error(`Missing required chain parameter: ${r}`);
        this._chainParams = e;
      } else throw new Error('Wrong input format');
      for (const n of this.hardforks())
        if (n.block === void 0)
          throw new Error('Hardfork cannot have undefined block number');
      return this._chainParams;
    }
    setHardfork(e) {
      let n = !1;
      for (const r of this.HARDFORK_CHANGES)
        r[0] === e &&
          (this._hardfork !== e &&
            ((this._hardfork = e), this.emit('hardforkChanged', e)),
          (n = !0));
      if (!n) throw new Error(`Hardfork with name ${e} not supported`);
    }
    getHardforkByBlockNumber(e, n, r) {
      const i = pa(e, yr.BigInt),
        s = pa(n, yr.BigInt),
        o = pa(r, yr.Number),
        a = this.hardforks().filter(
          (h) =>
            h.block !== null ||
            (h.ttd !== null && h.ttd !== void 0) ||
            h.timestamp !== void 0
        ),
        c = a.findIndex((h) => h.ttd !== null && h.ttd !== void 0);
      if (
        a.slice(c + 1).findIndex((h) => h.ttd !== null && h.ttd !== void 0) >= 0
      )
        throw Error('More than one merge hardforks found with ttd specified');
      let u = a.findIndex(
        (h) =>
          (h.block !== null && h.block > i) ||
          (o !== void 0 && Number(h.timestamp) > o)
      );
      if (u === -1) u = a.length;
      else if (u === 0)
        throw Error('Must have at least one hardfork at block 0');
      if (o === void 0) {
        const h = a
          .slice(0, u)
          .reverse()
          .findIndex((g) => g.block !== null || g.ttd !== void 0);
        u -= h;
      }
      if (((u -= 1), a[u].block === null && a[u].timestamp === void 0))
        (s == null || BigInt(a[u].ttd) > s) && (u -= 1);
      else if (c >= 0 && s !== void 0 && s !== null) {
        if (u >= c && BigInt(a[c].ttd) > s)
          throw Error(
            'Maximum HF determined by total difficulty is lower than the block number HF'
          );
        if (u < c && BigInt(a[c].ttd) <= s)
          throw Error(
            'HF determined by block number is lower than the minimum total difficulty HF'
          );
      }
      const d = u;
      for (
        ;
        u < a.length - 1 &&
        !(
          a[u].block !== a[u + 1].block || a[u].timestamp !== a[u + 1].timestamp
        );
        u += 1
      );
      if (o) {
        if (
          a.slice(0, d).reduce((m, y) => {
            var p;
            return Math.max(
              Number((p = y.timestamp) !== null && p !== void 0 ? p : '0'),
              m
            );
          }, 0) > o
        )
          throw Error(
            'Maximum HF determined by timestamp is lower than the block number/ttd HF'
          );
        if (
          a.slice(u + 1).reduce((m, y) => {
            var p;
            return Math.min(
              Number((p = y.timestamp) !== null && p !== void 0 ? p : o),
              m
            );
          }, o) < o
        )
          throw Error(
            'Maximum HF determined by block number/ttd is lower than timestamp HF'
          );
      }
      return a[u].name;
    }
    setHardforkByBlockNumber(e, n, r) {
      const i = this.getHardforkByBlockNumber(e, n, r);
      return (this.setHardfork(i), i);
    }
    _getHardfork(e) {
      const n = this.hardforks();
      for (const r of n) if (r.name === e) return r;
      return null;
    }
    setEIPs(e = []) {
      for (const n of e) {
        if (!(n in ma)) throw new Error(`${n} not supported`);
        const r = this.gteHardfork(ma[n].minimumHardfork);
        if (!r)
          throw new Error(
            `${n} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${r}`
          );
        if (ma[n].requiredEIPs !== void 0) {
          for (const i of ma[n].requiredEIPs)
            if (!(e.includes(i) || this.isActivatedEIP(i)))
              throw new Error(
                `${n} requires EIP ${i}, but is not included in the EIP list`
              );
        }
      }
      this._eips = e;
    }
    param(e, n) {
      let r;
      for (const i of this._eips)
        if (((r = this.paramByEIP(e, n, i)), r !== void 0)) return r;
      return this.paramByHardfork(e, n, this._hardfork);
    }
    paramByHardfork(e, n, r) {
      let i = null;
      for (const s of this.HARDFORK_CHANGES) {
        if ('eips' in s[1]) {
          const o = s[1].eips;
          for (const a of o) {
            const c = this.paramByEIP(e, n, a);
            i = typeof c == 'bigint' ? c : i;
          }
        } else {
          if (s[1][e] === void 0) throw new Error(`Topic ${e} not defined`);
          s[1][e][n] !== void 0 && (i = s[1][e][n].v);
        }
        if (s[0] === r) break;
      }
      return BigInt(i ?? 0);
    }
    paramByEIP(e, n, r) {
      if (!(r in ma)) throw new Error(`${r} not supported`);
      const i = ma[r];
      if (!(e in i)) throw new Error(`Topic ${e} not defined`);
      if (i[e][n] === void 0) return;
      const s = i[e][n].v;
      return BigInt(s);
    }
    paramByBlock(e, n, r, i, s) {
      const o = this.getHardforkByBlockNumber(r, i, s);
      return this.paramByHardfork(e, n, o);
    }
    isActivatedEIP(e) {
      if (this.eips().includes(e)) return !0;
      for (const n of this.HARDFORK_CHANGES) {
        const r = n[1];
        if (this.gteHardfork(r.name) && 'eips' in r && r.eips.includes(e))
          return !0;
      }
      return !1;
    }
    hardforkIsActiveOnBlock(e, n) {
      const r = pa(n, yr.BigInt),
        i = e ?? this._hardfork,
        s = this.hardforkBlock(i);
      return typeof s == 'bigint' && s !== BigInt(0) && r >= s;
    }
    activeOnBlock(e) {
      return this.hardforkIsActiveOnBlock(null, e);
    }
    hardforkGteHardfork(e, n) {
      const r = e ?? this._hardfork,
        i = this.hardforks();
      let s = -1,
        o = -1,
        a = 0;
      for (const c of i)
        (c.name === r && (s = a), c.name === n && (o = a), (a += 1));
      return s >= o && o !== -1;
    }
    gteHardfork(e) {
      return this.hardforkGteHardfork(null, e);
    }
    hardforkBlock(e) {
      var n;
      const r = e ?? this._hardfork,
        i =
          (n = this._getHardfork(r)) === null || n === void 0
            ? void 0
            : n.block;
      return i == null ? null : BigInt(i);
    }
    hardforkTimestamp(e) {
      var n;
      const r = e ?? this._hardfork,
        i =
          (n = this._getHardfork(r)) === null || n === void 0
            ? void 0
            : n.timestamp;
      return i == null ? null : BigInt(i);
    }
    eipBlock(e) {
      for (const n of this.HARDFORK_CHANGES) {
        const r = n[1];
        if ('eips' in r && r.eips.includes(e))
          return this.hardforkBlock(
            typeof n[0] == 'number' ? String(n[0]) : n[0]
          );
      }
      return null;
    }
    hardforkTTD(e) {
      var n;
      const r = e ?? this._hardfork,
        i =
          (n = this._getHardfork(r)) === null || n === void 0 ? void 0 : n.ttd;
      return i == null ? null : BigInt(i);
    }
    isHardforkBlock(e, n) {
      const r = pa(e, yr.BigInt),
        i = n ?? this._hardfork,
        s = this.hardforkBlock(i);
      return typeof s == 'bigint' && s !== BigInt(0) ? s === r : !1;
    }
    nextHardforkBlockOrTimestamp(e) {
      var n, r, i;
      const s = (n = e) !== null && n !== void 0 ? n : this._hardfork,
        o = this.hardforks();
      let a = o.findIndex((d) => d.name === s);
      if ((s === gt.Merge && (a -= 1), a < 0)) return null;
      let c = (r = o[a].timestamp) !== null && r !== void 0 ? r : o[a].block;
      c = c != null ? Number(c) : null;
      const l = o.slice(a + 1).find((d) => {
        var f;
        let h = (f = d.timestamp) !== null && f !== void 0 ? f : d.block;
        return (
          (h = h != null ? Number(h) : null),
          d.name !== gt.Merge && h !== null && h !== void 0 && h !== c
        );
      });
      if (l === void 0) return null;
      const u = (i = l.timestamp) !== null && i !== void 0 ? i : l.block;
      return u == null ? null : BigInt(u);
    }
    nextHardforkBlock(e) {
      var n;
      const r = (n = e) !== null && n !== void 0 ? n : this._hardfork;
      let i = this.hardforkBlock(r);
      if (i === null && r === gt.Merge) {
        const o = this.hardforks(),
          a = o.findIndex((c) => c.ttd !== null && c.ttd !== void 0);
        if (a < 0) throw Error('Merge hardfork should have been found');
        i = this.hardforkBlock(o[a - 1].name);
      }
      return i === null
        ? null
        : this.hardforks().reduce((o, a) => {
            const c = BigInt(
              a.block === null || (a.ttd !== void 0 && a.ttd !== null)
                ? 0
                : a.block
            );
            return c > i && o === null ? c : o;
          }, null);
    }
    isNextHardforkBlock(e, n) {
      const r = pa(e, yr.BigInt),
        i = n ?? this._hardfork,
        s = this.nextHardforkBlock(i);
      return s === null ? !1 : s === r;
    }
    _calcForkHash(e, n) {
      let r = new Uint8Array(),
        i = 0;
      for (const a of this.hardforks()) {
        const {block: c, timestamp: l, name: u} = a;
        let d = l ?? c;
        if (
          ((d = d !== null ? Number(d) : null),
          typeof d == 'number' && d !== 0 && d !== i && u !== gt.Merge)
        ) {
          const f = bt(d.toString(16).padStart(16, '0'));
          ((r = Mn(r, f)), (i = d));
        }
        if (a.name === e) break;
      }
      const s = Mn(n, r);
      return We(e7(X7(s) >>> 0));
    }
    forkHash(e, n) {
      const r = e ?? this._hardfork,
        i = this._getHardfork(r);
      if (
        i === null ||
        ((i == null ? void 0 : i.block) === null &&
          (i == null ? void 0 : i.timestamp) === void 0 &&
          (i == null ? void 0 : i.ttd) === void 0)
      ) {
        const s = 'No fork hash calculation possible for future hardfork';
        throw new Error(s);
      }
      if (
        (i == null ? void 0 : i.forkHash) !== null &&
        (i == null ? void 0 : i.forkHash) !== void 0
      )
        return i.forkHash;
      if (!n) throw new Error('genesisHash required for forkHash calculation');
      return this._calcForkHash(r, n);
    }
    hardforkForForkHash(e) {
      const n = this.hardforks().filter((r) => r.forkHash === e);
      return n.length >= 1 ? n[n.length - 1] : null;
    }
    setForkHashes(e) {
      var n;
      for (const r of this.hardforks()) {
        const i = (n = r.timestamp) !== null && n !== void 0 ? n : r.block;
        (r.forkHash === null || r.forkHash === void 0) &&
          (i != null || typeof r.ttd < 'u') &&
          (r.forkHash = this.forkHash(r.name, e));
      }
    }
    genesis() {
      return this._chainParams.genesis;
    }
    hardforks() {
      return this._chainParams.hardforks;
    }
    bootstrapNodes() {
      return this._chainParams.bootstrapNodes;
    }
    dnsNetworks() {
      return this._chainParams.dnsNetworks;
    }
    hardfork() {
      return this._hardfork;
    }
    chainId() {
      return BigInt(this._chainParams.chainId);
    }
    chainName() {
      return this._chainParams.name;
    }
    networkId() {
      return BigInt(this._chainParams.networkId);
    }
    eips() {
      return this._eips;
    }
    consensusType() {
      const e = this.hardfork();
      let n;
      for (const r of this.HARDFORK_CHANGES)
        if (('consensus' in r[1] && (n = r[1].consensus.type), r[0] === e))
          break;
      return n ?? this._chainParams.consensus.type;
    }
    consensusAlgorithm() {
      const e = this.hardfork();
      let n;
      for (const r of this.HARDFORK_CHANGES)
        if (('consensus' in r[1] && (n = r[1].consensus.algorithm), r[0] === e))
          break;
      return n ?? this._chainParams.consensus.algorithm;
    }
    consensusConfig() {
      var e;
      const n = this.hardfork();
      let r;
      for (const i of this.HARDFORK_CHANGES)
        if (
          ('consensus' in i[1] &&
            (r = i[1].consensus[i[1].consensus.algorithm]),
          i[0] === n)
        )
          break;
      return (e =
        r ?? this._chainParams.consensus[this.consensusAlgorithm()]) !== null &&
        e !== void 0
        ? e
        : {};
    }
    copy() {
      const e = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
      return (e.removeAllListeners(), e);
    }
    static _getInitializedChains(e) {
      const n = {};
      for (const [i, s] of Object.entries(oh)) n[s] = i.toLowerCase();
      const r = {mainnet: d7, goerli: u7, sepolia: f7};
      if (e)
        for (const i of e) {
          const {name: s} = i;
          ((n[i.chainId.toString()] = s), (r[s] = i));
        }
      return ((r.names = n), r);
    }
  }
  var Jr;
  (function (t) {
    ((t[(t.EIP155ReplayProtection = 155)] = 'EIP155ReplayProtection'),
      (t[(t.EIP1559FeeMarket = 1559)] = 'EIP1559FeeMarket'),
      (t[(t.EIP2718TypedTransaction = 2718)] = 'EIP2718TypedTransaction'),
      (t[(t.EIP2930AccessLists = 2930)] = 'EIP2930AccessLists'));
  })(Jr || (Jr = {}));
  function eN(t) {
    if (t.length === 0) return !0;
    const e = t[0];
    return !!Array.isArray(e);
  }
  function tN(t) {
    return !eN(t);
  }
  class Wa {
    constructor(e) {
      if (e.length !== 20) throw new Error('Invalid address length');
      this.buf = e;
    }
    static zero() {
      return new Wa(bS(20));
    }
    equals(e) {
      return gp(this.buf, e.buf);
    }
    isZero() {
      return this.equals(Wa.zero());
    }
    toString() {
      return We(this.buf);
    }
    toArray() {
      return this.buf;
    }
    static publicToAddress(e, n = !1) {
      let r = e;
      if (
        (gv(r),
        n &&
          r.length !== 64 &&
          (r = ls.ProjectivePoint.fromHex(r).toRawBytes(!1).slice(1)),
        r.length !== 64)
      )
        throw new Error('Expected pubKey to be of length 64');
      return xn(r).slice(-20);
    }
  }
  const nN = (t, e) => {
      const n = t.param('vm', 'maxInitCodeSize');
      if (n && BigInt(e) > n)
        throw new Error(
          `the initcode size of this transaction is too large: it is ${e} while the max is ${t.param('vm', 'maxInitCodeSize')}`
        );
    },
    wS = (t) => {
      let e, n;
      if (tN(t)) {
        e = t;
        const r = [];
        for (let i = 0; i < t.length; i += 1) {
          const s = t[i],
            o = _t(s.address),
            a = [];
          for (let c = 0; c < s.storageKeys.length; c += 1)
            a.push(_t(s.storageKeys[c]));
          r.push([o, a]);
        }
        n = r;
      } else {
        n = t ?? [];
        const r = [];
        for (let i = 0; i < n.length; i += 1) {
          const s = n[i],
            o = We(s[0]),
            a = [];
          for (let l = 0; l < s[1].length; l += 1) a.push(We(s[1][l]));
          const c = {address: o, storageKeys: a};
          r.push(c);
        }
        e = r;
      }
      return {AccessListJSON: e, accessList: n};
    },
    _S = (t) => {
      for (let e = 0; e < t.length; e += 1) {
        const n = t[e],
          r = n[0],
          i = n[1];
        if (n[2] !== void 0)
          throw new Error(
            'Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.'
          );
        if (r.length !== 20)
          throw new Error(
            'Invalid EIP-2930 transaction: address length should be 20 bytes'
          );
        for (let s = 0; s < i.length; s += 1)
          if (i[s].length !== 32)
            throw new Error(
              'Invalid EIP-2930 transaction: storage slot length should be 32 bytes'
            );
      }
    },
    ES = (t) => {
      const e = [];
      for (let n = 0; n < t.length; n += 1) {
        const r = t[n],
          i = {address: We(pw(r[0], 20)), storageKeys: []},
          s = r && r[1];
        for (let o = 0; o < s.length; o += 1) {
          const a = s[o];
          i.storageKeys.push(We(pw(a, 32)));
        }
        e.push(i);
      }
      return e;
    },
    AS = (t, e) => {
      const n = e.param('gasPrices', 'accessListStorageKeyCost'),
        r = e.param('gasPrices', 'accessListAddressCost');
      let i = 0;
      for (let o = 0; o < t.length; o += 1) {
        const c = t[o][1];
        i += c.length;
      }
      return t.length * Number(r) + i * Number(n);
    };
  class yc {
    constructor(e, n) {
      var r, i;
      ((this.cache = {hash: void 0, dataFee: void 0}),
        (this.activeCapabilities = []),
        (this.DEFAULT_CHAIN = oh.Mainnet),
        (this.DEFAULT_HARDFORK = gt.Merge));
      const {
        nonce: s,
        gasLimit: o,
        to: a,
        value: c,
        data: l,
        v: u,
        r: d,
        s: f,
        type: h
      } = e;
      ((this._type = Number(mt(_t(h)))), (this.txOptions = n));
      const g = _t(a === '' ? '0x' : a),
        m = _t(u === '' ? '0x' : u),
        y = _t(d === '' ? '0x' : d),
        p = _t(f === '' ? '0x' : f);
      ((this.nonce = mt(_t(s === '' ? '0x' : s))),
        (this.gasLimit = mt(_t(o === '' ? '0x' : o))),
        (this.to = g.length > 0 ? new Wa(g) : void 0),
        (this.value = mt(_t(c === '' ? '0x' : c))),
        (this.data = _t(l === '' ? '0x' : l)),
        (this.v = m.length > 0 ? mt(m) : void 0),
        (this.r = y.length > 0 ? mt(y) : void 0),
        (this.s = p.length > 0 ? mt(p) : void 0),
        this._validateCannotExceedMaxInteger({
          value: this.value,
          r: this.r,
          s: this.s
        }),
        this._validateCannotExceedMaxInteger({gasLimit: this.gasLimit}, 64),
        this._validateCannotExceedMaxInteger({nonce: this.nonce}, 64, !0));
      const b = this.to === void 0 || this.to === null,
        v =
          (r = n.allowUnlimitedInitCodeSize) !== null && r !== void 0 ? r : !1,
        x = (i = n.common) !== null && i !== void 0 ? i : this._getCommon();
      b && x.isActivatedEIP(3860) && !v && nN(x, this.data.length);
    }
    get type() {
      return this._type;
    }
    supports(e) {
      return this.activeCapabilities.includes(e);
    }
    validate(e = !1) {
      const n = [];
      return (
        this.getBaseFee() > this.gasLimit &&
          n.push(
            `gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`
          ),
        this.isSigned() &&
          !this.verifySignature() &&
          n.push('Invalid Signature'),
        e ? n : n.length === 0
      );
    }
    _validateYParity() {
      const {v: e} = this;
      if (e !== void 0 && e !== BigInt(0) && e !== BigInt(1)) {
        const n = this._errorMsg(
          'The y-parity of the transaction should either be 0 or 1'
        );
        throw new Error(n);
      }
    }
    _validateHighS() {
      const {s: e} = this;
      if (this.common.gteHardfork('homestead') && e !== void 0 && e > ZO) {
        const n = this._errorMsg(
          'Invalid Signature: s-values greater than secp256k1n/2 are considered invalid'
        );
        throw new Error(n);
      }
    }
    getBaseFee() {
      const e = this.common.param('gasPrices', 'tx');
      let n = this.getDataFee();
      if (
        (e && (n += e),
        this.common.gteHardfork('homestead') && this.toCreationAddress())
      ) {
        const r = this.common.param('gasPrices', 'txCreation');
        r && (n += r);
      }
      return n;
    }
    getDataFee() {
      const e = this.common.param('gasPrices', 'txDataZero'),
        n = this.common.param('gasPrices', 'txDataNonZero');
      let r = BigInt(0);
      for (let i = 0; i < this.data.length; i += 1)
        this.data[i] === 0 ? (r += e) : (r += n);
      if (
        (this.to === void 0 || this.to === null) &&
        this.common.isActivatedEIP(3860)
      ) {
        const i = BigInt(Math.ceil(this.data.length / 32)),
          s = this.common.param('gasPrices', 'initCodeWordCost') * i;
        r += s;
      }
      return r;
    }
    toCreationAddress() {
      return this.to === void 0 || this.to.buf.length === 0;
    }
    isSigned() {
      const {v: e, r: n, s: r} = this;
      return !(e === void 0 || n === void 0 || r === void 0);
    }
    verifySignature() {
      try {
        const e = this.getSenderPublicKey();
        return ah(e).length !== 0;
      } catch {
        return !1;
      }
    }
    getSenderAddress() {
      return new Wa(Wa.publicToAddress(this.getSenderPublicKey()));
    }
    sign(e) {
      if (e.length !== 32) {
        const c = this._errorMsg('Private key must be 32 bytes in length.');
        throw new Error(c);
      }
      let n = !1;
      this.type === 0 &&
        this.common.gteHardfork('spuriousDragon') &&
        !this.supports(Jr.EIP155ReplayProtection) &&
        (this.activeCapabilities.push(Jr.EIP155ReplayProtection), (n = !0));
      const r = this.getMessageToSign(!0),
        {v: i, r: s, s: o} = this._ecsign(r, e),
        a = this._processSignature(i, s, o);
      if (n) {
        const c = this.activeCapabilities.indexOf(Jr.EIP155ReplayProtection);
        c > -1 && this.activeCapabilities.splice(c, 1);
      }
      return a;
    }
    _getCommon(e, n) {
      var r, i, s, o;
      if (n !== void 0) {
        const a = mt(_t(n));
        if (e) {
          if (e.chainId() !== a) {
            const c = this._errorMsg(
              'The chain ID does not match the chain ID of Common'
            );
            throw new Error(c);
          }
          return e.copy();
        }
        return Bt.isSupportedChainId(a)
          ? new Bt({chain: a, hardfork: this.DEFAULT_HARDFORK})
          : Bt.custom(
              {name: 'custom-chain', networkId: a, chainId: a},
              {baseChain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK}
            );
      }
      if (
        e != null &&
        e.copy &&
        typeof (e == null ? void 0 : e.copy) == 'function'
      )
        return e.copy();
      if (e) {
        const a = typeof e.hardfork == 'function' ? e.hardfork() : e.hardfork;
        return Bt.custom(
          {
            name: 'custom-chain',
            networkId: e.networkId
              ? e.networkId()
              : (i = BigInt(
                    (r = e.customChain) === null || r === void 0
                      ? void 0
                      : r.networkId
                  )) !== null && i !== void 0
                ? i
                : void 0,
            chainId: e.chainId
              ? e.chainId()
              : (o = BigInt(
                    (s = e.customChain) === null || s === void 0
                      ? void 0
                      : s.chainId
                  )) !== null && o !== void 0
                ? o
                : void 0
          },
          {baseChain: this.DEFAULT_CHAIN, hardfork: a || this.DEFAULT_HARDFORK}
        );
      }
      return new Bt({
        chain: this.DEFAULT_CHAIN,
        hardfork: this.DEFAULT_HARDFORK
      });
    }
    _validateCannotExceedMaxInteger(e, n = 256, r = !1) {
      for (const [i, s] of Object.entries(e))
        switch (n) {
          case 64:
            if (r) {
              if (s !== void 0 && s >= dw) {
                const o = this._errorMsg(
                  `${i} cannot equal or exceed MAX_UINT64 (2^64-1), given ${s}`
                );
                throw new Error(o);
              }
            } else if (s !== void 0 && s > dw) {
              const o = this._errorMsg(
                `${i} cannot exceed MAX_UINT64 (2^64-1), given ${s}`
              );
              throw new Error(o);
            }
            break;
          case 256:
            if (r) {
              if (s !== void 0 && s >= ru) {
                const o = this._errorMsg(
                  `${i} cannot equal or exceed MAX_INTEGER (2^256-1), given ${s}`
                );
                throw new Error(o);
              }
            } else if (s !== void 0 && s > ru) {
              const o = this._errorMsg(
                `${i} cannot exceed MAX_INTEGER (2^256-1), given ${s}`
              );
              throw new Error(o);
            }
            break;
          default: {
            const o = this._errorMsg('unimplemented bits value');
            throw new Error(o);
          }
        }
    }
    static _validateNotArray(e) {
      const n = [
        'nonce',
        'gasPrice',
        'gasLimit',
        'to',
        'value',
        'data',
        'v',
        'r',
        's',
        'type',
        'baseFee',
        'maxFeePerGas',
        'chainId'
      ];
      for (const [r, i] of Object.entries(e))
        if (n.includes(r) && Array.isArray(i))
          throw new Error(`${r} cannot be an array`);
    }
    _getSharedErrorPostfix() {
      let e = '';
      try {
        e = this.isSigned() ? We(this.hash()) : 'not available (unsigned)';
      } catch {
        e = 'error';
      }
      let n = '';
      try {
        n = this.isSigned().toString();
      } catch {
        e = 'error';
      }
      let r = '';
      try {
        r = this.common.hardfork();
      } catch {
        r = 'error';
      }
      let i = `tx type=${this.type} hash=${e} nonce=${this.nonce} value=${this.value} `;
      return ((i += `signed=${n} hf=${r}`), i);
    }
    _ecsign(e, n, r) {
      const i = ls.sign(e, n),
        s = i.toCompactRawBytes(),
        o = s.subarray(0, 32),
        a = s.subarray(32, 64),
        c =
          r === void 0
            ? BigInt(i.recovery + 27)
            : BigInt(i.recovery + 35) + BigInt(r) * BigInt(2);
      return {r: o, s: a, v: c};
    }
    static fromSerializedTx(e, n = {}) {}
    static fromTxData(e, n = {}) {}
  }
  const sg = 2,
    _m = bt(sg.toString(16).padStart(2, '0'));
  class To extends yc {
    static fromTxData(e, n = {}) {
      return new To(e, n);
    }
    static fromSerializedTx(e, n = {}) {
      if (!gp(e.subarray(0, 1), _m))
        throw new Error(
          `Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ${sg}, received: ${We(e.subarray(0, 1))}`
        );
      const r = vr.RLP.decode(e.subarray(1));
      if (!Array.isArray(r))
        throw new Error('Invalid serialized tx input: must be array');
      return To.fromValuesArray(r, n);
    }
    static fromValuesArray(e, n = {}) {
      if (e.length !== 9 && e.length !== 12)
        throw new Error(
          'Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).'
        );
      const [r, i, s, o, a, c, l, u, d, f, h, g] = e;
      return (
        this._validateNotArray({chainId: r, v: f}),
        Wy({
          nonce: i,
          maxPriorityFeePerGas: s,
          maxFeePerGas: o,
          gasLimit: a,
          value: l,
          v: f,
          r: h,
          s: g
        }),
        new To(
          {
            chainId: mt(r),
            nonce: i,
            maxPriorityFeePerGas: s,
            maxFeePerGas: o,
            gasLimit: a,
            to: c,
            value: l,
            data: u,
            accessList: d ?? [],
            v: f !== void 0 ? mt(f) : void 0,
            r: h,
            s: g
          },
          n
        )
      );
    }
    constructor(e, n = {}) {
      var r;
      (super(Object.assign(Object.assign({}, e), {type: sg}), n),
        (this.DEFAULT_HARDFORK = 'london'));
      const {
        chainId: i,
        accessList: s,
        maxFeePerGas: o,
        maxPriorityFeePerGas: a
      } = e;
      if (
        ((this.common = this._getCommon(n.common, i)),
        (this.chainId = this.common.chainId()),
        !this.common.isActivatedEIP(1559))
      )
        throw new Error('EIP-1559 not enabled on Common');
      this.activeCapabilities = this.activeCapabilities.concat([
        1559, 2718, 2930
      ]);
      const c = wS(s ?? []);
      if (
        ((this.accessList = c.accessList),
        (this.AccessListJSON = c.AccessListJSON),
        _S(this.accessList),
        (this.maxFeePerGas = mt(_t(o === '' ? '0x' : o))),
        (this.maxPriorityFeePerGas = mt(_t(a === '' ? '0x' : a))),
        this._validateCannotExceedMaxInteger({
          maxFeePerGas: this.maxFeePerGas,
          maxPriorityFeePerGas: this.maxPriorityFeePerGas
        }),
        yc._validateNotArray(e),
        this.gasLimit * this.maxFeePerGas > ru)
      ) {
        const u = this._errorMsg(
          'gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)'
        );
        throw new Error(u);
      }
      if (this.maxFeePerGas < this.maxPriorityFeePerGas) {
        const u = this._errorMsg(
          'maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)'
        );
        throw new Error(u);
      }
      (this._validateYParity(),
        this._validateHighS(),
        ((r = n == null ? void 0 : n.freeze) !== null && r !== void 0
          ? r
          : !0) && Object.freeze(this));
    }
    getDataFee() {
      if (
        this.cache.dataFee &&
        this.cache.dataFee.hardfork === this.common.hardfork()
      )
        return this.cache.dataFee.value;
      let e = super.getDataFee();
      return (
        (e += BigInt(AS(this.accessList, this.common))),
        Object.isFrozen(this) &&
          (this.cache.dataFee = {value: e, hardfork: this.common.hardfork()}),
        e
      );
    }
    getUpfrontCost(e = BigInt(0)) {
      const n = this.maxPriorityFeePerGas,
        r = this.maxFeePerGas - e,
        s = (n < r ? n : r) + e;
      return this.gasLimit * s + this.value;
    }
    raw() {
      return [
        Je(this.chainId),
        Je(this.nonce),
        Je(this.maxPriorityFeePerGas),
        Je(this.maxFeePerGas),
        Je(this.gasLimit),
        this.to !== void 0 ? this.to.buf : Uint8Array.from([]),
        Je(this.value),
        this.data,
        this.accessList,
        this.v !== void 0 ? Je(this.v) : Uint8Array.from([]),
        this.r !== void 0 ? Je(this.r) : Uint8Array.from([]),
        this.s !== void 0 ? Je(this.s) : Uint8Array.from([])
      ];
    }
    serialize() {
      const e = this.raw();
      return Mn(_m, vr.RLP.encode(e));
    }
    getMessageToSign(e = !0) {
      const n = this.raw().slice(0, 9),
        r = Mn(_m, vr.RLP.encode(n));
      return e ? xn(r) : r;
    }
    hash() {
      if (!this.isSigned()) {
        const e = this._errorMsg(
          'Cannot call hash method if transaction is not signed'
        );
        throw new Error(e);
      }
      return Object.isFrozen(this)
        ? (this.cache.hash || (this.cache.hash = xn(this.serialize())),
          this.cache.hash)
        : xn(this.serialize());
    }
    getMessageToVerifySignature() {
      return this.getMessageToSign();
    }
    getSenderPublicKey() {
      if (!this.isSigned()) {
        const s = this._errorMsg(
          'Cannot call this method if transaction is not signed'
        );
        throw new Error(s);
      }
      const e = this.getMessageToVerifySignature(),
        {v: n, r, s: i} = this;
      this._validateHighS();
      try {
        return yv(e, n + BigInt(27), Je(r), Je(i));
      } catch {
        const o = this._errorMsg('Invalid Signature');
        throw new Error(o);
      }
    }
    _processSignature(e, n, r) {
      const i = Object.assign(Object.assign({}, this.txOptions), {
        common: this.common
      });
      return To.fromTxData(
        {
          chainId: this.chainId,
          nonce: this.nonce,
          maxPriorityFeePerGas: this.maxPriorityFeePerGas,
          maxFeePerGas: this.maxFeePerGas,
          gasLimit: this.gasLimit,
          to: this.to,
          value: this.value,
          data: this.data,
          accessList: this.accessList,
          v: e - BigInt(27),
          r: mt(n),
          s: mt(r)
        },
        i
      );
    }
    toJSON() {
      const e = ES(this.accessList);
      return {
        chainId: Et(this.chainId),
        nonce: Et(this.nonce),
        maxPriorityFeePerGas: Et(this.maxPriorityFeePerGas),
        maxFeePerGas: Et(this.maxFeePerGas),
        gasLimit: Et(this.gasLimit),
        to: this.to !== void 0 ? this.to.toString() : void 0,
        value: Et(this.value),
        data: We(this.data),
        accessList: e,
        v: this.v !== void 0 ? Et(this.v) : void 0,
        r: this.r !== void 0 ? Et(this.r) : void 0,
        s: this.s !== void 0 ? Et(this.s) : void 0
      };
    }
    errorStr() {
      let e = this._getSharedErrorPostfix();
      return (
        (e += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`),
        e
      );
    }
    _errorMsg(e) {
      return `${e} (${this.errorStr()})`;
    }
  }
  const og = 1,
    Em = bt(og.toString(16).padStart(2, '0'));
  class Io extends yc {
    static fromTxData(e, n = {}) {
      return new Io(e, n);
    }
    static fromSerializedTx(e, n = {}) {
      if (!gp(e.subarray(0, 1), Em))
        throw new Error(
          `Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${og}, received: ${We(e.subarray(0, 1))}`
        );
      const r = vr.RLP.decode(Uint8Array.from(e.subarray(1)));
      if (!Array.isArray(r))
        throw new Error('Invalid serialized tx input: must be array');
      return Io.fromValuesArray(r, n);
    }
    static fromValuesArray(e, n = {}) {
      if (e.length !== 8 && e.length !== 11)
        throw new Error(
          'Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).'
        );
      const [r, i, s, o, a, c, l, u, d, f, h] = e;
      (this._validateNotArray({chainId: r, v: d}),
        Wy({nonce: i, gasPrice: s, gasLimit: o, value: c, v: d, r: f, s: h}));
      const g = [];
      return new Io(
        {
          chainId: mt(r),
          nonce: i,
          gasPrice: s,
          gasLimit: o,
          to: a,
          value: c,
          data: l,
          accessList: u ?? g,
          v: d !== void 0 ? mt(d) : void 0,
          r: f,
          s: h
        },
        n
      );
    }
    constructor(e, n = {}) {
      var r;
      (super(Object.assign(Object.assign({}, e), {type: og}), n),
        (this.DEFAULT_HARDFORK = 'berlin'));
      const {chainId: i, accessList: s, gasPrice: o} = e;
      if (
        ((this.common = this._getCommon(n.common, i)),
        (this.chainId = this.common.chainId()),
        !this.common.isActivatedEIP(2930))
      )
        throw new Error('EIP-2930 not enabled on Common');
      this.activeCapabilities = this.activeCapabilities.concat([2718, 2930]);
      const a = wS(s ?? []);
      if (
        ((this.accessList = a.accessList),
        (this.AccessListJSON = a.AccessListJSON),
        _S(this.accessList),
        (this.gasPrice = mt(_t(o === '' ? '0x' : o))),
        this._validateCannotExceedMaxInteger({gasPrice: this.gasPrice}),
        yc._validateNotArray(e),
        this.gasPrice * this.gasLimit > ru)
      ) {
        const l = this._errorMsg(
          'gasLimit * gasPrice cannot exceed MAX_INTEGER'
        );
        throw new Error(l);
      }
      (this._validateYParity(),
        this._validateHighS(),
        ((r = n == null ? void 0 : n.freeze) !== null && r !== void 0
          ? r
          : !0) && Object.freeze(this));
    }
    getDataFee() {
      if (
        this.cache.dataFee &&
        this.cache.dataFee.hardfork === this.common.hardfork()
      )
        return this.cache.dataFee.value;
      let e = super.getDataFee();
      return (
        (e += BigInt(AS(this.accessList, this.common))),
        Object.isFrozen(this) &&
          (this.cache.dataFee = {value: e, hardfork: this.common.hardfork()}),
        e
      );
    }
    getUpfrontCost() {
      return this.gasLimit * this.gasPrice + this.value;
    }
    raw() {
      return [
        Je(this.chainId),
        Je(this.nonce),
        Je(this.gasPrice),
        Je(this.gasLimit),
        this.to !== void 0 ? this.to.buf : Uint8Array.from([]),
        Je(this.value),
        this.data,
        this.accessList,
        this.v !== void 0 ? Je(this.v) : Uint8Array.from([]),
        this.r !== void 0 ? Je(this.r) : Uint8Array.from([]),
        this.s !== void 0 ? Je(this.s) : Uint8Array.from([])
      ];
    }
    serialize() {
      const e = this.raw();
      return Mn(Em, vr.RLP.encode(e));
    }
    getMessageToSign(e = !0) {
      const n = this.raw().slice(0, 8),
        r = Mn(Em, vr.RLP.encode(n));
      return e ? xn(r) : r;
    }
    hash() {
      if (!this.isSigned()) {
        const e = this._errorMsg(
          'Cannot call hash method if transaction is not signed'
        );
        throw new Error(e);
      }
      return Object.isFrozen(this)
        ? (this.cache.hash || (this.cache.hash = xn(this.serialize())),
          this.cache.hash)
        : xn(this.serialize());
    }
    getMessageToVerifySignature() {
      return this.getMessageToSign();
    }
    getSenderPublicKey() {
      if (!this.isSigned()) {
        const s = this._errorMsg(
          'Cannot call this method if transaction is not signed'
        );
        throw new Error(s);
      }
      const e = this.getMessageToVerifySignature(),
        {v: n, r, s: i} = this;
      this._validateHighS();
      try {
        return yv(e, n + BigInt(27), Je(r), Je(i));
      } catch {
        const o = this._errorMsg('Invalid Signature');
        throw new Error(o);
      }
    }
    _processSignature(e, n, r) {
      const i = Object.assign(Object.assign({}, this.txOptions), {
        common: this.common
      });
      return Io.fromTxData(
        {
          chainId: this.chainId,
          nonce: this.nonce,
          gasPrice: this.gasPrice,
          gasLimit: this.gasLimit,
          to: this.to,
          value: this.value,
          data: this.data,
          accessList: this.accessList,
          v: e - BigInt(27),
          r: mt(n),
          s: mt(r)
        },
        i
      );
    }
    toJSON() {
      const e = ES(this.accessList);
      return {
        chainId: Et(this.chainId),
        nonce: Et(this.nonce),
        gasPrice: Et(this.gasPrice),
        gasLimit: Et(this.gasLimit),
        to: this.to !== void 0 ? this.to.toString() : void 0,
        value: Et(this.value),
        data: We(this.data),
        accessList: e,
        v: this.v !== void 0 ? Et(this.v) : void 0,
        r: this.r !== void 0 ? Et(this.r) : void 0,
        s: this.s !== void 0 ? Et(this.s) : void 0
      };
    }
    errorStr() {
      var e, n;
      let r = this._getSharedErrorPostfix();
      return (
        (r += ` gasPrice=${this.gasPrice} accessListCount=${(n = (e = this.accessList) === null || e === void 0 ? void 0 : e.length) !== null && n !== void 0 ? n : 0}`),
        r
      );
    }
    _errorMsg(e) {
      return `${e} (${this.errorStr()})`;
    }
  }
  const rN = 0;
  function yw(t, e) {
    const n = Number(t),
      r = Number(e) * 2;
    return n === r + 35 || n === r + 36;
  }
  class $s extends yc {
    static fromTxData(e, n = {}) {
      return new $s(e, n);
    }
    static fromSerializedTx(e, n = {}) {
      const r = vr.RLP.decode(e);
      if (!Array.isArray(r))
        throw new Error('Invalid serialized tx input. Must be array');
      return this.fromValuesArray(r, n);
    }
    static fromValuesArray(e, n = {}) {
      if (e.length !== 6 && e.length !== 9)
        throw new Error(
          'Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).'
        );
      const [r, i, s, o, a, c, l, u, d] = e;
      return (
        Wy({nonce: r, gasPrice: i, gasLimit: s, value: a, v: l, r: u, s: d}),
        new $s(
          {
            nonce: r,
            gasPrice: i,
            gasLimit: s,
            to: o,
            value: a,
            data: c,
            v: l,
            r: u,
            s: d
          },
          n
        )
      );
    }
    constructor(e, n = {}) {
      var r;
      if (
        (super(Object.assign(Object.assign({}, e), {type: rN}), n),
        (this.common = this._validateTxV(this.v, n.common)),
        (this.gasPrice = mt(_t(e.gasPrice === '' ? '0x' : e.gasPrice))),
        this.gasPrice * this.gasLimit > ru)
      ) {
        const s = this._errorMsg(
          'gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)'
        );
        throw new Error(s);
      }
      (this._validateCannotExceedMaxInteger({gasPrice: this.gasPrice}),
        yc._validateNotArray(e),
        this.common.gteHardfork('spuriousDragon') &&
          (this.isSigned()
            ? yw(this.v, this.common.chainId()) &&
              this.activeCapabilities.push(Jr.EIP155ReplayProtection)
            : this.activeCapabilities.push(Jr.EIP155ReplayProtection)),
        ((r = n == null ? void 0 : n.freeze) !== null && r !== void 0
          ? r
          : !0) && Object.freeze(this));
    }
    raw() {
      return [
        Je(this.nonce),
        Je(this.gasPrice),
        Je(this.gasLimit),
        this.to !== void 0 ? this.to.buf : Uint8Array.from([]),
        Je(this.value),
        this.data,
        this.v !== void 0 ? Je(this.v) : Uint8Array.from([]),
        this.r !== void 0 ? Je(this.r) : Uint8Array.from([]),
        this.s !== void 0 ? Je(this.s) : Uint8Array.from([])
      ];
    }
    serialize() {
      return vr.RLP.encode(this.raw());
    }
    _getMessageToSign() {
      const e = [
        Je(this.nonce),
        Je(this.gasPrice),
        Je(this.gasLimit),
        this.to !== void 0 ? this.to.buf : Uint8Array.from([]),
        Je(this.value),
        this.data
      ];
      return (
        this.supports(Jr.EIP155ReplayProtection) &&
          (e.push(_t(this.common.chainId())),
          e.push(ah(_t(0))),
          e.push(ah(_t(0)))),
        e
      );
    }
    getMessageToSign(e = !0) {
      const n = this._getMessageToSign();
      return e ? xn(vr.RLP.encode(n)) : n;
    }
    getDataFee() {
      return this.cache.dataFee &&
        this.cache.dataFee.hardfork === this.common.hardfork()
        ? this.cache.dataFee.value
        : (Object.isFrozen(this) &&
            (this.cache.dataFee = {
              value: super.getDataFee(),
              hardfork: this.common.hardfork()
            }),
          super.getDataFee());
    }
    getUpfrontCost() {
      return this.gasLimit * this.gasPrice + this.value;
    }
    hash() {
      if (!this.isSigned()) {
        const e = this._errorMsg(
          'Cannot call hash method if transaction is not signed'
        );
        throw new Error(e);
      }
      return Object.isFrozen(this)
        ? (this.cache.hash || (this.cache.hash = xn(vr.RLP.encode(this.raw()))),
          this.cache.hash)
        : xn(vr.RLP.encode(this.raw()));
    }
    getMessageToVerifySignature() {
      if (!this.isSigned()) {
        const n = this._errorMsg('This transaction is not signed');
        throw new Error(n);
      }
      const e = this._getMessageToSign();
      return xn(vr.RLP.encode(e));
    }
    getSenderPublicKey() {
      const e = this.getMessageToVerifySignature(),
        {v: n, r, s: i} = this;
      this._validateHighS();
      try {
        return yv(
          e,
          n,
          Je(r),
          Je(i),
          this.supports(Jr.EIP155ReplayProtection)
            ? this.common.chainId()
            : void 0
        );
      } catch {
        const o = this._errorMsg('Invalid Signature');
        throw new Error(o);
      }
    }
    _processSignature(e, n, r) {
      let i = e;
      this.supports(Jr.EIP155ReplayProtection) &&
        (i += this.common.chainId() * BigInt(2) + BigInt(8));
      const s = Object.assign(Object.assign({}, this.txOptions), {
        common: this.common
      });
      return $s.fromTxData(
        {
          nonce: this.nonce,
          gasPrice: this.gasPrice,
          gasLimit: this.gasLimit,
          to: this.to,
          value: this.value,
          data: this.data,
          v: i,
          r: mt(n),
          s: mt(r)
        },
        s
      );
    }
    toJSON() {
      return {
        nonce: Et(this.nonce),
        gasPrice: Et(this.gasPrice),
        gasLimit: Et(this.gasLimit),
        to: this.to !== void 0 ? this.to.toString() : void 0,
        value: Et(this.value),
        data: We(this.data),
        v: this.v !== void 0 ? Et(this.v) : void 0,
        r: this.r !== void 0 ? Et(this.r) : void 0,
        s: this.s !== void 0 ? Et(this.s) : void 0
      };
    }
    _validateTxV(e, n) {
      let r;
      const i = e !== void 0 ? Number(e) : void 0;
      if (i !== void 0 && i < 37 && i !== 27 && i !== 28)
        throw new Error(
          `Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${i}`
        );
      if (
        i !== void 0 &&
        i !== 0 &&
        (!n || n.gteHardfork('spuriousDragon')) &&
        i !== 27 &&
        i !== 28
      )
        if (n) {
          if (!yw(BigInt(i), n.chainId()))
            throw new Error(
              `Incompatible EIP155-based V ${i} and chain id ${n.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`
            );
        } else {
          let s;
          ((i - 35) % 2 === 0 ? (s = 35) : (s = 36),
            (r = BigInt(i - s) / BigInt(2)));
        }
      return this._getCommon(n, r);
    }
    errorStr() {
      let e = this._getSharedErrorPostfix();
      return ((e += ` gasPrice=${this.gasPrice}`), e);
    }
    _errorMsg(e) {
      return `${e} (${this.errorStr()})`;
    }
  }
  const Am = new Map();
  class ea {
    constructor() {}
    static typeToInt(e) {
      return Number(mt(_t(e)));
    }
    static registerTransactionType(e, n) {
      const r = ea.typeToInt(e);
      Am.set(r, n);
    }
    static fromTxData(e, n = {}) {
      if (!('type' in e) || e.type === void 0) return $s.fromTxData(e, n);
      const r = ea.typeToInt(e.type);
      if (r === 0) return $s.fromTxData(e, n);
      if (r === 1) return Io.fromTxData(e, n);
      if (r === 2) return To.fromTxData(e, n);
      const i = Am.get(r);
      if (i != null && i.fromTxData) return i.fromTxData(e, n);
      throw new Error(`Tx instantiation with type ${r} not supported`);
    }
    static fromSerializedData(e, n = {}) {
      if (e[0] <= 127)
        switch (e[0]) {
          case 1:
            return Io.fromSerializedTx(e, n);
          case 2:
            return To.fromSerializedTx(e, n);
          default: {
            const r = Am.get(Number(e[0]));
            if (r != null && r.fromSerializedTx)
              return r.fromSerializedTx(e, n);
            throw new Error(`TypedTransaction with ID ${e[0]} unknown`);
          }
        }
      else return $s.fromSerializedTx(e, n);
    }
    static fromBlockBodyData(e, n = {}) {
      if (co(e)) return this.fromSerializedData(e, n);
      if (Array.isArray(e)) return $s.fromValuesArray(e, n);
      throw new Error('Cannot decode transaction: unknown type input');
    }
  }
  var Cp = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  const Pc = (t, e) => {
      let n;
      if (!e && typeof t == 'string' && it(t) && t.length !== 66)
        throw new kb();
      try {
        n = co(t) ? t : yi(t);
      } catch {
        throw new CR();
      }
      if (!e && n.byteLength !== 32) throw new kb();
      return n;
    },
    vv = (t, e = !1) => {
      const n = it(t) ? t : Hr(t),
        r = bt(n),
        i = bt(
          M3(`Ethereum Signed Message:
${r.byteLength}`)
        ),
        s = e ? r : Mn(i, r);
      return rr(s);
    },
    iN = (t, e) => {
      const n = Pc(e),
        r = ls.sign(t.substring(2), n),
        i = r.toCompactRawBytes(),
        s = r.r.toString(16).padStart(64, '0'),
        o = r.s.toString(16).padStart(64, '0'),
        a = r.recovery + 27;
      return {
        messageHash: t,
        v: $t(a),
        r: `0x${s}`,
        s: `0x${o}`,
        signature: `${We(i)}${a.toString(16)}`
      };
    },
    SS = (t, e) => {
      const n = vv(t),
        {messageHash: r, v: i, r: s, s: o, signature: a} = iN(n, e);
      return {message: t, messageHash: r, v: i, r: s, s: o, signature: a};
    },
    sN = (t, e) =>
      Cp(void 0, void 0, void 0, function* () {
        const n = t.sign(bt(e));
        if (ie(n.v) || ie(n.r) || ie(n.s)) throw new G0('Signer Error');
        const r = n.validate(!0);
        if (r.length > 0) {
          let o = 'Signer Error ';
          for (const a of r) o += `${o} ${a}.`;
          throw new G0(o);
        }
        const i = We(n.serialize()),
          s = rr(i);
        return {
          messageHash: We(n.getMessageToSign(!0)),
          v: `0x${n.v.toString(16)}`,
          r: `0x${n.r.toString(16).padStart(64, '0')}`,
          s: `0x${n.s.toString(16).padStart(64, '0')}`,
          rawTransaction: i,
          transactionHash: We(s)
        };
      }),
    oN = (t) => {
      if (ie(t)) throw new KR();
      const e = ea.fromSerializedData(bt(t));
      return _i(e.getSenderAddress().toString());
    },
    ag = (t, e, n, r, i) => {
      if (typeof t == 'object') {
        const d = `${t.r}${t.s.slice(2)}${t.v.slice(2)}`;
        return ag(t.messageHash, d, n);
      }
      if (typeof e == 'string' && typeof n == 'string' && !ie(r)) {
        const d = `${n}${r.slice(2)}${e.slice(2)}`;
        return ag(t, d, i);
      }
      if (ie(e)) throw new TR('signature string undefined');
      const s = 130,
        o = n ? t : vv(t);
      let a = parseInt(e.substring(s), 16);
      a > 26 && (a -= 27);
      const c = ls.Signature.fromCompact(e.slice(2, s))
          .addRecoveryBit(a)
          .recoverPublicKey(o.replace('0x', ''))
          .toRawBytes(!1),
        l = rr(c.subarray(1));
      return _i(`0x${l.slice(-40)}`);
    },
    Tp = (t) => {
      const e = Pc(t),
        n = ls.getPublicKey(e, !1),
        i = rr(n.slice(1)).slice(-40);
      return _i(`0x${i}`);
    },
    aN = (t, e) => {
      const n = Pc(t);
      return `0x${We(ls.getPublicKey(n, e)).slice(4)}`;
    },
    xS = (t, e, n) =>
      Cp(void 0, void 0, void 0, function* () {
        var r, i, s, o, a, c, l;
        const u = Pc(t);
        let d;
        if (
          (n != null && n.salt
            ? (d = typeof n.salt == 'string' ? bt(n.salt) : n.salt)
            : (d = eu(32)),
          !(Gy(e) || co(e)))
        )
          throw new RR();
        const f = typeof e == 'string' ? bt(Hr(e)) : e;
        let h;
        if (n != null && n.iv) {
          if (
            ((h = typeof n.iv == 'string' ? bt(n.iv) : n.iv), h.length !== 16)
          )
            throw new PR();
        } else h = eu(16);
        const g =
          (r = n == null ? void 0 : n.kdf) !== null && r !== void 0
            ? r
            : 'scrypt';
        let m, y;
        if (g === 'pbkdf2') {
          if (
            ((y = {
              dklen:
                (i = n == null ? void 0 : n.dklen) !== null && i !== void 0
                  ? i
                  : 32,
              salt: We(d).replace('0x', ''),
              c:
                (s = n == null ? void 0 : n.c) !== null && s !== void 0
                  ? s
                  : 262144,
              prf: 'hmac-sha256'
            }),
            y.c < 1e3)
          )
            throw new MR();
          m = oS(f, d, y.c, y.dklen, 'sha256');
        } else if (g === 'scrypt')
          ((y = {
            n:
              (o = n == null ? void 0 : n.n) !== null && o !== void 0
                ? o
                : 8192,
            r: (a = n == null ? void 0 : n.r) !== null && a !== void 0 ? a : 8,
            p: (c = n == null ? void 0 : n.p) !== null && c !== void 0 ? c : 1,
            dklen:
              (l = n == null ? void 0 : n.dklen) !== null && l !== void 0
                ? l
                : 32,
            salt: We(d).replace('0x', '')
          }),
            (m = aS(f, d, y.n, y.p, y.r, y.dklen)));
        else throw new GA();
        const p = yield cv(u, m.slice(0, 16), h, 'aes-128-ctr'),
          b = We(p).slice(2),
          v = rr(Mn(m.slice(16, 32), p)).replace('0x', '');
        return {
          version: 3,
          id: nv(),
          address: Tp(u).toLowerCase().replace('0x', ''),
          crypto: {
            ciphertext: b,
            cipherparams: {iv: We(h).replace('0x', '')},
            cipher: 'aes-128-ctr',
            kdf: g,
            kdfparams: y,
            mac: v
          }
        };
      }),
    bv = (t, e) => {
      const n = Pc(t, e);
      return {
        address: Tp(n),
        privateKey: We(n),
        signTransaction: (r) => {
          throw new G0('Do not have network access to sign the transaction');
        },
        sign: (r) => SS(typeof r == 'string' ? r : JSON.stringify(r), n),
        encrypt: (r, i) =>
          Cp(void 0, void 0, void 0, function* () {
            return xS(n, r, i);
          })
      };
    },
    cN = () => {
      const t = ls.utils.randomPrivateKey();
      return bv(`${We(t)}`);
    },
    lN = (t, e, n) =>
      Cp(void 0, void 0, void 0, function* () {
        const r =
          typeof t == 'object' ? t : JSON.parse(n ? t.toLowerCase() : t);
        if ((Ie.validateJSONSchema(YO, r), r.version !== 3)) throw new kR();
        const i = typeof e == 'string' ? bt(Hr(e)) : e;
        Ie.validate(['bytes'], [i]);
        let s;
        if (r.crypto.kdf === 'scrypt') {
          const l = r.crypto.kdfparams,
            u = typeof l.salt == 'string' ? bt(l.salt) : l.salt;
          s = aS(i, u, l.n, l.p, l.r, l.dklen);
        } else if (r.crypto.kdf === 'pbkdf2') {
          const l = r.crypto.kdfparams,
            u = typeof l.salt == 'string' ? bt(l.salt) : l.salt;
          s = oS(i, u, l.c, l.dklen, 'sha256');
        } else throw new GA();
        const o = bt(r.crypto.ciphertext);
        if (rr(Mn(s.slice(16, 32), o)).replace('0x', '') !== r.crypto.mac)
          throw new IR();
        const c = yield rO(
          bt(r.crypto.ciphertext),
          s.slice(0, 16),
          bt(r.crypto.cipherparams.iv)
        );
        return bv(c);
      });
  var vw = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  const uN = 1e3;
  class dN {
    constructor(e) {
      ((this._requestManager = e), (this._requests = new Map()));
    }
    get requests() {
      return [...this._requests.values()].map((e) => e.payload);
    }
    add(e) {
      const n = Qo(e),
        r = new nh();
      return (this._requests.set(n.id, {payload: n, promise: r}), r);
    }
    execute(e) {
      return vw(this, void 0, void 0, function* () {
        var n;
        if (this.requests.length === 0) return Promise.resolve([]);
        const r = new nh({
          timeout:
            (n = e == null ? void 0 : e.timeout) !== null && n !== void 0
              ? n
              : uN,
          eagerStart: !0,
          timeoutMessage: 'Batch request timeout'
        });
        return (
          this._processBatchRequest(r).catch((i) => r.reject(i)),
          r.catch((i) => {
            (i instanceof zA && this._abortAllRequests('Batch request timeout'),
              r.reject(i));
          }),
          r
        );
      });
    }
    _processBatchRequest(e) {
      return vw(this, void 0, void 0, function* () {
        var n, r;
        const i = yield this._requestManager.sendBatch(
          [...this._requests.values()].map((a) => a.payload)
        );
        if (i.length !== this._requests.size)
          throw (
            this._abortAllRequests('Invalid batch response'),
            new Qr(
              i,
              `Batch request size mismatch the results size. Requests: ${this._requests.size}, Responses: ${i.length}`
            )
          );
        const s = this.requests
            .map((a) => a.id)
            .map(Number)
            .sort((a, c) => a - c),
          o = i
            .map((a) => a.id)
            .map(Number)
            .sort((a, c) => a - c);
        if (JSON.stringify(s) !== JSON.stringify(o))
          throw (
            this._abortAllRequests('Invalid batch response'),
            new Qr(
              i,
              `Batch request mismatch the results. Requests: [${s.join()}], Responses: [${o.join()}]`
            )
          );
        for (const a of i)
          Vs(a)
            ? (n = this._requests.get(a.id)) === null ||
              n === void 0 ||
              n.promise.resolve(a.result)
            : Gs(a) &&
              ((r = this._requests.get(a.id)) === null ||
                r === void 0 ||
                r.promise.reject(a.error));
        e.resolve(i);
      });
    }
    _abortAllRequests(e) {
      for (const {promise: n} of this._requests.values()) n.reject(new $R(e));
    }
  }
  var fN = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  class Un extends Y9 {
    constructor(e) {
      var n;
      if (
        (super(),
        (this.providers = Fo.providers),
        Re(e) || (typeof e == 'string' && e.trim() !== '') || rh(e))
      ) {
        ((this._requestManager = new Fo(e)),
          (this._subscriptionManager = new ih(this._requestManager, {})));
        return;
      }
      const {
        config: r,
        provider: i,
        requestManager: s,
        subscriptionManager: o,
        registeredSubscriptions: a,
        accountProvider: c,
        wallet: l,
        requestManagerMiddleware: u
      } = e;
      (this.setConfig(r ?? {}),
        (this._requestManager =
          s ??
          new Fo(
            i,
            (n = r == null ? void 0 : r.enableExperimentalFeatures) === null ||
            n === void 0
              ? void 0
              : n.useSubscriptionWhenCheckingBlockTimeout,
            u
          )),
        o
          ? (this._subscriptionManager = o)
          : (this._subscriptionManager = new ih(this.requestManager, a ?? {})),
        c && (this._accountProvider = c),
        l && (this._wallet = l));
    }
    get requestManager() {
      return this._requestManager;
    }
    get subscriptionManager() {
      return this._subscriptionManager;
    }
    get wallet() {
      return this._wallet;
    }
    get accountProvider() {
      return this._accountProvider;
    }
    static fromContextObject(...e) {
      return new this(...e.reverse());
    }
    getContextObject() {
      var e;
      return {
        config: this.config,
        provider: this.provider,
        requestManager: this.requestManager,
        subscriptionManager: this.subscriptionManager,
        registeredSubscriptions:
          (e = this.subscriptionManager) === null || e === void 0
            ? void 0
            : e.registeredSubscriptions,
        providers: this.providers,
        wallet: this.wallet,
        accountProvider: this.accountProvider
      };
    }
    use(e, ...n) {
      const r = new e(...n, this.getContextObject());
      return (
        this.on(Jo.CONFIG_CHANGE, (i) => {
          r.setConfig({[i.name]: i.newValue});
        }),
        (this[e.name] = r),
        r
      );
    }
    link(e) {
      (this.setConfig(e.config),
        (this._requestManager = e.requestManager),
        (this.provider = e.provider),
        (this._subscriptionManager = e.subscriptionManager),
        (this._wallet = e.wallet),
        (this._accountProvider = e._accountProvider),
        e.on(Jo.CONFIG_CHANGE, (n) => {
          this.setConfig({[n.name]: n.newValue});
        }));
    }
    registerPlugin(e) {
      if (this[e.pluginNamespace] !== void 0) throw new HR(e.pluginNamespace);
      const n = {[e.pluginNamespace]: e};
      (n[e.pluginNamespace].link(this), Object.assign(this, n));
    }
    get provider() {
      return this.currentProvider;
    }
    set provider(e) {
      this.requestManager.setProvider(e);
    }
    get currentProvider() {
      return this.requestManager.provider;
    }
    set currentProvider(e) {
      this.requestManager.setProvider(e);
    }
    get givenProvider() {
      return Un.givenProvider;
    }
    setProvider(e) {
      return ((this.provider = e), !0);
    }
    setRequestManagerMiddleware(e) {
      this.requestManager.setMiddleware(e);
    }
    get BatchRequest() {
      return dN.bind(void 0, this._requestManager);
    }
    extend(e) {
      var n;
      return (
        e.property && !this[e.property] && (this[e.property] = {}),
        (n = e.methods) === null ||
          n === void 0 ||
          n.forEach((r) => {
            const i = (...s) =>
              fN(this, void 0, void 0, function* () {
                return this.requestManager.send({method: r.call, params: s});
              });
            e.property ? (this[e.property][r.name] = i) : (this[r.name] = i);
          }),
        this
      );
    }
  }
  Un.providers = Fo.providers;
  class Ot {
    constructor(e) {
      if (
        ((this.toAddress = () => {
          if (this.isDirect()) {
            const n = this._iban.slice(4),
              r = Ot._parseInt(n, 36),
              i = Jl(r, 40);
            return _i(i);
          }
          throw new Error(
            'Iban is indirect and cannot be converted. Must be length of 34 or 35'
          );
        }),
        Ot.isIndirect(e) || Ot.isDirect(e))
      )
        this._iban = e;
      else throw new Error('Invalid IBAN was provided');
    }
    static isDirect(e) {
      return e.length === 34 || e.length === 35;
    }
    isDirect() {
      return Ot.isDirect(this._iban);
    }
    static isIndirect(e) {
      return e.length === 20;
    }
    isIndirect() {
      return Ot.isIndirect(this._iban);
    }
    static isValid(e) {
      return (
        /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(e) &&
        Ot._mod9710(Ot._iso13616Prepare(e)) === 1
      );
    }
    isValid() {
      return Ot.isValid(this._iban);
    }
    static fromBban(e) {
      const n = 'XE',
        i =
          `0${(98 - this._mod9710(this._iso13616Prepare(`${n}00${e}`))).toString()}`.slice(
            -2
          );
      return new Ot(`${n}${i}${e}`);
    }
    static createIndirect(e) {
      return Ot.fromBban(`ETH${e.institution}${e.identifier}`);
    }
    static fromAddress(e) {
      if (!nr(e)) throw new $y(e);
      const r = BigInt(Mu(e)).toString(36),
        i = Jl(r, 15);
      return Ot.fromBban(i.toUpperCase());
    }
    static toIban(e) {
      return Ot.fromAddress(e).toString();
    }
    client() {
      return this.isIndirect() ? this._iban.slice(11) : '';
    }
    checksum() {
      return this._iban.slice(2, 4);
    }
    institution() {
      return this.isIndirect() ? this._iban.slice(7, 11) : '';
    }
    toString() {
      return this._iban;
    }
  }
  Ot._iso13616Prepare = (t) => {
    const r = t.toUpperCase();
    return `${r.slice(4)}${r.slice(0, 4)}`
      .split('')
      .map((s) => {
        const o = s.charCodeAt(0);
        return o >= 65 && o <= 90 ? o - 65 + 10 : s;
      })
      .join('');
  };
  Ot._parseInt = (t, e) =>
    [...t].reduce((n, r) => BigInt(parseInt(r, e)) + BigInt(e) * n, BigInt(0));
  Ot._mod9710 = (t) => {
    let e = t,
      n;
    for (; e.length > 2; )
      ((n = e.slice(0, 9)),
        (e = `${(parseInt(n, 10) % 97).toString()}${e.slice(n.length)}`));
    return parseInt(e, 10) % 97;
  };
  Ot.toAddress = (t) => new Ot(t).toAddress();
  var Sm = function (t, e, n, r) {
      function i(s) {
        return s instanceof n
          ? s
          : new n(function (o) {
              o(s);
            });
      }
      return new (n || (n = Promise))(function (s, o) {
        function a(u) {
          try {
            l(r.next(u));
          } catch (d) {
            o(d);
          }
        }
        function c(u) {
          try {
            l(r.throw(u));
          } catch (d) {
            o(d);
          }
        }
        function l(u) {
          u.done ? s(u.value) : i(u.value).then(a, c);
        }
        l((r = r.apply(t, e || [])).next());
      });
    },
    CS;
  class TS extends Ep {
    constructor(e) {
      (super(), (this[CS] = 'Promise'), (this._promise = new Promise(e)));
    }
    then(e, n) {
      return Sm(this, void 0, void 0, function* () {
        return this._promise.then(e, n);
      });
    }
    catch(e) {
      return Sm(this, void 0, void 0, function* () {
        return this._promise.catch(e);
      });
    }
    finally(e) {
      return Sm(this, void 0, void 0, function* () {
        return this._promise.finally(e);
      });
    }
    on(e, n) {
      return (super.on(e, n), this);
    }
    once(e, n) {
      return (super.once(e, n), this);
    }
  }
  CS = Symbol.toStringTag;
  var xm = {},
    bw;
  function hN() {
    return (
      bw ||
        ((bw = 1),
        (function (t, e) {
          if (t.setImmediate) return;
          var n = 1,
            r = {},
            i = !1,
            s = t.document,
            o;
          function a(b) {
            typeof b != 'function' && (b = new Function('' + b));
            for (
              var v = new Array(arguments.length - 1), x = 0;
              x < v.length;
              x++
            )
              v[x] = arguments[x + 1];
            var C = {callback: b, args: v};
            return ((r[n] = C), o(n), n++);
          }
          function c(b) {
            delete r[b];
          }
          function l(b) {
            var v = b.callback,
              x = b.args;
            switch (x.length) {
              case 0:
                v();
                break;
              case 1:
                v(x[0]);
                break;
              case 2:
                v(x[0], x[1]);
                break;
              case 3:
                v(x[0], x[1], x[2]);
                break;
              default:
                v.apply(e, x);
                break;
            }
          }
          function u(b) {
            if (i) setTimeout(u, 0, b);
            else {
              var v = r[b];
              if (v) {
                i = !0;
                try {
                  l(v);
                } finally {
                  (c(b), (i = !1));
                }
              }
            }
          }
          function d() {
            o = function (b) {
              process.nextTick(function () {
                u(b);
              });
            };
          }
          function f() {
            if (t.postMessage && !t.importScripts) {
              var b = !0,
                v = t.onmessage;
              return (
                (t.onmessage = function () {
                  b = !1;
                }),
                t.postMessage('', '*'),
                (t.onmessage = v),
                b
              );
            }
          }
          function h() {
            var b = 'setImmediate$' + Math.random() + '$',
              v = function (x) {
                x.source === t &&
                  typeof x.data == 'string' &&
                  x.data.indexOf(b) === 0 &&
                  u(+x.data.slice(b.length));
              };
            (t.addEventListener
              ? t.addEventListener('message', v, !1)
              : t.attachEvent('onmessage', v),
              (o = function (x) {
                t.postMessage(b + x, '*');
              }));
          }
          function g() {
            var b = new MessageChannel();
            ((b.port1.onmessage = function (v) {
              var x = v.data;
              u(x);
            }),
              (o = function (v) {
                b.port2.postMessage(v);
              }));
          }
          function m() {
            var b = s.documentElement;
            o = function (v) {
              var x = s.createElement('script');
              ((x.onreadystatechange = function () {
                (u(v),
                  (x.onreadystatechange = null),
                  b.removeChild(x),
                  (x = null));
              }),
                b.appendChild(x));
            };
          }
          function y() {
            o = function (b) {
              setTimeout(u, 0, b);
            };
          }
          var p = Object.getPrototypeOf && Object.getPrototypeOf(t);
          ((p = p && p.setTimeout ? p : t),
            {}.toString.call(t.process) === '[object process]'
              ? d()
              : f()
                ? h()
                : t.MessageChannel
                  ? g()
                  : s && 'onreadystatechange' in s.createElement('script')
                    ? m()
                    : y(),
            (p.setImmediate = a),
            (p.clearImmediate = c));
        })(typeof self > 'u' ? (typeof Oa > 'u' ? xm : Oa) : self)),
      xm
    );
  }
  hN();
  var Le = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  function pN(t) {
    return Le(this, void 0, void 0, function* () {
      return t.send({method: 'eth_protocolVersion', params: []});
    });
  }
  function IS(t) {
    return Le(this, void 0, void 0, function* () {
      return t.send({method: 'eth_syncing', params: []});
    });
  }
  function mN(t) {
    return Le(this, void 0, void 0, function* () {
      return t.send({method: 'eth_coinbase', params: []});
    });
  }
  function gN(t) {
    return Le(this, void 0, void 0, function* () {
      return t.send({method: 'eth_mining', params: []});
    });
  }
  function yN(t) {
    return Le(this, void 0, void 0, function* () {
      return t.send({method: 'eth_hashrate', params: []});
    });
  }
  function vN(t) {
    return Le(this, void 0, void 0, function* () {
      return t.send({method: 'eth_gasPrice', params: []});
    });
  }
  function bN(t) {
    return Le(this, void 0, void 0, function* () {
      return t.send({method: 'eth_maxPriorityFeePerGas', params: []});
    });
  }
  function wN(t) {
    return Le(this, void 0, void 0, function* () {
      return t.send({method: 'eth_accounts', params: []});
    });
  }
  function _N(t) {
    return Le(this, void 0, void 0, function* () {
      return t.send({method: 'eth_blockNumber', params: []});
    });
  }
  function EN(t, e, n) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['address', 'blockNumberOrTag'], [e, n]),
        t.send({method: 'eth_getBalance', params: [e, n]})
      );
    });
  }
  function AN(t, e, n, r) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['address', 'hex', 'blockNumberOrTag'], [e, n, r]),
        t.send({method: 'eth_getStorageAt', params: [e, n, r]})
      );
    });
  }
  function SN(t, e, n) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['address', 'blockNumberOrTag'], [e, n]),
        t.send({method: 'eth_getTransactionCount', params: [e, n]})
      );
    });
  }
  function xN(t, e) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['bytes32'], [e]),
        t.send({method: 'eth_getBlockTransactionCountByHash', params: [e]})
      );
    });
  }
  function CN(t, e) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['blockNumberOrTag'], [e]),
        t.send({method: 'eth_getBlockTransactionCountByNumber', params: [e]})
      );
    });
  }
  function TN(t, e) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['bytes32'], [e]),
        t.send({method: 'eth_getUncleCountByBlockHash', params: [e]})
      );
    });
  }
  function IN(t, e) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['blockNumberOrTag'], [e]),
        t.send({method: 'eth_getUncleCountByBlockNumber', params: [e]})
      );
    });
  }
  function kN(t, e, n) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['address', 'blockNumberOrTag'], [e, n]),
        t.send({method: 'eth_getCode', params: [e, n]})
      );
    });
  }
  function RN(t, e, n) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['address', 'hex'], [e, n]),
        t.send({method: 'eth_sign', params: [e, n]})
      );
    });
  }
  function PN(t, e) {
    return Le(this, void 0, void 0, function* () {
      return t.send({method: 'eth_signTransaction', params: [e]});
    });
  }
  function MN(t, e) {
    return Le(this, void 0, void 0, function* () {
      return t.send({method: 'eth_sendTransaction', params: [e]});
    });
  }
  function kS(t, e) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['hex'], [e]),
        t.send({method: 'eth_sendRawTransaction', params: [e]})
      );
    });
  }
  function ON(t, e, n) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['blockNumberOrTag'], [n]),
        t.send({method: 'eth_call', params: [e, n]})
      );
    });
  }
  function NN(t, e, n) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['blockNumberOrTag'], [n]),
        t.send({method: 'eth_estimateGas', params: [e, n]})
      );
    });
  }
  function LN(t, e, n) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['bytes32', 'bool'], [e, n]),
        t.send({method: 'eth_getBlockByHash', params: [e, n]})
      );
    });
  }
  function RS(t, e, n) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['blockNumberOrTag', 'bool'], [e, n]),
        t.send({method: 'eth_getBlockByNumber', params: [e, n]})
      );
    });
  }
  function BN(t, e) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['bytes32'], [e]),
        t.send({method: 'eth_getTransactionByHash', params: [e]})
      );
    });
  }
  function DN(t, e, n) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['bytes32', 'hex'], [e, n]),
        t.send({
          method: 'eth_getTransactionByBlockHashAndIndex',
          params: [e, n]
        })
      );
    });
  }
  function FN(t, e, n) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['blockNumberOrTag', 'hex'], [e, n]),
        t.send({
          method: 'eth_getTransactionByBlockNumberAndIndex',
          params: [e, n]
        })
      );
    });
  }
  function $N(t, e) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['bytes32'], [e]),
        t.send({method: 'eth_getTransactionReceipt', params: [e]})
      );
    });
  }
  function HN(t, e, n) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['bytes32', 'hex'], [e, n]),
        t.send({method: 'eth_getUncleByBlockHashAndIndex', params: [e, n]})
      );
    });
  }
  function jN(t, e, n) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['blockNumberOrTag', 'hex'], [e, n]),
        t.send({method: 'eth_getUncleByBlockNumberAndIndex', params: [e, n]})
      );
    });
  }
  function UN(t, e) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['filter'], [e]),
        t.send({method: 'eth_newFilter', params: [e]})
      );
    });
  }
  function KN(t) {
    return Le(this, void 0, void 0, function* () {
      return t.send({method: 'eth_newBlockFilter', params: []});
    });
  }
  function qN(t) {
    return Le(this, void 0, void 0, function* () {
      return t.send({method: 'eth_newPendingTransactionFilter', params: []});
    });
  }
  function VN(t, e) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['hex'], [e]),
        t.send({method: 'eth_uninstallFilter', params: [e]})
      );
    });
  }
  function GN(t, e) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['hex'], [e]),
        t.send({method: 'eth_getFilterChanges', params: [e]})
      );
    });
  }
  function zN(t, e) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['hex'], [e]),
        t.send({method: 'eth_getFilterLogs', params: [e]})
      );
    });
  }
  function WN(t, e) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['filter'], [e]),
        t.send({method: 'eth_getLogs', params: [e]})
      );
    });
  }
  function ZN(t) {
    return Le(this, void 0, void 0, function* () {
      return t.send({method: 'eth_getWork', params: []});
    });
  }
  function YN(t, e, n, r) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['bytes8', 'bytes32', 'bytes32'], [e, n, r]),
        t.send({method: 'eth_submitWork', params: [e, n, r]})
      );
    });
  }
  function QN(t, e, n, r) {
    return Le(this, void 0, void 0, function* () {
      Ie.validate(['hex', 'blockNumberOrTag'], [e, n]);
      for (const i of r) Ie.validate(['number'], [i]);
      return t.send({method: 'eth_feeHistory', params: [e, n, r]});
    });
  }
  function JN(t) {
    return Le(this, void 0, void 0, function* () {
      return t.send({method: 'eth_pendingTransactions', params: []});
    });
  }
  function XN(t) {
    return Le(this, void 0, void 0, function* () {
      return t.send({method: 'eth_requestAccounts', params: []});
    });
  }
  function eL(t) {
    return Le(this, void 0, void 0, function* () {
      return t.send({method: 'eth_chainId', params: []});
    });
  }
  function tL(t, e, n, r) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['address', 'bytes32[]', 'blockNumberOrTag'], [e, n, r]),
        t.send({method: 'eth_getProof', params: [e, n, r]})
      );
    });
  }
  function nL(t) {
    return Le(this, void 0, void 0, function* () {
      return t.send({method: 'web3_clientVersion', params: []});
    });
  }
  function rL(t, e, n) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['blockNumberOrTag'], [n]),
        t.send({method: 'eth_createAccessList', params: [e, n]})
      );
    });
  }
  function iL(t, e, n, r = !1) {
    return Le(this, void 0, void 0, function* () {
      return (
        Ie.validate(['address'], [e]),
        t.send({method: `eth_signTypedData${r ? '' : '_v4'}`, params: [e, n]})
      );
    });
  }
  var wv = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  function sL(t) {
    return wv(this, void 0, void 0, function* () {
      return t.send({method: 'net_version', params: []});
    });
  }
  function oL(t) {
    return wv(this, void 0, void 0, function* () {
      return t.send({method: 'net_peerCount', params: []});
    });
  }
  function aL(t) {
    return wv(this, void 0, void 0, function* () {
      return t.send({method: 'net_listening', params: []});
    });
  }
  var us = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  const cL = (t) =>
      us(void 0, void 0, void 0, function* () {
        return t.send({method: 'personal_listAccounts', params: []});
      }),
    lL = (t, e) =>
      us(void 0, void 0, void 0, function* () {
        return t.send({method: 'personal_newAccount', params: [e]});
      }),
    uL = (t, e, n, r) =>
      us(void 0, void 0, void 0, function* () {
        return t.send({method: 'personal_unlockAccount', params: [e, n, r]});
      }),
    dL = (t, e) =>
      us(void 0, void 0, void 0, function* () {
        return t.send({method: 'personal_lockAccount', params: [e]});
      }),
    fL = (t, e, n) =>
      us(void 0, void 0, void 0, function* () {
        return t.send({method: 'personal_importRawKey', params: [e, n]});
      }),
    hL = (t, e, n) =>
      us(void 0, void 0, void 0, function* () {
        return t.send({method: 'personal_sendTransaction', params: [e, n]});
      }),
    pL = (t, e, n) =>
      us(void 0, void 0, void 0, function* () {
        return t.send({method: 'personal_signTransaction', params: [e, n]});
      }),
    mL = (t, e, n, r) =>
      us(void 0, void 0, void 0, function* () {
        return t.send({method: 'personal_sign', params: [e, n, r]});
      }),
    gL = (t, e, n) =>
      us(void 0, void 0, void 0, function* () {
        return t.send({method: 'personal_ecRecover', params: [e, n]});
      }),
    ww = {
      type: 'object',
      properties: {
        accessList: {type: 'null'},
        maxFeePerGas: {type: 'null'},
        maxPriorityFeePerGas: {type: 'null'}
      }
    },
    _w = {
      type: 'object',
      properties: {
        maxFeePerGas: {type: 'null'},
        maxPriorityFeePerGas: {type: 'null'}
      }
    },
    Ew = {type: 'object', properties: {gasPrice: {type: 'null'}}},
    Xu = (t, e, n) => {
      try {
        Ie.validateJSONSchema(t, e);
      } catch (r) {
        throw r instanceof lc ? new hP(r.errors, n) : r;
      }
    },
    yL = (t) => {
      var e, n;
      const r = t;
      if (!ie(r.type)) {
        let s;
        switch (r.type) {
          case '0x0':
            s = ww;
            break;
          case '0x1':
            s = _w;
            break;
          case '0x2':
            s = Ew;
            break;
          default:
            return ge({format: 'uint'}, r.type, Be);
        }
        return (Xu(s, r, r.type), ge({format: 'uint'}, r.type, Be));
      }
      if (!ie(r.maxFeePerGas) || !ie(r.maxPriorityFeePerGas))
        return (Xu(Ew, r, '0x2'), '0x2');
      if (!ie(r.accessList)) return (Xu(_w, r, '0x1'), '0x1');
      const i =
        (e = r.hardfork) !== null && e !== void 0
          ? e
          : (n = r.common) === null || n === void 0
            ? void 0
            : n.hardfork;
      if (!ie(i)) {
        const s = Object.keys(yl).indexOf(i);
        if (s >= Object.keys(yl).indexOf('london'))
          return ie(r.gasPrice) ? '0x2' : '0x0';
        if (s === Object.keys(yl).indexOf('berlin')) return '0x0';
      }
      if (!ie(r.gasPrice)) return (Xu(ww, r, '0x0'), '0x0');
    },
    vL = (t, e) => {
      var n;
      return (
        (n = e == null ? void 0 : e.transactionTypeParser) !== null &&
          n !== void 0
          ? n
          : yL
      )(t);
    },
    bL = (t) => (t[0] > 127 ? '0x0' : is(t[0])),
    wL = {
      type: 'object',
      properties: {
        address: {format: 'address'},
        storageKeys: {type: 'array', items: {format: 'bytes32'}}
      }
    },
    _v = {type: 'array', items: Object.assign({}, wL)},
    _L = {
      type: 'object',
      properties: {accessList: Object.assign({}, _v), gasUsed: {type: 'string'}}
    },
    Aw = {
      type: 'string',
      enum: ['goerli', 'kovan', 'mainnet', 'rinkeby', 'ropsten', 'sepolia']
    },
    Sw = {
      type: 'string',
      enum: [
        'arrowGlacier',
        'berlin',
        'byzantium',
        'chainstart',
        'constantinople',
        'dao',
        'homestead',
        'istanbul',
        'london',
        'merge',
        'muirGlacier',
        'petersburg',
        'shanghai',
        'spuriousDragon',
        'tangerineWhistle'
      ]
    },
    EL = {
      type: 'object',
      properties: {
        name: {format: 'string'},
        networkId: {format: 'uint'},
        chainId: {format: 'uint'}
      }
    },
    PS = {
      type: 'object',
      properties: {
        from: {format: 'address'},
        to: {oneOf: [{format: 'address'}, {type: 'null'}]},
        value: {format: 'uint'},
        gas: {format: 'uint'},
        gasPrice: {format: 'uint'},
        effectiveGasPrice: {format: 'uint'},
        type: {format: 'uint'},
        maxFeePerGas: {format: 'uint'},
        maxPriorityFeePerGas: {format: 'uint'},
        accessList: Object.assign({}, _v),
        data: {format: 'bytes'},
        input: {format: 'bytes'},
        nonce: {format: 'uint'},
        chain: Object.assign({}, Aw),
        hardfork: Object.assign({}, Sw),
        chainId: {format: 'uint'},
        networkId: {format: 'uint'},
        common: {
          type: 'object',
          properties: {
            customChain: Object.assign({}, EL),
            baseChain: Object.assign({}, Aw),
            hardfork: Object.assign({}, Sw)
          }
        },
        gasLimit: {format: 'uint'},
        v: {format: 'uint'},
        r: {format: 'bytes32'},
        s: {format: 'bytes32'}
      }
    },
    cg = {
      type: 'object',
      properties: Object.assign(Object.assign({}, PS.properties), {
        blockHash: {format: 'bytes32'},
        blockNumber: {format: 'uint'},
        hash: {format: 'bytes32'},
        transactionIndex: {format: 'uint'},
        from: {format: 'address'},
        to: {oneOf: [{format: 'address'}, {type: 'null'}]},
        value: {format: 'uint'},
        gas: {format: 'uint'},
        gasPrice: {format: 'uint'},
        effectiveGasPrice: {format: 'uint'},
        type: {format: 'uint'},
        maxFeePerGas: {format: 'uint'},
        maxPriorityFeePerGas: {format: 'uint'},
        accessList: Object.assign({}, _v),
        data: {format: 'bytes'},
        input: {format: 'bytes'},
        nonce: {format: 'uint'},
        gasLimit: {format: 'uint'},
        v: {format: 'uint'},
        r: {format: 'bytes32'},
        s: {format: 'bytes32'}
      })
    },
    MS = {
      type: 'object',
      properties: {
        index: {format: 'uint'},
        validatorIndex: {format: 'uint'},
        address: {format: 'address'},
        amount: {format: 'uint'}
      }
    },
    ch = {
      type: 'object',
      properties: {
        baseFeePerGas: {format: 'uint'},
        blobGasUsed: {format: 'uint'},
        difficulty: {format: 'uint'},
        excessBlobGas: {format: 'uint'},
        extraData: {format: 'bytes'},
        gasLimit: {format: 'uint'},
        gasUsed: {format: 'uint'},
        hash: {format: 'bytes32'},
        logsBloom: {format: 'bytes256'},
        miner: {format: 'bytes'},
        mixHash: {format: 'bytes32'},
        nonce: {format: 'uint'},
        number: {format: 'uint'},
        parentBeaconBlockRoot: {format: 'bytes32'},
        parentHash: {format: 'bytes32'},
        receiptsRoot: {format: 'bytes32'},
        sha3Uncles: {format: 'bytes32'},
        size: {format: 'uint'},
        stateRoot: {format: 'bytes32'},
        timestamp: {format: 'uint'},
        totalDifficulty: {format: 'uint'},
        transactions: {
          oneOf: [
            {type: 'array', items: Object.assign({}, cg)},
            {type: 'array', items: {format: 'bytes32'}}
          ]
        },
        transactionsRoot: {format: 'bytes32'},
        uncles: {type: 'array', items: {format: 'bytes32'}},
        withdrawals: {type: 'array', items: Object.assign({}, MS)},
        withdrawalsRoot: {format: 'bytes32'}
      }
    },
    AL = {
      type: 'object',
      properties: {
        author: {format: 'bytes32'},
        excessDataGas: {format: 'uint'},
        baseFeePerGas: {format: 'uint'},
        blobGasUsed: {format: 'uint'},
        difficulty: {format: 'uint'},
        excessBlobGas: {format: 'uint'},
        extraData: {format: 'bytes'},
        gasLimit: {format: 'uint'},
        gasUsed: {format: 'uint'},
        hash: {format: 'bytes32'},
        logsBloom: {format: 'bytes256'},
        miner: {format: 'bytes'},
        mixHash: {format: 'bytes32'},
        nonce: {format: 'uint'},
        number: {format: 'uint'},
        parentBeaconBlockRoot: {format: 'bytes32'},
        parentHash: {format: 'bytes32'},
        receiptsRoot: {format: 'bytes32'},
        sha3Uncles: {format: 'bytes32'},
        size: {format: 'uint'},
        stateRoot: {format: 'bytes32'},
        timestamp: {format: 'uint'},
        totalDifficulty: {format: 'uint'},
        transactions: {type: 'array', items: {format: 'bytes32'}},
        transactionsRoot: {format: 'bytes32'},
        uncles: {type: 'array', items: {format: 'bytes32'}},
        withdrawals: {type: 'array', items: Object.assign({}, MS)},
        withdrawalsRoot: {format: 'bytes32'}
      }
    },
    Mc = {
      type: 'object',
      properties: {
        removed: {format: 'bool'},
        logIndex: {format: 'uint'},
        transactionIndex: {format: 'uint'},
        transactionHash: {format: 'bytes32'},
        blockHash: {format: 'bytes32'},
        blockNumber: {format: 'uint'},
        address: {format: 'address'},
        data: {format: 'bytes'},
        topics: {type: 'array', items: {format: 'bytes32'}}
      }
    },
    SL = {
      type: 'object',
      properties: {
        startingBlock: {format: 'string'},
        currentBlock: {format: 'string'},
        highestBlock: {format: 'string'},
        knownStates: {format: 'string'},
        pulledStates: {format: 'string'}
      }
    },
    Oc = {
      type: 'object',
      properties: {
        transactionHash: {format: 'bytes32'},
        transactionIndex: {format: 'uint'},
        blockHash: {format: 'bytes32'},
        blockNumber: {format: 'uint'},
        from: {format: 'address'},
        to: {format: 'address'},
        cumulativeGasUsed: {format: 'uint'},
        gasUsed: {format: 'uint'},
        effectiveGasPrice: {format: 'uint'},
        contractAddress: {format: 'address'},
        logs: {type: 'array', items: Object.assign({}, Mc)},
        logsBloom: {format: 'bytes'},
        root: {format: 'bytes'},
        status: {format: 'uint'},
        type: {format: 'uint'}
      }
    },
    xL = {
      type: 'object',
      properties: {
        messageHash: {format: 'bytes'},
        r: {format: 'bytes32'},
        s: {format: 'bytes32'},
        v: {format: 'bytes'},
        message: {format: 'bytes'},
        signature: {format: 'bytes'}
      }
    },
    CL = {
      type: 'object',
      properties: {
        oldestBlock: {format: 'uint'},
        baseFeePerGas: {type: 'array', items: {format: 'uint'}},
        reward: {
          type: 'array',
          items: {type: 'array', items: {format: 'uint'}}
        },
        gasUsedRatio: {type: 'array', items: {type: 'number'}}
      }
    },
    TL = {
      type: 'object',
      properties: {
        key: {format: 'bytes32'},
        value: {format: 'uint'},
        proof: {type: 'array', items: {format: 'bytes32'}}
      }
    },
    IL = {
      type: 'object',
      properties: {
        balance: {format: 'uint'},
        codeHash: {format: 'bytes32'},
        nonce: {format: 'uint'},
        storageHash: {format: 'bytes32'},
        accountProof: {type: 'array', items: {format: 'bytes32'}},
        storageProof: {type: 'array', items: Object.assign({}, TL)}
      }
    };
  function Vn(t, e = Tn, n = {transactionSchema: cg, fillInputAndData: !1}) {
    var r, i;
    let s = lo({}, t);
    if (
      (ie(t == null ? void 0 : t.common) ||
        ((s.common = Object.assign({}, t.common)),
        ie((r = t.common) === null || r === void 0 ? void 0 : r.customChain) ||
          (s.common.customChain = Object.assign({}, t.common.customChain))),
      (s = ge(
        (i = n.transactionSchema) !== null && i !== void 0 ? i : cg,
        s,
        e
      )),
      !ie(s.data) && !ie(s.input) && is(s.data) !== is(s.input))
    )
      throw new QA({data: We(s.data), input: We(s.input)});
    return (
      n.fillInputAndData &&
        (ie(s.data) ? ie(s.input) || (s.data = s.input) : (s.input = s.data)),
      ie(s.gasLimit) || ((s.gas = s.gasLimit), delete s.gasLimit),
      s
    );
  }
  function kL(t, e, n = {fillInputAndData: !1}) {
    return {
      raw: ge({format: 'bytes'}, t, e),
      tx: Vn(
        Object.assign(
          Object.assign({}, ea.fromSerializedData(bt(t)).toJSON()),
          {hash: We(fc(bt(t))), type: bL(bt(t))}
        ),
        e,
        {
          fillInputAndData: n.fillInputAndData,
          transactionSchema: n.transactionSchema
        }
      )
    };
  }
  var Ev = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  function Av(t, e) {
    return Ev(this, void 0, void 0, function* () {
      const n = yield sL(t.requestManager);
      return ge({format: 'uint'}, n, e);
    });
  }
  function RL(t, e) {
    return Ev(this, void 0, void 0, function* () {
      const n = yield oL(t.requestManager);
      return ge({format: 'uint'}, n, e);
    });
  }
  const PL = (t) =>
    Ev(void 0, void 0, void 0, function* () {
      return aL(t.requestManager);
    });
  var Cm = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  class OS extends Un {
    getId(e = this.defaultReturnFormat) {
      return Cm(this, void 0, void 0, function* () {
        return Av(this, e);
      });
    }
    getPeerCount(e = this.defaultReturnFormat) {
      return Cm(this, void 0, void 0, function* () {
        return RL(this, e);
      });
    }
    isListening() {
      return Cm(this, void 0, void 0, function* () {
        return PL(this);
      });
    }
  }
  const vc = 'ALLEVENTS',
    lg = {name: vc, signature: '', type: 'event', inputs: []},
    Ip = {bytes: ts.HEX, number: wr.NUMBER};
  var NS = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  function ML(t, e, n) {
    return NS(this, void 0, void 0, function* () {
      var r, i, s, o;
      const a = yield lx(e, e.defaultBlock, !1, Be);
      if (ie(a.baseFeePerGas)) throw new lP();
      let c;
      if (
        (ie(t.gasPrice) &&
          BigInt(a.baseFeePerGas) === BigInt(0) &&
          (c = yield Mv(e, n)),
        !ie(t.gasPrice) || !ie(c))
      ) {
        const l = ge(
          {format: 'uint'},
          (r = t.gasPrice) !== null && r !== void 0 ? r : c,
          n
        );
        return {maxPriorityFeePerGas: l, maxFeePerGas: l};
      }
      return {
        maxPriorityFeePerGas: ge(
          {format: 'uint'},
          (i = t.maxPriorityFeePerGas) !== null && i !== void 0
            ? i
            : e.defaultMaxPriorityFeePerGas,
          n
        ),
        maxFeePerGas: ge(
          {format: 'uint'},
          (s = t.maxFeePerGas) !== null && s !== void 0
            ? s
            : BigInt(a.baseFeePerGas) * BigInt(2) +
                BigInt(
                  (o = t.maxPriorityFeePerGas) !== null && o !== void 0
                    ? o
                    : e.defaultMaxPriorityFeePerGas
                ),
          n
        )
      };
    });
  }
  function LS(t, e, n) {
    return NS(this, void 0, void 0, function* () {
      const r = BS(t, e);
      if (!ie(r)) {
        if (r.startsWith('-')) throw new Ob(r);
        if (Number(r) < 0 || Number(r) > 127) throw new Ob(r);
        if (ie(t.gasPrice) && (r === '0x0' || r === '0x1'))
          return {
            gasPrice: yield Mv(e, n),
            maxPriorityFeePerGas: void 0,
            maxFeePerGas: void 0
          };
        if (r === '0x2')
          return Object.assign({gasPrice: void 0}, yield ML(t, e, n));
      }
    });
  }
  var Sv = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  const ug = (t, e, n, r) => {
      if (n !== void 0 && t in n && n[t] !== void 0) {
        if (typeof n[t] == 'string' && nr(n[t])) return n[t];
        if (!it(n[t]) && R3(n[t])) {
          if (e.wallet) {
            const i = e.wallet.get(ge({format: 'uint'}, n[t], Ip));
            if (!ie(i)) return i.address;
            throw new Nb();
          }
          throw new Nb();
        } else throw t === 'from' ? new qR(n.from) : new VR(n.to);
      }
      if (t === 'from') {
        if (!ie(r)) return Tp(r);
        if (!ie(e.defaultAccount)) return e.defaultAccount;
      }
    },
    OL = (t, e, ...n) =>
      Sv(
        void 0,
        [t, e, ...n],
        void 0,
        function* (r, i, s = r.defaultReturnFormat) {
          if (ie(i)) throw new cP();
          return dx(r, i, r.defaultBlock, s);
        }
      ),
    BS = (t, e) => {
      const n = vL(t, e);
      if (!ie(n)) return n;
      if (!ie(e.defaultTransactionType))
        return ge({format: 'uint'}, e.defaultTransactionType, Be);
    };
  function NL(t) {
    return Sv(this, void 0, void 0, function* () {
      var e, n;
      let r = ge(PS, t.transaction, t.web3Context.defaultReturnFormat);
      if (
        (ie(r.from) &&
          (r.from = ug('from', t.web3Context, void 0, t.privateKey)),
        ie(r.nonce) && (r.nonce = yield OL(t.web3Context, r.from, Be)),
        ie(r.value) && (r.value = '0x0'),
        ie(r.data))
      )
        ie(r.input)
          ? (r.input = '0x')
          : r.input.startsWith('0x') || (r.input = `0x${r.input}`);
      else {
        if (!ie(r.input) && r.data !== r.input)
          throw new QA({data: We(r.data), input: We(r.input)});
        r.data.startsWith('0x') || (r.data = `0x${r.data}`);
      }
      if (ie(r.common)) {
        if (t.web3Context.defaultCommon) {
          const i = t.web3Context.defaultCommon,
            s = i.customChain.chainId,
            o = i.customChain.networkId,
            a = i.customChain.name;
          r.common = Object.assign(Object.assign({}, i), {
            customChain: {chainId: s, networkId: o, name: a}
          });
        }
        (ie(r.chain) && (r.chain = t.web3Context.defaultChain),
          ie(r.hardfork) && (r.hardfork = t.web3Context.defaultHardfork));
      }
      if (
        (ie(r.chainId) &&
          ie(
            (e = r.common) === null || e === void 0
              ? void 0
              : e.customChain.chainId
          ) &&
          (r.chainId = yield hx(t.web3Context, Be)),
        ie(r.networkId) &&
          (r.networkId =
            (n = t.web3Context.defaultNetworkId) !== null && n !== void 0
              ? n
              : yield Av(t.web3Context, Be)),
        ie(r.gasLimit) && !ie(r.gas) && (r.gasLimit = r.gas),
        (r.type = BS(r, t.web3Context)),
        ie(r.accessList) &&
          (r.type === '0x1' || r.type === '0x2') &&
          (r.accessList = []),
        t.fillGasPrice &&
          (r = Object.assign(
            Object.assign({}, r),
            yield LS(r, t.web3Context, Be)
          )),
        ie(r.gas) && ie(r.gasLimit) && t.fillGasLimit)
      ) {
        const i = yield Lv(t.web3Context, r, 'latest', Be);
        r = Object.assign(Object.assign({}, r), {
          gas: ge({format: 'uint'}, i, Be)
        });
      }
      return r;
    });
  }
  const LL = (t) =>
    Sv(void 0, void 0, void 0, function* () {
      var e;
      return (
        (e = t.web3Context.transactionBuilder) !== null && e !== void 0 ? e : NL
      )(Object.assign(Object.assign({}, t), {transaction: t.transaction}));
    });
  var xv = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  function dg(t, e, n) {
    const r = t.transactionPollingInterval,
      [i, s] = q3(
        () =>
          xv(this, void 0, void 0, function* () {
            let a;
            try {
              a = yield Ov(t, Ip);
            } catch (l) {
              console.warn(
                'An error happen while trying to get the block number',
                l
              );
              return;
            }
            const c = a - e;
            if (c >= t.transactionBlockTimeout)
              return new e3({
                starterBlockNumber: e,
                numberOfBlocks: c,
                transactionHash: n
              });
          }),
        r
      );
    return [
      s,
      {
        clean: () => {
          clearInterval(i);
        }
      }
    ];
  }
  function BL(t, e, n) {
    return xv(this, void 0, void 0, function* () {
      var r;
      let i = !0,
        s,
        o;
      function a(l, u) {
        (u &&
          console.warn(
            'error happened at subscription. So revert to polling...',
            u
          ),
          o.clean(),
          (i = !1));
        const [d, f] = dg(t, e, n);
        ((o.clean = f.clean), d.catch((h) => l(h)));
      }
      try {
        ((s = yield (r = t.subscriptionManager) === null || r === void 0
          ? void 0
          : r.subscribe('newHeads')),
          (o = {
            clean: () => {
              var l;
              s.id &&
                ((l = t.subscriptionManager) === null ||
                  l === void 0 ||
                  l
                    .removeSubscription(s)
                    .then(() => {})
                    .catch(() => {}));
            }
          }));
      } catch {
        return dg(t, e, n);
      }
      return [
        new Promise((l, u) => {
          try {
            (s.on('data', (d) => {
              if (((i = !1), !(d != null && d.number))) return;
              const f = Number(BigInt(d.number) - BigInt(e));
              f >= t.transactionBlockTimeout &&
                u(
                  new e3({
                    starterBlockNumber: e,
                    numberOfBlocks: f,
                    transactionHash: n
                  })
                );
            }),
              s.on('error', (d) => {
                a(u, d);
              }));
          } catch (d) {
            a(u, d);
          }
          setTimeout(() => {
            i && a(u);
          }, t.blockHeaderTimeout * 1e3);
        }),
        o
      ];
    });
  }
  function DS(t, e) {
    return xv(this, void 0, void 0, function* () {
      var n, r;
      const {provider: i} = t.requestManager;
      let s;
      const o = yield Ov(t, Ip);
      return (
        !((r = (n = i).supportsSubscriptions) === null || r === void 0) &&
        r.call(n) &&
        t.enableExperimentalFeatures.useSubscriptionWhenCheckingBlockTimeout
          ? (s = yield BL(t, o, e))
          : (s = dg(t, o, e)),
        s
      );
    });
  }
  var DL = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  function fg(t, e, n) {
    return DL(this, void 0, void 0, function* () {
      const [r, i] = tv(
          t.transactionSendTimeout,
          new uP({
            numberOfSeconds: t.transactionSendTimeout / 1e3,
            transactionHash: n
          })
        ),
        [s, o] = yield DS(t, n);
      try {
        return yield Promise.race([e(), i, s]);
      } finally {
        (clearTimeout(r), o.clean());
      }
    });
  }
  var xw = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  function FS(t, e, n, r) {
    return xw(this, void 0, void 0, function* () {
      var i;
      const s =
          (i = t.transactionReceiptPollingInterval) !== null && i !== void 0
            ? i
            : t.transactionPollingInterval,
        [o, a] = ev(
          () =>
            xw(this, void 0, void 0, function* () {
              try {
                return (r ?? ux)(t, e, n);
              } catch (f) {
                console.warn(
                  'An error happen while trying to get the transaction receipt',
                  f
                );
                return;
              }
            }),
          s
        ),
        [c, l] = tv(
          t.transactionPollingTimeout,
          new XA({
            numberOfSeconds: t.transactionPollingTimeout / 1e3,
            transactionHash: e
          })
        ),
        [u, d] = yield DS(t, e);
      try {
        return yield Promise.race([o, l, u]);
      } finally {
        (c && clearTimeout(c), a && clearInterval(a), d.clean());
      }
    });
  }
  var FL = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  const Kd = ({
    web3Context: t,
    transactionReceipt: e,
    transactionPromiEvent: n,
    customTransactionReceiptSchema: r,
    returnFormat: i
  }) => {
    var s;
    let o = 1;
    const a = setInterval(
      () => {
        FL(void 0, void 0, void 0, function* () {
          if (o >= t.transactionConfirmationBlocks) {
            clearInterval(a);
            return;
          }
          const c = yield RS(
            t.requestManager,
            $t(BigInt(e.blockNumber) + BigInt(o)),
            !1
          );
          c != null &&
            c.hash &&
            ((o += 1),
            n.emit('confirmation', {
              confirmations: ge({format: 'uint'}, o, i),
              receipt: ge(r ?? Oc, e, i),
              latestBlockHash: ge({format: 'bytes32'}, c.hash, i)
            }));
        });
      },
      (s = t.transactionReceiptPollingInterval) !== null && s !== void 0
        ? s
        : t.transactionPollingInterval
    );
  };
  var Cw = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  const $L = ({
    web3Context: t,
    transactionReceipt: e,
    transactionPromiEvent: n,
    customTransactionReceiptSchema: r,
    returnFormat: i
  }) => {
    let s = !0,
      o;
    (setImmediate(() => {
      var a;
      (a = t.subscriptionManager) === null ||
        a === void 0 ||
        a
          .subscribe('newHeads')
          .then((c) => {
            (c.on('data', (l) =>
              Cw(void 0, void 0, void 0, function* () {
                var u;
                if (
                  ((s = !1),
                  !(l != null && l.number) ||
                    o === (l == null ? void 0 : l.parentHash))
                )
                  return;
                o = l == null ? void 0 : l.parentHash;
                const d = BigInt(l.number) - BigInt(e.blockNumber) + BigInt(1);
                (n.emit('confirmation', {
                  confirmations: ge({format: 'uint'}, d, i),
                  receipt: ge(r ?? Oc, e, i),
                  latestBlockHash: ge({format: 'bytes32'}, l.parentHash, i)
                }),
                  d >= t.transactionConfirmationBlocks &&
                    (yield (u = t.subscriptionManager) === null || u === void 0
                      ? void 0
                      : u.removeSubscription(c)));
              })
            ),
              c.on('error', () =>
                Cw(void 0, void 0, void 0, function* () {
                  var l;
                  (yield (l = t.subscriptionManager) === null || l === void 0
                    ? void 0
                    : l.removeSubscription(c),
                    (s = !1),
                    Kd({
                      web3Context: t,
                      transactionReceipt: e,
                      transactionPromiEvent: n,
                      customTransactionReceiptSchema: r,
                      returnFormat: i
                    }));
                })
              ));
          })
          .catch(() => {
            ((s = !1),
              Kd({
                web3Context: t,
                transactionReceipt: e,
                customTransactionReceiptSchema: r,
                transactionPromiEvent: n,
                returnFormat: i
              }));
          });
    }),
      setTimeout(() => {
        s &&
          Kd({
            web3Context: t,
            transactionReceipt: e,
            transactionPromiEvent: n,
            returnFormat: i
          });
      }, t.blockHeaderTimeout * 1e3));
  };
  function HL(t, e, n, r, i, s) {
    if (ie(n) || ie(n.blockHash))
      throw new dP({
        receipt: n,
        blockHash: ge({format: 'bytes32'}, n == null ? void 0 : n.blockHash, i),
        transactionHash: ge({format: 'bytes32'}, r, i)
      });
    if (!n.blockNumber) throw new fP({receipt: n});
    e.emit('confirmation', {
      confirmations: ge({format: 'uint'}, 1, i),
      receipt: ge(s ?? Oc, n, i),
      latestBlockHash: ge({format: 'bytes32'}, n.blockHash, i)
    });
    const o = t.requestManager.provider;
    o && 'supportsSubscriptions' in o && o.supportsSubscriptions()
      ? $L({
          web3Context: t,
          transactionReceipt: n,
          transactionPromiEvent: e,
          customTransactionReceiptSchema: s,
          returnFormat: i
        })
      : Kd({
          web3Context: t,
          transactionReceipt: n,
          transactionPromiEvent: e,
          customTransactionReceiptSchema: s,
          returnFormat: i
        });
  }
  const kp = (t) =>
      !Re(t) && typeof t == 'object' && !Re(t.type) && t.type === 'error',
    Cv = (t) =>
      !Re(t) && typeof t == 'object' && !Re(t.type) && t.type === 'event',
    Rp = (t) =>
      !Re(t) && typeof t == 'object' && !Re(t.type) && t.type === 'function',
    jL = (t) =>
      !Re(t) && typeof t == 'object' && !Re(t.type) && t.type === 'constructor',
    UL = (t) =>
      typeof t == 'object' && typeof t.components > 'u' && typeof t.name > 'u',
    $S = (t) =>
      t.includes('[]')
        ? {type: 'tuple[]', name: t.slice(0, -2)}
        : {type: 'tuple', name: t},
    HS = (t) => {
      const e = [];
      for (const n of Object.keys(t)) {
        const r = t[n];
        typeof r == 'object'
          ? e.push(Object.assign(Object.assign({}, $S(n)), {components: HS(r)}))
          : e.push({name: n, type: t[n]});
      }
      return e;
    },
    hg = (t, e) => {
      const n = [];
      return (
        e.forEach((r) => {
          if (typeof r.components == 'object') {
            if (!r.type.startsWith('tuple'))
              throw new Ze(
                `Invalid value given "${r.type}". Error: components found but type is not tuple.`
              );
            const i = r.type.indexOf('['),
              s = i >= 0 ? r.type.substring(i) : '',
              o = hg(t, r.components);
            n.push(`(${o.join(',')})${s}`);
          } else n.push(r.type);
        }),
        n
      );
    },
    Yi = (t) => {
      var e, n, r, i;
      return kp(t) || Cv(t) || Rp(t)
        ? !((e = t.name) === null || e === void 0) && e.includes('(')
          ? t.name
          : `${(n = t.name) !== null && n !== void 0 ? n : ''}(${hg(!1, (r = t.inputs) !== null && r !== void 0 ? r : []).join(',')})`
        : `(${hg(!1, (i = t.inputs) !== null && i !== void 0 ? i : []).join(',')})`;
    },
    KL = (t) => {
      if (typeof t != 'string' && !kp(t))
        throw new Ze('Invalid parameter value in encodeErrorSignature');
      let e;
      return (
        t && (typeof t == 'function' || typeof t == 'object')
          ? (e = Yi(t))
          : (e = t),
        rr(e)
      );
    },
    Tv = (t) => {
      if (typeof t != 'string' && !Cv(t))
        throw new Ze('Invalid parameter value in encodeEventSignature');
      let e;
      return (
        t && (typeof t == 'function' || typeof t == 'object')
          ? (e = Yi(t))
          : (e = t),
        rr(e)
      );
    };
  function Iv(t, e) {
    const n = t.exec(e);
    return n == null ? void 0 : n.groups;
  }
  var jS = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
    US =
      /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,
    KS = /^\(.+?\).*?$/,
    qL = Object.defineProperty,
    VL = (t, e, n) =>
      e in t
        ? qL(t, e, {enumerable: !0, configurable: !0, writable: !0, value: n})
        : (t[e] = n),
    Vc = (t, e, n) => (VL(t, typeof e != 'symbol' ? e + '' : e, n), n),
    GL = 'abitype',
    zL = '0.7.1',
    Hn = class extends Error {
      constructor(t, e = {}) {
        var s;
        const n =
            e.cause instanceof Hn
              ? e.cause.details
              : (s = e.cause) != null && s.message
                ? e.cause.message
                : e.details,
          r = (e.cause instanceof Hn && e.cause.docsPath) || e.docsPath,
          i = [
            t || 'An error occurred.',
            '',
            ...(e.metaMessages ? [...e.metaMessages, ''] : []),
            ...(r ? [`Docs: https://abitype.dev${r}`] : []),
            ...(n ? [`Details: ${n}`] : []),
            `Version: ${GL}@${zL}`
          ].join(`
`);
        (super(i),
          Vc(this, 'details'),
          Vc(this, 'docsPath'),
          Vc(this, 'metaMessages'),
          Vc(this, 'shortMessage'),
          Vc(this, 'name', 'AbiTypeError'),
          e.cause && (this.cause = e.cause),
          (this.details = n),
          (this.docsPath = r),
          (this.metaMessages = e.metaMessages),
          (this.shortMessage = t));
      }
    },
    qS = /^struct (?<name>[a-zA-Z0-9_]+) \{(?<properties>.*?)\}$/;
  function VS(t) {
    return qS.test(t);
  }
  function WL(t) {
    return Iv(qS, t);
  }
  var Tw = new Set(['memory', 'indexed', 'storage', 'calldata']),
    ZL = new Set(['calldata', 'memory', 'storage']);
  function YL(t, e) {
    return e ? `${e}:${t}` : t;
  }
  var Tm = new Map([
      ['address', {type: 'address'}],
      ['bool', {type: 'bool'}],
      ['bytes', {type: 'bytes'}],
      ['bytes32', {type: 'bytes32'}],
      ['int', {type: 'int256'}],
      ['int256', {type: 'int256'}],
      ['string', {type: 'string'}],
      ['uint', {type: 'uint256'}],
      ['uint8', {type: 'uint8'}],
      ['uint16', {type: 'uint16'}],
      ['uint24', {type: 'uint24'}],
      ['uint32', {type: 'uint32'}],
      ['uint64', {type: 'uint64'}],
      ['uint96', {type: 'uint96'}],
      ['uint112', {type: 'uint112'}],
      ['uint160', {type: 'uint160'}],
      ['uint192', {type: 'uint192'}],
      ['uint256', {type: 'uint256'}],
      ['address owner', {type: 'address', name: 'owner'}],
      ['address to', {type: 'address', name: 'to'}],
      ['bool approved', {type: 'bool', name: 'approved'}],
      ['bytes _data', {type: 'bytes', name: '_data'}],
      ['bytes data', {type: 'bytes', name: 'data'}],
      ['bytes signature', {type: 'bytes', name: 'signature'}],
      ['bytes32 hash', {type: 'bytes32', name: 'hash'}],
      ['bytes32 r', {type: 'bytes32', name: 'r'}],
      ['bytes32 root', {type: 'bytes32', name: 'root'}],
      ['bytes32 s', {type: 'bytes32', name: 's'}],
      ['string name', {type: 'string', name: 'name'}],
      ['string symbol', {type: 'string', name: 'symbol'}],
      ['string tokenURI', {type: 'string', name: 'tokenURI'}],
      ['uint tokenId', {type: 'uint256', name: 'tokenId'}],
      ['uint8 v', {type: 'uint8', name: 'v'}],
      ['uint256 balance', {type: 'uint256', name: 'balance'}],
      ['uint256 tokenId', {type: 'uint256', name: 'tokenId'}],
      ['uint256 value', {type: 'uint256', name: 'value'}],
      [
        'event:address indexed from',
        {type: 'address', name: 'from', indexed: !0}
      ],
      ['event:address indexed to', {type: 'address', name: 'to', indexed: !0}],
      [
        'event:uint indexed tokenId',
        {type: 'uint256', name: 'tokenId', indexed: !0}
      ],
      [
        'event:uint256 indexed tokenId',
        {type: 'uint256', name: 'tokenId', indexed: !0}
      ]
    ]),
    QL =
      /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z0-9_]+))?$/,
    JL =
      /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z0-9_]+))?$/,
    XL = /^u?int$/;
  function lh(t, e) {
    var d, f;
    const n = YL(t, e == null ? void 0 : e.type);
    if (Tm.has(n)) return Tm.get(n);
    const r = KS.test(t),
      i = Iv(r ? JL : QL, t);
    if (!i) throw new Hn('Invalid ABI parameter.', {details: t});
    if (i.name && tB(i.name))
      throw new Hn('Invalid ABI parameter.', {
        details: t,
        metaMessages: [
          `"${i.name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
        ]
      });
    const s = i.name ? {name: i.name} : {},
      o = i.modifier === 'indexed' ? {indexed: !0} : {},
      a = (e == null ? void 0 : e.structs) ?? {};
    let c,
      l = {};
    if (r) {
      c = 'tuple';
      const h = xa(i.type),
        g = [],
        m = h.length;
      for (let y = 0; y < m; y++) g.push(lh(h[y], {structs: a}));
      l = {components: g};
    } else if (i.type in a) ((c = 'tuple'), (l = {components: a[i.type]}));
    else if (XL.test(i.type)) c = `${i.type}256`;
    else if (
      ((c = i.type), (e == null ? void 0 : e.type) !== 'struct' && !GS(c))
    )
      throw new Hn('Unknown type.', {
        metaMessages: [`Type "${c}" is not a valid ABI type.`]
      });
    if (i.modifier) {
      if (
        !(
          (f =
            (d = e == null ? void 0 : e.modifiers) == null ? void 0 : d.has) !=
            null && f.call(d, i.modifier)
        )
      )
        throw new Hn('Invalid ABI parameter.', {
          details: t,
          metaMessages: [
            `Modifier "${i.modifier}" not allowed${e != null && e.type ? ` in "${e.type}" type` : ''}.`
          ]
        });
      if (ZL.has(i.modifier) && !nB(c, !!i.array))
        throw new Hn('Invalid ABI parameter.', {
          details: t,
          metaMessages: [
            `Modifier "${i.modifier}" not allowed${e != null && e.type ? ` in "${e.type}" type` : ''}.`,
            `Data location can only be specified for array, struct, or mapping types, but "${i.modifier}" was given.`
          ]
        });
    }
    const u = {type: `${c}${i.array ?? ''}`, ...s, ...o, ...l};
    return (Tm.set(n, u), u);
  }
  function xa(t, e = [], n = '', r = 0) {
    if (t === '') {
      if (n === '') return e;
      if (r !== 0)
        throw new Hn('Unbalanced parentheses.', {
          metaMessages: [
            `"${n.trim()}" has too many ${r > 0 ? 'opening' : 'closing'} parentheses.`
          ],
          details: `Depth "${r}"`
        });
      return [...e, n.trim()];
    }
    const i = t.length;
    for (let s = 0; s < i; s++) {
      const o = t[s],
        a = t.slice(s + 1);
      switch (o) {
        case ',':
          return r === 0 ? xa(a, [...e, n.trim()]) : xa(a, e, `${n}${o}`, r);
        case '(':
          return xa(a, e, `${n}${o}`, r + 1);
        case ')':
          return xa(a, e, `${n}${o}`, r - 1);
        default:
          return xa(a, e, `${n}${o}`, r);
      }
    }
    return [];
  }
  function GS(t) {
    return (
      t === 'address' ||
      t === 'bool' ||
      t === 'function' ||
      t === 'string' ||
      jS.test(t) ||
      US.test(t)
    );
  }
  var eB =
    /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
  function tB(t) {
    return (
      t === 'address' ||
      t === 'bool' ||
      t === 'function' ||
      t === 'string' ||
      t === 'tuple' ||
      jS.test(t) ||
      US.test(t) ||
      eB.test(t)
    );
  }
  function nB(t, e) {
    return e || t === 'bytes' || t === 'string' || t === 'tuple';
  }
  function rB(t) {
    const e = {},
      n = t.length;
    for (let o = 0; o < n; o++) {
      const a = t[o];
      if (!VS(a)) continue;
      const c = WL(a);
      if (!c) throw new Hn('Invalid struct signature.', {details: a});
      const l = c.properties.split(';'),
        u = [],
        d = l.length;
      for (let f = 0; f < d; f++) {
        const g = l[f].trim();
        if (!g) continue;
        const m = lh(g, {type: 'struct'});
        u.push(m);
      }
      if (!u.length)
        throw new Hn('Invalid struct signature.', {
          details: a,
          metaMessages: ['No properties exist.']
        });
      e[c.name] = u;
    }
    const r = {},
      i = Object.entries(e),
      s = i.length;
    for (let o = 0; o < s; o++) {
      const [a, c] = i[o];
      r[a] = zS(c, e);
    }
    return r;
  }
  var iB = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\[\d*?\])+?)?$/;
  function zS(t, e, n = new Set()) {
    const r = [],
      i = t.length;
    for (let s = 0; s < i; s++) {
      const o = t[s];
      if (KS.test(o.type)) r.push(o);
      else {
        const c = Iv(iB, o.type);
        if (!(c != null && c.type))
          throw new Hn('Invalid ABI parameter.', {
            details: JSON.stringify(o, null, 2),
            metaMessages: ['ABI parameter type is invalid.']
          });
        const {array: l, type: u} = c;
        if (u in e) {
          if (n.has(u))
            throw new Hn('Circular reference detected.', {
              metaMessages: [`Struct "${u}" is a circular reference.`]
            });
          r.push({
            ...o,
            type: `tuple${l ?? ''}`,
            components: zS(e[u] ?? [], e, new Set([...n, u]))
          });
        } else if (GS(u)) r.push(o);
        else
          throw new Hn('Unknown type.', {
            metaMessages: [
              `Type "${u}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
            ]
          });
      }
    }
    return r;
  }
  function sB(t) {
    let e;
    if (typeof t == 'string') e = lh(t, {modifiers: Tw});
    else {
      const n = rB(t),
        r = t.length;
      for (let i = 0; i < r; i++) {
        const s = t[i];
        if (!VS(s)) {
          e = lh(s, {modifiers: Tw, structs: n});
          break;
        }
      }
    }
    if (!e)
      throw new Hn('Failed to parse ABI parameter.', {
        details: `parseAbiParameter(${JSON.stringify(t, null, 2)})`,
        docsPath: '/api/human.html#parseabiparameter-1'
      });
    return e;
  }
  const It = 32;
  function pg(t = 0) {
    var e;
    if (
      ((e = globalThis.Buffer) === null || e === void 0 ? void 0 : e.alloc) !==
      void 0
    ) {
      const n = globalThis.Buffer.alloc(t);
      return new Uint8Array(n.buffer, n.byteOffset, n.byteLength);
    }
    return new Uint8Array(t);
  }
  function WS(t) {
    var e, n;
    return Object.assign(Object.assign({}, t), {
      name: (e = t.name) !== null && e !== void 0 ? e : '',
      components:
        (n = t.components) === null || n === void 0
          ? void 0
          : n.map((r) => WS(r))
    });
  }
  function oB(t) {
    return (
      !Re(t) && typeof t == 'object' && !Re(t.type) && typeof t.type == 'string'
    );
  }
  function ZS(t) {
    return t.map((e) => {
      var n;
      if (oB(e)) return e;
      if (typeof e == 'string') return WS(sB(e.replace(/tuple/, '')));
      if (UL(e)) {
        const r = Object.keys(e)[0],
          i = $S(r);
        return (
          (i.name = (n = i.name) !== null && n !== void 0 ? n : ''),
          Object.assign(Object.assign({}, i), {components: HS(e[r])})
        );
      }
      throw new Ze('Invalid abi');
    });
  }
  function kv(t) {
    const e = t.type.lastIndexOf('['),
      n = t.type.substring(0, e),
      r = t.type.substring(e);
    let i = -1;
    if (r !== '[]' && ((i = Number(r.slice(1, -1))), isNaN(i)))
      throw new Ze('Invalid fixed array size', {size: r});
    return {param: {type: n, name: '', components: t.components}, size: i};
  }
  function uh(t) {
    var e, n;
    return t.type === 'string' || t.type === 'bytes' || t.type.endsWith('[]')
      ? !0
      : t.type === 'tuple'
        ? (n =
            (e = t.components) === null || e === void 0
              ? void 0
              : e.some(uh)) !== null && n !== void 0
          ? n
          : !1
        : t.type.endsWith(']')
          ? uh(kv(t).param)
          : !1;
  }
  const YS = 20,
    QS = It - YS;
  function aB(t, e) {
    if (typeof e != 'string')
      throw new Ze('address type expects string as input type', {
        value: e,
        name: t.name,
        type: t.type
      });
    let n = e.toLowerCase();
    if ((n.startsWith('0x') || (n = `0x${n}`), !nr(n)))
      throw new Ze('provided input is not valid address', {
        value: e,
        name: t.name,
        type: t.type
      });
    const r = oa(n),
      i = pg(It);
    return (i.set(r, QS), {dynamic: !1, encoded: i});
  }
  function cB(t, e) {
    const n = e.subarray(QS, It);
    if (n.length !== YS)
      throw new Ze(
        'Invalid decoding input, not enough bytes to decode address',
        {bytes: e}
      );
    const r = cs(n);
    return {result: _i(r), encoded: e.subarray(It), consumed: It};
  }
  const ro = new Map();
  let ed = BigInt(256);
  for (let t = 8; t <= 256; t += 8)
    (ro.set(`uint${t}`, {min: BigInt(0), max: ed - BigInt(1)}),
      ro.set(`int${t}`, {
        min: -ed / BigInt(2),
        max: ed / BigInt(2) - BigInt(1)
      }),
      (ed *= BigInt(256)));
  ro.set('int', ro.get('int256'));
  ro.set('uint', ro.get('uint256'));
  const JS = BigInt(1) << BigInt(256);
  function lB(t, e = It) {
    let n;
    return (
      t < 0 ? (n = (JS + t).toString(16)) : (n = t.toString(16)),
      (n = dc(n, e * 2)),
      oa(n)
    );
  }
  function uB(t, e) {
    const n = cs(t),
      r = BigInt(n);
    return r <= e ? r : r - JS;
  }
  function Fu(t, e) {
    let n;
    try {
      n = xo(e);
    } catch {
      throw new Ze('provided input is not number value', {
        type: t.type,
        value: e,
        name: t.name
      });
    }
    const r = ro.get(t.type);
    if (!r)
      throw new Ze('provided abi contains invalid number datatype', {
        type: t.type
      });
    if (n < r.min)
      throw new Ze('provided input is less then minimum for given type', {
        type: t.type,
        value: e,
        name: t.name,
        minimum: r.min.toString()
      });
    if (n > r.max)
      throw new Ze('provided input is greater then maximum for given type', {
        type: t.type,
        value: e,
        name: t.name,
        maximum: r.max.toString()
      });
    return {dynamic: !1, encoded: lB(n)};
  }
  function bc(t, e) {
    if (e.length < It)
      throw new Ze('Not enough bytes left to decode', {
        param: t,
        bytesLeft: e.length
      });
    const n = e.subarray(0, It),
      r = ro.get(t.type);
    if (!r)
      throw new Ze('provided abi contains invalid number datatype', {
        type: t.type
      });
    const i = uB(n, r.max);
    if (i < r.min)
      throw new Ze('decoded value is less then minimum for given type', {
        type: t.type,
        value: i,
        name: t.name,
        minimum: r.min.toString()
      });
    if (i > r.max)
      throw new Ze('decoded value is greater then maximum for given type', {
        type: t.type,
        value: i,
        name: t.name,
        maximum: r.max.toString()
      });
    return {result: i, encoded: e.subarray(It), consumed: It};
  }
  function dB(t, e) {
    let n;
    try {
      n = L3(e);
    } catch (r) {
      if (r instanceof Hy)
        throw new Ze('provided input is not valid boolean value', {
          type: t.type,
          value: e,
          name: t.name
        });
    }
    return Fu({type: 'uint8', name: ''}, Number(n));
  }
  function fB(t, e) {
    const n = bc({type: 'uint8', name: ''}, e);
    if (n.result > 1 || n.result < 0)
      throw new Ze('Invalid boolean value encoded', {
        boolBytes: e.subarray(0, It),
        numberResult: n
      });
    return {result: n.result === BigInt(1), encoded: n.encoded, consumed: It};
  }
  const hB = 32;
  function XS(t, e) {
    if ((typeof e == 'string' && e.length % 2 !== 0 && (e += '0'), !ao(e)))
      throw new Ze('provided input is not valid bytes value', {
        type: t.type,
        value: e,
        name: t.name
      });
    const n = yi(e),
      [, r] = t.type.split('bytes');
    if (r) {
      if (Number(r) > hB || Number(r) < 1)
        throw new Ze(
          'invalid bytes type. Static byte type can have between 1 and 32 bytes',
          {type: t.type}
        );
      if (Number(r) < n.length)
        throw new Ze('provided input size is different than type size', {
          type: t.type,
          value: e,
          name: t.name
        });
      const o = pg(It);
      return (o.set(n), {dynamic: !1, encoded: o});
    }
    const i = Math.ceil(n.length / It),
      s = pg(It + i * It);
    return (
      s.set(Fu({type: 'uint32', name: ''}, n.length).encoded),
      s.set(n, It),
      {dynamic: !0, encoded: s}
    );
  }
  function ex(t, e) {
    const [, n] = t.type.split('bytes');
    let r = Number(n),
      i = e,
      s = 1,
      o = 0;
    if (!r) {
      const a = bc({type: 'uint32', name: ''}, i);
      ((r = Number(a.result)),
        (o += a.consumed),
        (i = a.encoded),
        (s = Math.ceil(r / It)));
    }
    if (r > e.length)
      throw new Ze('there is not enough data to decode', {
        type: t.type,
        encoded: e,
        size: r
      });
    return {
      result: We(i.subarray(0, r)),
      encoded: i.subarray(s * It),
      consumed: o + s * It
    };
  }
  function pB(t, e) {
    if (typeof e != 'string')
      throw new Ze('invalid input, should be string', {input: e});
    const n = Qy(e);
    return XS({type: 'bytes', name: ''}, n);
  }
  function mB(t, e) {
    const n = ex({type: 'bytes'}, e);
    return {result: vp(n.result), encoded: n.encoded, consumed: n.consumed};
  }
  function tx(t) {
    let e = 0,
      n = 0;
    const r = [],
      i = [];
    for (const s of t) s.dynamic ? (e += It) : (e += s.encoded.length);
    for (const s of t)
      s.dynamic
        ? (r.push(Fu({type: 'uint256', name: ''}, e + n)),
          i.push(s),
          (n += s.encoded.length))
        : r.push(s);
    return Mn(...r.map((s) => s.encoded), ...i.map((s) => s.encoded));
  }
  function gB(t, e) {
    if (!Array.isArray(e))
      throw new Ze('Expected value to be array', {abi: t, values: e});
    const {size: n, param: r} = kv(t),
      i = e.map((a) => mg(r, a)),
      s = n === -1,
      o = i.length > 0 && i[0].dynamic;
    if (!s && e.length !== n)
      throw new Ze("Given arguments count doesn't match array length", {
        arrayLength: n,
        argumentsLength: e.length
      });
    if (s || o) {
      const a = tx(i);
      if (s) {
        const c = Fu({type: 'uint256', name: ''}, i.length).encoded;
        return {dynamic: !0, encoded: i.length > 0 ? Mn(c, a) : c};
      }
      return {dynamic: !0, encoded: a};
    }
    return {dynamic: !1, encoded: Mn(...i.map((a) => a.encoded))};
  }
  function yB(t, e) {
    let {size: n, param: r} = kv(t);
    const i = n === -1;
    let s = 0;
    const o = [];
    let a = e;
    if (i) {
      const l = bc({type: 'uint32', name: ''}, e);
      ((n = Number(l.result)), (s = l.consumed), (a = l.encoded));
    }
    if (uh(r)) {
      for (let l = 0; l < n; l += 1) {
        const u = bc({type: 'uint32', name: ''}, a.subarray(l * It));
        s += u.consumed;
        const d = dh(r, a.subarray(Number(u.result)));
        ((s += d.consumed), o.push(d.result));
      }
      return {result: o, encoded: a.subarray(s), consumed: s};
    }
    for (let l = 0; l < n; l += 1) {
      const u = dh(r, e.subarray(s));
      ((s += u.consumed), o.push(u.result));
    }
    return {result: o, encoded: e.subarray(s), consumed: s};
  }
  function mg(t, e) {
    if (t.type === 'string') return pB(t, e);
    if (t.type === 'bool') return dB(t, e);
    if (t.type === 'address') return aB(t, e);
    if (t.type === 'tuple') return Rv(t, e);
    if (t.type.endsWith(']')) return gB(t, e);
    if (t.type.startsWith('bytes')) return XS(t, e);
    if (t.type.startsWith('uint') || t.type.startsWith('int')) return Fu(t, e);
    throw new Ze('Unsupported', {param: t, value: e});
  }
  function dh(t, e) {
    if (t.type === 'string') return mB(t, e);
    if (t.type === 'bool') return fB(t, e);
    if (t.type === 'address') return cB(t, e);
    if (t.type === 'tuple') return nx(t, e);
    if (t.type.endsWith(']')) return yB(t, e);
    if (t.type.startsWith('bytes')) return ex(t, e);
    if (t.type.startsWith('uint') || t.type.startsWith('int')) return bc(t, e);
    throw new Ze('Unsupported', {param: t, bytes: e});
  }
  function Rv(t, e) {
    var n, r, i;
    let s = !1;
    if (!Array.isArray(e) && typeof e != 'object')
      throw new Ze('param must be either Array or Object', {
        param: t,
        input: e
      });
    const o = e,
      a = [];
    for (
      let c = 0;
      c <
      ((r = (n = t.components) === null || n === void 0 ? void 0 : n.length) !==
        null && r !== void 0
        ? r
        : 0);
      c += 1
    ) {
      const l = t.components[c];
      let u;
      if (Array.isArray(o)) {
        if (c >= o.length)
          throw new Ze('input param length missmatch', {param: t, input: e});
        u = mg(l, o[c]);
      } else {
        const d = o[(i = l.name) !== null && i !== void 0 ? i : ''];
        if (d == null)
          throw new Ze('missing input defined in abi', {
            param: t,
            input: e,
            paramName: l.name
          });
        u = mg(l, d);
      }
      (u.dynamic && (s = !0), a.push(u));
    }
    return s
      ? {dynamic: !0, encoded: tx(a)}
      : {dynamic: !1, encoded: Mn(...a.map((c) => c.encoded))};
  }
  function nx(t, e) {
    const n = {__length__: 0};
    let r = 0;
    if (!t.components) return {result: n, encoded: e, consumed: r};
    let i = 0;
    for (const [s, o] of t.components.entries()) {
      let a;
      if (uh(o)) {
        const c = bc({type: 'uint32', name: ''}, e.subarray(r));
        ((a = dh(o, e.subarray(Number(c.result)))),
          (r += c.consumed),
          (i += a.consumed));
      } else ((a = dh(o, e.subarray(r))), (r += a.consumed));
      ((n.__length__ += 1),
        (n[s] = a.result),
        o.name && o.name !== '' && (n[o.name] = a.result));
    }
    return {encoded: e.subarray(r + i), result: n, consumed: r + i};
  }
  function vB(t, e, n) {
    const r = ZS(t),
      i = oa(e);
    return nx({components: r}, i).result;
  }
  function rx(t) {
    const e = [];
    return (
      t.forEach((n) => {
        if (Array.isArray(n)) {
          const r = rx(n);
          e.push({type: 'tuple', components: r, name: ''});
        } else e.push({type: is(n, !0)});
      }),
      e
    );
  }
  function Pp(t, e) {
    if ((t == null ? void 0 : t.length) !== e.length)
      throw new Ze('Invalid number of values received for given ABI', {
        expected: t == null ? void 0 : t.length,
        received: e.length
      });
    const n = ZS(t);
    return cs(Rv({type: 'tuple', name: '', components: n}, e).encoded);
  }
  function bB(t) {
    try {
      const e = rx(t);
      return cs(Rv({type: 'tuple', name: '', components: e}, t).encoded);
    } catch {
      throw new Ze('Could not infer types from given params', {params: t});
    }
  }
  const gg = (t, e) => Pp([t], [e]),
    ix = (t, e, n) => {
      try {
        if (t.length > 0 && (!e || e === '0x' || e === '0X'))
          throw new Ze(
            "Returned values aren't valid, did it run Out of Gas? You might also see this error if you are not using the correct ABI for the contract you are retrieving data from, requesting data from a block number that does not exist, or querying a node which is not fully synced."
          );
        return vB(t, `0x${e.replace(/0x/i, '')}`, n);
      } catch (r) {
        throw new Ze(`Parameter decoding error: ${r.message}`, {
          internalErr: r
        });
      }
    },
    Ho = (t, e) => ix(t, e, !1),
    sx = (t, e) => Ho([t], e)[0],
    iu = (t) => {
      if (typeof t != 'string' && !Rp(t))
        throw new Ze('Invalid parameter value in encodeFunctionSignature');
      let e;
      return (
        t && (typeof t == 'function' || typeof t == 'object')
          ? (e = Yi(t))
          : (e = t),
        rr(e).slice(0, 10)
      );
    },
    wB = (t, e) => {
      var n;
      if (!Rp(t)) throw new Ze('Invalid parameter value in encodeFunctionCall');
      return `${iu(t)}${Pp((n = t.inputs) !== null && n !== void 0 ? n : [], e ?? []).replace('0x', '')}`;
    },
    yg = (t, e, n = !0) => {
      const r =
        n && e && e.length >= 10 && e.startsWith('0x') ? e.slice(10) : e;
      if (!t.inputs) throw new In('No inputs found in the ABI');
      const i = Ho([...t.inputs], r);
      return Object.assign(Object.assign({}, i), {__method__: Yi(t)});
    },
    _B = (t, e) => {
      if (t.type === 'constructor') return e;
      if (!e) return null;
      const n = e.length >= 2 ? e.slice(2) : e;
      if (!t.outputs) return null;
      const r = Ho([...t.outputs], n);
      return r.__length__ === 1 ? r[0] : r;
    },
    EB = ['bool', 'string', 'int', 'uint', 'address', 'fixed', 'ufixed'],
    AB = (t, e) => (t === 'string' ? e : sx(t, e)),
    ox = (t, e, n) => {
      const r = Array.isArray(n) ? n : [n],
        i = {},
        s = {};
      for (const [f, h] of t.entries()) h.indexed ? (i[f] = h) : (s[f] = h);
      const o = e ? ix(Object.values(s), e, !0) : {__length__: 0},
        a = r.length - Object.keys(i).length,
        c = Object.values(i).map((f, h) =>
          EB.some((g) => f.type.startsWith(g)) ? AB(f.type, r[h + a]) : r[h + a]
        ),
        l = {__length__: 0};
      let u = 0,
        d = 0;
      for (const [f, h] of t.entries())
        ((l[f] = h.type === 'string' ? '' : void 0),
          i[f] && ((l[f] = c[u]), (u += 1)),
          s[f] && ((l[f] = o[String(d)]), (d += 1)),
          h.name && (l[h.name] = l[f]),
          (l.__length__ += 1));
      return l;
    },
    qd = (t, e) => {
      if (e != null && e.data) {
        let n, r, i;
        try {
          const s = e.data.slice(0, 10),
            o = t.find((a) => KL(a).startsWith(s));
          o != null && o.inputs
            ? ((n = o.name),
              (r = Yi(o)),
              (i = Ho([...o.inputs], e.data.substring(10))))
            : e.data.startsWith('0x08c379a0')
              ? ((n = 'Error'),
                (r = 'Error(string)'),
                (i = Ho(
                  [{name: 'message', type: 'string'}],
                  e.data.substring(10)
                )))
              : e.data.startsWith('0x4e487b71')
                ? ((n = 'Panic'),
                  (r = 'Panic(uint256)'),
                  (i = Ho(
                    [{name: 'code', type: 'uint256'}],
                    e.data.substring(10)
                  )))
                : console.error(
                    'No matching error abi found for error data',
                    e.data
                  );
        } catch (s) {
          console.error(s);
        }
        n && e.setDecodedProperties(n, r, i);
      }
    };
  var SB = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  const xB = (t, e) => {
    var n, r, i, s, o;
    if (t instanceof Bo && t.cause instanceof lp) {
      if (e !== void 0) {
        const a = e.filter((c) => kp(c));
        return (
          qd(a, t.cause),
          {
            reason: t.cause.message,
            signature:
              (n = t.cause.data) === null || n === void 0
                ? void 0
                : n.slice(0, 10),
            data:
              (r = t.cause.data) === null || r === void 0
                ? void 0
                : r.substring(10),
            customErrorName: t.cause.errorName,
            customErrorDecodedSignature: t.cause.errorSignature,
            customErrorArguments: t.cause.errorArgs
          }
        );
      }
      return {
        reason: t.cause.message,
        signature:
          (i = t.cause.data) === null || i === void 0 ? void 0 : i.slice(0, 10),
        data:
          (s = t.cause.data) === null || s === void 0 ? void 0 : s.substring(10)
      };
    }
    if (
      t instanceof up &&
      !Array.isArray(
        (o = t.cause) === null || o === void 0 ? void 0 : o.errors
      ) &&
      t.cause !== void 0
    )
      return t.cause.message;
    throw t;
  };
  function ax(t, e, n) {
    return SB(
      this,
      arguments,
      void 0,
      function* (r, i, s, o = r.defaultReturnFormat) {
        try {
          yield Nv(r, i, r.defaultBlock, o);
          return;
        } catch (a) {
          return xB(a, s);
        }
      }
    );
  }
  var CB = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  function Im(t, e, n, r, i, s) {
    return CB(this, void 0, void 0, function* () {
      let o = s;
      o === void 0 && t.handleRevert && e !== void 0 && (o = yield ax(t, e, i));
      let a;
      if (o === void 0) a = new ZA(n);
      else if (typeof o == 'string') a = new Hf(o, void 0, n);
      else if (
        o.customErrorName !== void 0 &&
        o.customErrorDecodedSignature !== void 0 &&
        o.customErrorArguments !== void 0
      ) {
        const c = o;
        a = new WA(
          c.reason,
          c.customErrorName,
          c.customErrorDecodedSignature,
          c.customErrorArguments,
          c.signature,
          n,
          c.data
        );
      } else a = new Hf(o.reason, o.signature, n, o.data);
      return a;
    });
  }
  const Pv = (t, e, n, r = Tn) => {
    var i, s, o, a, c, l;
    let u = Object.assign({}, t);
    const d = ge(Mc, e, r);
    if ([vc, 'allEvents'].includes(u.name)) {
      const h = n.find((g) => g.signature === e.topics[0]);
      h ? (u = h) : (u = {anonymous: !0});
    }
    if (
      ((u.inputs =
        (s = (i = u.inputs) !== null && i !== void 0 ? i : t.inputs) !== null &&
        s !== void 0
          ? s
          : []),
      !u.anonymous)
    ) {
      let h = 0;
      (((o = u.inputs) !== null && o !== void 0 ? o : []).forEach((g) => {
        g.indexed && (h += 1);
      }),
        h > 0 &&
          e != null &&
          e.topics &&
          (e == null ? void 0 : e.topics.length) !== h + 1 &&
          (u = Object.assign(Object.assign({}, u), {
            anonymous: !0,
            inputs: []
          })));
    }
    const f = u.anonymous
      ? e.topics
      : ((a = e.topics) !== null && a !== void 0 ? a : []).slice(1);
    return Object.assign(Object.assign({}, d), {
      returnValues: ox(
        [...((c = u.inputs) !== null && c !== void 0 ? c : [])],
        e.data,
        f
      ),
      event: u.name,
      signature:
        !u.anonymous &&
        ((l = e.topics) === null || l === void 0 ? void 0 : l.length) > 0 &&
        e.topics[0]
          ? e.topics[0]
          : void 0,
      raw: {data: e.data, topics: e.topics}
    });
  };
  var mo = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  class cx {
    constructor({options: e, web3Context: n, promiEvent: r, returnFormat: i}) {
      ((this.options = {checkRevertBeforeSending: !0}),
        (this.options = e),
        (this.web3Context = n),
        (this.promiEvent = r),
        (this.returnFormat = i));
    }
    getReceiptWithEvents(e) {
      var n, r;
      const i = Object.assign({}, e ?? {});
      if (
        !((n = this.options) === null || n === void 0) &&
        n.contractAbi &&
        i.logs &&
        i.logs.length > 0
      ) {
        i.events = {};
        for (const s of i.logs) {
          const o = Pv(
            lg,
            s,
            (r = this.options) === null || r === void 0
              ? void 0
              : r.contractAbi,
            this.returnFormat
          );
          o.event && (i.events[o.event] = o);
        }
      }
      return i;
    }
    checkRevertBeforeSending(e) {
      return mo(this, void 0, void 0, function* () {
        if (this.options.checkRevertBeforeSending !== !1) {
          let n = e;
          ie(e.data) &&
            ie(e.input) &&
            ie(e.gas) &&
            (n = Object.assign(Object.assign({}, e), {gas: 21e3}));
          const r = yield ax(this.web3Context, n, this.options.contractAbi);
          if (r !== void 0)
            throw yield Im(
              this.web3Context,
              e,
              void 0,
              void 0,
              this.options.contractAbi,
              r
            );
        }
      });
    }
    emitSending(e) {
      this.promiEvent.listenerCount('sending') > 0 &&
        this.promiEvent.emit('sending', e);
    }
    populateGasPrice(e) {
      return mo(
        this,
        arguments,
        void 0,
        function* ({transactionFormatted: n, transaction: r}) {
          var i;
          let s = n;
          return (
            !this.web3Context.config.ignoreGasPricing &&
              !(
                !((i = this.options) === null || i === void 0) &&
                i.ignoreGasPricing
              ) &&
              ie(n.gasPrice) &&
              (ie(r.maxPriorityFeePerGas) || ie(r.maxFeePerGas)) &&
              (s = Object.assign(
                Object.assign({}, n),
                yield LS(n, this.web3Context, Be)
              )),
            s
          );
        }
      );
    }
    signAndSend(e) {
      return mo(this, arguments, void 0, function* ({wallet: n, tx: r}) {
        if (n) {
          const i = yield n.signTransaction(r);
          return fg(
            this.web3Context,
            () =>
              mo(this, void 0, void 0, function* () {
                return kS(this.web3Context.requestManager, i.rawTransaction);
              }),
            i.transactionHash
          );
        }
        return fg(this.web3Context, () =>
          mo(this, void 0, void 0, function* () {
            return MN(this.web3Context.requestManager, r);
          })
        );
      });
    }
    emitSent(e) {
      this.promiEvent.listenerCount('sent') > 0 &&
        this.promiEvent.emit('sent', e);
    }
    emitTransactionHash(e) {
      this.promiEvent.listenerCount('transactionHash') > 0 &&
        this.promiEvent.emit('transactionHash', e);
    }
    emitReceipt(e) {
      this.promiEvent.listenerCount('receipt') > 0 &&
        this.promiEvent.emit('receipt', e);
    }
    handleError(e) {
      return mo(this, arguments, void 0, function* ({error: n, tx: r}) {
        var i;
        let s = n;
        return (
          s instanceof Bo &&
            this.web3Context.handleRevert &&
            (s = yield Im(
              this.web3Context,
              r,
              void 0,
              void 0,
              (i = this.options) === null || i === void 0
                ? void 0
                : i.contractAbi
            )),
          (s instanceof up ||
            s instanceof Bo ||
            s instanceof WA ||
            s instanceof ZA ||
            s instanceof Hf ||
            s instanceof XA) &&
            this.promiEvent.listenerCount('error') > 0 &&
            this.promiEvent.emit('error', s),
          s
        );
      });
    }
    emitConfirmation({
      receipt: e,
      transactionHash: n,
      customTransactionReceiptSchema: r
    }) {
      this.promiEvent.listenerCount('confirmation') > 0 &&
        HL(this.web3Context, this.promiEvent, e, n, this.returnFormat, r);
    }
    handleResolve(e) {
      return mo(this, arguments, void 0, function* ({receipt: n, tx: r}) {
        var i, s, o;
        if (
          !((i = this.options) === null || i === void 0) &&
          i.transactionResolver
        )
          return (s = this.options) === null || s === void 0
            ? void 0
            : s.transactionResolver(n);
        if (n.status === BigInt(0)) {
          const a = yield Im(
            this.web3Context,
            r,
            n,
            void 0,
            (o = this.options) === null || o === void 0 ? void 0 : o.contractAbi
          );
          throw (
            this.promiEvent.listenerCount('error') > 0 &&
              this.promiEvent.emit('error', a),
            a
          );
        } else return n;
      });
    }
  }
  var ft = function (t, e, n, r) {
      function i(s) {
        return s instanceof n
          ? s
          : new n(function (o) {
              o(s);
            });
      }
      return new (n || (n = Promise))(function (s, o) {
        function a(u) {
          try {
            l(r.next(u));
          } catch (d) {
            o(d);
          }
        }
        function c(u) {
          try {
            l(r.throw(u));
          } catch (d) {
            o(d);
          }
        }
        function l(u) {
          u.done ? s(u.value) : i(u.value).then(a, c);
        }
        l((r = r.apply(t, e || [])).next());
      });
    },
    TB = function (t, e) {
      var n = {};
      for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) &&
          e.indexOf(r) < 0 &&
          (n[r] = t[r]);
      if (t != null && typeof Object.getOwnPropertySymbols == 'function')
        for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
          e.indexOf(r[i]) < 0 &&
            Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
            (n[r[i]] = t[r[i]]);
      return n;
    };
  const IB = (t) =>
    ft(void 0, void 0, void 0, function* () {
      return IS(t.requestManager);
    });
  function kB(t, e) {
    return ft(this, void 0, void 0, function* () {
      const n = yield yN(t.requestManager);
      return ge({format: 'uint'}, n, e ?? t.defaultReturnFormat);
    });
  }
  function Mv(t, e) {
    return ft(this, void 0, void 0, function* () {
      const n = yield vN(t.requestManager);
      return ge({format: 'uint'}, n, e ?? t.defaultReturnFormat);
    });
  }
  function RB(t, e) {
    return ft(this, void 0, void 0, function* () {
      const n = yield bN(t.requestManager);
      return ge({format: 'uint'}, n, e ?? t.defaultReturnFormat);
    });
  }
  function Ov(t, e) {
    return ft(this, void 0, void 0, function* () {
      const n = yield _N(t.requestManager);
      return ge({format: 'uint'}, n, e ?? t.defaultReturnFormat);
    });
  }
  function PB(t, e) {
    return ft(this, arguments, void 0, function* (n, r, i = n.defaultBlock, s) {
      const o = Gt(i) ? i : ge({format: 'uint'}, i, Be),
        a = yield EN(n.requestManager, r, o);
      return ge({format: 'uint'}, a, s ?? n.defaultReturnFormat);
    });
  }
  function MB(t, e, n) {
    return ft(
      this,
      arguments,
      void 0,
      function* (r, i, s, o = r.defaultBlock, a) {
        const c = ge({format: 'uint'}, s, Be),
          l = Gt(o) ? o : ge({format: 'uint'}, o, Be),
          u = yield AN(r.requestManager, i, c, l);
        return ge({format: 'bytes'}, u, a ?? r.defaultReturnFormat);
      }
    );
  }
  function OB(t, e) {
    return ft(this, arguments, void 0, function* (n, r, i = n.defaultBlock, s) {
      const o = Gt(i) ? i : ge({format: 'uint'}, i, Be),
        a = yield kN(n.requestManager, r, o);
      return ge({format: 'bytes'}, a, s ?? n.defaultReturnFormat);
    });
  }
  function lx(t) {
    return ft(
      this,
      arguments,
      void 0,
      function* (e, n = e.defaultBlock, r = !1, i) {
        var s;
        let o;
        if (ao(n)) {
          const c = ge({format: 'bytes32'}, n, Be);
          o = yield LN(e.requestManager, c, r);
        } else {
          const c = Gt(n) ? n : ge({format: 'uint'}, n, Be);
          o = yield RS(e.requestManager, c, r);
        }
        const a = ge(ch, o, i ?? e.defaultReturnFormat);
        return ie(a)
          ? a
          : Object.assign(Object.assign({}, a), {
              transactions:
                (s = a.transactions) !== null && s !== void 0 ? s : []
            });
      }
    );
  }
  function NB(t) {
    return ft(this, arguments, void 0, function* (e, n = e.defaultBlock, r) {
      let i;
      if (ao(n)) {
        const s = ge({format: 'bytes32'}, n, Be);
        i = yield xN(e.requestManager, s);
      } else {
        const s = Gt(n) ? n : ge({format: 'uint'}, n, Be);
        i = yield CN(e.requestManager, s);
      }
      return ge({format: 'uint'}, i, r ?? e.defaultReturnFormat);
    });
  }
  function LB(t) {
    return ft(this, arguments, void 0, function* (e, n = e.defaultBlock, r) {
      let i;
      if (ao(n)) {
        const s = ge({format: 'bytes32'}, n, Be);
        i = yield TN(e.requestManager, s);
      } else {
        const s = Gt(n) ? n : ge({format: 'uint'}, n, Be);
        i = yield IN(e.requestManager, s);
      }
      return ge({format: 'uint'}, i, r ?? e.defaultReturnFormat);
    });
  }
  function BB(t) {
    return ft(this, arguments, void 0, function* (e, n = e.defaultBlock, r, i) {
      const s = ge({format: 'uint'}, r, Be);
      let o;
      if (ao(n)) {
        const a = ge({format: 'bytes32'}, n, Be);
        o = yield HN(e.requestManager, a, s);
      } else {
        const a = Gt(n) ? n : ge({format: 'uint'}, n, Be);
        o = yield jN(e.requestManager, a, s);
      }
      return ge(ch, o, i ?? e.defaultReturnFormat);
    });
  }
  function DB(t, e) {
    return ft(
      this,
      arguments,
      void 0,
      function* (n, r, i = n.defaultReturnFormat) {
        const s = ge({format: 'bytes32'}, r, Tn),
          o = yield BN(n.requestManager, s);
        return ie(o)
          ? o
          : Vn(o, i, {
              transactionSchema: n.config.customTransactionSchema,
              fillInputAndData: !0
            });
      }
    );
  }
  function FB(t, e) {
    return ft(this, void 0, void 0, function* () {
      return (yield JN(t.requestManager)).map((r) =>
        Vn(r, e ?? t.defaultReturnFormat, {
          transactionSchema: t.config.customTransactionSchema,
          fillInputAndData: !0
        })
      );
    });
  }
  function $B(t) {
    return ft(this, arguments, void 0, function* (e, n = e.defaultBlock, r, i) {
      const s = ge({format: 'uint'}, r, Be);
      let o;
      if (ao(n)) {
        const a = ge({format: 'bytes32'}, n, Be);
        o = yield DN(e.requestManager, a, s);
      } else {
        const a = Gt(n) ? n : ge({format: 'uint'}, n, Be);
        o = yield FN(e.requestManager, a, s);
      }
      return ie(o)
        ? o
        : Vn(o, i ?? e.defaultReturnFormat, {
            transactionSchema: e.config.customTransactionSchema,
            fillInputAndData: !0
          });
    });
  }
  function ux(t, e, n) {
    return ft(this, void 0, void 0, function* () {
      const r = ge({format: 'bytes32'}, e, Tn);
      let i;
      try {
        i = yield $N(t.requestManager, r);
      } catch (s) {
        if (
          typeof s == 'object' &&
          !ie(s) &&
          'message' in s &&
          s.message === 'transaction indexing is in progress'
        )
          console.warn('Transaction indexing is in progress.');
        else throw s;
      }
      return ie(i) ? i : ge(Oc, i, n ?? t.defaultReturnFormat);
    });
  }
  function dx(t, e) {
    return ft(this, arguments, void 0, function* (n, r, i = n.defaultBlock, s) {
      const o = Gt(i) ? i : ge({format: 'uint'}, i, Be),
        a = yield SN(n.requestManager, r, o);
      return ge({format: 'uint'}, a, s ?? n.defaultReturnFormat);
    });
  }
  function su(t, e, n, r = {checkRevertBeforeSending: !0}, i) {
    const s = new TS((o, a) => {
      setImmediate(() => {
        ft(this, void 0, void 0, function* () {
          const c = new cx({
            web3Context: t,
            promiEvent: s,
            options: r,
            returnFormat: n
          });
          let l = Object.assign({}, e);
          ie(i) || (l = yield i.processTransaction(l));
          let u = Vn(
            Object.assign(Object.assign({}, l), {
              from: ug('from', t, l),
              to: ug('to', t, l)
            }),
            Be,
            {transactionSchema: t.config.customTransactionSchema}
          );
          try {
            ((u = yield c.populateGasPrice({
              transaction: l,
              transactionFormatted: u
            })),
              yield c.checkRevertBeforeSending(u),
              c.emitSending(u));
            let d;
            t.wallet && !ie(u.from) && (d = t.wallet.get(u.from));
            const f = yield c.signAndSend({wallet: d, tx: u}),
              h = ge({format: 'bytes32'}, f, n ?? t.defaultReturnFormat);
            (c.emitSent(u), c.emitTransactionHash(h));
            const g = yield FS(t, f, n ?? t.defaultReturnFormat),
              m = c.getReceiptWithEvents(ge(Oc, g, n ?? t.defaultReturnFormat));
            (c.emitReceipt(m),
              o(yield c.handleResolve({receipt: m, tx: u})),
              c.emitConfirmation({receipt: m, transactionHash: f}));
          } catch (d) {
            a(yield c.handleError({error: d, tx: u}));
          }
        });
      });
    });
    return s;
  }
  function HB(t, e, n, r = {checkRevertBeforeSending: !0}) {
    const i = new TS((s, o) => {
      setImmediate(() => {
        ft(this, void 0, void 0, function* () {
          const a = new cx({
              web3Context: t,
              promiEvent: i,
              options: r,
              returnFormat: n
            }),
            c = ge({format: 'bytes'}, e, Be),
            l = ea.fromSerializedData(yi(bt(c))),
            u = Object.assign(Object.assign({}, l.toJSON()), {
              from: l.getSenderAddress().toString()
            });
          try {
            const {v: d, r: f, s: h} = u,
              g = TB(u, ['v', 'r', 's']);
            (yield a.checkRevertBeforeSending(g), a.emitSending(c));
            const m = yield fg(t, () =>
              ft(this, void 0, void 0, function* () {
                return kS(t.requestManager, c);
              })
            );
            a.emitSent(c);
            const y = ge({format: 'bytes32'}, m, n ?? t.defaultReturnFormat);
            a.emitTransactionHash(y);
            const p = yield FS(t, m, n ?? t.defaultReturnFormat),
              b = a.getReceiptWithEvents(ge(Oc, p, n ?? t.defaultReturnFormat));
            (a.emitReceipt(b),
              s(yield a.handleResolve({receipt: b, tx: u})),
              a.emitConfirmation({receipt: b, transactionHash: m}));
          } catch (d) {
            o(yield a.handleError({error: d, tx: u}));
          }
        });
      });
    });
    return i;
  }
  function jB(t, e, n) {
    return ft(
      this,
      arguments,
      void 0,
      function* (r, i, s, o = r.defaultReturnFormat) {
        var a;
        const c = ge({format: 'bytes'}, i, Tn);
        if (!((a = r.wallet) === null || a === void 0) && a.get(s)) {
          const d = r.wallet.get(s).sign(c);
          return ge(xL, d, o);
        }
        if (typeof s == 'number')
          throw new UR(
            i,
            'RPC method "eth_sign" does not support index signatures'
          );
        const l = yield RN(r.requestManager, s, c);
        return ge({format: 'bytes'}, l, o);
      }
    );
  }
  function UB(t, e) {
    return ft(
      this,
      arguments,
      void 0,
      function* (n, r, i = n.defaultReturnFormat) {
        const s = yield PN(
          n.requestManager,
          Vn(r, Be, {transactionSchema: n.config.customTransactionSchema})
        );
        return Gy(s)
          ? kL(s, i, {fillInputAndData: !0})
          : {
              raw: ge({format: 'bytes'}, s.raw, i),
              tx: Vn(s.tx, i, {
                transactionSchema: n.config.customTransactionSchema,
                fillInputAndData: !0
              })
            };
      }
    );
  }
  function Nv(t, e) {
    return ft(
      this,
      arguments,
      void 0,
      function* (n, r, i = n.defaultBlock, s = n.defaultReturnFormat) {
        const o = Gt(i) ? i : ge({format: 'uint'}, i, Be),
          a = yield ON(
            n.requestManager,
            Vn(r, Be, {transactionSchema: n.config.customTransactionSchema}),
            o
          );
        return ge({format: 'bytes'}, a, s);
      }
    );
  }
  function Lv(t, e) {
    return ft(this, arguments, void 0, function* (n, r, i = n.defaultBlock, s) {
      const o = Vn(r, Be, {
          transactionSchema: n.config.customTransactionSchema
        }),
        a = Gt(i) ? i : ge({format: 'uint'}, i, Be),
        c = yield NN(n.requestManager, o, a);
      return ge({format: 'uint'}, c, s ?? n.defaultReturnFormat);
    });
  }
  function fx(t, e, n) {
    return ft(this, void 0, void 0, function* () {
      let {toBlock: r, fromBlock: i} = e;
      (ie(r) || ((typeof r == 'number' || typeof r == 'bigint') && (r = $t(r))),
        ie(i) ||
          ((typeof i == 'number' || typeof i == 'bigint') && (i = $t(i))));
      const s = Object.assign(Object.assign({}, e), {fromBlock: i, toBlock: r});
      return (yield WN(t.requestManager, s)).map((c) =>
        typeof c == 'string' ? c : ge(Mc, c, n ?? t.defaultReturnFormat)
      );
    });
  }
  function hx(t, e) {
    return ft(this, void 0, void 0, function* () {
      const n = yield eL(t.requestManager);
      return ge({format: 'uint'}, n, e ?? t.defaultReturnFormat);
    });
  }
  function KB(t, e, n) {
    return ft(
      this,
      arguments,
      void 0,
      function* (r, i, s, o = r.defaultBlock, a) {
        const c = s.map((d) => ge({format: 'bytes'}, d, Be)),
          l = Gt(o) ? o : ge({format: 'uint'}, o, Be),
          u = yield tL(r.requestManager, i, c, l);
        return ge(IL, u, a ?? r.defaultReturnFormat);
      }
    );
  }
  function qB(t, e) {
    return ft(
      this,
      arguments,
      void 0,
      function* (n, r, i = n.defaultBlock, s, o) {
        const a = ge({format: 'uint'}, r, Be),
          c = Gt(i) ? i : ge({format: 'uint'}, i, Be),
          l = ge({type: 'array', items: {format: 'uint'}}, s, Ip),
          u = yield QN(n.requestManager, a, c, l);
        return ge(CL, u, o ?? n.defaultReturnFormat);
      }
    );
  }
  function px(t, e) {
    return ft(this, arguments, void 0, function* (n, r, i = n.defaultBlock, s) {
      const o = Gt(i) ? i : ge({format: 'uint'}, i, Be),
        a = yield rL(
          n.requestManager,
          Vn(r, Be, {transactionSchema: n.config.customTransactionSchema}),
          o
        );
      return ge(_L, a, s ?? n.defaultReturnFormat);
    });
  }
  function VB(t, e, n, r, i) {
    return ft(this, void 0, void 0, function* () {
      const s = yield iL(t.requestManager, e, n, r);
      return ge({format: 'bytes'}, s, i ?? t.defaultReturnFormat);
    });
  }
  var Nc = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  function GB(t, e) {
    return Nc(this, void 0, void 0, function* () {
      const n = yield qN(t.requestManager);
      return ge({format: 'uint'}, n, e ?? t.defaultReturnFormat);
    });
  }
  function zB(t, e, n) {
    return Nc(this, void 0, void 0, function* () {
      let {toBlock: r, fromBlock: i} = e;
      (ie(r) || ((typeof r == 'number' || typeof r == 'bigint') && (r = $t(r))),
        ie(i) ||
          ((typeof i == 'number' || typeof i == 'bigint') && (i = $t(i))));
      const s = Object.assign(Object.assign({}, e), {fromBlock: i, toBlock: r}),
        o = yield UN(t.requestManager, s);
      return ge({format: 'uint'}, o, n ?? t.defaultReturnFormat);
    });
  }
  function WB(t, e) {
    return Nc(this, void 0, void 0, function* () {
      const n = yield KN(t.requestManager);
      return ge({format: 'uint'}, n, e ?? t.defaultReturnFormat);
    });
  }
  function ZB(t, e) {
    return Nc(this, void 0, void 0, function* () {
      return yield VN(t.requestManager, $t(e));
    });
  }
  function YB(t, e, n) {
    return Nc(this, void 0, void 0, function* () {
      return (yield GN(t.requestManager, $t(e))).map((s) =>
        typeof s == 'string' ? s : ge(Mc, s, n ?? t.defaultReturnFormat)
      );
    });
  }
  function QB(t, e, n) {
    return Nc(this, void 0, void 0, function* () {
      return (yield zN(t.requestManager, $t(e))).map((s) =>
        typeof s == 'string' ? s : ge(Mc, s, n ?? t.defaultReturnFormat)
      );
    });
  }
  class mx extends Lu {
    _buildSubscriptionParams() {
      return ['logs', this.args];
    }
    formatSubscriptionResult(e) {
      return ge(Mc, e, super.returnFormat);
    }
  }
  class Iw extends Lu {
    _buildSubscriptionParams() {
      return ['newPendingTransactions'];
    }
    formatSubscriptionResult(e) {
      return ge({format: 'string'}, e, super.returnFormat);
    }
  }
  class fh extends Lu {
    _buildSubscriptionParams() {
      return ['newHeads'];
    }
    formatSubscriptionResult(e) {
      return ge(AL, e, super.returnFormat);
    }
  }
  class gx extends Lu {
    _buildSubscriptionParams() {
      return ['syncing'];
    }
    _processSubscriptionResult(e) {
      if (typeof e == 'boolean') this.emit('changed', e);
      else {
        const n = Object.fromEntries(
          Object.entries((e == null ? void 0 : e.status) || e).map(([r, i]) => [
            r.charAt(0).toLowerCase() + r.substring(1),
            i
          ])
        );
        (this.emit('changed', e.syncing),
          this.emit('data', ge(SL, n, super.returnFormat)));
      }
    }
  }
  var De = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  const vg = {
    logs: mx,
    newPendingTransactions: Iw,
    newHeads: fh,
    syncing: gx,
    pendingTransactions: Iw,
    newBlockHeaders: fh
  };
  class Mp extends Un {
    constructor(e) {
      if (typeof e == 'string' || rh(e)) {
        super({provider: e, registeredSubscriptions: vg});
        return;
      }
      if (e.registeredSubscriptions) {
        super(e);
        return;
      }
      (super(
        Object.assign(Object.assign({}, e), {registeredSubscriptions: vg})
      ),
        (this.getFeeData = this.calculateFeeData));
    }
    setTransactionMiddleware(e) {
      this.transactionMiddleware = e;
    }
    getTransactionMiddleware() {
      return this.transactionMiddleware;
    }
    getProtocolVersion() {
      return De(this, void 0, void 0, function* () {
        return pN(this.requestManager);
      });
    }
    isSyncing() {
      return De(this, void 0, void 0, function* () {
        return IS(this.requestManager);
      });
    }
    getCoinbase() {
      return De(this, void 0, void 0, function* () {
        return mN(this.requestManager);
      });
    }
    isMining() {
      return De(this, void 0, void 0, function* () {
        return gN(this.requestManager);
      });
    }
    getHashrate(e) {
      return De(this, void 0, void 0, function* () {
        var n;
        return (
          e === void 0 &&
            (e =
              (n = this.defaultReturnFormat) !== null && n !== void 0 ? n : Tn),
          this.getHashRate(e)
        );
      });
    }
    getHashRate() {
      return De(
        this,
        arguments,
        void 0,
        function* (e = this.defaultReturnFormat) {
          return kB(this, e);
        }
      );
    }
    getGasPrice() {
      return De(
        this,
        arguments,
        void 0,
        function* (e = this.defaultReturnFormat) {
          return Mv(this, e);
        }
      );
    }
    getMaxPriorityFeePerGas() {
      return De(
        this,
        arguments,
        void 0,
        function* (e = this.defaultReturnFormat) {
          return RB(this, e);
        }
      );
    }
    calculateFeeData() {
      return De(
        this,
        arguments,
        void 0,
        function* (e = BigInt(2), n = yp.Gwei) {
          var r;
          const i = yield this.getBlock(void 0, !1),
            s =
              (r = i == null ? void 0 : i.baseFeePerGas) !== null &&
              r !== void 0
                ? r
                : void 0;
          let o;
          try {
            o = yield this.getGasPrice();
          } catch {}
          let a;
          try {
            a = yield this.getMaxPriorityFeePerGas();
          } catch {}
          let c;
          if (s) {
            a = a ?? n;
            let l;
            (typeof e == 'number'
              ? (l = BigInt(Math.floor(e * 1e3)) / BigInt(1e3))
              : (l = e),
              (c = s * l + a));
          }
          return {
            gasPrice: o,
            maxFeePerGas: c,
            maxPriorityFeePerGas: a,
            baseFeePerGas: s
          };
        }
      );
    }
    getAccounts() {
      return De(this, void 0, void 0, function* () {
        var e;
        return (
          (e = yield wN(this.requestManager)) !== null && e !== void 0 ? e : []
        ).map((r) => _i(r));
      });
    }
    getBlockNumber() {
      return De(
        this,
        arguments,
        void 0,
        function* (e = this.defaultReturnFormat) {
          return Ov(this, e);
        }
      );
    }
    getBalance(e) {
      return De(
        this,
        arguments,
        void 0,
        function* (n, r = this.defaultBlock, i = this.defaultReturnFormat) {
          return PB(this, n, r, i);
        }
      );
    }
    getStorageAt(e, n) {
      return De(
        this,
        arguments,
        void 0,
        function* (r, i, s = this.defaultBlock, o = this.defaultReturnFormat) {
          return MB(this, r, i, s, o);
        }
      );
    }
    getCode(e) {
      return De(
        this,
        arguments,
        void 0,
        function* (n, r = this.defaultBlock, i = this.defaultReturnFormat) {
          return OB(this, n, r, i);
        }
      );
    }
    getBlock() {
      return De(
        this,
        arguments,
        void 0,
        function* (
          e = this.defaultBlock,
          n = !1,
          r = this.defaultReturnFormat
        ) {
          return lx(this, e, n, r);
        }
      );
    }
    getBlockTransactionCount() {
      return De(
        this,
        arguments,
        void 0,
        function* (e = this.defaultBlock, n = this.defaultReturnFormat) {
          return NB(this, e, n);
        }
      );
    }
    getBlockUncleCount() {
      return De(
        this,
        arguments,
        void 0,
        function* (e = this.defaultBlock, n = this.defaultReturnFormat) {
          return LB(this, e, n);
        }
      );
    }
    getUncle() {
      return De(
        this,
        arguments,
        void 0,
        function* (e = this.defaultBlock, n, r = this.defaultReturnFormat) {
          return BB(this, e, n, r);
        }
      );
    }
    getTransaction(e) {
      return De(
        this,
        arguments,
        void 0,
        function* (n, r = this.defaultReturnFormat) {
          const i = yield DB(this, n, r);
          if (!i) throw new Mb();
          return i;
        }
      );
    }
    getPendingTransactions() {
      return De(
        this,
        arguments,
        void 0,
        function* (e = this.defaultReturnFormat) {
          return FB(this, e);
        }
      );
    }
    getTransactionFromBlock() {
      return De(
        this,
        arguments,
        void 0,
        function* (e = this.defaultBlock, n, r = this.defaultReturnFormat) {
          return $B(this, e, n, r);
        }
      );
    }
    getTransactionReceipt(e) {
      return De(
        this,
        arguments,
        void 0,
        function* (n, r = this.defaultReturnFormat) {
          const i = yield ux(this, n, r);
          if (!i) throw new Mb();
          return i;
        }
      );
    }
    getTransactionCount(e) {
      return De(
        this,
        arguments,
        void 0,
        function* (n, r = this.defaultBlock, i = this.defaultReturnFormat) {
          return dx(this, n, r, i);
        }
      );
    }
    sendTransaction(e, n = this.defaultReturnFormat, r) {
      return su(this, e, n, r, this.transactionMiddleware);
    }
    sendSignedTransaction(e, n = this.defaultReturnFormat, r) {
      return HB(this, e, n, r);
    }
    sign(e, n) {
      return De(
        this,
        arguments,
        void 0,
        function* (r, i, s = this.defaultReturnFormat) {
          return jB(this, r, i, s);
        }
      );
    }
    signTransaction(e) {
      return De(
        this,
        arguments,
        void 0,
        function* (n, r = this.defaultReturnFormat) {
          return UB(this, n, r);
        }
      );
    }
    call(e) {
      return De(
        this,
        arguments,
        void 0,
        function* (n, r = this.defaultBlock, i = this.defaultReturnFormat) {
          return Nv(this, n, r, i);
        }
      );
    }
    estimateGas(e) {
      return De(
        this,
        arguments,
        void 0,
        function* (n, r = this.defaultBlock, i = this.defaultReturnFormat) {
          return Lv(this, n, r, i);
        }
      );
    }
    getPastLogs(e) {
      return De(
        this,
        arguments,
        void 0,
        function* (n, r = this.defaultReturnFormat) {
          return fx(this, n, r);
        }
      );
    }
    getWork() {
      return De(this, void 0, void 0, function* () {
        return ZN(this.requestManager);
      });
    }
    submitWork(e, n, r) {
      return De(this, void 0, void 0, function* () {
        return YN(this.requestManager, e, n, r);
      });
    }
    requestAccounts() {
      return De(this, void 0, void 0, function* () {
        return XN(this.requestManager);
      });
    }
    getChainId() {
      return De(
        this,
        arguments,
        void 0,
        function* (e = this.defaultReturnFormat) {
          return hx(this, e);
        }
      );
    }
    getNodeInfo() {
      return De(this, void 0, void 0, function* () {
        return nL(this.requestManager);
      });
    }
    getProof(e, n) {
      return De(
        this,
        arguments,
        void 0,
        function* (r, i, s = this.defaultBlock, o = this.defaultReturnFormat) {
          return KB(this, r, i, s, o);
        }
      );
    }
    getFeeHistory(e) {
      return De(
        this,
        arguments,
        void 0,
        function* (n, r = this.defaultBlock, i, s = this.defaultReturnFormat) {
          return qB(this, n, r, i, s);
        }
      );
    }
    createAccessList(e) {
      return De(
        this,
        arguments,
        void 0,
        function* (n, r = this.defaultBlock, i = this.defaultReturnFormat) {
          return px(this, n, r, i);
        }
      );
    }
    signTypedData(e, n, r, i) {
      return De(this, void 0, void 0, function* () {
        var s;
        return (
          r === void 0 && (r = !1),
          i === void 0 &&
            (i =
              (s = this.defaultReturnFormat) !== null && s !== void 0 ? s : Tn),
          VB(this, e, n, r, i)
        );
      });
    }
    subscribe(e, n, r) {
      return De(this, void 0, void 0, function* () {
        var i, s;
        r === void 0 &&
          (r =
            (i = this.defaultReturnFormat) !== null && i !== void 0 ? i : Tn);
        const o = yield (s = this.subscriptionManager) === null || s === void 0
          ? void 0
          : s.subscribe(e, n, r);
        return (
          o instanceof mx &&
            e === 'logs' &&
            typeof n == 'object' &&
            !Re(n.fromBlock) &&
            Number.isFinite(Number(n.fromBlock)) &&
            setImmediate(() => {
              this.getPastLogs(n)
                .then((a) => {
                  for (const c of a) o._processSubscriptionResult(c);
                })
                .catch((a) => {
                  o._processSubscriptionError(a);
                });
            }),
          o
        );
      });
    }
    static shouldClearSubscription({sub: e}) {
      return !(e instanceof gx);
    }
    clearSubscriptions(e = !1) {
      var n;
      return (n = this.subscriptionManager) === null || n === void 0
        ? void 0
        : n.unsubscribe(e ? Mp.shouldClearSubscription : void 0);
    }
    createNewPendingTransactionFilter() {
      return De(
        this,
        arguments,
        void 0,
        function* (e = this.defaultReturnFormat) {
          return GB(this, e);
        }
      );
    }
    createNewFilter(e) {
      return De(
        this,
        arguments,
        void 0,
        function* (n, r = this.defaultReturnFormat) {
          return zB(this, n, r);
        }
      );
    }
    createNewBlockFilter() {
      return De(
        this,
        arguments,
        void 0,
        function* (e = this.defaultReturnFormat) {
          return WB(this, e);
        }
      );
    }
    uninstallFilter(e) {
      return De(this, void 0, void 0, function* () {
        return ZB(this, e);
      });
    }
    getFilterChanges(e) {
      return De(
        this,
        arguments,
        void 0,
        function* (n, r = this.defaultReturnFormat) {
          return YB(this, n, r);
        }
      );
    }
    getFilterLogs(e) {
      return De(
        this,
        arguments,
        void 0,
        function* (n, r = this.defaultReturnFormat) {
          return QB(this, n, r);
        }
      );
    }
  }
  const JB = (t) => {
      if (!ie(t.common)) {
        if (ie(t.common.customChain)) throw new GR();
        if (ie(t.common.customChain.chainId)) throw new zR();
        if (!ie(t.chainId) && t.chainId !== t.common.customChain.chainId)
          throw new WR({
            txChainId: t.chainId,
            customChainId: t.common.customChain.chainId
          });
      }
    },
    XB = (t) => {
      if (!ie(t.common) && !ie(t.chain) && !ie(t.hardfork)) throw new QR();
      if ((!ie(t.chain) && ie(t.hardfork)) || (!ie(t.hardfork) && ie(t.chain)))
        throw new JR({chain: t.chain, hardfork: t.hardfork});
    },
    eD = (t) => {
      if (
        !ie(t.common) &&
        !ie(t.common.baseChain) &&
        !ie(t.chain) &&
        t.chain !== t.common.baseChain
      )
        throw new ZR({txChain: t.chain, baseChain: t.common.baseChain});
    },
    tD = (t) => {
      if (
        !ie(t.common) &&
        !ie(t.common.hardfork) &&
        !ie(t.hardfork) &&
        t.hardfork !== t.common.hardfork
      )
        throw new YR({
          txHardfork: t.hardfork,
          commonHardfork: t.common.hardfork
        });
    },
    kw = (t) => {
      if (ie(t.gas) || !rs(t.gas) || ie(t.gasPrice) || !rs(t.gasPrice))
        throw new rP({gas: t.gas, gasPrice: t.gasPrice});
      if (!ie(t.maxFeePerGas) || !ie(t.maxPriorityFeePerGas))
        throw new YA({
          maxFeePerGas: t.maxFeePerGas,
          maxPriorityFeePerGas: t.maxPriorityFeePerGas
        });
    },
    Rw = (t) => {
      if (!ie(t.gasPrice) && t.type === '0x2') throw new sP(t.gasPrice);
      if (t.type === '0x0' || t.type === '0x1')
        throw new YA({
          maxFeePerGas: t.maxFeePerGas,
          maxPriorityFeePerGas: t.maxPriorityFeePerGas
        });
      if (
        ie(t.maxFeePerGas) ||
        !rs(t.maxFeePerGas) ||
        ie(t.maxPriorityFeePerGas) ||
        !rs(t.maxPriorityFeePerGas)
      )
        throw new iP({
          maxPriorityFeePerGas: t.maxPriorityFeePerGas,
          maxFeePerGas: t.maxFeePerGas
        });
    },
    nD = (t) => {
      const e = !ie(t.gas) || !ie(t.gasLimit),
        n = e && !ie(t.gasPrice),
        r = e && !ie(t.maxPriorityFeePerGas) && !ie(t.maxFeePerGas);
      if (!n && !r)
        throw new eP({
          gas: t.gas,
          gasPrice: t.gasPrice,
          maxPriorityFeePerGas: t.maxPriorityFeePerGas,
          maxFeePerGas: t.maxFeePerGas
        });
      if (n && r)
        throw new nP({
          gas: t.gas,
          gasPrice: t.gasPrice,
          maxPriorityFeePerGas: t.maxPriorityFeePerGas,
          maxFeePerGas: t.maxFeePerGas
        });
      ((n ? kw : Rw)(t), (!ie(t.type) && t.type > '0x1' ? Rw : kw)(t));
    },
    rD = (t, e, n = {transactionSchema: void 0}) => {
      if (!ie(e)) {
        e(t);
        return;
      }
      if (typeof t != 'object' || ie(t)) throw new oP(t);
      (JB(t), XB(t), eD(t), tD(t));
      const r = Vn(t, Be, {transactionSchema: n.transactionSchema});
      if (
        (nD(r),
        ie(r.nonce) ||
          ie(r.chainId) ||
          r.nonce.startsWith('-') ||
          r.chainId.startsWith('-'))
      )
        throw new aP({nonce: t.nonce, chainId: t.chainId});
    };
  var iD = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  const sD = (t) => {
      var e, n;
      return Object.assign(Object.assign({}, t), {
        nonce: t.nonce,
        gasPrice: t.gasPrice,
        gasLimit: (e = t.gasLimit) !== null && e !== void 0 ? e : t.gas,
        to: t.to,
        value: t.value,
        data: (n = t.data) !== null && n !== void 0 ? n : t.input,
        type: t.type,
        chainId: t.chainId,
        accessList: t.accessList,
        maxPriorityFeePerGas: t.maxPriorityFeePerGas,
        maxFeePerGas: t.maxFeePerGas
      });
    },
    oD = (t, e) => {
      var n, r, i, s, o, a, c, l, u, d, f, h, g, m, y, p, b, v;
      const x = (!ie(t.chain) && !ie(t.hardfork)) || !ie(t.common);
      let C;
      if (!x)
        e.defaultCommon
          ? ((C = Object.assign({}, e.defaultCommon)),
            ie(C.hardfork) &&
              (C.hardfork =
                (n = t.hardfork) !== null && n !== void 0
                  ? n
                  : e.defaultHardfork),
            ie(C.baseChain) && (C.baseChain = e.defaultChain))
          : (C = Bt.custom(
              {
                name: 'custom-network',
                chainId: jn(t.chainId),
                networkId: ie(t.networkId) ? void 0 : jn(t.networkId),
                defaultHardfork:
                  (r = t.hardfork) !== null && r !== void 0
                    ? r
                    : e.defaultHardfork
              },
              {baseChain: e.defaultChain}
            ));
      else {
        const $ =
            (a =
              (o =
                (s =
                  (i = t == null ? void 0 : t.common) === null || i === void 0
                    ? void 0
                    : i.customChain) === null || s === void 0
                  ? void 0
                  : s.name) !== null && o !== void 0
                ? o
                : t.chain) !== null && a !== void 0
              ? a
              : 'custom-network',
          G = jn(
            (u =
              (l =
                (c = t == null ? void 0 : t.common) === null || c === void 0
                  ? void 0
                  : c.customChain) === null || l === void 0
                ? void 0
                : l.chainId) !== null && u !== void 0
              ? u
              : t == null
                ? void 0
                : t.chainId
          ),
          L = jn(
            (h =
              (f =
                (d = t == null ? void 0 : t.common) === null || d === void 0
                  ? void 0
                  : d.customChain) === null || f === void 0
                ? void 0
                : f.networkId) !== null && h !== void 0
              ? h
              : t == null
                ? void 0
                : t.networkId
          ),
          F =
            (y =
              (m =
                (g = t == null ? void 0 : t.common) === null || g === void 0
                  ? void 0
                  : g.hardfork) !== null && m !== void 0
                ? m
                : t == null
                  ? void 0
                  : t.hardfork) !== null && y !== void 0
              ? y
              : e.defaultHardfork,
          k =
            (v =
              (b =
                (p = t.common) === null || p === void 0
                  ? void 0
                  : p.baseChain) !== null && b !== void 0
                ? b
                : t.chain) !== null && v !== void 0
              ? v
              : e.defaultChain;
        G &&
          L &&
          $ &&
          (C = Bt.custom(
            {name: $, chainId: G, networkId: L, defaultHardfork: F},
            {baseChain: k}
          ));
      }
      return {common: C};
    },
    aD = (t, e, n, ...r) =>
      iD(void 0, [t, e, n, ...r], void 0, function* (i, s, o, a = !1, c = !0) {
        const l = yield LL({
            transaction: i,
            web3Context: s,
            privateKey: o,
            fillGasPrice: a,
            fillGasLimit: c
          }),
          u = Vn(l, Be, {transactionSchema: s.config.customTransactionSchema});
        return (
          rD(u, void 0, {transactionSchema: s.config.customTransactionSchema}),
          ea.fromTxData(sD(u), oD(u, s))
        );
      }),
    Pw = ({address: t}, e, n) => {
      var r, i;
      const s = n == null ? void 0 : n.topics,
        o =
          (r = n == null ? void 0 : n.filter) !== null && r !== void 0 ? r : {},
        a = {};
      if (
        (Re(n == null ? void 0 : n.fromBlock) ||
          (a.fromBlock = ge(
            ch.properties.number,
            n == null ? void 0 : n.fromBlock,
            {number: wr.HEX, bytes: ts.HEX}
          )),
        Re(n == null ? void 0 : n.toBlock) ||
          (a.toBlock = ge(
            ch.properties.number,
            n == null ? void 0 : n.toBlock,
            {number: wr.HEX, bytes: ts.HEX}
          )),
        s && Array.isArray(s))
      )
        a.topics = [...s];
      else if (
        ((a.topics = []),
        e &&
          !e.anonymous &&
          ![vc, 'allEvents'].includes(e.name) &&
          a.topics.push(
            (i = e.signature) !== null && i !== void 0 ? i : Tv(Yi(e))
          ),
        ![vc, 'allEvents'].includes(e.name) && e.inputs)
      )
        for (const c of e.inputs) {
          if (!c.indexed) continue;
          const l = o[c.name];
          if (!l) {
            a.topics.push(null);
            continue;
          }
          Array.isArray(l)
            ? a.topics.push(l.map((u) => gg(c.type, u)))
            : c.type === 'string'
              ? a.topics.push(fc(l))
              : a.topics.push(gg(c.type, l));
        }
      return (
        a.topics.length || delete a.topics,
        t && (a.address = t.toLowerCase()),
        a
      );
    },
    wl = (t, e, n) => {
      const r = Array.isArray(t.inputs) ? t.inputs.length : 0;
      if (t.inputs && r !== e.length)
        throw new In(
          `The number of arguments is not matching the methods required number. You need to pass ${r} arguments.`
        );
      let i;
      if (
        (t.inputs
          ? (i = Pp(Array.isArray(t.inputs) ? t.inputs : [], e).replace(
              '0x',
              ''
            ))
          : (i = bB(e).replace('0x', '')),
        jL(t))
      ) {
        if (!n)
          throw new In(
            'The contract has no contract data option set. This is necessary to append the constructor parameters.'
          );
        return n.startsWith('0x') ? `${n}${i}` : `0x${n}${i}`;
      }
      return `${iu(t)}${i}`;
    };
  class yx extends Lu {
    constructor(e, n) {
      (super(e, n),
        (this.address = e.address),
        (this.topics = e.topics),
        (this.abi = e.abi),
        (this.jsonInterface = e.jsonInterface));
    }
    _buildSubscriptionParams() {
      return ['logs', {address: this.address, topics: this.topics}];
    }
    formatSubscriptionResult(e) {
      return Pv(this.abi, e, this.jsonInterface, super.returnFormat);
    }
  }
  Array.from({length: 256}, (t, e) => e.toString(16).padStart(2, '0'));
  const Op = (t, e, n, r) => {
      var i, s;
      const o = {};
      return (
        (!Re(t.data) || r === 'both') &&
          (o.data = wl(
            e,
            n,
            (i = t.data) !== null && i !== void 0 ? i : t.input
          )),
        (!Re(t.input) || r === 'both') &&
          (o.input = wl(
            e,
            n,
            (s = t.input) !== null && s !== void 0 ? s : t.data
          )),
        Re(o.input) && Re(o.data) && (o[r] = wl(e, n)),
        {data: o.data, input: o.input}
      );
    },
    bg = ({abi: t, params: e, options: n, contractOptions: r}) => {
      var i, s, o;
      if (
        !((o =
          (s =
            (i = n == null ? void 0 : n.input) !== null && i !== void 0
              ? i
              : n == null
                ? void 0
                : n.data) !== null && s !== void 0
            ? s
            : r.input) !== null && o !== void 0
          ? o
          : r.data) &&
        !(n != null && n.to) &&
        !r.address
      )
        throw new In('Contract address not specified');
      if (!(n != null && n.from) && !r.from)
        throw new In('Contract "from" address not specified');
      let c = lo(
        {
          to: r.address,
          gas: r.gas,
          gasPrice: r.gasPrice,
          from: r.from,
          input: r.input,
          maxPriorityFeePerGas: r.maxPriorityFeePerGas,
          maxFeePerGas: r.maxFeePerGas,
          data: r.data
        },
        n
      );
      const l = Op(c, t, e, n == null ? void 0 : n.dataInputFill);
      return (
        (c = Object.assign(Object.assign({}, c), {
          data: l.data,
          input: l.input
        })),
        c
      );
    },
    cD = ({abi: t, params: e, options: n, contractOptions: r}) => {
      if (!(n != null && n.to) && !r.address)
        throw new In('Contract address not specified');
      let i = lo(
        {
          to: r.address,
          gas: r.gas,
          gasPrice: r.gasPrice,
          from: r.from,
          input: r.input,
          maxPriorityFeePerGas: r.maxPriorityFeePerGas,
          maxFeePerGas: r.maxFeePerGas,
          data: r.data
        },
        n
      );
      const s = Op(i, t, e, n == null ? void 0 : n.dataInputFill);
      return (
        (i = Object.assign(Object.assign({}, i), {
          data: s.data,
          input: s.input
        })),
        i
      );
    },
    lD = ({abi: t, params: e, options: n, contractOptions: r}) => {
      let i = lo(
        {
          to: r.address,
          gas: r.gas,
          gasPrice: r.gasPrice,
          from: r.from,
          input: r.input,
          data: r.data
        },
        n
      );
      const s = Op(i, t, e, n == null ? void 0 : n.dataInputFill);
      return (
        (i = Object.assign(Object.assign({}, i), {
          data: s.data,
          input: s.input
        })),
        i
      );
    },
    Mw = (t) =>
      typeof t == 'object' && !Re(t) && Object.keys(t).length !== 0 && !Fs(t),
    uD = ({abi: t, params: e, options: n, contractOptions: r}) => {
      if (!(n != null && n.to) && !r.address)
        throw new In('Contract address not specified');
      if (!(n != null && n.from) && !r.from)
        throw new In('Contract "from" address not specified');
      let i = lo(
        {
          to: r.address,
          gas: r.gas,
          gasPrice: r.gasPrice,
          from: r.from,
          input: r.input,
          maxPriorityFeePerGas: r.maxPriorityFeePerGas,
          maxFeePerGas: r.maxFeePerGas,
          data: r.data
        },
        n
      );
      const s = Op(i, t, e, n == null ? void 0 : n.dataInputFill);
      return (
        (i = Object.assign(Object.assign({}, i), {
          data: s.data,
          input: s.input
        })),
        i
      );
    };
  var dD = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  class fD {
    _contractMethodDeploySend(e) {
      const n = {
        transactionResolver: (r) => {
          if (r.status === BigInt(0))
            throw new In("code couldn't be stored", r);
          const i = this.parent.clone();
          return ((i.options.address = r.contractAddress), i);
        },
        contractAbi: this.parent.options.jsonInterface,
        checkRevertBeforeSending: !1
      };
      return ie(this.parent.getTransactionMiddleware())
        ? su(this.parent, e, this.parent.defaultReturnFormat, n)
        : su(
            this.parent,
            e,
            this.parent.defaultReturnFormat,
            n,
            this.parent.getTransactionMiddleware()
          );
    }
    constructor(e, n) {
      ((this.parent = e), (this.deployOptions = n));
      const {
        args: r,
        abi: i,
        contractOptions: s,
        deployData: o
      } = this.calculateDeployParams();
      ((this.args = r),
        (this.constructorAbi = i),
        (this.contractOptions = s),
        (this.deployData = o));
    }
    send(e) {
      const n = Object.assign({}, e),
        r = this.populateTransaction(n);
      return this._contractMethodDeploySend(r);
    }
    populateTransaction(e) {
      var n, r;
      const i = Object.assign(Object.assign({}, this.contractOptions), {
          from:
            (r =
              (n = this.contractOptions.from) !== null && n !== void 0
                ? n
                : this.parent.defaultAccount) !== null && r !== void 0
              ? r
              : void 0
        }),
        s = bg({
          abi: this.constructorAbi,
          params: this.args,
          options: Object.assign(Object.assign({}, e), {
            dataInputFill: this.parent.contractDataInputFill
          }),
          contractOptions: i
        });
      return (s.dataInputFill && delete s.dataInputFill, s);
    }
    calculateDeployParams() {
      var e, n, r, i, s, o;
      let a = this.parent.options.jsonInterface.find(
        (h) => h.type === 'constructor'
      );
      a || (a = {type: 'constructor', stateMutability: ''});
      const c = ge(
          {format: 'bytes'},
          (n =
            (e = this.deployOptions) === null || e === void 0
              ? void 0
              : e.input) !== null && n !== void 0
            ? n
            : this.parent.options.input,
          Tn
        ),
        l = ge(
          {format: 'bytes'},
          (i =
            (r = this.deployOptions) === null || r === void 0
              ? void 0
              : r.data) !== null && i !== void 0
            ? i
            : this.parent.options.data,
          Tn
        );
      if ((!c || c.trim() === '0x') && (!l || l.trim() === '0x'))
        throw new In('contract creation without any data provided.');
      const u =
          (o =
            (s = this.deployOptions) === null || s === void 0
              ? void 0
              : s.arguments) !== null && o !== void 0
            ? o
            : [],
        d = Object.assign(Object.assign({}, this.parent.options), {
          input: c,
          data: l
        });
      return {args: u, abi: a, contractOptions: d, deployData: c ?? l};
    }
    estimateGas(e) {
      return dD(
        this,
        arguments,
        void 0,
        function* (n, r = this.parent.defaultReturnFormat) {
          const i = Object.assign({}, n);
          return this.parent.contractMethodEstimateGas({
            abi: this.constructorAbi,
            params: this.args,
            returnFormat: r,
            options: i,
            contractOptions: this.contractOptions
          });
        }
      );
    }
    encodeABI() {
      return wl(
        this.constructorAbi,
        this.args,
        ge({format: 'bytes'}, this.deployData, this.parent.defaultReturnFormat)
      );
    }
    decodeData(e) {
      return Object.assign(
        Object.assign(
          {},
          yg(this.constructorAbi, e.replace(this.deployData, ''), !1)
        ),
        {__method__: this.constructorAbi.type}
      );
    }
  }
  var hD = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  class pD extends ih {
    constructor(e, n) {
      (super(e.requestManager, e.registeredSubscriptions),
        (this.parentContract = n));
    }
    subscribe(e, n) {
      const r = Object.create(null, {subscribe: {get: () => super.subscribe}});
      return hD(this, arguments, void 0, function* (i, s, o = Tn) {
        return r.subscribe.call(this, i, s ?? this.parentContract.options, o);
      });
    }
  }
  var go = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  const mD = {logs: yx, newHeads: fh, newBlockHeaders: fh};
  class jo extends Un {
    get subscriptionManager() {
      return this._subscriptionManager;
    }
    constructor(e, n, r, i, s) {
      var o, a, c;
      const l = Fs(n) ? n : Fs(r) ? r : void 0;
      let u;
      Mw(n) ? (u = n) : Mw(r) ? (u = r) : (u = i);
      let d;
      if (
        (typeof n == 'object' && 'provider' in n
          ? (d = n.provider)
          : typeof r == 'object' && 'provider' in r
            ? (d = r.provider)
            : typeof i == 'object' && 'provider' in i
              ? (d = i.provider)
              : (d = jo.givenProvider),
        super(
          Object.assign(Object.assign({}, u), {
            provider: d,
            registeredSubscriptions: mD
          })
        ),
        (this.syncWithContext = !1),
        (this._functions = {}),
        (this._subscriptionManager = new pD(super.subscriptionManager, this)),
        u != null && u.wallet && (this._wallet = u.wallet),
        u != null &&
          u.accountProvider &&
          (this._accountProvider = u.accountProvider),
        !ie(l) &&
          !ie(l.data) &&
          !ie(l.input) &&
          this.config.contractDataInputFill !== 'both')
      )
        throw new BR({data: l.data, input: l.input});
      this._overloadedMethodAbis = new Map();
      const f = Di(i) ? i : Di(r) ? r : (s ?? this.defaultReturnFormat),
        h = typeof n == 'string' ? n : void 0;
      ((this.config.contractDataInputFill =
        (o = l == null ? void 0 : l.dataInputFill) !== null && o !== void 0
          ? o
          : this.config.contractDataInputFill),
        this._parseAndSetJsonInterface(e, f),
        this.defaultReturnFormat !== f && (this.defaultReturnFormat = f),
        ie(h) || this._parseAndSetAddress(h, f),
        (this.options = {
          address: h,
          jsonInterface: this._jsonInterface,
          gas:
            (a = l == null ? void 0 : l.gas) !== null && a !== void 0
              ? a
              : l == null
                ? void 0
                : l.gasLimit,
          gasPrice: l == null ? void 0 : l.gasPrice,
          from: l == null ? void 0 : l.from,
          input: l == null ? void 0 : l.input,
          data: l == null ? void 0 : l.data
        }),
        (this.syncWithContext =
          (c = l == null ? void 0 : l.syncWithContext) !== null && c !== void 0
            ? c
            : !1),
        u instanceof Un && this.subscribeToContextEvents(u),
        Object.defineProperty(this.options, 'address', {
          set: (g) => this._parseAndSetAddress(g, f),
          get: () => this._address
        }),
        Object.defineProperty(this.options, 'jsonInterface', {
          set: (g) => this._parseAndSetJsonInterface(g, f),
          get: () => this._jsonInterface
        }),
        u instanceof Un &&
          u.on(Jo.CONFIG_CHANGE, (g) => {
            this.setConfig({[g.name]: g.newValue});
          }));
    }
    setTransactionMiddleware(e) {
      this.transactionMiddleware = e;
    }
    getTransactionMiddleware() {
      return this.transactionMiddleware;
    }
    get events() {
      return this._events;
    }
    get methods() {
      return this._methods;
    }
    clone() {
      let e;
      return (
        this.options.address
          ? (e = new jo(
              [...this._jsonInterface, ...this._errorsInterface],
              this.options.address,
              {
                gas: this.options.gas,
                gasPrice: this.options.gasPrice,
                from: this.options.from,
                input: this.options.input,
                data: this.options.data,
                provider: this.currentProvider,
                syncWithContext: this.syncWithContext,
                dataInputFill: this.config.contractDataInputFill
              },
              this.getContextObject()
            ))
          : (e = new jo(
              [...this._jsonInterface, ...this._errorsInterface],
              {
                gas: this.options.gas,
                gasPrice: this.options.gasPrice,
                from: this.options.from,
                input: this.options.input,
                data: this.options.data,
                provider: this.currentProvider,
                syncWithContext: this.syncWithContext,
                dataInputFill: this.config.contractDataInputFill
              },
              this.getContextObject()
            )),
        this.context && e.subscribeToContextEvents(this.context),
        e
      );
    }
    deploy(e) {
      return new fD(this, e);
    }
    getPastEvents(e, n, r) {
      return go(this, void 0, void 0, function* () {
        var i;
        const s = typeof e == 'string' ? e : vc,
          o = typeof e != 'string' && !Di(e) ? e : Di(n) ? {} : n,
          a = Di(e) ? e : Di(n) ? n : (r ?? this.defaultReturnFormat),
          c =
            s === 'allEvents' || s === vc
              ? lg
              : this._jsonInterface.find((p) => 'name' in p && p.name === s);
        if (!c) throw new In(`Event ${String(s)} not found.`);
        const {
            fromBlock: l,
            toBlock: u,
            topics: d,
            address: f
          } = Pw(this.options, c, o ?? {}),
          h = yield fx(
            this,
            {fromBlock: l, toBlock: u, topics: d, address: f},
            a
          ),
          g = h
            ? h.map((p) =>
                typeof p == 'string' ? p : Pv(c, p, this._jsonInterface, a)
              )
            : [],
          m =
            (i = o == null ? void 0 : o.filter) !== null && i !== void 0
              ? i
              : {},
          y = Object.keys(m);
        return y.length > 0
          ? g.filter((p) =>
              typeof p == 'string'
                ? !0
                : y.every((b) => {
                    var v;
                    if (Array.isArray(m[b]))
                      return m[b].some(
                        (C) =>
                          String(p.returnValues[b]).toUpperCase() ===
                          String(C).toUpperCase()
                      );
                    const x =
                      (v = c.inputs) === null || v === void 0
                        ? void 0
                        : v.filter((C) => C.name === b)[0];
                    return x != null &&
                      x.indexed &&
                      x.type === 'string' &&
                      fc(m[b]) === String(p.returnValues[b])
                      ? !0
                      : String(p.returnValues[b]).toUpperCase() ===
                          String(m[b]).toUpperCase();
                  })
            )
          : g;
      });
    }
    _parseAndSetAddress(e, n = this.defaultReturnFormat) {
      this._address = e && _i(ge({format: 'address'}, e, n));
    }
    decodeMethodData(e) {
      const n = e.slice(0, 10),
        i = this._jsonInterface
          .filter((s) => s.type !== 'error')
          .find((s) => n === iu(Yi(s)));
      if (!i)
        throw new In(
          `The ABI for the provided method signature ${n} was not found.`
        );
      return yg(i, e);
    }
    _parseAndSetJsonInterface(e, n = this.defaultReturnFormat) {
      var r, i;
      ((this._functions = {}), (this._methods = {}), (this._events = {}));
      let s = [];
      const o = e.filter((c) => c.type !== 'error'),
        a = e.filter((c) => kp(c));
      for (const c of o) {
        const l = Object.assign(Object.assign({}, c), {signature: ''});
        if (Rp(l)) {
          const u = Yi(l),
            d = iu(u);
          ((l.methodNameWithInputs = u),
            (l.signature = d),
            (l.constant =
              l.stateMutability === 'view' ||
              l.stateMutability === 'pure' ||
              l.constant),
            (l.payable = l.stateMutability === 'payable' || l.payable),
            this._overloadedMethodAbis.set(l.name, [
              ...((r = this._overloadedMethodAbis.get(l.name)) !== null &&
              r !== void 0
                ? r
                : []),
              l
            ]));
          const f =
              (i = this._overloadedMethodAbis.get(l.name)) !== null &&
              i !== void 0
                ? i
                : [],
            h = this._createContractMethod(f, a),
            g = this._createContractMethod(f, a, !0);
          ((this._functions[u] = {signature: d, method: g}),
            (this._methods[l.name] = h),
            (this._methods[u] = g),
            (this._methods[d] = g));
        } else if (Cv(l)) {
          const u = Yi(l),
            d = Tv(u),
            f = this._createContractEvent(l, n);
          ((l.signature = d),
            (!(u in this._events) || l.name === 'bound') &&
              (this._events[u] = f),
            (this._events[l.name] = f),
            (this._events[d] = f));
        }
        s = [...s, l];
      }
      ((this._events.allEvents = this._createContractEvent(lg, n)),
        (this._jsonInterface = [...s]),
        (this._errorsInterface = a));
    }
    _getAbiParams(e, n) {
      var r;
      try {
        return bl((r = e.inputs) !== null && r !== void 0 ? r : [], n);
      } catch (i) {
        throw new In(`Invalid parameters for method ${e.name}: ${i.message}`);
      }
    }
    _createContractMethod(e, n, r = !1) {
      const i = e[e.length - 1];
      return (...s) => {
        var o, a, c;
        let l;
        const u =
          (a = r
            ? (o = this._overloadedMethodAbis.get(i.name)) === null ||
              o === void 0
              ? void 0
              : o.filter((m) => m.signature === i.signature)
            : this._overloadedMethodAbis.get(i.name)) !== null && a !== void 0
            ? a
            : [];
        let d = u[0];
        const f = n,
          h = u.filter((m) => {
            var y;
            return (
              ((y = m.inputs) !== null && y !== void 0 ? y : []).length ===
              s.length
            );
          });
        if (u.length === 1 || h.length === 0)
          ((l = this._getAbiParams(d, s)),
            Ie.validate((c = i.inputs) !== null && c !== void 0 ? c : [], l));
        else {
          const m = [],
            y = [];
          for (const p of h)
            try {
              ((l = this._getAbiParams(p, s)),
                Ie.validate(p.inputs, l),
                y.push(p));
            } catch (b) {
              m.push(b);
            }
          if (
            (y.length === 1
              ? ([d] = y)
              : y.length > 1 &&
                (([d] = y),
                console.warn(`Multiple methods found that is compatible with the given inputs.
	Found ${y.length} compatible methods: ${JSON.stringify(y.map((p) => `${p.methodNameWithInputs} (signature: ${p.signature})`))} 
	The first one will be used: ${d.methodNameWithInputs}`)),
            m.length === h.length)
          )
            throw new lc(m);
        }
        const g = {
          arguments: l,
          call: (m, y) =>
            go(this, void 0, void 0, function* () {
              return this._contractMethodCall(d, l, f, m, y);
            }),
          send: (m) => this._contractMethodSend(d, l, f, m),
          populateTransaction: (m, y) => {
            var p, b;
            let v = y ?? this.options;
            v = Object.assign(Object.assign({}, v), {
              input: void 0,
              from:
                (b =
                  (p = v == null ? void 0 : v.from) !== null && p !== void 0
                    ? p
                    : this.defaultAccount) !== null && b !== void 0
                  ? b
                  : void 0
            });
            const x = bg({
              abi: i,
              params: s,
              options: Object.assign(Object.assign({}, m), {
                dataInputFill: this.config.contractDataInputFill
              }),
              contractOptions: v
            });
            return (x.dataInputFill && delete x.dataInputFill, x);
          },
          estimateGas: (m, ...y) =>
            go(
              this,
              [m, ...y],
              void 0,
              function* (p, b = this.defaultReturnFormat) {
                return this.contractMethodEstimateGas({
                  abi: d,
                  params: l,
                  returnFormat: b,
                  options: p
                });
              }
            ),
          encodeABI: () => wl(d, l),
          decodeData: (m) => yg(d, m),
          createAccessList: (m, y) =>
            go(this, void 0, void 0, function* () {
              return this._contractMethodCreateAccessList(d, l, f, m, y);
            })
        };
        return (d.stateMutability === 'payable', g);
      };
    }
    _contractMethodCall(e, n, r, i, s) {
      return go(this, void 0, void 0, function* () {
        var o;
        const a = cD({
          abi: e,
          params: n,
          options: Object.assign(Object.assign({}, i), {
            dataInputFill: this.config.contractDataInputFill
          }),
          contractOptions: Object.assign(Object.assign({}, this.options), {
            from:
              (o = this.options.from) !== null && o !== void 0
                ? o
                : this.config.defaultAccount
          })
        });
        try {
          const c = yield Nv(this, a, s, this.defaultReturnFormat);
          return _B(e, c);
        } catch (c) {
          throw (c instanceof Bo && qd(r, c.cause), c);
        }
      });
    }
    _contractMethodCreateAccessList(e, n, r, i, s) {
      return go(this, void 0, void 0, function* () {
        var o;
        const a = uD({
          abi: e,
          params: n,
          options: Object.assign(Object.assign({}, i), {
            dataInputFill: this.config.contractDataInputFill
          }),
          contractOptions: Object.assign(Object.assign({}, this.options), {
            from:
              (o = this.options.from) !== null && o !== void 0
                ? o
                : this.config.defaultAccount
          })
        });
        try {
          return px(this, a, s, this.defaultReturnFormat);
        } catch (c) {
          throw (c instanceof Bo && qd(r, c.cause), c);
        }
      });
    }
    _contractMethodSend(e, n, r, i, s) {
      var o, a;
      let c = s ?? this.options;
      c = Object.assign(Object.assign({}, c), {
        input: void 0,
        from:
          (a =
            (o = c.from) !== null && o !== void 0 ? o : this.defaultAccount) !==
            null && a !== void 0
            ? a
            : void 0
      });
      const l = bg({
          abi: e,
          params: n,
          options: Object.assign(Object.assign({}, i), {
            dataInputFill: this.config.contractDataInputFill
          }),
          contractOptions: c
        }),
        u = ie(this.transactionMiddleware)
          ? su(this, l, this.defaultReturnFormat, {
              checkRevertBeforeSending: !1,
              contractAbi: this._jsonInterface
            })
          : su(
              this,
              l,
              this.defaultReturnFormat,
              {checkRevertBeforeSending: !1, contractAbi: this._jsonInterface},
              this.transactionMiddleware
            );
      return (
        u.on('error', (d) => {
          d instanceof Bo && qd(r, d.cause);
        }),
        u
      );
    }
    contractMethodEstimateGas(e) {
      return go(
        this,
        arguments,
        void 0,
        function* ({
          abi: n,
          params: r,
          returnFormat: i,
          options: s,
          contractOptions: o
        }) {
          const a = lD({
            abi: n,
            params: r,
            options: Object.assign(Object.assign({}, s), {
              dataInputFill: this.config.contractDataInputFill
            }),
            contractOptions: o ?? this.options
          });
          return Lv(this, a, qi.LATEST, i ?? this.defaultReturnFormat);
        }
      );
    }
    _createContractEvent(e, n = this.defaultReturnFormat) {
      return (...r) => {
        var i;
        const {topics: s, fromBlock: o} = Pw(this.options, e, r[0]),
          a = new yx(
            {
              address: this.options.address,
              topics: s,
              abi: e,
              jsonInterface: this._jsonInterface
            },
            {subscriptionManager: this.subscriptionManager, returnFormat: n}
          );
        return (
          ie(o) ||
            this.getPastEvents(e.name, {fromBlock: o, topics: s}, n)
              .then((c) => {
                c && c.forEach((l) => a.emit('data', l));
              })
              .catch((c) => {
                a.emit('error', new Li('Failed to get past events.', c));
              }),
          (i = this.subscriptionManager) === null ||
            i === void 0 ||
            i.addSubscription(a).catch((c) => {
              a.emit('error', new Li('Failed to subscribe.', c));
            }),
          a
        );
      };
    }
    subscribeToContextEvents(e) {
      const n = this;
      ((this.context = e),
        n.syncWithContext &&
          e.on(Jo.CONFIG_CHANGE, (r) => {
            n.setConfig({[r.name]: r.newValue});
          }));
    }
  }
  const Ow = {
      addr: '0x3b3b57de',
      name: '0x691f3431',
      abi: '0x2203ab56',
      pubkey: '0xc8690233',
      text: '0x59d1d43c',
      contenthash: '0xbc1c58d1'
    },
    ga = {
      setAddr: 'addr',
      addr: 'addr',
      pubkey: 'pubkey',
      contenthash: 'contenthash',
      text: 'text',
      name: 'name'
    },
    hh = {
      main: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
      goerli: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e'
    },
    gD = {'0x1': 'main', '0x5': 'goerli'},
    yD = [
      {
        anonymous: !1,
        inputs: [
          {indexed: !0, internalType: 'bytes32', name: 'node', type: 'bytes32'},
          {
            indexed: !0,
            internalType: 'bytes32',
            name: 'label',
            type: 'bytes32'
          },
          {indexed: !1, internalType: 'address', name: 'owner', type: 'address'}
        ],
        name: 'NewOwner',
        type: 'event'
      },
      {
        anonymous: !1,
        inputs: [
          {indexed: !0, internalType: 'bytes32', name: 'node', type: 'bytes32'},
          {
            indexed: !1,
            internalType: 'address',
            name: 'resolver',
            type: 'address'
          }
        ],
        name: 'NewResolver',
        type: 'event'
      },
      {
        anonymous: !1,
        inputs: [
          {indexed: !0, internalType: 'bytes32', name: 'node', type: 'bytes32'},
          {indexed: !1, internalType: 'address', name: 'owner', type: 'address'}
        ],
        name: 'Transfer',
        type: 'event'
      },
      {
        inputs: [
          {internalType: 'address', name: 'owner', type: 'address'},
          {internalType: 'address', name: 'operator', type: 'address'}
        ],
        name: 'isApprovedForAll',
        outputs: [{internalType: 'bool', name: '', type: 'bool'}],
        stateMutability: 'view',
        type: 'function'
      },
      {
        inputs: [{internalType: 'bytes32', name: 'node', type: 'bytes32'}],
        name: 'owner',
        outputs: [{internalType: 'address', name: '', type: 'address'}],
        stateMutability: 'view',
        type: 'function'
      },
      {
        inputs: [{internalType: 'bytes32', name: 'node', type: 'bytes32'}],
        name: 'recordExists',
        outputs: [{internalType: 'bool', name: '', type: 'bool'}],
        stateMutability: 'view',
        type: 'function'
      },
      {
        inputs: [{internalType: 'bytes32', name: 'node', type: 'bytes32'}],
        name: 'resolver',
        outputs: [{internalType: 'address', name: '', type: 'address'}],
        stateMutability: 'view',
        type: 'function'
      },
      {
        inputs: [{internalType: 'bytes32', name: 'node', type: 'bytes32'}],
        name: 'ttl',
        outputs: [{internalType: 'uint64', name: '', type: 'uint64'}],
        stateMutability: 'view',
        type: 'function'
      }
    ],
    vD = [
      {
        anonymous: !1,
        inputs: [
          {indexed: !0, internalType: 'bytes32', name: 'node', type: 'bytes32'},
          {indexed: !1, internalType: 'address', name: 'a', type: 'address'}
        ],
        name: 'AddrChanged',
        type: 'event'
      },
      {
        anonymous: !1,
        inputs: [
          {indexed: !0, internalType: 'bytes32', name: 'node', type: 'bytes32'},
          {
            indexed: !1,
            internalType: 'uint256',
            name: 'coinType',
            type: 'uint256'
          },
          {
            indexed: !1,
            internalType: 'bytes',
            name: 'newAddress',
            type: 'bytes'
          }
        ],
        name: 'AddressChanged',
        type: 'event'
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: 'address',
            name: 'owner',
            type: 'address'
          },
          {
            indexed: !0,
            internalType: 'address',
            name: 'operator',
            type: 'address'
          },
          {indexed: !1, internalType: 'bool', name: 'approved', type: 'bool'}
        ],
        name: 'ApprovalForAll',
        type: 'event'
      },
      {
        anonymous: !1,
        inputs: [
          {indexed: !0, internalType: 'bytes32', name: 'node', type: 'bytes32'},
          {indexed: !1, internalType: 'bytes', name: 'hash', type: 'bytes'}
        ],
        name: 'ContenthashChanged',
        type: 'event'
      },
      {
        anonymous: !1,
        inputs: [
          {indexed: !0, internalType: 'bytes32', name: 'node', type: 'bytes32'},
          {indexed: !1, internalType: 'bytes', name: 'name', type: 'bytes'},
          {
            indexed: !1,
            internalType: 'uint16',
            name: 'resource',
            type: 'uint16'
          },
          {indexed: !1, internalType: 'bytes', name: 'record', type: 'bytes'}
        ],
        name: 'DNSRecordChanged',
        type: 'event'
      },
      {
        anonymous: !1,
        inputs: [
          {indexed: !0, internalType: 'bytes32', name: 'node', type: 'bytes32'},
          {indexed: !1, internalType: 'bytes', name: 'name', type: 'bytes'},
          {
            indexed: !1,
            internalType: 'uint16',
            name: 'resource',
            type: 'uint16'
          }
        ],
        name: 'DNSRecordDeleted',
        type: 'event'
      },
      {
        anonymous: !1,
        inputs: [
          {indexed: !0, internalType: 'bytes32', name: 'node', type: 'bytes32'}
        ],
        name: 'DNSZoneCleared',
        type: 'event'
      },
      {
        anonymous: !1,
        inputs: [
          {indexed: !0, internalType: 'bytes32', name: 'node', type: 'bytes32'},
          {
            indexed: !1,
            internalType: 'bytes',
            name: 'lastzonehash',
            type: 'bytes'
          },
          {indexed: !1, internalType: 'bytes', name: 'zonehash', type: 'bytes'}
        ],
        name: 'DNSZonehashChanged',
        type: 'event'
      },
      {
        anonymous: !1,
        inputs: [
          {indexed: !0, internalType: 'bytes32', name: 'node', type: 'bytes32'},
          {
            indexed: !0,
            internalType: 'bytes4',
            name: 'interfaceID',
            type: 'bytes4'
          },
          {
            indexed: !1,
            internalType: 'address',
            name: 'implementer',
            type: 'address'
          }
        ],
        name: 'InterfaceChanged',
        type: 'event'
      },
      {
        anonymous: !1,
        inputs: [
          {indexed: !0, internalType: 'bytes32', name: 'node', type: 'bytes32'},
          {indexed: !1, internalType: 'string', name: 'name', type: 'string'}
        ],
        name: 'NameChanged',
        type: 'event'
      },
      {
        anonymous: !1,
        inputs: [
          {indexed: !0, internalType: 'bytes32', name: 'node', type: 'bytes32'},
          {indexed: !1, internalType: 'bytes32', name: 'x', type: 'bytes32'},
          {indexed: !1, internalType: 'bytes32', name: 'y', type: 'bytes32'}
        ],
        name: 'PubkeyChanged',
        type: 'event'
      },
      {
        anonymous: !1,
        inputs: [
          {indexed: !0, internalType: 'bytes32', name: 'node', type: 'bytes32'},
          {
            indexed: !0,
            internalType: 'string',
            name: 'indexedKey',
            type: 'string'
          },
          {indexed: !1, internalType: 'string', name: 'key', type: 'string'}
        ],
        name: 'TextChanged',
        type: 'event'
      },
      {
        inputs: [
          {internalType: 'bytes32', name: 'node', type: 'bytes32'},
          {internalType: 'uint256', name: 'contentTypes', type: 'uint256'}
        ],
        name: 'ABI',
        outputs: [
          {internalType: 'uint256', name: '', type: 'uint256'},
          {internalType: 'bytes', name: '', type: 'bytes'}
        ],
        stateMutability: 'view',
        type: 'function'
      },
      {
        inputs: [{internalType: 'bytes32', name: 'node', type: 'bytes32'}],
        name: 'addr',
        outputs: [{internalType: 'address payable', name: '', type: 'address'}],
        stateMutability: 'view',
        type: 'function'
      },
      {
        inputs: [
          {internalType: 'bytes32', name: 'node', type: 'bytes32'},
          {internalType: 'uint256', name: 'coinType', type: 'uint256'}
        ],
        name: 'addr',
        outputs: [{internalType: 'bytes', name: '', type: 'bytes'}],
        stateMutability: 'view',
        type: 'function'
      },
      {
        inputs: [{internalType: 'bytes32', name: 'node', type: 'bytes32'}],
        name: 'contenthash',
        outputs: [{internalType: 'bytes', name: '', type: 'bytes'}],
        stateMutability: 'view',
        type: 'function'
      },
      {
        inputs: [
          {internalType: 'bytes32', name: 'node', type: 'bytes32'},
          {internalType: 'bytes32', name: 'name', type: 'bytes32'},
          {internalType: 'uint16', name: 'resource', type: 'uint16'}
        ],
        name: 'dnsRecord',
        outputs: [{internalType: 'bytes', name: '', type: 'bytes'}],
        stateMutability: 'view',
        type: 'function'
      },
      {
        inputs: [
          {internalType: 'bytes32', name: 'node', type: 'bytes32'},
          {internalType: 'bytes32', name: 'name', type: 'bytes32'}
        ],
        name: 'hasDNSRecords',
        outputs: [{internalType: 'bool', name: '', type: 'bool'}],
        stateMutability: 'view',
        type: 'function'
      },
      {
        inputs: [
          {internalType: 'bytes32', name: 'node', type: 'bytes32'},
          {internalType: 'bytes4', name: 'interfaceID', type: 'bytes4'}
        ],
        name: 'interfaceImplementer',
        outputs: [{internalType: 'address', name: '', type: 'address'}],
        stateMutability: 'view',
        type: 'function'
      },
      {
        inputs: [
          {internalType: 'address', name: 'account', type: 'address'},
          {internalType: 'address', name: 'operator', type: 'address'}
        ],
        name: 'isApprovedForAll',
        outputs: [{internalType: 'bool', name: '', type: 'bool'}],
        stateMutability: 'view',
        type: 'function'
      },
      {
        inputs: [{internalType: 'bytes32', name: 'node', type: 'bytes32'}],
        name: 'name',
        outputs: [{internalType: 'string', name: '', type: 'string'}],
        stateMutability: 'view',
        type: 'function'
      },
      {
        inputs: [{internalType: 'bytes32', name: 'node', type: 'bytes32'}],
        name: 'pubkey',
        outputs: [
          {internalType: 'bytes32', name: 'x', type: 'bytes32'},
          {internalType: 'bytes32', name: 'y', type: 'bytes32'}
        ],
        stateMutability: 'view',
        type: 'function'
      },
      {
        inputs: [{internalType: 'bytes4', name: 'interfaceID', type: 'bytes4'}],
        name: 'supportsInterface',
        outputs: [{internalType: 'bool', name: '', type: 'bool'}],
        stateMutability: 'view',
        type: 'function'
      },
      {
        inputs: [
          {internalType: 'bytes32', name: 'node', type: 'bytes32'},
          {internalType: 'string', name: 'key', type: 'string'}
        ],
        name: 'text',
        outputs: [{internalType: 'string', name: '', type: 'string'}],
        stateMutability: 'view',
        type: 'function'
      },
      {
        inputs: [{internalType: 'bytes32', name: 'node', type: 'bytes32'}],
        name: 'zonehash',
        outputs: [{internalType: 'bytes', name: '', type: 'bytes'}],
        stateMutability: 'view',
        type: 'function'
      },
      {
        inputs: [
          {internalType: 'bytes32', name: 'node', type: 'bytes32'},
          {internalType: 'address', name: 'a', type: 'address'}
        ],
        name: 'setAddr',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function'
      }
    ];
  var bD =
    'AEkU4AngDVgB0QKRAQYBOwDqATEAnwDbAIUApABsAOAAbwCRAEYAiQBPAHYAPgA+ACsANwAlAGMAHwAvACsAJQAWAC8AGwAiACIALwAUACsAEQAiAAsAGwARABcAGAA6ACkALAAsADUAFgAsABEAHQAhAA8AGwAdABUAFgAZAA0ADQAXABAAGQAUABIEqgYJAR4UFjfDBdMAsQCuPwFnAKUBA10jAK5/Ly8vLwE/pwUJ6/0HPwbkMQVXBVgAPSs5APa2EQbIwQuUCkEDyJ4zAsUKLwKOoQKG2D+Ob4kCxcsCg/IBH98JAPKtAUECLY0KP48A4wDiChUAF9S5yAwLPZ0EG3cA/QI5GL0P6wkGKekFBIFnDRsHLQCrAGmR76WcfwBbBpMjBukAGwA7DJMAWxVbqfu75wzbIM8IuykDsRQ7APcta6MAoX0YABcEJdcWAR0AuRnNBPoJIEw3CZcJiB4bVllM44NCABMADAAVAA5rVAAhAA4AR+4V2D3zOVjKleYuChAdX01YPewAEwAMABUADmsgXECXAMPrABsAOQzFABsVW6n7Adq4HB0FWwXiAtCfAsSwCkwcpGUUcxptTPUAuw1nAuEACy00iRfJkQKBewETGwC9DWcC4QALLQFIUCWRTAoDLfsFMgnXaRetAddDAEkrEncCMRYhAusnuTdrADnhAfUlAMcOy7UBG2OBALEFAAUAitNJBRvDHwcXAKgn0QGhKy0DmwBnAQoZPu03dAQYFwCqAccCIQDTKxJzOvNQsAWQOncnNUgF+icFWQVYr7gFaTtdQhI6WEGXe5NmX6H4CxMDxQcl8XcjBKNLAlNTAnUbqycBj6OlNVsDRRcEg2EJANEGqz8vIwcpAjldAGsBYR9xAIMdGQCVAUm3ACdpFwGvxQM3LSFDUwFvWQZlAmUA8UkXAykBBQBJQQCrAF0AcwArtQYH8+8ZjX8ACSEAKQCzG0cB0QHbBwsxl3iB6AAKABEANAA9ADgzd3nTwBBfEFwBTQlMbDoVCwKsD6YL5REVDNEqy9PYADSpB+sDUwfrA1MDUwfrB+sDUwfrA1MDUwNTA1McCvAa08AQXw9IBG0FjgWLBNYIgyZJEYEHKAjSVA10HhxHA0UA/CMlSRw7kzMLJUJMDE0DB/w2QmynfTgDRzGrVPWQogPLMk85bAEecRKgACoPcxw1tU5+ekdxoApLT661f0liTmcCvjqoP/gKIQmTb7t3TgY9EBcnoRDzDC8BsQE3DelL1ATtBjcExR95GRUPyZWYCKEt2QzpJt8unYBWI/EqfwXpS/A82QtJUWQPVQthCd86X4FKAx0BCSKHCtkNNQhpEO8KxWcN4RFBBzUD0UmWAKEG/QsNHTEVsSYMYqgLBTlzBvca8guLJqsTJXr4Bc8aHQZJASUa+wDLLuOFrFotXBhPWwX/CyEjwxSkUBwNIUCzeEQaFwcRJaUCjUNsSoNRMh6PIfI8OQ1iLg9ReAfxPAEZSwt9PJpGp0UKEc4+iT1EIkVMKAQxeywrJ4cJyw+BDLV8bgFVCR0JrQxtEy0REzfBCDUHFSmXICcRCB1GkWCWBPObA+8TzQMHBTsJPQcPA7EcKRMqFSUFCYEg0wLvNtEurwKLVnwBEwXHDyEf2xBMR9wO5QiXAmEDfyXnACkVHQATIpcIP18AW4/UUwEuxwjDamgjcANjFONdEW8HjQ5TB6McLxW7HN1wxF4HhgQon6sJVwFxCZUBWwTfCAU1V4ycID1nT4tUGJcgXUE7XfgCLQxhFZtEuYd0AocPZxIXATEBbwc1DP0CcxHpEWcQkQjnhgA1sTP0OiEESyF/IA0KIwNLbMoLIyb1DPRlAZ8SXgMINDl36menYLIgF/kHFTLBQVwh7QuOT8kMmBq9GD5UKhngB7sD7xrvJ+ZBUwX7A58POkkz6gS5C2UIhwk7AEUOnxMH0xhmCm2MzAEthwGzlQNTjX8Ca4sGMwcHAGMHgwV14QAZAqMInwABAMsDUwA1AqkHmQAVAIE9ATkDIysBHeECiwOPCC3HAZErAe8lBBe/DBEA8zNuRgLDrQKAZmaeBdlUAooCRTEBSSEEAUpDTQOrbd0A1wBHBg/bQwERp0bHFt8/AdtrJwDDAPcAATEHAT0ByQHvaQCzAVsLLQmer7EBSeUlAH8AEWcB0wKFANkAMQB77QFPAEkFVfUFzwJLRQENLRQnU10BtwMbAS8BCQB1BseJocUDGwRpB88CEBcV3QLvKgexAyLbE8lCwQK92lEAMhIKNAq1CrQfX/NcLwItbj1MAAofpD7DP0oFTTtPO1Q7TztUO087VDtPO1Q7TztUA5O73rveCmhfQWHnDKIN0ETEOkUT12BNYC4TxC2zFL0VyiVSGTkauCcBJeBVBQ8ALc9mLAgoNHEXuAA7KWSDPWOCHiwKRxzjU41U9C0XAK1LnjOrDagbEUQ8BUN16WImFgoKHgJkfQJiPldJq1c3HAKh8wJolAJmBQKfgDgXBwJmNwJmIgRqBHsDfw8Dfo45AjlzEzl+Oh8fAmwZAjIyOAYCbcMCbarrhi9jQScBYwDaAN0ARgEHlAyJAPoHvgAJsQJ3KwJ2njsCeUc/Ani2GVjXRapG0wJ8OwJ6xAJ9BQJ87AVVBRxH/Eh5XyAAJxFJVEpXERNKyALQ/QLQyEsjA4hLA4fiRMGRLgLynVz/AwOqS8pMKSHLTUhNqwKLOwKK1L0XAxk/YwGzAo4zAo5YPJN9Ao7VAo5YdFGwUzEGUtBUgQKT9wKTCADlABhVGlWrVcwCLBcpkYIy3XhiRTc1ApebAu+uWB2kAFUhApaLApZ4mAClWahaBX1JADcClrEClkpcQFzNApnHAplgXMZdAxUCnJc5vjqZApwSAp+XAp60hgAZCy0mCwKd7QKejgCxOWEwYesCns8CoGoBpQKemxsCnkqhY8RkIyEnAierAiZ6AqD3AqBIAqLZAqHAAqYrAqXKAqf7AHkCp+5oeGit/0VqGGrNAqzfAqyqAq1jAqz+AlcZAlXYArHd0wMfSmyTArK5CQKy5BNs3G1fbURbAyXJArZYNztujAMpQQK4WgK5QxECuSZzcDJw3QK9FQK71nCSAzINAr6Ecf4DM20CvhZzHnNLAsPHAsMAc350RzFBdNwDPKMDPJYDPbsCxXgCxkMCxgyFAshlTQLIQALJSwLJKgJkmQLdznh1XXiqeSFLzAMYn2b+AmHwGe+VIHsHXo5etw0Cz2cCz2grR0/O7w+bAMKpAs9vASXmA04OfkcBAtwjAtuGAtJLA1JYA1NbAP0DVYiAhTvHEulcQYIYgs+CyoOJAtrDAtnahAyERac4A4ahACsDZAqGbVX1AFEC32EC3rRvcwLiK+0QAfMsIwH0lwHyzoMC6+8C6Wx1Aur1AurgAPVDAbUC7oUC65iWppb/Au47A4XcmHVw3HGdAvL/AGUDjhKZjwL3DwORagOSgwL3lAL51QL4YpoYmqe3M5saA51/Av72ARcANZ8Yn68DBYkDpmYDptUAzcEDBmahhKIBBQMMRQELARsHaQZdtWMBALcEZ7sNhx6vCQATcTUAHwMvEkkDhXsBXyMdAIzrAB0A5p8Dm40IswYbn8EApwURu+kdPT4WeAVoNz5AK0IhQrRfcRFfvACWxQUyAJBMGZu5OyZgMhG6zw4vGMYYicn2BVcFWAVXBVgFYwVYBVcFWAVXBVgFVwVYBVcFWEYVCNeFZwICAgpkXukrBMkDsQYvu7sAuwSnuwDnQCkWsgVGPmk+cEI/QrZfdTdf6ABYETOrAIz+zGvL/KbnRno9JiMEKxYnNjV+bd9qwfEZwixpAWvXbjAXBV8FasnBybgIz0lbAAAACnxefYu+ADM/gQADFtEG5a0jBQCMwwsDAQ0A5WUdPSQfSkKxQrxBOCNfJ2A2JzgjCcE9CkQ/Qz54PoE+cD5xAolCvElCO1/LTk9qTQosa1QvagtuH1/gMzobCWebCmIjKzwdJkKrQrwrzAHL/F/JDh8uCQgJIn6d32o6LUoXyavJrAllwcvMCmBBXw/lEKMRAJONHUVCJRupbTnOOAozP0M+cEI/HAcKHUxHbFssLVrhvBIKfe0dK0I/HF0ISgkOM1RDQjcEO0OcLAqBGy1CPxv1CFMiIxgwMQAFj2HwXgpxZMlgC2AtI25DYBk5AhseYLMGAmsQZU5gTREBZOdgFWCVYH1gs2BLYJFoFhcGtQ7cVam8WgtDFqsBuyvNwQIfFQAcAx4BeQJsLzCVUoABigq4RxoA5CN0jgrKDaZN6gGbAoecTwVAXwD39wkANBZXDAulDCQfuq9HAE8MNAAVE58rggh6AtILS2URGwDYTgZ1BAoeWgAxALa4AZonCxZvqyQ4nxkBWwGGCfwD2e0PBqoGSga5AB3LValaCbthE4kLLT8OuwG7ASICR1ooKCggHh8hLBImBiEMjQBUAm5XkEmVAW4fD3FHAdN1D85RIBmpsE3qBxEFTF8A9/cKAHoGJGwKKwulODAtx69WDQsAX7wLAGNAlQh6AOpN7yIbvwAxALa4AZonLTsOzgKQGHtQu1jIdHKO16WbDvWZFT0b7AEpEFwSBg8bAccJOhCTBRArDDYLABEAs84BAgCkAOEAmIIABWtXLwAUAFsbxi5sdioNwRACOyQz0+EcHgsbfQJ7Ls6hHATBCqrxbAA3OS0Opge7CQAQOi7OERkAfavaHA+7GkcczaF3HgE9Kl8cAuugCAHCAULz5B9lAb4Jtwz6CDwKPgAFwAs9AksNuwi8DTwKvC7OoSoJPA67BZgBG2sKD4sa4QHDARELuxY7AKALOxC7BBige9wAO2sMPAACpgm8BRvQ9QUBvgH6bsoGewAHuwG7D00RErwBAQDqAQAAdBVbBhbLFPxvF7sYOwAuuwLrDlaouwAeuwJVICp/AAG7AALjAAg7FTwVuwAbuwG9KOClWw6/xAD0AGj7L7ZtvgNIo7vIqDsDAbuVJ0sAAlsACrsEAOfdGbsIGnsIoQUK/3AA37unuxjbGruji3lyBvupm4MAErsGGwsBvAAAhgBtuwYAC7unOwEaO7oIoZzKAbsL7QfAqTsA4XsBvwAA5QAVuwAG+wAJuwBpiwAauwAOuwIYu45pFfsAAVsADmsALkseAAa7ABe7CCEADUoBwgC3ryYBwAAAtAAOmwG+J+QAsloAHBsBv/7hCqEABcYLFRXbAAebAEK7AQIAabsAC3sAHbsACLsJoQAFygBunxnVAJEIIQAFygABOwAH2wAdmwghAAaaAAl7ABsrAG0bAOa7gAAIWwAUuwkhAAbKAOOLAAk7C6EOxPtfAAc7AG6cQEgARwADOwAJrQM3AAcbABl7Abv/Aab7AAobAAo7AAn7p+sGuwAJGwADCwAQOwAAFDsAEWsAD4sADesADbsAGQsGFhsAFTsAbpsWswG7ALoAEzsDAGkrCgDhSwACOwAEUgAXewUbAAbQABi7AAv7AF+7AGv7AOSLAbsAF3YBvAABcguhAAVKHgF7KFIAOUUA/gcNDHIAKCpwAaQFCF4BvF4jDAkHb0tsXyqJHzwUYi02A6EKtAHYABYC0QNuAXZyR1IUIQNPAhU+ASwGA3NGvHtSekAAKQAxAfsAUwrbAHuQLAErAHblDREyRgFKAFcFAAFQAQeKzAB4OwQgpQBaANYVAJVoNx+LAM1rsQDP1BYIwnVzGxhWHQnRAYiQqyJTU01IEjzCifkAfxw3QCkr4BGXTwByASksMClCGQ8DMFUE98XuAEtl3ABqAnECPxF6Osd4LjXVBgUAEBsdCggMKgQfHSlOU04IuboAChLNACYAARoAhgCJAI41AO4AtADgAJ08ALsAqwCmAKEA8gCfANMAnADrAQwBBwDAAHkAWgDLAM0BBwDXAOsAiACiATUA4wDYANUDAQcqM9TU1NS2wNzN0M5DMhcBTQFXL0cBVQFkAWMBVgFHS0NFaA0BThUHCAMyNgwHACINJCYpLDg6Oj09PT4/DkAeUVFRUVNTUlMpVFVXVlYcXWFhYGJhI2ZocG9ycnJycnJ0dHR0dHR0dHR0dHZ2d3Z1WwBA7ABFAJYAdAAuAGLyAIoAUwBTADMCc+kAh//y8gBgAI/sAJsASwBeAGD5+aoAgQCBAGUAUgCtAB4AsgB/AjwCPwD4AOMA+gD6AOQA+wDlAOUA5ADiACkCdwFNATwBOgFQAToBOgE6ATUBNAE0ATQBGAFUDwArCAAATRcKFgMVFg4AigCSAKIASwBkGAItAHAAaQCRAxIDJCoDHkE+RykAiwJLAMMCUwKgALoCkgKSApICkgKSApIChwKSApICkgKSApICkgKRApEClAKcApMCkgKSApACkAKQApACjgKRAnEB0AKTApsCkgKSApEWeQsA+gUDpwJdAjYXAVAQNQLeEQorEwFKNxNNkQF3pDwBZVkA/wM9RwEAAJMpHhiPagApYABpAC4AiQOUzIvwroRaBborDsIRAZ3VdCoLBCMxbAEzWmwBsgDdfoB/foB+gYKCfoOGhH6FiIaAh4KIgol+in6LfoyKjX6Ofo+CkH6RfpJ+k36Ug5WIloKXftoC2WzhAtdsAIJsJGygAINsbARCBD8EQQREBEIESARFBEAERgRIBEcEQwRFBEgAlmZsAKMDh2wAtGYBBWwAyVFsbADPbAIMbAD2WmwA9gEZAPYA9AD0APUA9AN8XmzUhCNlvwD2APQA9AD1APQcbGwAiVpsAPYAiQEZAPYAiQLsAPYAiQN8XmzUhCNlvxxsAPdabAEZAPYA9gD0APQA9QD0APcA9AD0APUA9AN8XmzUhCNlvxxsbACJWmwBGQD2AIkA9gCJAuwA9gCJA3xebNSEI2W/HGwCQwE2bAJKATlsAkvBbGwCV2xsA54C7AOeA54DnwOfA58DnwN8XmzUhCNlvxxsbACJWmwBGQOeAIkDngCJAuwDngCJA3xebNSEI2W/HGwEN2wAiQQ4AIkGjTFtIC9s1m4DJmwA/QDGWgJsbABVWv4UMgJsbACJAmwAVAEAuV5sAmxebGwAiV5sAmxebD3YAEls1gJsbEZFNiJ9FGVAe8xvEZKvxVfKZszAVTBzYBH2d1iyUXEHH7twNw7eZF5JJRHI5EgaRr5D20/3dfONrFLSq5qSrrgd2CEUq722WBQ/LzpA+bx1oREI5xy4BDSZNun0ZWORUJqInZSyMaioyvfSI0l5uFDzbWaQ28/zdB0hwR4OQZ0/jn9ALSLNikjFYGfqR389qtFlhD3a6KdIh97rhZYpywuLc7o8ql5/X8KCbPU3L/QlmCowhRXhsGDvg6wUNprA9bM/49uxlAj7ZVy3ouEY/BgFXBNyK0TLrSjZWeJm/T4nz6QGLT3cJNtWRZVZTvIdtaxMMJRHgig9+S11LjBh7Inr06ykoch1U097Rw0hvgmOrydQyaWcEQDg0RavuMuT0zYabUZl1e33HNSK1oNUCS03eh+9C2EvF3fq9h+XBaAMFuoWeZf+mfZgL4HzyiKDIUtfNU4oFu0aE9qt3VA3U4D3fOSrAcYVnjG3cSkp1vhXZnp3JQm4JknKdBitO2NVnGCYQwU3YMWHWB87NEd+4AHuOKI8BSIH92reW0pfs+kWCTJxDCbRjFv8Cfc4/DSBYJScJYTeAEgg9wTEvcwd/QuHRHqGzAQ4fXf5FUI1lPrO+fvEcPl4JInM1z9AtBT2bL4QYEREe7KiSnnxTwtmAFjn8lqT3mND8qTktX2F16Ae9cakqJ6/pEQsHURqyqWlRMCzKXRKfCHT7sYHWx9/T/ugYTFY6iVN3Btm58ATJR5alYZybKMWojwOw3HbFn23NFyeLl7+Er82RchyYuBoGQ3j7SAWNxiYvp5U+Fq/DEzB9cG5DlJWsqkosRze92OVlCtQEYo1S1lF72Z8xWc4ld/+fFcfTEDTFb9d8tJGQ75dpJEvcWyGmGBiTbiWDdGOcw93Dmxq5ISUrmasygONfHLvhgo83HQZenbdBtSzBkvYrCEQ/xEDMhMZsN6gqplx5jGG9mSQLhM81UEdEeJ59sdNJDAFy/gPyJoKlwPZgB/MkC/kICLiCB8va+nCdO2ry4aDfkmPFpF/H/SGQ3LJ6aAv9dtJ8DniHtLOckZix0BVb0iR5V3LAp521LBSIi6AtV7r2ZB/hQEvAw54EFNOQcFnl1xGUIc67tqK1INNwD2n/RbwgzO9h45LM6VMuN8V1ZNIQ6t+Xy3lTqyVCD5kqLy/t3/b8MLbgDg8JIWDkSZ+LrGhhr+gYpH+pr1TnCUnZPjpUdw6bSL6MWVXoDDciQDWECwU2e6VEpfrcOBbrSOijqGkEIoJPbpmeJLkcwbvA0yWIixQVjo0HnYh7fji+Dfdq1mtV1lG2Zz9R7eFMHS+FK7nybutu2fwzDpFldO2pZBshsHJWaltn3PWOoGJpCT2jE8EHOuC6FkejNWcfsWCqNqMLP9xTwcWArj2EiiI7D+EaDi7/2cqHL1gPiF6C/J7aUo7RQqogPZ11WqbyP97nsoMxPOC78wZMF7B1Y0g7JNXJV/nN1m4xx8hbqWz07KSaqr5hE4icB326DMR/vUKX9LoNjle/ZWtbUhrTAcsdgrLlG5Ne8aiR0bS/2ZhpNOVVxavWIZsEM/rd68EB4vjbbD13NkMK1qvMk74vGbSkL7ULO0sZ9R6APSCo6KH+Xn98wEdw1bCPAnDTaBsD6sidAGN58uiH4a3ovG1KyZAu2XtyGgF/vgWKGxw9R1lfAVcfuYE71DHuxtTzfGZnHaDpDGWmfEq0N4GawE7yIkaoz8jcmVmzJe1ydM8q0p08YIxFcY1YcqQc1djWBEoNETDFcgk5waRftEJasPREkrV++N/TOKkERF1fCLrXS8DFGYGRBeECMQRNEs0ES3FzUtXCcNxpYEM3Uei6XodZruXUIRnn+UXf2b/r7n1vQutoi6WoIbW7svDNWBbUWcDUc7F9SJK3bvSy9KIqhgyJHoW2Kpvv0J4ob14HFXGWWVsYXJzjwxS+SADShTgCRjhoDgjAYRGxwJ1Vonw+cpnCKhz8NQPrb0SFxHIRbmG95Q2hlC4mDxvPBRbkFa60cvWakd7f0kVBxxktzZ9agPJEWyA63RSHYVqt8cPrs2uFJ3rS3k9ETGKn5+A6F9IOrdZHfT1biEyUJKEvwzuscwshGCBJvd16TrefW03xVnJf4xvs72PdxrMidjJO8EiWyN/VWyB3fv9kc34YIuZTFtXGo9DuG3H1Uka5FgBMwDPEvRcSabi3WakNQkXFecJlFk6buLVk5YHpuKWTw6oF632FPPSVIVl5hgUAeHhj0t/sw/PEEvThLQDDFE34eCg/rLOyXT3r+L98oRKrlTO0MdALYQ3rRQqC7d822dJPGxF1K4J2TtfPSMFaCAg0n0NGk9yiaKKOJD1v2aBX9HUOIawjjfvwCmjHZJTR62R9c9x33JnBjWrN4QYEOmehy0oZMP9XM9Zyi6TYoe07PaLceRXcCWZiY/imRUWW6+mci7+wMxSdwMdbXckXtvhJH8sc4iQcTwm7yp+3f7CaesTTQB2qkgeXh+wFiSMXfMlH7Yil0OoZ2QTtRLTip2O0cLZ4SstqWHZ6H+8A2kZXhpm0kPbL9dUanTOvziqIUh6Ambwa3WrCb2eWbuCN3L1hgWUmjRC3JoL3dBhR3imSQI8xuCMfsszlji7cSShNSYdqCXPxEVwbqO9i5B6hf93YI7aeyI8jxgcVXK0I/klbvhSXjkjOIwZgPdVwmsFW7HGPLUAvDRuKm+itybRg7c8+Yqqjg824Qf+/NxsBSUNAK9KCoJpauFqK0XQULrWYj4FnxeKDuvr54iokpi+D57e6Y1zxRJJdsHnDR3JyraCUufHBRTKODWBVzthjm4k3/Hv+Q990XDVR+KW+TcJX045LW86EKhz/97aqj89A8ZvTk1//tczosU90loIPVaHuWegJU3wP//7XHcO7c0yQM2jM/IhQKrf8hiObHWiWDZManF8Uf/HzbmDfC2wT//aiZ4hGTv/xzgKwdb1sD6cGEkceow0s3b89/zg+3plyRm0HlZi886j5wUwFhdHiDTaBidZRo5cx/tMeLyguOATbzq17ydhzbrpxunuHx6lbFGiO97gsd4dk//7iCIo+Ew+hG2so5kvv+ITG4c1fzHPtu1Xn5QfUnqY3/uByVmB7gmnE/E+5zdm+6nDmoews5fr+NzThdSHzK4bBQOL9c4O8OI0xLSqjJ4lbniLJg1aFpQRLwaSMZmpkC9e/j6FOVrTQ6a/a4alGgfrl2ZL1sbHUQ3DOI7ntq9diHFfm3t1mul3rdJEJCHnlW/hlQntipMrpeMs7fUr6wK370D7VbXH0DUHzdYfRg/6Z11Ult1sffJS+heHbco15Sxy3+rDnPesqH1lajk0yu02hPUvEUqvcUXWXL7Ad0wNGMx5gOle4XJxq/r/YY0xdco2wRSEGwcT7YADlBrHc9ZbvzOL0QwyWCWWChB9Obg800v7tyBWaNvdwz+fL7Ph9i2irEeJkRgOzeEDw+JiD/V93vH9FgMEoFIJMoIuogmicZohf94SBuPn6hXaV9jP4VVVA/bu+Wg8S88GLtmEPSNRLdtlXx2XL/nuM8nKkhnlnjaropiKKLIH94pLIASci0pDBfj9Hi5BfaTSXQg5+PMjQX91Ktk4MOqK1K99l4BRPv5+vNovGZ3IxQv8ICvjV4/diThpoaM8uvd3D9d/DE477w3yAbW3IDm2i73pZ9aEj38JqS6h/s8/xgmUIVcuq2JTgefAyuoafzQxAuRASeg3NtG3ach/JEkyuX+JDt2PnDZTShUhyHHG3ttBg/6lhAchGjLJBtopj4e01MlCp2yqQRTr4sBBXru+lKaoanwYX8y2aWCJiR3KnhCOkYVFSvsO0oDRujUFOEptiNDTYrJoUbvOyvl4AhC9h3wORiTXK1MrpMfnvdnndnR/HRVSusMBgIxwrLdn3vq1VcncPiD0SquTx/kNmxeFyCT4uXVUd9AL+rSGmuq7OOCzDKeVPjiNWVaoP5KOFqYq5Xcuf/xW9S+u9eIq9GAtZWtQlgkRecjRtvG1NR4WXXpn+pwsTBTIy079Ikg8rSef1aVapIFcXCd6C2wHVjLXR+N0tw4Taw6x6H90BFRgNrtlq2up6hHKuV3inM5RJaQWZHd84e6RsKkk9po3dk9by54tpPw7cBkFas/G+GbHwuG+AwP55BZyXILTHCIVrPpXHEaUPYfL6nphJP1Rc10xG4UaCeY4IHCwuur8xmSQDgY4aVwhzWhjbtSHG8JO6P2i2nC9/0Bfx0zk6dYQq3aw7k5vIObD7SEKrxhz0fQ0+YTOfHW23CBNeZci1qNsUDhoeqmfyP6PvjoEjHk8QbrFyQVZPHVWijnb8YCM65iYNoEbvnchStZ/9cKg5Vd45j8KnB6UjzXl/bkyZx7VoD47ocUUi117WwgySSb4rXgLJ52Mv5XJbp3I+uBP81BUvOjy4Cacgi+GWWlC/8dwgqwiojjUBDnEOxyRyowwLQfytFra1OZS4XvRYr4uoamAfG3I/p2bA7G90yqKThH8Ke00Tqd+3l3dmJpaCZelBMYjGqNLVa3SM4+LQeL56gY6Bymy2LQPVOxjWfj5tq4o74swcxhyGJPynkS5xAjOXZP1/FAYcBT3u6qLoIkEfErwo4gozmyI1YCvM0oyI3ghjGPQSsof2sKUhq91WsKy9cYWN+4A2v4pG/Mxpdc6w6kI/HX7Xb0TuihmsiOy2wQIsrZbUmr3OBSUo6oDJNgQp+YqYkgTgYcWZDgawJw3DFfdzT//PhVUidgB2qa8uw/j9ToHBAS33iT8YLhhAfyXG0bQUFp7QmH7oQ3i6Flf4OTZLvJdh8pfuflmWu2ohm5pTiSg1pl3vq9uluTJwqXfh1hqy8e2iHoD+Y35gCIViTo6VOtK5dD8HYClucJucXASzwe2kPj4S4eYQtmkYHagXhAzp/F541xE8YFYqSPszDuz3soWzHy0p3E2jwZNQaIcGU9FNQwQxeDw0ZlK9dxXrj9IUHGUPTOyib8CqXmbZ7Ex54bn1rLx3qqAavu/gh6XjV0GmN1p+yyMK9HN5uYEvxgbAk43tsheREhyI+Q5WLIneKTGPmYiM/lxOp8fvqHy8YgXK0TlMiX0tliLI2JtfmWZP8eVV732sdYm+pcWzDzEmKLJZyeelyaZKkjPnnUO9keDwtgiLnmd5+t+Sr5y8brRnlvxcWEWfCqIALQYHvaXx6jTg4dAlye469uGwwOZVZCILLfGjaMg4LUCNMTtMSp1aC2y/3wR2t1v3w/iNBRQ+bNbtDqL2NAr7K4rUcyqbSpNrXZgAWXvjxBBtfYLK1uRYt3q2pfXJOAL0HtWcEwJLddOSJKV1SwvcvEuzg/4MPnA8MIUJOLqm3qI6wFyN99Ck6zYaV/zGSAzF/PGsaNa4vPLe5QnyuqVUnVQ6xELA6gbe53aGgeke+R/ycb2LJVyc7BhuzI90zA+c6wUDTb7NH//gdDSl2u/aW7lRJm8m1fLtPxcNuEM5JbkOCZKPM88HUsLRoC1pmKKlvWyeAXuxILbu0snpSxf8N+RgtLUSe5n2gdjOjoSTaN7mMZ7bF+cWk/MS8mFD4pcyl5UN7CbpFZH2a+Pm1VAnUTVfbw8qrmz1G9m5aKmRzY1SMhhPrlCn2t4uNUXNA3IFe6NOjSC1DEaAFZAfDlEkQCsbNhsZPj6NQPDSB3tLiTo0ZYoEbIeEIaKtU3Wk60rEszawTFuyHVd365LA/c/uarABN5M5rGq/dqTG3Ilye/5EKiYisisuzqNaZjmWv0z9TORc0CKbaTea214oNM9u2sXUZub/eqM3Pi/PjRSyQiOSwPWif2asTgu6hS6fb5UGosCWxdedMqdViIUUSSdIJx+qQ4KShfTT39VAWZbi+mB+iKICNwpt6cflY57Rcbs6d1kA26Iru73cuxYVlSvuJdcR5VfDYZRk8X0AXePROyw3Le6LaUdmTLzYsoNhhgQpd67xVNiHgk3pakmndeIAtTC4DCXy9oS6eU4CWxDdVmY53pKNbdAKmQsP37lrJZC6iDXMELGKcHjNuuZgcDyY8W/yv6ha3DX7OWm/35fpvhw55oitf4V+GULlcPWYyGGuVBdro19c8u0RDddDun40W7G5cSIzHLh/qZxb59R+EPY+wZ2XerkUim92hhXpKyW6WtAh6zQS97DrPyjCvKi3pCw96LeKynOpyjtsMQc2RmI/20zFOZcSa2AK++PoRcT6zeJyxlBZ7kk5mhqXGkLlM2hFKc+/T544xXP0Ua38Q6xdPTLTeG1PHnLMaOvksUQMrEFTB/lizCirmFQL8zYVU+OTeYQEFaITsBSMMYexS9HkajO2gGIf2micvntCZJsZQEwIH3/4JGJQGflBuH5rNXmnRRYXDQs3ZoEQoMtYDr1kFKUS/siiQSUxcTH9XYeBZiKDDFQoExREO9dddKQLO3BwMHvymCSTFyY+vxn3D27NDx6OlU092D5EDUwilttqVHpjJQDUceJYCLsK2swfXeNUVrBJT/w/sk+7si8rPtiMFis+oxvGdGQxirMBID700T39mULuNHzOyN+xBfcFACZcyngF1aSpv0JPkNUrAZTqfplv509cGXFUiEEm5dZb+OsP/blizqdK45/dSsIrufYTrCPY2lgJD6k6QljTfXVlHfYKSq+MsagyUcaMintyr95bD8kdTAeYNLNsMmo/Wdd8a2nStBP49ARIjqqpUHWY4q4mvO5Cq/CgCP+4/B+5zutGwX5pssgVLr1+fIM7WWLfiUQDk4c6ZdHZOWv5hG3g2dgQ5NXnpIY+BWwJpaouf25bXnjDzbHnQNofH/c6m+dEAS9Gs2h7pFRPKOBDnqswZ8KZjhId1ytHUTs533KwBoSiImoxKQUgZ7z6pA9QB3sZ8Cq0vwutJTTkfbX8AzCpm2cFXx/P22niUMHauU8IGc+78R6TsutoonoqFuoNA3l80t387YHMoL5KGAT1JO4zmx+vJ0LbLHlicHraSVYvJjnO9p++qnWgKw9OwFVVUagvZuf9qfiuum+hIicxP1q4zDnzkHsCNriLxBpxY9N+UOmqzdY1MunLMDgkMyi3uvnN3UBXJeZ8YLs5xr8QrOhimYoKuGBebZHAiBIkViv3DG8k2oNpp5OIgX6ulqaRN8V62QUPjn5tl1kPXhT9bcd8qIm8gi4or/FGbvQ6pgGSHmnayrugmf5E0upGxPRf/3xOtitGMaHLKJVm5zhglmVfI91o0yxhJZVS/5wQ8zfxK8Ylw0WmHXoGfRkoBRx9Hsnl/6sgTjAVwpmNuSeZtBwlX4qB8Bh8lxjqBDIuFGJ4I1wxN0XRlAAslzqMKwQfyA7OkuivCXfv+i+3XmhcBFM2n4jdT+NyUmBnQJPV3F2sZfKvJhUlXzSosFR4VevVVcOkFnnjdiRWc0TeSYxj41sJGYMbZTeLI3GvyZ8/gAAudQ1+4oFX+enX5V49MczGCYVBuoC4kHjp7ZVxj+clBwPr9k+v05SsezQK3enxLs1Nt/N7c7AImVUysjGou4iOohHo83Zs9/MI/OWB+OyXzOBD93NbApGHXrv8CVRHp2bwH+xB55cfNrdqFD35HSMx4iVmtzYAmSCIV8kXsHoq3DIb93riTWbubnjxbBW5zConVtbxLRStXHkIyAByaozME952Gc9aAdAbBpZSVCH88Uwb/4bPTVOVl+WoMYD7JIvK8VcMrJ8zHV4bbG0Dg7Kx17A4ej/ZcZ2Z5pVuVLUH1E/AccUTKm81SE+LQ6STTUDscUk0x2OWIbEORhg69tdoTGNkA1RfkGIRZHr5mCXOpLC55WWzCZoGPFUVtZRHwh0nq039CDdjEPo+JyaxSQAvDgR6Iqvxy0frrtEG1A385N81l05SSzN+IDm9bypF9m92EUqblnauZ5sjc37wRykOdl7w4o8WMgQsjii3EE/aJYDfHs1cH6DNBEujjcCc8qAefYFyIAURDcDnzun5UmkbBQsU4eu/W8I9nBE0qJKTdg2hwjq0+XV7a3TJ7R+alvJZCRia9lJ+grNB9dbrOmWEvUotMjvDhq4wV/kq4fvIBkzUGpDeYH74rne8uU3dgoNZdR9pUL6q9YDNRfOiF6Dyk+SYXQIghTjm9qR4tBHh0gnmF/9q3Qv22EzaLhSvDlDOxMrrCNRmLCl1jApzLrBCPn2mjn5zqK7OYK7VxOfQ5GfBfoPdyQwqFEgCVHkJ9oTnagRM3R0+rsuN5jQv9icCav/p1WqiEXSzCdLd/WEA6z6dDP7tPqPbeDYKAkVcz1lLGbFOC9b7cBd3MV0Ve8dZ89oR7OnxGS7uVpSry8banVZwpJg+nkH1jRBYa2BvBMY2xITH9ERXCjHzdZxs+ipdXP2DY7X+eWiBhtT2L0RRGTLPeazn5tpl4tu8iE2rWig731iuJDRbCHHy+g/Mb9+miAyVqfIpXT/iZeOxOxODO0hEpLM78I1+G2Z45yi3lS1K3m4WMQ559Lp4UML5vZUjYGJuxl+OPpUH5klpyBujkjprhei0TmUik10gjvNUp8mDkWlNKikmYspaVTqewbnOzJrmz8FLIpsT67EJLHIIfeDcWEfiP+DJrZ1jfxpoAb2abeMqLx+9RuZGzQoYtYVGgAWwEM9Kek2vPIeBNAKD6ao7nw6sgvfeLZPoXkbYO/tStHJdKzk+WFSFEU2NcALJAEP6S8pcnqqBBt57dwTrzQNCIdk2SocK4dLRbD/pu/VryKnm65ZYXiJCfHJk3mx9MRSl+nSK6OqEBSoGjz0/LADddwF/HqcfK3K3O+6YUGQcmj8pZL4PhZ6KrGkb8B38FmDvvLd3XQXbvS/FQmrXFTvJNkaN/FGo83KuS43BK1UfVnIqigGkCoP5fBda2MwAGTGNKX9K9t4Bx83pMFc5KSORmWKv+8VoVggWxoaBz3/9IBh6RwLd1tebwy89xvE5z6EEpXpDfrXWfRsMs6+ekUHH6idVosno55+xQ8Zqzelh0bxtJTgCcH3Z3/Cxlx9eNIS4JIFKOAVrDqbrXRszmY55a5+niJGHtkO3b6mnIDxLa1WXc7BAe33mt2KyM4Fbc3R6/WVTQN8QhlqAtave2WsQTqzWeSlKuGUVIJRqtObpv294rS0kDN1RKzdstZTXJebR2HlzsQ4P3NbMHUqFZMZw+/IKXnh4t+lY8qocp/B1oMszR03EFs3bPeND8QkItMvllObeCz3SZAjqZrobmLcrpFyQV7mwBjg3C3C8/bc5goQhv8j/IXMLGnt4mF7tybRDG5G0polxoUScQkPvmnga2/K+aapKeqSL0BTmo1Cm5g+booNOtdyKva2KoefRURaBk7113QKo3y+WTuFKtgETIK8HRluYS9DvlcciCDvnG8UaJRfZE2siZsiTHvRmN80xkUIInHeRZl5Re/+ATL6VhKFi8CZ/n/jbFV6T5pZ+Uoppvsi3qjacVFOJgWWfdlwVHKPW/TJO3na9hRM9bS2yo2rEsC6IBzRReVO6IesJU7PItzOamr+ROFfwGZmZ7ue8HNxAgLJKb7P3p8dMqk6Be5PJaT/5Rdc1deYVihWH9cjVKc9uz5EnfHqxLUkOO8iJUENBNVf5LyNy8zjLu/78k5WNTywiPfYeX3CPk7yc6CI3lum/CEZwfUaNpcI3KsPqfn2lmz3kd/acQjKA1ebkJaiuLD+epQ/Fc1llHXXMzofWzz/Kd29SNmOhcjMWw1jq1g3YfrXZ9rzXDYW4ZttfgfMi6oCUtBs0PkMVuxmq5lxEoCaSXPSqCJJ7MlKdRDidVt0AFlxk5cTdX++sBF2+E35mjwfm8ERVxH0FvuAQtsfA4V2G0TKTUxeyRGVjd/u6F1SvuAiU2/WaQjcNCU4Ep7VunXCYSbZj3U3wzu/LWM5MPlYuyQ3FOOCD/zt7K295hY2JhwF+ODDIZ676vGQFKveEQYkWj7lkK7rVmD7MhU0Y/tF8EcTTpo4/yqOufbd/zWIpMajnbDuWK2vn6OPPtz2rc9MIBNlPd8tt+yf+7SC4wqEPbozKMCwY5Bygx4JmoIEDsixWRDcdHd6S3/dZMHXOJAAv7+NIstl00crgSqHZKAEe4g3G4dzIV51EeZB01r7p8GNlfUnG/GjZgNGsqXZdYMBVtAtFNv3hJWPve4GvqZ2XxuiNkHTz5kxWgr0PjQdJlVywJ9Zf2ZvqeeTbolKtvK54re2Lq5BoyzfsRtvDfyao3kmyFzDQ88nM+qx83w74RDlkngtYiArI05Epre3GgBeSlMig0pE6RGQaFznKkGeb0SozLCyiOtxh7hgwZlbKbClzUUfC8ntMiHUOZE375RhTy9c4DA+oMLkUDkztSybZbdmP1xpaIbjUpPAHBq3cIq+CBFzbMlMMCCkUQ6d9LGV6GYCsYiEWZIy3nBnuxOYXeU4YTGDSin9e4/pCjPtQSHlg5LMEvIlF0ElthqrF129iK2RPBEWd3XWOl3SWV5uz5VUyZYp5kEFmz7QfP/B1W1BBzQ2iTGbSVT79lUHzcGXz3PJceSgz4uknETUwo0xffpr2KUvZF0i/r2sL3IFIClYx8CbIZE6Qt7MDJbOPB3xMScwaOcWG66IJfCnDkb0D2Mb+PHzX+oiCbxeTIogtyN+s2NJirNACk/OACSOTtV6vscwbzW4M168xqaI+RzR47S1nlV/rOoZnid87n/Ima2XYa3un3BuGAisNjb8eLMT9OnMtazQROFCuO1HiZXaOc0oUDbNC4eKLToOx8DzVhMgGA8XIAQ2x3b6I0uEyLssQjJX3QphcUMx4KsMgJ+72km4N2aqkBF2coKmUEt1eqIMGn+5txMT4kYVGd3ALO+y9Z4PP3d3l48JQK8s9ZZ/Qx/+NBKgBEJFlQ32psoJiihGO7FSYM5L81q72kaAYcilEFMG+ZK1BcMqELkflyCV7v8JEXLO4Rf/oZYNZHZVjJhfL6fnpP9Tio3Euue5uS7FMkfGOeRCTrBZ06Caev7tgufeTrX34Ur/Vvc+b8ksiIShNJtuF9WmYxOZ4xg8y6zTdy3KAB2y5kYkcRnXsptWwAFyKZ2I/QGySNeoQLkINUMloC+5L3WuMMx297Q1xUYLKqZ9XHavaobo6QQv4auMm+i84IhxRpPt9nUmcav9NcjCcP+TcMmxsQZ/F3mgeoA0fQgwvTsyXuuTaM3Sqtv2jaaajmaFQpK9W6uIbeqwvSDo34ZrY6elDUHwSCjHRRmlwmyy+eOra64Ssq0XSXYljMHtKY+FShcMkHsEUY/4Bw63dJ6KpwDaxmthlDdbdE+TvYF3v33cGSKqO+1H1pKYhJMvZD5ckQcHyNF8zrtiR5b0ko6NPGoRexUZTYP6VbUdn3zzxGBOi8Z0OqHjGqYxRXwN3mYi0GYEEZYq+Q3QvdKcEHILLLj8S+VFepSfErtmfZCdvxbfIifFSpEzKi+7VJsLMT+zEFeyp1OdwRC1VZrfTLIyR7xTPUcZFYPD9qI7D70uTb4hdpqPXsJIRNYbZtNwch1OI3trh3u2ScoQyM9POnInsUa+OovcwkUP1UfIzPb95n4BaF2ev57NHAej0+BVMF9/Cj9663HN2/JN3SQgslL914bKfiTTDFAz9PlQEL/dSv1H8xl3mtWxh1McFO9EJXlRDaKQDsyKO4vOJW90NFE6yw2tjbc2GeF95sbs0I9enAa6QwQVf/kJQhAD2BzUDKggOyjy1TEhED6sfk+418lQy3c/uj8aw8UEzZ6hIMCd8RohAkumMtIj9m73l2yPWoGHVTPaywkC7Yj9tBM1NxMgcrDwRtk4RO2WHT7Ql5kQCKdJj6kNuOTeyEBYBjLMhGz+O5/YGa84HEiTYEpZ6fFzy26GG2hWtTyteuYrhSyG56BjsT/wQeLRytpTY3D7sIMqZnJ9z1FDrfyjFlGl2TNw9BQysbaxOuwYYZs/7I6BANgkqCknWZC7/BBXvaeKwAmC959I+G39BUE9bExkNlbRoFRyEtNzv+NJ91FuisG3JCS6uYBeRnfv8AkAfKTeg9EYamqnsGfAV7d0f9DghHEQ5IsPGDIUhgoSj7obM4Bu5uhQ3/CYEDTHc92AsFvDK4XGrwUeGBWBHPlS+f4x+CxmmHz2sAGmSFNt65kwZC64mnaoWlu2310laYn8r62AqsR5dfjyK18MEdurdagldzfJtjFXlZs7St4QhdPiye6TPh2/ZAQLU/Fip5s7TDEM16KtRWrK9hmxnQ7bmfa/+7pa10Z8WDPK3NuJ+NN/RAbQ5vHx2uX0Lm7/w7cAEH/hvZA+mt7J7zGw7YtQYwnNN6dpgwkGjjrS3yQoeoYt1EnczmtmJfQZWzUlP3Hlg9Wzlr9IH23q3thGth+QNEANFettxKfskkGOlLk8AqoKJwDqOxAa6UzAx07plSSyNBJSGco9zjnC5gGbDoKvsMDuBR6bGRlGzJ+hFsGa/Izt78aI+WZ6dJlZKp4pGISuv9rV0sAS0MWEwCmfauO7oQZMiakHU35LBxiyJoOMddhUWgcZuC8r4Ksvn75TTcQXLJ7kWtYhGuGqPd9dZuFjBWQHNwosXY5snbHFQq72CvHXhIg+shQxycuLOuWYErwCLZeF24b7F78pO7xw4X6lIAR02hUOf5087Rl0nOaeb6CK4i/KA/EZv76ftOWZtjwxslNr0E/u8rWUmnf3amfg6UZmBAluuoj3Dd7UV+9IAJ6iYcDfSJlgmIImohjfIUMJ27z+opj50Ak9af2LCNrWrBJvMovA1OeNO+MF/MwZvnaCxTgG7Cw4QfSPF6AYCGFt21M8PySZFeV3t2Rqqs5JMzMYzGRgq4o+UaKRgBf9GHi/9X9HXA3wxkCsd/UhnHSh2zUVDiraio/6nP4y3XJqs8ABfALAtCYU7DHPMPRjgcM6Ad/HiSXDAbOdSMkvGZPAkHs8wuQTy6X2Ov/JFvcPuKfV3/r9Q28';
  const Nw = new Map([
      [8217, 'apostrophe'],
      [8260, 'fraction slash'],
      [12539, 'middle dot']
    ]),
    Lw = 4;
  function wD(t) {
    let e = 0;
    function n() {
      return (t[e++] << 8) | t[e++];
    }
    let r = n(),
      i = 1,
      s = [0, 1];
    for (let C = 1; C < r; C++) s.push((i += n()));
    let o = n(),
      a = e;
    e += o;
    let c = 0,
      l = 0;
    function u() {
      return (c == 0 && ((l = (l << 8) | t[e++]), (c = 8)), (l >> --c) & 1);
    }
    const d = 31,
      f = 2 ** d,
      h = f >>> 1,
      g = h >> 1,
      m = f - 1;
    let y = 0;
    for (let C = 0; C < d; C++) y = (y << 1) | u();
    let p = [],
      b = 0,
      v = f;
    for (;;) {
      let C = Math.floor(((y - b + 1) * i - 1) / v),
        $ = 0,
        G = r;
      for (; G - $ > 1; ) {
        let k = ($ + G) >>> 1;
        C < s[k] ? (G = k) : ($ = k);
      }
      if ($ == 0) break;
      p.push($);
      let L = b + Math.floor((v * s[$]) / i),
        F = b + Math.floor((v * s[$ + 1]) / i) - 1;
      for (; ((L ^ F) & h) == 0; )
        ((y = ((y << 1) & m) | u()),
          (L = (L << 1) & m),
          (F = ((F << 1) & m) | 1));
      for (; L & ~F & g; )
        ((y = (y & h) | ((y << 1) & (m >>> 1)) | u()),
          (L = (L << 1) ^ h),
          (F = ((F ^ h) << 1) | h | 1));
      ((b = L), (v = 1 + F - L));
    }
    let x = r - 4;
    return p.map((C) => {
      switch (C - x) {
        case 3:
          return x + 65792 + ((t[a++] << 16) | (t[a++] << 8) | t[a++]);
        case 2:
          return x + 256 + ((t[a++] << 8) | t[a++]);
        case 1:
          return x + t[a++];
        default:
          return C - 1;
      }
    });
  }
  function _D(t) {
    let e = 0;
    return () => t[e++];
  }
  function vx(t) {
    return _D(wD(ED(t)));
  }
  function ED(t) {
    let e = [];
    [
      ...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    ].forEach((i, s) => (e[i.charCodeAt(0)] = s));
    let n = t.length,
      r = new Uint8Array((6 * n) >> 3);
    for (let i = 0, s = 0, o = 0, a = 0; i < n; i++)
      ((a = (a << 6) | e[t.charCodeAt(i)]),
        (o += 6),
        o >= 8 && (r[s++] = a >> (o -= 8)));
    return r;
  }
  function AD(t) {
    return t & 1 ? ~t >> 1 : t >> 1;
  }
  function SD(t, e) {
    let n = Array(t);
    for (let r = 0, i = 0; r < t; r++) n[r] = i += AD(e());
    return n;
  }
  function ou(t, e = 0) {
    let n = [];
    for (;;) {
      let r = t(),
        i = t();
      if (!i) break;
      e += r;
      for (let s = 0; s < i; s++) n.push(e + s);
      e += i + 1;
    }
    return n;
  }
  function bx(t) {
    return au(() => {
      let e = ou(t);
      if (e.length) return e;
    });
  }
  function wx(t) {
    let e = [];
    for (;;) {
      let n = t();
      if (n == 0) break;
      e.push(xD(n, t));
    }
    for (;;) {
      let n = t() - 1;
      if (n < 0) break;
      e.push(CD(n, t));
    }
    return e.flat();
  }
  function au(t) {
    let e = [];
    for (;;) {
      let n = t(e.length);
      if (!n) break;
      e.push(n);
    }
    return e;
  }
  function _x(t, e, n) {
    let r = Array(t)
      .fill()
      .map(() => []);
    for (let i = 0; i < e; i++) SD(t, n).forEach((s, o) => r[o].push(s));
    return r;
  }
  function xD(t, e) {
    let n = 1 + e(),
      r = e(),
      i = au(e);
    return _x(i.length, 1 + t, e).flatMap((o, a) => {
      let [c, ...l] = o;
      return Array(i[a])
        .fill()
        .map((u, d) => {
          let f = d * r;
          return [c + d * n, l.map((h) => h + f)];
        });
    });
  }
  function CD(t, e) {
    let n = 1 + e();
    return _x(n, 1 + t, e).map((i) => [i[0], i.slice(1)]);
  }
  function TD(t) {
    let e = [],
      n = ou(t);
    return (i(r([]), []), e);
    function r(s) {
      let o = t(),
        a = au(() => {
          let c = ou(t).map((l) => n[l]);
          if (c.length) return r(c);
        });
      return {S: o, B: a, Q: s};
    }
    function i({S: s, B: o}, a, c) {
      if (!(s & 4 && c === a[a.length - 1])) {
        (s & 2 && (c = a[a.length - 1]), s & 1 && e.push(a));
        for (let l of o) for (let u of l.Q) i(l, [...a, u], c);
      }
    }
  }
  function ID(t) {
    return t.toString(16).toUpperCase().padStart(2, '0');
  }
  function Ex(t) {
    return `{${ID(t)}}`;
  }
  function kD(t) {
    let e = [];
    for (let n = 0, r = t.length; n < r; ) {
      let i = t.codePointAt(n);
      ((n += i < 65536 ? 1 : 2), e.push(i));
    }
    return e;
  }
  function wc(t) {
    let n = t.length;
    if (n < 4096) return String.fromCodePoint(...t);
    let r = [];
    for (let i = 0; i < n; )
      r.push(String.fromCodePoint(...t.slice(i, (i += 4096))));
    return r.join('');
  }
  function RD(t, e) {
    let n = t.length,
      r = n - e.length;
    for (let i = 0; r == 0 && i < n; i++) r = t[i] - e[i];
    return r;
  }
  var PD =
    'AEUDVgHLCGMATwDUADIAdAAhADQAFAAtABQAIQAPACcADQASAAoAGAAJABIACQARAAUACwAFAAwABQAQAAMABwAEAAoABQAJAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACwANAA0AAwAKAAkABAAdAAYAZwDTAeYDMwCxCl8B8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgPi89uj00MsvBXxEPAGPCDwBnQKoEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiC+AZ4EWRJJFbEu7QDQLARtEbgECxDwAb/RyAk1AV4nD2cEQQKTAzsAGpobWgAahAGPCrysdy0OAKwAfFIcBAQFUmoA/PtZADkBIadVj2UMUgx5Il4ANQC9vAITAdQZWxDzALN9AhsZVwIcGSkCBAgXOhG7AqMZ4M7+1M0UAPDNAWsC+mcJDe8AAQA99zkEXLICyQozAo6lAobcP5JvjQLFzwKD9gU/OD8FEQCtEQL6bW+nAKUEvzjDHsuRyUvOFHcacUz5AqIFRSE2kzsBEQCuaQL5DQTlcgO6twSpTiUgCwIFCAUXBHQEqQV6swAVxUlmTmsCwjqsP/wKJQmXb793UgZBEBsnpRD3DDMBtQE7De1L2ATxBjsEyR99GRkPzZWcCKUt3QztJuMuoYBaI/UqgwXtS/Q83QtNUWgPWQtlCeM6Y4FOAyEBDSKLCt0NOQhtEPMKyWsN5RFFBzkD1UmaAKUHAQsRHTUVtSYQYqwLCTl3Bvsa9guPJq8TKXr8BdMaIQZNASka/wDPLueFsFoxXBxPXwYDCyUjxxSoUCANJUC3eEgaGwcVJakCkUNwSodRNh6TIfY8PQ1mLhNRfAf1PAUZTwuBPJ5Gq0UOEdI+jT1IIklMLAQ1fywvJ4sJzw+FDLl8cgFZCSEJsQxxEzERFzfFCDkHGS2XJCcVCCFGlWCaBPefA/MT0QMLBT8JQQcTA7UcLRMuFSkFDYEk1wLzNtUuswKPVoABFwXLDyUf3xBQR+AO6QibAmUDgyXrAC0VIQAXIpsIQ2MAX4/YUwUuywjHamwjdANnFOdhEXMHkQ5XB6ccMxW/HOFwyF4Lhggoo68JWwF1CZkBXwTjCAk1W4ygIEFnU4tYGJsgYUE/XfwCMQxlFZ9EvYd4AosPaxIbATUBcwc5DQECdxHtEWsQlQjrhgQ1tTP4OiUETyGDIBEKJwNPbM4LJyb5DPhpAaMSYgMMND137merYLYkF/0HGTLFQWAh8QuST80MnBrBGEJULhnkB78D8xrzJ+pBVwX/A6MDEzpNM+4EvQtpCIsJPwBJDqMXB9cYagpxjNABMYsBt5kDV5GDAm+PBjcHCwBnC4cFeeUAHQKnCKMABQDPA1cAOQKtB50AGQCFQQE9AycvASHlAo8DkwgxywGVLwHzKQQbwwwVAPc3bkoCw7ECgGpmogXdWAKOAkk1AU0lBAVOR1EDr3HhANsASwYT30cBFatKyxrjQwHfbysAxwD7AAU1BwVBAc0B820AtwFfCzEJorO1AU3pKQCDABVrAdcCiQDdADUAf/EBUwBNBVn5BdMCT0kBETEYK1dhAbsDHwEzAQ0AeQbLjaXJBx8EbQfTAhAbFeEC7y4HtQEDIt8TzULFAr3eVaFgAmSBAmJCW02vWzcgAqH3AmiYAmYJAp+EOBsLAmY7AmYmBG4EfwN/EwN+kjkGOXcXOYI6IyMCbB0CMjY4CgJtxwJtru+KM2dFKwFnAN4A4QBKBQeYDI0A/gvCAA21AncvAnaiPwJ5S0MCeLodXNtFrkbXAnw/AnrIAn0JAnzwBVkFIEgASH1jJAKBbQKAAAKABQJ/rklYSlsVF0rMAtEBAtDMSycDiE8Dh+ZExZEyAvKhXQMDA65LzkwtJQPPTUxNrwKLPwKK2MEbBx1DZwW3Ao43Ao5cQJeBAo7ZAo5ceFG0UzUKUtRUhQKT+wKTDADpABxVHlWvVdAGLBsplYYy4XhmRTs5ApefAu+yWCGoAFklApaPApZ8nACpWaxaCYFNADsClrUClk5cRFzRApnLAplkXMpdBxkCnJs5wjqdApwWAp+bAp64igAdDzEqDwKd8QKekgC1PWE0Ye8CntMCoG4BqQKenx8Cnk6lY8hkJyUrAievAiZ+AqD7AqBMAqLdAqHEAqYvAqXOAqf/AH0Cp/JofGixAANJahxq0QKs4wKsrgKtZwKtAgJXHQJV3AKx4dcDH05slwKyvQ0CsugXbOBtY21IXwMlzQK2XDs/bpADKUUCuF4CuUcVArkqd3A2cOECvRkCu9pwlgMyEQK+iHICAzNxAr4acyJzTwLDywLDBHOCdEs1RXTgAzynAzyaAz2/AsV8AsZHAsYQiQLIaVECyEQCyU8CyS4CZJ0C3dJ4eWF4rnklS9ADGKNnAgJh9BnzlSR7C16SXrsRAs9rAs9sL0tT0vMTnwDGrQLPcwEp6gNOEn5LBQLcJwLbigLSTwNSXANTXwEBA1WMgIk/AMsW7WBFghyC04LOg40C2scC2d6EEIRJpzwDhqUALwNkDoZxWfkAVQLfZQLeuHN3AuIv7RQB8zAnAfSbAfLShwLr8wLpcHkC6vkC6uQA+UcBuQLuiQLrnJaqlwMC7j8DheCYeXDgcaEC8wMAaQOOFpmTAvcTA5FuA5KHAveYAvnZAvhmmhyaq7s3mx4DnYMC/voBGwA5nxyfswMFjQOmagOm2QDRxQMGaqGIogUJAwxJAtQAPwMA4UEXUwER8wNrB5dnBQCTLSu3r73bAYmZFH8RBDkB+ykFIQ6dCZ8Akv0TtRQrxQL3LScApQC3BbmOkRc/xqdtQS4UJo0uAUMBgPwBtSYAdQMOBG0ALAIWDKEAAAoCPQJqA90DfgSRASBFBSF8CgAFAEQAEwA2EgJ3AQAF1QNr7wrFAgD3Cp8nv7G35QGRIUFCAekUfxE0wIkABAAbAFoCRQKEiwAGOlM6lI1tALg6jzrQAI04wTrcAKUA6ADLATqBOjs5/Dn5O3aJOls7nok6bzkYAVYBMwFsBS81XTWeNa01ZjV1NbY1xTWCNZE10jXhNZ41rTXuNf01sjXBNgI2ETXGNdU2FjYnNd417TYuNj02LjUtITY6Nj02PDbJNwgEkDxXNjg23TcgNw82yiA3iTcwCgSwPGc2JDcZN2w6jTchQtRDB0LgQwscDw8JmyhtKFFVBgDpfwDpsAD+mxQ91wLpNSMArQC9BbeOkRdLxptzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgELgEaJZkC7aMAoQCjBcGOmxdNxrsBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUHqSvAj5Gqwr7YrMUACT9AN3rlr3JG9m8w9lIAXltp/v8kfWaIaaR9OwpAES/I3ZVamDXSgB/UsOgAG6D0tq+5CIqE15FiAhV3yA2VhCQ7tj+m6xXaF53FIfGi/IAZIskMGAi2MU7MDVJNCbMzERyHZi+osdPtnFVbvq653O8rwaCy4IAf9OOok65AqJUtUriUfYsGPPVbe6jm0s9lbKlPCUKjdkHsFsEhvX4kT39ZCtAAbwQdn/h4TpO5hTByWAmr5n+Wuwhdegv6bmvX4LyOes3z2+cuHv2JFYwVMNuq2gzn8YHTjlUQd39osyWei4NKl3LAdfxlO876hh5ENp/cOvpuI9bF55guEthLLPOXjD4dktTH04P5TvZrWTM0e4+BHJxj7MLApXIFOs0sWKhNkG8iwuM5wR83my6V3wW06abhDzTXYfOr/ZpFXgXzmv4d12FFyP00/dPGbIVGV5ao8UufGzUwp/IHx6v/wDWJr9iaoCulhWwlZ7A8q/NMoD12+mBdNRgJYnThRLtMx1Bgwttn8/4Qn2CDfOSup9GVXEvA21ILgp0owHYxNOkpwLWz0G7K+WREIDjIzUzSn8I99CuJSmSpPyH0Ke6/NERYiNx+3dncSebPnOUnnWD61AhJ1n/tSLZmU5wYO5GfgzyAYJm6VL91LxZ8hL1lfximQxIDMRhIecQZBmeE5R0XlrpvwplVrJwpa8BBCdp93GPP9lyBeZ2zkRr920CR3cYbKpKHfogvm0nV7XdDz6EbjzlxADCMjSLXuXpIpyuizy39yY+I+H9rmpoIF3YwEjlH9MgGgWcCNTjHEWMqAbprn2Ox7rOHupaVE3lNyg3nt5XaZID6Y+uml5Ja+aOPu+BI+DZbiJVfaspUadakWUX6TA4dETkIqdJJHYnU4Z4yKpt5y8rVIahoMUf8A8kWtAQNCTbjp71gx3/zVdqNz1Sutkw0gFIMVm2BF4Xdv/0olw+NaDIR9Bb3DPweZA2K/cw+/b+AwyWl9ZOP67A9nexmeTNjfdzPGf9J6E6BMPKa5lJh+qNsdUz3HBUevU71eQFCqOcxiIYhacAhh/8PX0J5DdSViZ6WazDDx7cukJNpMfEkYLJ5Ao4vLoVd3d25Pg4qaVa2p2D2L3WvYPJ5Yf/A/MSxptjlgXL/KJtP2U0cRv2I09ATAiWCJYuRwiapeKFsqmi18yMMulDp3HdcIldq+7jkwsJUOHLHCzzzBw5XFvL0CAmo1ub456z7zb7shk3KPGCLZzr47oT1k/j06XNnJvG3Udv6XrP+wsqTBlZ5MaNPt9FOs/4Bt/ja/vbVhTNpBFl9Gq7MqINvGlWKOAwQzwOZy+EzSdjAqKJVV2YcskTuM94aIK+kc/AZaXiZLPREUDpkXIV947IFfj+85TrqPqLfkGcxgboMQjosf+az+odLNXdyp1mDNGsqSdK/pJ2Ca04mt/4d6s1X+lncOEYaGBBeW4pApGcjf7/XJCFbj3N3mFb+BtlIcw8ZiDKoClFX9Rf0bxCqtLpicObKJzBVVHr/6u4siH2hK75RNv7w9GfTbhJOQBYiFUZAByY4rn37tZBHT//kqKsNi3ryL9AqXJRzqiMIJMhILjoi/i8LVEsbu+Ih9bsyW16sgQqjYLO0qda6KaCPKj3DQcu6CfV5lKtjS3ZCdqLAZkOey9MR+QutJBGiz/r15GVD6rCVwJR4UUKC4GNJkfDf00OMW8aQtLSAGLXV8MIi9mbbl/qQEpxCm2L5hutFX4ekeLH4QgBWUFKs/2VVMKy46WtFE6AbwgmYm/Z0yHk5veDIrcl2HpVqb/rSE0PC9EbDzJEWqeaPhh7vF369Umq2kSiB3s5rBI6c/7N9bkRu4h2n+/h5nSwy+7n+/I+6oXQVANo2Jb5zDwtiBPf1ySCzHdT6yJShMzqSRZfnykX49CaFaxhoVF4PBhEuECJ1PrFYSpmHuyYsl14DTAV9ZxRms1XiR/kBrjhZjidOt0UNe+GSml7XNgpVw8YsUTmZXLTK+6iYnyW/wYR1W4UXwOi14xpFROHb6HcZzksgF5DbL2AFXzKNwHU2adjdAY+KCyM/cwRTBkkq/a227NI0q6DR2MkMCRu620t79bGcYUmACtqN3mk/0uNwd3JSXHqE1kzf6Yyj0W2083JNDRnIXDlgBxJ6uf58NN1f6FQiRCWB4egF8QDx74AixV8oTyw7PluIjr3/rj/WzgwPSq4xPojaF7V0xqG2u5ti2L1h6yYHv73Isrukr0kURDIEjClBsBx7kdcXUxaYMS0syT3ymLzDzslNDWQOT1Tao1YNmJHARUenhCkmV9tqCPGI5GqZaRpkiPxyjoncWjyOHYGqvbvRX+Bn1pn7EhRNXa1lqJPmoeN5VqdqIDPhEVhFsyG0d4iQEIYX0wZUbY2XbZWYlpZ/l66IrDDY0q1C1YzBDpHC4h05YqHQLqS9anyl22JQ6lEvjvdBwMHfE7z0luCXD34/rFeDa2TmSeEAykSpYO5j1G/nsgpR3qn0qaQEmLjnnLfcz+veoYqPnRqmRGwCJ6FJ3Gm/Z1/aVX5PSb03MMnjAf41ww54sD5k8FrkfBP+K0b1MrYpapWjtpZfve2HVf4ickX3LKSOhu7qI1Vd4c1kNrn2ajy1t4y93JhV4fnWCKq7OmFpcr7FjdJCXPTql0Drr14Ho3Z87+GPQ4Z/DcTiGqtvZxlRYi8cNuhXABveZIwNl/BX1huhVLaFax5OqypUrQRyb9OE3SSkPlDdy5uo5XGg2EIGEjLY1MO5cr1ibfiFWV7zspcTgkBKkwo5jPyAin04LqizZXb2tDRgwKJjGx4cVk3ngAQixwcxjYAg2Q7vmUR/hpwInMdw7OhC2qyf41vTPkudQAORS0DdLtOGQxb4fH2VYGsvJCkeWPeUwtf1/tuIhzXEThoCZzzSJqqjUtbaPI3ntHm3T5uf849hGUA0zU8ni5W+EEn3/0Y6oUhQFw9z0aGjkljBbAlFXc0y82G2wkd7VdgWa5KTgJJNjNwZMfmdnUIUn1JU5LiWX5UZEZbVlKSN76mlmjUR2ku+fucTNlO4IAAahnLjBhlvQNR9pe9swGBgq0YR7P3VCyI/seYwQ4QBzy9X+HPePgoF8WfKaJ4MBOhLCGHae6Z8xkNXwni9QAKvTNtVA56x8YJflZ/VvONRSlsSLmiSyNMnTjTaE1ko81zkzGEnVwEhjCzlwIqpxmpDAqwsEmtpdr3xpc7i/ZX3f2TzT3M0FdxIEQvO1jgmmiN+D1YpMduAzEhBtj2OBkMN/rv6p7Th4pSH6f5aH3aTvwFTl7EOSgGASI7ttyMehzpm4AVyK+bFEaFg9gnZsSUPpsbAe/0RFhrH+EXZ12Z7thf4dzN1+Sn+G8QrDA1VKaN4IFxD1rQz9Xq9Coii9S9/hPbTGjyBwFH3H1UdQuz5KsgPDEHua4/kPg2Gp/IIItsaLWBqiT9XH45MiQxSosGJ56H/0F2cjcCFd72l1665RNHURdC3lspI77esfJsl+rXXabkAy7vxDXG/XGGcKpwiKDPFfvMEgjkAHil4Za1F36RnyxxvdIAzvgfH8knukYDck07tc++DP4TdWeI7HXuq5Yl6VVFrUQtf64/dkXewlKZSHQo6YvCSpREB0GDrz+Ys2GfO8nw2SwrYwaf88AifzlPvP17bf1mI3AuccJvAjZIpBmqvharKFAebEjVKfGAwpQjWoXlm9LROsq9bCk1UeQ3CJxJqprzssS/Q04JeS1ReCCubL3J7sx86spkP4eNpp95UF+8K748icIs8vdILFklk9skQqi1So6cx3X906pvy1vz+KipTJ8fiVJxsV5MmT0XwA';
  const cu = 44032,
    ph = 4352,
    mh = 4449,
    gh = 4519,
    Ax = 19,
    Sx = 21,
    _c = 28,
    yh = Sx * _c,
    MD = Ax * yh,
    OD = cu + MD,
    ND = ph + Ax,
    LD = mh + Sx,
    BD = gh + _c;
  function tl(t) {
    return (t >> 24) & 255;
  }
  function xx(t) {
    return t & 16777215;
  }
  let wg, Bw, _g, Vd;
  function DD() {
    let t = vx(PD);
    ((wg = new Map(bx(t).flatMap((e, n) => e.map((r) => [r, (n + 1) << 24])))),
      (Bw = new Set(ou(t))),
      (_g = new Map()),
      (Vd = new Map()));
    for (let [e, n] of wx(t)) {
      if (!Bw.has(e) && n.length == 2) {
        let [r, i] = n,
          s = Vd.get(r);
        (s || ((s = new Map()), Vd.set(r, s)), s.set(i, e));
      }
      _g.set(e, n.reverse());
    }
  }
  function Cx(t) {
    return t >= cu && t < OD;
  }
  function FD(t, e) {
    if (t >= ph && t < ND && e >= mh && e < LD)
      return cu + (t - ph) * yh + (e - mh) * _c;
    if (Cx(t) && e > gh && e < BD && (t - cu) % _c == 0) return t + (e - gh);
    {
      let n = Vd.get(t);
      return n && ((n = n.get(e)), n) ? n : -1;
    }
  }
  function Tx(t) {
    wg || DD();
    let e = [],
      n = [],
      r = !1;
    function i(s) {
      let o = wg.get(s);
      (o && ((r = !0), (s |= o)), e.push(s));
    }
    for (let s of t)
      for (;;) {
        if (s < 128) e.push(s);
        else if (Cx(s)) {
          let o = s - cu,
            a = (o / yh) | 0,
            c = ((o % yh) / _c) | 0,
            l = o % _c;
          (i(ph + a), i(mh + c), l > 0 && i(gh + l));
        } else {
          let o = _g.get(s);
          o ? n.push(...o) : i(s);
        }
        if (!n.length) break;
        s = n.pop();
      }
    if (r && e.length > 1) {
      let s = tl(e[0]);
      for (let o = 1; o < e.length; o++) {
        let a = tl(e[o]);
        if (a == 0 || s <= a) {
          s = a;
          continue;
        }
        let c = o - 1;
        for (;;) {
          let l = e[c + 1];
          if (((e[c + 1] = e[c]), (e[c] = l), !c || ((s = tl(e[--c])), s <= a)))
            break;
        }
        s = tl(e[o]);
      }
    }
    return e;
  }
  function $D(t) {
    let e = [],
      n = [],
      r = -1,
      i = 0;
    for (let s of t) {
      let o = tl(s),
        a = xx(s);
      if (r == -1) o == 0 ? (r = a) : e.push(a);
      else if (i > 0 && i >= o)
        (o == 0 ? (e.push(r, ...n), (n.length = 0), (r = a)) : n.push(a),
          (i = o));
      else {
        let c = FD(r, a);
        c >= 0
          ? (r = c)
          : i == 0 && o == 0
            ? (e.push(r), (r = a))
            : (n.push(a), (i = o));
      }
    }
    return (r >= 0 && e.push(r, ...n), e);
  }
  function Ix(t) {
    return Tx(t).map(xx);
  }
  function HD(t) {
    return $D(Tx(t));
  }
  const Dw = 45,
    kx = '.',
    Rx = 65039,
    Px = 1,
    vh = (t) => Array.from(t);
  function lu(t, e) {
    return t.P.has(e) || t.Q.has(e);
  }
  class jD extends Array {
    get is_emoji() {
      return !0;
    }
  }
  let Eg, Mx, ko, Ag, Ox, Za, km, Ca, wo, Fw, Sg;
  function Bv() {
    if (Eg) return;
    let t = vx(bD);
    const e = () => ou(t),
      n = () => new Set(e()),
      r = (u, d) => d.forEach((f) => u.add(f));
    ((Eg = new Map(wx(t))),
      (Mx = n()),
      (ko = e()),
      (Ag = new Set(e().map((u) => ko[u]))),
      (ko = new Set(ko)),
      (Ox = n()),
      n());
    let i = bx(t),
      s = t();
    const o = () => {
      let u = new Set();
      return (e().forEach((d) => r(u, i[d])), r(u, e()), u);
    };
    ((Za = au((u) => {
      let d = au(t).map((f) => f + 96);
      if (d.length) {
        let f = u >= s;
        ((d[0] -= 32), (d = wc(d)), f && (d = `Restricted[${d}]`));
        let h = o(),
          g = o(),
          m = !t();
        return {N: d, P: h, Q: g, M: m, R: f};
      }
    })),
      (km = n()),
      (Ca = new Map()));
    let a = e()
      .concat(vh(km))
      .sort((u, d) => u - d);
    a.forEach((u, d) => {
      let f = t(),
        h = (a[d] = f ? a[d - f] : {V: [], M: new Map()});
      (h.V.push(u), km.has(u) || Ca.set(u, h));
    });
    for (let {V: u, M: d} of new Set(Ca.values())) {
      let f = [];
      for (let g of u) {
        let m = Za.filter((p) => lu(p, g)),
          y = f.find(({G: p}) => m.some((b) => p.has(b)));
        (y || ((y = {G: new Set(), V: []}), f.push(y)), y.V.push(g), r(y.G, m));
      }
      let h = f.flatMap((g) => vh(g.G));
      for (let {G: g, V: m} of f) {
        let y = new Set(h.filter((p) => !g.has(p)));
        for (let p of m) d.set(p, y);
      }
    }
    wo = new Set();
    let c = new Set();
    const l = (u) => (wo.has(u) ? c.add(u) : wo.add(u));
    for (let u of Za) {
      for (let d of u.P) l(d);
      for (let d of u.Q) l(d);
    }
    for (let u of wo) !Ca.has(u) && !c.has(u) && Ca.set(u, Px);
    (r(wo, Ix(wo)),
      (Fw = TD(t)
        .map((u) => jD.from(u))
        .sort(RD)),
      (Sg = new Map()));
    for (let u of Fw) {
      let d = [Sg];
      for (let f of u) {
        let h = d.map((g) => {
          let m = g.get(f);
          return (m || ((m = new Map()), g.set(f, m)), m);
        });
        f === Rx ? d.push(...h) : (d = h);
      }
      for (let f of d) f.V = u;
    }
  }
  function Dv(t) {
    return (Nx(t) ? '' : `${Fv(Np([t]))} `) + Ex(t);
  }
  function Fv(t) {
    return `"${t}"‎`;
  }
  function UD(t) {
    if (t.length >= 4 && t[2] == Dw && t[3] == Dw)
      throw new Error(`invalid label extension: "${wc(t.slice(0, 4))}"`);
  }
  function KD(t) {
    for (let n = t.lastIndexOf(95); n > 0; )
      if (t[--n] !== 95) throw new Error('underscore allowed only at start');
  }
  function qD(t) {
    let e = t[0],
      n = Nw.get(e);
    if (n) throw _l(`leading ${n}`);
    let r = t.length,
      i = -1;
    for (let s = 1; s < r; s++) {
      e = t[s];
      let o = Nw.get(e);
      if (o) {
        if (i == s) throw _l(`${n} + ${o}`);
        ((i = s + 1), (n = o));
      }
    }
    if (i == r) throw _l(`trailing ${n}`);
  }
  function Np(t, e = 1 / 0, n = Ex) {
    let r = [];
    (VD(t[0]) && r.push('◌'),
      t.length > e &&
        ((e >>= 1), (t = [...t.slice(0, e), 8230, ...t.slice(-e)])));
    let i = 0,
      s = t.length;
    for (let o = 0; o < s; o++) {
      let a = t[o];
      Nx(a) && (r.push(wc(t.slice(i, o))), r.push(n(a)), (i = o + 1));
    }
    return (r.push(wc(t.slice(i, s))), r.join(''));
  }
  function VD(t, e) {
    return (Bv(), ko.has(t));
  }
  function Nx(t) {
    return (Bv(), Ox.has(t));
  }
  function GD(t) {
    return YD(zD(t, HD, XD));
  }
  function zD(t, e, n) {
    if (!t) return [];
    Bv();
    let r = 0;
    return t.split(kx).map((i) => {
      let s = kD(i),
        o = {input: s, offset: r};
      r += s.length + 1;
      try {
        let a = (o.tokens = JD(s, e, n)),
          c = a.length,
          l;
        if (!c) throw new Error('empty label');
        let u = (o.output = a.flat());
        if (
          (KD(u),
          !(o.emoji = c > 1 || a[0].is_emoji) && u.every((f) => f < 128))
        )
          (UD(u), (l = 'ASCII'));
        else {
          let f = a.flatMap((h) => (h.is_emoji ? [] : h));
          if (!f.length) l = 'Emoji';
          else {
            if (ko.has(u[0])) throw _l('leading combining mark');
            for (let m = 1; m < c; m++) {
              let y = a[m];
              if (!y.is_emoji && ko.has(y[0]))
                throw _l(
                  `emoji + combining mark: "${wc(a[m - 1])} + ${Np([y[0]])}"`
                );
            }
            qD(u);
            let h = vh(new Set(f)),
              [g] = ZD(h);
            (QD(g, f), WD(g, h), (l = g.N));
          }
        }
        o.type = l;
      } catch (a) {
        o.error = a;
      }
      return o;
    });
  }
  function WD(t, e) {
    let n,
      r = [];
    for (let i of e) {
      let s = Ca.get(i);
      if (s === Px) return;
      if (s) {
        let o = s.M.get(i);
        if (((n = n ? n.filter((a) => o.has(a)) : vh(o)), !n.length)) return;
      } else r.push(i);
    }
    if (n) {
      for (let i of n)
        if (r.every((s) => lu(i, s)))
          throw new Error(`whole-script confusable: ${t.N}/${i.N}`);
    }
  }
  function ZD(t) {
    let e = Za;
    for (let n of t) {
      let r = e.filter((i) => lu(i, n));
      if (!r.length) throw Za.some((i) => lu(i, n)) ? Bx(e[0], n) : Lx(n);
      if (((e = r), r.length == 1)) break;
    }
    return e;
  }
  function YD(t) {
    return t
      .map(({input: e, error: n, output: r}) => {
        if (n) {
          let i = n.message;
          throw new Error(
            t.length == 1 ? i : `Invalid label ${Fv(Np(e, 63))}: ${i}`
          );
        }
        return wc(r);
      })
      .join(kx);
  }
  function Lx(t) {
    return new Error(`disallowed character: ${Dv(t)}`);
  }
  function Bx(t, e) {
    let n = Dv(e),
      r = Za.find((i) => i.P.has(e));
    return (
      r && (n = `${r.N} ${n}`),
      new Error(`illegal mixture: ${t.N} + ${n}`)
    );
  }
  function _l(t) {
    return new Error(`illegal placement: ${t}`);
  }
  function QD(t, e) {
    for (let n of e) if (!lu(t, n)) throw Bx(t, n);
    if (t.M) {
      let n = Ix(e);
      for (let r = 1, i = n.length; r < i; r++)
        if (Ag.has(n[r])) {
          let s = r + 1;
          for (let o; s < i && Ag.has((o = n[s])); s++)
            for (let a = r; a < s; a++)
              if (n[a] == o)
                throw new Error(`duplicate non-spacing marks: ${Dv(o)}`);
          if (s - r > Lw)
            throw new Error(
              `excessive non-spacing marks: ${Fv(Np(n.slice(r - 1, s)))} (${s - r}/${Lw})`
            );
          r = s;
        }
    }
  }
  function JD(t, e, n) {
    let r = [],
      i = [];
    for (t = t.slice().reverse(); t.length; ) {
      let s = eF(t);
      if (s) (i.length && (r.push(e(i)), (i = [])), r.push(n(s)));
      else {
        let o = t.pop();
        if (wo.has(o)) i.push(o);
        else {
          let a = Eg.get(o);
          if (a) i.push(...a);
          else if (!Mx.has(o)) throw Lx(o);
        }
      }
    }
    return (i.length && r.push(e(i)), r);
  }
  function XD(t) {
    return t.filter((e) => e != Rx);
  }
  function eF(t, e) {
    let n = Sg,
      r,
      i = t.length;
    for (; i && ((n = n.get(t[--i])), !!n); ) {
      let {V: s} = n;
      s && ((r = s), (t.length = i));
    }
    return r;
  }
  const tF = (t) => GD(t),
    Yr = (t) => {
      let e = '';
      for (let n = 0; n < 32; n += 1) e += '00';
      if (t) {
        const r = tF(t).split('.');
        for (let i = r.length - 1; i >= 0; i -= 1) {
          const s = rr(r[i]).slice(2);
          e = rr(`0x${e}${s}`).slice(2);
        }
      }
      return `0x${e}`;
    };
  var td = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  class nF {
    constructor(e, n) {
      ((this.contract = new jo(yD, n ?? hh.main, e)), (this.context = e));
    }
    getOwner(e) {
      return td(this, void 0, void 0, function* () {
        try {
          return this.contract.methods.owner(Yr(e)).call();
        } catch {
          throw new Error();
        }
      });
    }
    getTTL(e) {
      return td(this, void 0, void 0, function* () {
        try {
          return this.contract.methods.ttl(Yr(e)).call();
        } catch {
          throw new Error();
        }
      });
    }
    recordExists(e) {
      return td(this, void 0, void 0, function* () {
        try {
          return this.contract.methods.recordExists(Yr(e)).call();
        } catch {
          throw new Error();
        }
      });
    }
    getResolver(e) {
      return td(this, void 0, void 0, function* () {
        try {
          return this.contract.methods
            .resolver(Yr(e))
            .call()
            .then((n) => {
              if (typeof n == 'string') return new jo(vD, n, this.context);
              throw new Error();
            });
        } catch {
          throw new Error();
        }
      });
    }
    get events() {
      return this.contract.events;
    }
  }
  var ki = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  class rF {
    constructor(e) {
      this.registry = e;
    }
    getResolverContractAdapter(e) {
      return ki(this, void 0, void 0, function* () {
        return this.registry.getResolver(e);
      });
    }
    checkInterfaceSupport(e, n) {
      var r, i;
      return ki(this, void 0, void 0, function* () {
        if (Re(Ow[n]))
          throw new Rb(
            (r = e.options.address) !== null && r !== void 0 ? r : '',
            n
          );
        if (!(yield e.methods.supportsInterface(Ow[n]).call()))
          throw new Rb(
            (i = e.options.address) !== null && i !== void 0 ? i : '',
            n
          );
      });
    }
    supportsInterface(e, n) {
      var r;
      return ki(this, void 0, void 0, function* () {
        const i = yield this.getResolverContractAdapter(e);
        let s = n;
        if (!it(s)) {
          if (((s = (r = Nu(n)) !== null && r !== void 0 ? r : ''), n === ''))
            throw new Error('Invalid interface Id');
          s = s.slice(0, 10);
        }
        return i.methods.supportsInterface(s).call();
      });
    }
    getAddress(e, n = 60) {
      return ki(this, void 0, void 0, function* () {
        const r = yield this.getResolverContractAdapter(e);
        return (
          yield this.checkInterfaceSupport(r, ga.addr),
          r.methods.addr(Yr(e), n).call()
        );
      });
    }
    getPubkey(e) {
      return ki(this, void 0, void 0, function* () {
        const n = yield this.getResolverContractAdapter(e);
        return (
          yield this.checkInterfaceSupport(n, ga.pubkey),
          n.methods.pubkey(Yr(e)).call()
        );
      });
    }
    getContenthash(e) {
      return ki(this, void 0, void 0, function* () {
        const n = yield this.getResolverContractAdapter(e);
        return (
          yield this.checkInterfaceSupport(n, ga.contenthash),
          n.methods.contenthash(Yr(e)).call()
        );
      });
    }
    setAddress(e, n, r) {
      return ki(this, void 0, void 0, function* () {
        const i = yield this.getResolverContractAdapter(e);
        return (
          yield this.checkInterfaceSupport(i, ga.setAddr),
          i.methods.setAddr(Yr(e), n).send(r)
        );
      });
    }
    getText(e, n) {
      return ki(this, void 0, void 0, function* () {
        const r = yield this.getResolverContractAdapter(e);
        return (
          yield this.checkInterfaceSupport(r, ga.text),
          r.methods.text(Yr(e), n).call()
        );
      });
    }
    getName(e, n = !0) {
      return ki(this, void 0, void 0, function* () {
        const r = `${e.toLowerCase().substring(2)}.addr.reverse`,
          i = yield this.getResolverContractAdapter(r);
        return (
          n && (yield this.checkInterfaceSupport(i, ga.name)),
          i.methods.name(Yr(r)).call()
        );
      });
    }
  }
  var cr = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  class Dx extends Un {
    constructor(e, n) {
      (super(n ?? ''),
        (this.registryAddress = e ?? hh.main),
        (this._registry = new nF(this.getContextObject(), e)),
        (this._resolver = new rF(this._registry)));
    }
    getResolver(e) {
      return cr(this, void 0, void 0, function* () {
        return this._registry.getResolver(e);
      });
    }
    recordExists(e) {
      return cr(this, void 0, void 0, function* () {
        return this._registry.recordExists(e);
      });
    }
    getTTL(e) {
      return cr(this, void 0, void 0, function* () {
        return this._registry.getTTL(e);
      });
    }
    getOwner(e) {
      return cr(this, void 0, void 0, function* () {
        return this._registry.getOwner(e);
      });
    }
    getAddress(e, n = 60) {
      return cr(this, void 0, void 0, function* () {
        return this._resolver.getAddress(e, n);
      });
    }
    getText(e, n) {
      return cr(this, void 0, void 0, function* () {
        return nr(e)
          ? this._resolver.getText(yield this._resolver.getName(e, !1), n)
          : this._resolver.getText(e, n);
      });
    }
    getName(e, n = !0) {
      return cr(this, void 0, void 0, function* () {
        return this._resolver.getName(e, n);
      });
    }
    getPubkey(e) {
      return cr(this, void 0, void 0, function* () {
        return this._resolver.getPubkey(e);
      });
    }
    getContenthash(e) {
      return cr(this, void 0, void 0, function* () {
        return this._resolver.getContenthash(e);
      });
    }
    checkNetwork() {
      return cr(this, void 0, void 0, function* () {
        const e = Date.now() / 1e3;
        if (!this._lastSyncCheck || e - this._lastSyncCheck > 3600) {
          const i = yield IB(this);
          if (!(typeof i == 'boolean' && !i)) throw new FR();
          this._lastSyncCheck = e;
        }
        if (this._detectedAddress) return this._detectedAddress;
        const n = yield Av(
            this,
            Object.assign(Object.assign({}, this.defaultReturnFormat), {
              number: wr.HEX
            })
          ),
          r = hh[gD[n]];
        if (typeof r > 'u') throw new DR(n);
        return ((this._detectedAddress = r), this._detectedAddress);
      });
    }
    supportsInterface(e, n) {
      return cr(this, void 0, void 0, function* () {
        return this._resolver.supportsInterface(e, n);
      });
    }
    get events() {
      return this._registry.events;
    }
    setAddress(e, n, r) {
      return cr(this, void 0, void 0, function* () {
        return this._resolver.setAddress(e, n, r);
      });
    }
  }
  var ds = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  const iF = (t) =>
      ds(void 0, void 0, void 0, function* () {
        return (yield cL(t)).map(_i);
      }),
    sF = (t, e) =>
      ds(void 0, void 0, void 0, function* () {
        Ie.validate(['string'], [e]);
        const n = yield lL(t, e);
        return _i(n);
      }),
    oF = (t, e, n, r) =>
      ds(void 0, void 0, void 0, function* () {
        return (
          Ie.validate(['address', 'string', 'uint'], [e, n, r]),
          uL(t, e, n, r)
        );
      }),
    aF = (t, e) =>
      ds(void 0, void 0, void 0, function* () {
        return (Ie.validate(['address'], [e]), dL(t, e));
      }),
    cF = (t, e, n) =>
      ds(void 0, void 0, void 0, function* () {
        return (Ie.validate(['string', 'string'], [e, n]), fL(t, e, n));
      }),
    lF = (t, e, n, r) =>
      ds(void 0, void 0, void 0, function* () {
        const i = Vn(e, Be, {
          transactionSchema: r == null ? void 0 : r.customTransactionSchema
        });
        return hL(t, i, n);
      }),
    uF = (t, e, n, r) =>
      ds(void 0, void 0, void 0, function* () {
        const i = Vn(e, Be, {
          transactionSchema: r == null ? void 0 : r.customTransactionSchema
        });
        return pL(t, i, n);
      }),
    dF = (t, e, n, r) =>
      ds(void 0, void 0, void 0, function* () {
        Ie.validate(['string', 'address', 'string'], [e, n, r]);
        const i = it(e) ? e : Hr(e);
        return mL(t, i, n, r);
      }),
    fF = (t, e, n) =>
      ds(void 0, void 0, void 0, function* () {
        Ie.validate(['string', 'string'], [e, n]);
        const r = it(e) ? e : Hr(e);
        return gL(t, r, n);
      });
  var Ri = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  class Fx extends Un {
    getAccounts() {
      return Ri(this, void 0, void 0, function* () {
        return iF(this.requestManager);
      });
    }
    newAccount(e) {
      return Ri(this, void 0, void 0, function* () {
        return sF(this.requestManager, e);
      });
    }
    unlockAccount(e, n, r) {
      return Ri(this, void 0, void 0, function* () {
        return oF(this.requestManager, e, n, r);
      });
    }
    lockAccount(e) {
      return Ri(this, void 0, void 0, function* () {
        return aF(this.requestManager, e);
      });
    }
    importRawKey(e, n) {
      return Ri(this, void 0, void 0, function* () {
        return cF(this.requestManager, e, n);
      });
    }
    sendTransaction(e, n) {
      return Ri(this, void 0, void 0, function* () {
        return lF(this.requestManager, e, n, this.config);
      });
    }
    signTransaction(e, n) {
      return Ri(this, void 0, void 0, function* () {
        return uF(this.requestManager, e, n, this.config);
      });
    }
    sign(e, n, r) {
      return Ri(this, void 0, void 0, function* () {
        return dF(this.requestManager, e, n, r);
      });
    }
    ecRecover(e, n) {
      return Ri(this, void 0, void 0, function* () {
        return fF(this.requestManager, e, n);
      });
    }
  }
  var Xr;
  (function (t) {
    ((t.HTTPS = 'https'), (t.WebSocket = 'wss'));
  })(Xr || (Xr = {}));
  var we;
  (function (t) {
    ((t.ETH_MAINNET = 'eth_mainnet'),
      (t.ETH_SEPOLIA = 'eth_sepolia'),
      (t.ETH_HOLESKY = 'eth_holesky'),
      (t.POLYGON_MAINNET = 'polygon_mainnet'),
      (t.POLYGON_AMOY = 'polygon_amoy'),
      (t.AVALANCHE_C_MAINNET = 'avalanche_c_mainnet'),
      (t.AVALANCHE_P_MAINNET = 'avalanche_p_mainnet'),
      (t.AVALANCHE_X_MAINNET = 'avalanche_x_mainnet'),
      (t.ARBITRUM_MAINNET = 'arbitrum_mainnet'),
      (t.ARBITRUM_SEPOLIA = 'arbitrum_sepolia'),
      (t.BASE_MAINNET = 'base_mainnet'),
      (t.BASE_SEPOLIA = 'base_sepolia'),
      (t.OPTIMISM_MAINNET = 'optimism_mainnet'),
      (t.OPTIMISM_SEPOLIA = 'optimism_sepolia'),
      (t.FANTOM_MAINNET = 'fantom_mainnet'),
      (t.FANTOM_TESTNET = 'fantom_testnet'),
      (t.DYMENSION_MAINNET = 'dymension_mainnet'),
      (t.DYMENSION_TESTNET = 'dymension_testnet'),
      (t.BNB_MAINNET = 'bnb_mainnet'),
      (t.BNB_TESTNET = 'bnb_testnet'),
      (t.BSC_MAINNET = 'bsc_mainnet'),
      (t.BSC_TESTNET = 'bsc_testnet'),
      (t.ARBITRUM_ONE = 'arbitrum_one'),
      (t.ARBITRUM_NOVA = 'arbitrum_nova'),
      (t.AVALANCHE_FUJI_C = 'avalanche_fuji_c'),
      (t.AVALANCHE_FUJI_P = 'avalanche_fuji_p'),
      (t.AVALANCHE_FUJI_X = 'avalanche_fuji_x'),
      (t.BLAST_MAINNET = 'blast_mainnet'),
      (t.OPBNB_MAINNET = 'opbnb_mainnet'),
      (t.OPBNB_TESTNET = 'opbnb_testnet'),
      (t.GNOSIS_MAINNET = 'gnosis_mainnet'),
      (t.GNOSIS_CHIADO = 'gnosis_chiado'),
      (t.PULSECHAIN_MAINNET = 'pulsechain_mainnet'),
      (t.PULSECHAIN_TESTNET = 'pulsechain_testnet'),
      (t.KAVA_MAINNET = 'kava_mainnet'),
      (t.CRONOS_MAINNET = 'cronos_mainnet'),
      (t.MANTLE_MAINNET = 'mantle_mainnet'),
      (t.CHILIZ_MAINNET = 'chiliz_mainnet'),
      (t.CHILIZ_SPICY = 'chiliz_spicy'),
      (t.MOONBEAM_MAINNET = 'moonbeam_mainnet'),
      (t.TAIKO_MAINNET = 'taiko_mainnet'),
      (t.TAIKO_HEKLA = 'taiko_hekla'),
      (t.LINEA_MAINNET = 'linea_mainnet'),
      (t.LINEA_SEPOLIA = 'linea_sepolia'),
      (t.BAHAMUT_MAINNET = 'bahamut_mainnet'),
      (t.SCROLL_MAINNET = 'scroll_mainnet'),
      (t.SCROLL_SEPOLIA = 'scroll_sepolia'),
      (t.TRON_MAINNET = 'tron_mainnet'),
      (t.SYSCOIN_MAINNET = 'syscoin_mainnet'),
      (t.SYSCOIN_TANENBAUM = 'syscoin_tanenbaum'),
      (t.MOONRIVER_MAINNET = 'moonriver_mainnet'),
      (t.HAQQ_MAINNET = 'haqq_mainnet'),
      (t.EVMOS_MAINNET = 'evmos_mainnet'),
      (t.EVMOS_TESTNET = 'evmos_testnet'),
      (t.BERACHAIN_TESTNET = 'berachain_testnet'));
  })(we || (we = {}));
  const hF = 1300;
  class pF extends Ne {
    constructor(e) {
      (super(
        "You've reach the rate limit of free RPC calls from our Partner Quick Nodes. There are two options you can either create a paid Quick Nodes account and get 20% off for 2 months using WEB3JS referral code, or use Free public RPC endpoint.",
        e
      ),
        (this.code = hF));
    }
  }
  const mF = 1301;
  class $w extends Ne {
    constructor(e) {
      (super(`Invalid provider config options given for ${e}`),
        (this.code = mF));
    }
  }
  var gF = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  class $x extends ov {
    constructor(e, n, r, i, s) {
      if (
        (super(), s !== void 0 && n === Xr.HTTPS && !('providerOptions' in s))
      )
        throw new $w('HTTP Provider');
      if (
        s !== void 0 &&
        n === Xr.WebSocket &&
        !('socketOptions' in s || 'reconnectOptions' in s)
      )
        throw new $w('Websocket Provider');
      ((this.transport = n),
        n === Xr.HTTPS
          ? (this.provider = new Ap(this.getRPCURL(e, n, r, i), s))
          : n === Xr.WebSocket &&
            (this.provider = new Q3(
              this.getRPCURL(e, n, r, i),
              s == null ? void 0 : s.socketOptions,
              s == null ? void 0 : s.reconnectOptions
            )));
    }
    request(e, n) {
      return gF(this, void 0, void 0, function* () {
        return this.transport === Xr.HTTPS
          ? yield this.provider.request(e, n)
          : this.provider.request(e);
      });
    }
    getStatus() {
      return this.provider.getStatus();
    }
    supportsSubscriptions() {
      return this.provider.supportsSubscriptions();
    }
    once(e, n) {
      var r;
      !((r = this.provider) === null || r === void 0) &&
        r.once &&
        this.provider.once(e, n);
    }
    removeAllListeners(e) {
      var n;
      !((n = this.provider) === null || n === void 0) &&
        n.removeAllListeners &&
        this.provider.removeAllListeners(e);
    }
    connect() {
      var e;
      !((e = this.provider) === null || e === void 0) &&
        e.connect &&
        this.provider.connect();
    }
    disconnect(e, n) {
      var r;
      !((r = this.provider) === null || r === void 0) &&
        r.disconnect &&
        this.provider.disconnect(e, n);
    }
    reset() {
      var e;
      !((e = this.provider) === null || e === void 0) &&
        e.reset &&
        this.provider.reset();
    }
    on(e, n) {
      this.provider && this.provider.on(e, n);
    }
    removeListener(e, n) {
      this.provider && this.provider.removeListener(e, n);
    }
  }
  var yF = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  const Ht = (t) => t !== void 0 && t.trim().length > 0;
  class vF extends $x {
    constructor(e = we.ETH_MAINNET, n = Xr.HTTPS, r = '', i = '', s) {
      super(e, n, r, i, s);
    }
    request(e, n) {
      const r = Object.create(null, {request: {get: () => super.request}});
      return yF(this, void 0, void 0, function* () {
        try {
          return yield r.request.call(this, e, n);
        } catch (i) {
          throw i instanceof Qr && i.statusCode === 429 ? new pF(i) : i;
        }
      });
    }
    getRPCURL(e, n, r, i) {
      let s = '',
        o = '';
      switch (e) {
        case we.ETH_MAINNET:
          ((s = Ht(i) ? i : 'powerful-holy-bush.quiknode.pro'),
            (o = Ht(r) ? r : '3240624a343867035925ff7561eb60dfdba2a668'));
          break;
        case we.ETH_SEPOLIA:
          ((s = Ht(i)
            ? i
            : 'dimensional-fabled-glitter.ethereum-sepolia.quiknode.pro'),
            (o = Ht(r) ? r : '382a3b5a4b938f2d6e8686c19af4b22921fde2cd'));
          break;
        case we.ETH_HOLESKY:
          ((s = Ht(i) ? i : 'yolo-morning-card.ethereum-holesky.quiknode.pro'),
            (o = Ht(r) ? r : '481ebe70638c4dcf176af617a16d02ab866b9af9'));
          break;
        case we.ARBITRUM_MAINNET:
          ((s = Ht(i)
            ? i
            : 'autumn-divine-dinghy.arbitrum-mainnet.quiknode.pro'),
            (o = Ht(r) ? r : 'a5d7bfbf60b5ae9ce3628e53d69ef50d529e9a8c'));
          break;
        case we.ARBITRUM_SEPOLIA:
          ((s = Ht(i) ? i : 'few-patient-pond.arbitrum-sepolia.quiknode.pro'),
            (o = Ht(r) ? r : '3be985450970628c860b959c65cd2642dcafe53c'));
          break;
        case we.BNB_MAINNET:
          ((s = Ht(i) ? i : 'purple-empty-reel.bsc.quiknode.pro'),
            (o = Ht(r) ? r : 'ebf6c532961e21f092ff2facce1ec4c89c540158'));
          break;
        case we.BNB_TESTNET:
          ((s = Ht(i) ? i : 'floral-rough-scion.bsc-testnet.quiknode.pro'),
            (o = Ht(r) ? r : '5b297e5acff5f81f4c37ebf6f235f7299b6f9d28'));
          break;
        case we.POLYGON_MAINNET:
          ((s = Ht(i) ? i : 'small-chaotic-moon.matic.quiknode.pro'),
            (o = Ht(r) ? r : '847569f8a017e84d985e10d0f44365d965a951f1'));
          break;
        case we.POLYGON_AMOY:
          ((s = Ht(i) ? i : 'prettiest-side-shape.matic-amoy.quiknode.pro'),
            (o = Ht(r) ? r : '79a9476eea661d4f82de614db1d8a895b14b881c'));
          break;
        default:
          throw new Error('Network info not avalible.');
      }
      return `${n}://${s}/${o}`;
    }
  }
  const bF = (t) => t !== void 0 && t.trim().length > 0,
    wF = [
      we.DYMENSION_MAINNET,
      we.DYMENSION_TESTNET,
      we.KAVA_MAINNET,
      we.CRONOS_MAINNET,
      we.POLYGON_MAINNET
    ];
  class bh extends $x {
    constructor(e = we.ETH_MAINNET, n = Xr.HTTPS, r = '', i) {
      super(e, n, '', r, i);
    }
    getRPCURL(e, n, r, i) {
      if (!bh.networkHostMap[e]) throw new Error('Network info not avalible.');
      const s = `${bh.networkHostMap[e]}.publicnode.com`,
        o = bF(i) ? i : s;
      return wF.includes(e) && n === Xr.WebSocket
        ? `${n}://${o}/websocket`
        : `${n}://${o}`;
    }
  }
  bh.networkHostMap = {
    [we.POLYGON_AMOY]: 'polygon-amoy-bor-rpc',
    [we.DYMENSION_MAINNET]: 'dymension-evm-rpc',
    [we.DYMENSION_TESTNET]: 'dymension-testnet-evm-rpc',
    [we.BLAST_MAINNET]: 'blast-rpc',
    [we.GNOSIS_MAINNET]: 'gnosis-rpc',
    [we.PULSECHAIN_MAINNET]: 'pulsechain-rpc',
    [we.PULSECHAIN_TESTNET]: 'pulsechain-testnet-rpc',
    [we.KAVA_MAINNET]: 'kava-evm-rpc',
    [we.CRONOS_MAINNET]: 'cronos-evm-rpc',
    [we.MANTLE_MAINNET]: 'mantle-rpc',
    [we.TAIKO_MAINNET]: 'taiko-rpc',
    [we.TAIKO_HEKLA]: 'taiko-hekla-rpc',
    [we.LINEA_MAINNET]: 'linea-rpc',
    [we.LINEA_SEPOLIA]: 'linea-sepolia-rpc',
    [we.SCROLL_MAINNET]: 'scroll-rpc',
    [we.SCROLL_SEPOLIA]: 'scroll-sepolia-rpc',
    [we.SYSCOIN_MAINNET]: 'syscoin-evm-rpc',
    [we.SYSCOIN_TANENBAUM]: 'syscoin-tanenbaum-evm-rpc',
    [we.HAQQ_MAINNET]: 'haqq-evm-rpc',
    [we.EVMOS_MAINNET]: 'evmos-evm-rpc',
    [we.EVMOS_TESTNET]: 'evmos-testnet-evm-rpc',
    [we.BERACHAIN_TESTNET]: 'berachain-testnet-evm-rpc',
    [we.ETH_MAINNET]: 'ethereum-rpc',
    [we.ETH_SEPOLIA]: 'ethereum-sepolia-rpc',
    [we.ETH_HOLESKY]: 'ethereum-holesky-rpc',
    [we.BSC_MAINNET]: 'bsc-rpc',
    [we.BSC_TESTNET]: 'bsc-testnet-rpc',
    [we.POLYGON_MAINNET]: 'polygon-bor-rpc',
    [we.BASE_MAINNET]: 'base-rpc',
    [we.BASE_SEPOLIA]: 'base-sepolia-rpc',
    [we.ARBITRUM_ONE]: 'arbitrum-one-rpc',
    [we.ARBITRUM_NOVA]: 'arbitrum-nova-rpc',
    [we.ARBITRUM_SEPOLIA]: 'arbitrum-sepolia-rpc',
    [we.AVALANCHE_C_MAINNET]: 'avalanche-c-chain-rpc',
    [we.AVALANCHE_P_MAINNET]: 'avalanche-p-chain-rpc',
    [we.AVALANCHE_X_MAINNET]: 'avalanche-x-chain-rpc',
    [we.AVALANCHE_FUJI_C]: 'avalanche-fuji-c-chain-rpc',
    [we.AVALANCHE_FUJI_P]: 'avalanche-fuji-p-chain-rpc',
    [we.AVALANCHE_FUJI_X]: 'avalanche-fuji-x-chain-rpc',
    [we.OPTIMISM_MAINNET]: 'optimism-rpc',
    [we.OPTIMISM_SEPOLIA]: 'optimism-sepolia-rpc',
    [we.FANTOM_MAINNET]: 'fantom-rpc',
    [we.FANTOM_TESTNET]: 'fantom-testnet-rpc',
    [we.OPBNB_MAINNET]: 'opbnb-rpc',
    [we.OPBNB_TESTNET]: 'opbnb-testnet-rpc',
    [we.GNOSIS_CHIADO]: 'gnosis-chiado-rpc',
    [we.CHILIZ_MAINNET]: 'chiliz-rpc',
    [we.CHILIZ_SPICY]: 'chiliz-spicy-rpc',
    [we.MOONBEAM_MAINNET]: 'moonbeam-rpc',
    [we.BAHAMUT_MAINNET]: 'bahamut-rpc',
    [we.TRON_MAINNET]: 'tron-evm-rpc',
    [we.MOONRIVER_MAINNET]: 'moonriver-rpc'
  };
  const _F = new vF(),
    EF = {
      encodeEventSignature: Tv,
      encodeFunctionCall: wB,
      encodeFunctionSignature: iu,
      encodeParameter: gg,
      encodeParameters: Pp,
      decodeParameter: sx,
      decodeParameters: Ho,
      decodeLog: ox
    };
  var Gc = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  const AF = (t) => {
      const e = (o, a) =>
          Gc(void 0, void 0, void 0, function* () {
            const c = yield aD(o, t),
              l = ge({format: 'bytes'}, a, Be);
            return sN(c, l);
          }),
        n = (o) => {
          const a = bv(o);
          return Object.assign(Object.assign({}, a), {
            signTransaction: (c) =>
              Gc(void 0, void 0, void 0, function* () {
                return e(c, a.privateKey);
              })
          });
        },
        r = (o, a, c) =>
          Gc(void 0, void 0, void 0, function* () {
            var l;
            const u = yield lN(
              o,
              a,
              (l = c == null ? void 0 : c.nonStrict) !== null && l !== void 0
                ? l
                : !0
            );
            return Object.assign(Object.assign({}, u), {
              signTransaction: (d) =>
                Gc(void 0, void 0, void 0, function* () {
                  return e(d, u.privateKey);
                })
            });
          }),
        i = () => {
          const o = cN();
          return Object.assign(Object.assign({}, o), {
            signTransaction: (a) =>
              Gc(void 0, void 0, void 0, function* () {
                return e(a, o.privateKey);
              })
          });
        },
        s = new sh({create: i, privateKeyToAccount: n, decrypt: r});
      return {
        signTransaction: e,
        create: i,
        privateKeyToAccount: n,
        decrypt: r,
        recoverTransaction: oN,
        hashMessage: vv,
        sign: SS,
        recover: ag,
        encrypt: xS,
        wallet: s,
        privateKeyToAddress: Tp,
        parseAndValidatePrivateKey: Pc,
        privateKeyToPublicKey: aN
      };
    },
    SF = {version: '4.16.0'};
  var xF = function (t, e, n, r) {
      function i(s) {
        return s instanceof n
          ? s
          : new n(function (o) {
              o(s);
            });
      }
      return new (n || (n = Promise))(function (s, o) {
        function a(u) {
          try {
            l(r.next(u));
          } catch (d) {
            o(d);
          }
        }
        function c(u) {
          try {
            l(r.throw(u));
          } catch (d) {
            o(d);
          }
        }
        function l(u) {
          u.done ? s(u.value) : i(u.value).then(a, c);
        }
        l((r = r.apply(t, e || [])).next());
      });
    },
    wh;
  (function (t) {
    ((t.eip6963announceProvider = 'eip6963:announceProvider'),
      (t.eip6963requestProvider = 'eip6963:requestProvider'));
  })(wh || (wh = {}));
  const Rm = new Map(),
    Hx = 'web3:providersMapUpdated',
    CF = () =>
      xF(void 0, void 0, void 0, function* () {
        return new Promise((t, e) => {
          (typeof window > 'u' &&
            e(
              new Error(
                'window object not available, EIP-6963 is intended to be used within a browser'
              )
            ),
            window.addEventListener(wh.eip6963announceProvider, (n) => {
              Rm.set(n.detail.info.uuid, n.detail);
              const r = new CustomEvent(Hx, {detail: Rm});
              (window.dispatchEvent(r), t(Rm));
            }),
            window.dispatchEvent(new Event(wh.eip6963requestProvider)));
        });
      }),
    TF = (t) => {
      if (typeof window > 'u')
        throw new Error(
          'window object not available, EIP-6963 is intended to be used within a browser'
        );
      window.addEventListener(Hx, t);
    };
  class Lc extends Un {
    constructor(e = _F) {
      var n;
      (Re(e) ||
        (typeof e == 'string' && e.trim() === '') ||
        (typeof e != 'string' && !rh(e) && !e.provider)) &&
        console.warn(
          'NOTE: web3.js is running without provider. You need to pass a provider in order to interact with the network!'
        );
      let r = {};
      (typeof e == 'string' || rh(e)
        ? (r.provider = e)
        : e
          ? (r = e)
          : (r = {}),
        (r.registeredSubscriptions = Object.assign(
          Object.assign({}, vg),
          (n = r.registeredSubscriptions) !== null && n !== void 0 ? n : {}
        )),
        super(r));
      const i = AF(this);
      ((this._wallet = i.wallet),
        (this._accountProvider = i),
        (this.utils = Y3));
      const s = this;
      class o extends jo {
        constructor(l, u, d, f, h) {
          if (Fs(u) && Fs(d))
            throw new Pb(
              'Should not provide options at both 2nd and 3rd parameters'
            );
          let g,
            m = {},
            y,
            p;
          if (!Re(u) && typeof u != 'object' && typeof u != 'string')
            throw new Pb();
          if (
            (typeof u == 'string' && (g = u),
            Fs(u) ? (m = u) : Fs(d) ? (m = d) : (m = {}),
            u instanceof Un
              ? (y = u)
              : d instanceof Un
                ? (y = d)
                : f instanceof Un
                  ? (y = f)
                  : (y = s.getContextObject()),
            h ? (p = h) : Di(d) ? (p = d) : Di(f) && (p = f),
            super(l, g, m, y, p),
            super.subscribeToContextEvents(s),
            !Re(a))
          ) {
            const b = a.getTransactionMiddleware();
            Re(b) || super.setTransactionMiddleware(b);
          }
        }
      }
      const a = s.use(Mp);
      this.eth = Object.assign(a, {
        ens: s.use(Dx, hh.main),
        Iban: Ot,
        net: s.use(OS),
        personal: s.use(Fx),
        Contract: o,
        abi: EF,
        accounts: i
      });
    }
  }
  Lc.version = SF.version;
  Lc.utils = Y3;
  Lc.requestEIP6963Providers = CF;
  Lc.onNewProviderDiscovered = TF;
  Lc.modules = {Web3Eth: Mp, Iban: Ot, Net: OS, ENS: Dx, Personal: Fx};
  const $u = {
      TOP_LEFT: 'top-left',
      TOP_RIGHT: 'top-right',
      TOP_CENTER: 'top-center',
      BOTTOM_LEFT: 'bottom-left',
      BOTTOM_RIGHT: 'bottom-right',
      BOTTOM_CENTER: 'bottom-center'
    },
    Ec = {LIGHT: 'light', DARK: 'dark', COLORED: 'colored', AUTO: 'auto'},
    On = {
      INFO: 'info',
      SUCCESS: 'success',
      WARNING: 'warning',
      ERROR: 'error',
      DEFAULT: 'default'
    },
    IF = {
      BOUNCE: 'bounce',
      SLIDE: 'slide',
      FLIP: 'flip',
      ZOOM: 'zoom',
      NONE: 'none'
    },
    kF = {
      dangerouslyHTMLString: !1,
      multiple: !0,
      position: $u.TOP_RIGHT,
      autoClose: 5e3,
      transition: 'bounce',
      hideProgressBar: !1,
      pauseOnHover: !0,
      pauseOnFocusLoss: !0,
      closeOnClick: !0,
      className: '',
      bodyClassName: '',
      style: {},
      progressClassName: '',
      progressStyle: {},
      role: 'alert',
      theme: 'light'
    },
    RF = {rtl: !1, newestOnTop: !1, toastClassName: ''},
    jx = {...kF, ...RF};
  On.DEFAULT;
  var dt = ((t) => (
      (t[(t.COLLAPSE_DURATION = 300)] = 'COLLAPSE_DURATION'),
      (t[(t.DEBOUNCE_DURATION = 50)] = 'DEBOUNCE_DURATION'),
      (t.CSS_NAMESPACE = 'Toastify'),
      t
    ))(dt || {}),
    xg = ((t) => ((t.ENTRANCE_ANIMATION_END = 'd'), t))(xg || {});
  const PF = {
      enter: 'Toastify--animate Toastify__bounce-enter',
      exit: 'Toastify--animate Toastify__bounce-exit',
      appendPosition: !0
    },
    MF = {
      enter: 'Toastify--animate Toastify__slide-enter',
      exit: 'Toastify--animate Toastify__slide-exit',
      appendPosition: !0
    },
    OF = {
      enter: 'Toastify--animate Toastify__zoom-enter',
      exit: 'Toastify--animate Toastify__zoom-exit'
    },
    NF = {
      enter: 'Toastify--animate Toastify__flip-enter',
      exit: 'Toastify--animate Toastify__flip-exit'
    },
    Hw = 'Toastify--animate Toastify__none-enter';
  function Ux(t, e = !1) {
    var n;
    let r = PF;
    if (!t || typeof t == 'string')
      switch (t) {
        case 'flip':
          r = NF;
          break;
        case 'zoom':
          r = OF;
          break;
        case 'slide':
          r = MF;
          break;
      }
    else r = t;
    if (e) r.enter = Hw;
    else if (r.enter === Hw) {
      const i = (n = r.exit.split('__')[1]) == null ? void 0 : n.split('-')[0];
      r.enter = `Toastify--animate Toastify__${i}-enter`;
    }
    return r;
  }
  function LF(t) {
    return t.containerId || String(t.position);
  }
  const Lp = 'will-unmount';
  function BF(t = $u.TOP_RIGHT) {
    return !!document.querySelector(
      `.${dt.CSS_NAMESPACE}__toast-container--${t}`
    );
  }
  function DF(t = $u.TOP_RIGHT) {
    return `${dt.CSS_NAMESPACE}__toast-container--${t}`;
  }
  function FF(t, e, n = !1) {
    const r = [
      `${dt.CSS_NAMESPACE}__toast-container`,
      `${dt.CSS_NAMESPACE}__toast-container--${t}`,
      n ? `${dt.CSS_NAMESPACE}__toast-container--rtl` : null
    ]
      .filter(Boolean)
      .join(' ');
    return Ya(e)
      ? e({position: t, rtl: n, defaultClassName: r})
      : `${r} ${e || ''}`;
  }
  function $F(t) {
    var e;
    const {position: n, containerClassName: r, rtl: i = !1, style: s = {}} = t,
      o = dt.CSS_NAMESPACE,
      a = DF(n),
      c = document.querySelector(`.${o}`),
      l = document.querySelector(`.${a}`),
      u = !!l && !((e = l.className) != null && e.includes(Lp)),
      d = c || document.createElement('div'),
      f = document.createElement('div');
    ((f.className = FF(n, r, i)),
      (f.dataset.testid = `${dt.CSS_NAMESPACE}__toast-container--${n}`),
      (f.id = LF(t)));
    for (const h in s)
      if (Object.prototype.hasOwnProperty.call(s, h)) {
        const g = s[h];
        f.style[h] = g;
      }
    return (
      c || ((d.className = dt.CSS_NAMESPACE), document.body.appendChild(d)),
      u || d.appendChild(f),
      f
    );
  }
  function Cg(t) {
    var e, n, r;
    const i =
        typeof t == 'string'
          ? t
          : ((e = t.currentTarget) == null ? void 0 : e.id) ||
            ((n = t.target) == null ? void 0 : n.id),
      s = document.getElementById(i);
    s && s.removeEventListener('animationend', Cg, !1);
    try {
      (uu[i].unmount(),
        (r = document.getElementById(i)) == null || r.remove(),
        delete uu[i],
        delete Yt[i]);
    } catch {}
  }
  const uu = Ar({});
  function HF(t, e) {
    const n = document.getElementById(String(e));
    n && (uu[n.id] = t);
  }
  function Tg(t, e = !0) {
    const n = String(t);
    if (!uu[n]) return;
    const r = document.getElementById(n);
    (r && r.classList.add(Lp),
      e ? (UF(t), r && r.addEventListener('animationend', Cg, !1)) : Cg(n),
      (vi.items = vi.items.filter((i) => i.containerId !== t)));
  }
  function jF(t) {
    for (const e in uu) Tg(e, t);
    vi.items = [];
  }
  function Kx(t, e) {
    const n = document.getElementById(t.toastId);
    if (n) {
      let r = t;
      r = {...r, ...Ux(r.transition)};
      const i = r.appendPosition ? `${r.exit}--${r.position}` : r.exit;
      ((n.className += ` ${i}`), e && e(n));
    }
  }
  function UF(t) {
    for (const e in Yt) if (e === t) for (const n of Yt[e] || []) Kx(n);
  }
  function KF(t) {
    const e = Ac().find((n) => n.toastId === t);
    return e == null ? void 0 : e.containerId;
  }
  function $v(t) {
    return document.getElementById(t);
  }
  function qF(t) {
    const e = $v(t.containerId);
    return e && e.classList.contains(Lp);
  }
  function jw(t) {
    var e;
    const n = Ko(t.content) ? He(t.content.props) : null;
    return n ?? He((e = t.data) != null ? e : {});
  }
  function VF(t) {
    return t
      ? vi.items.filter((e) => e.containerId === t).length > 0
      : vi.items.length > 0;
  }
  function GF() {
    if (vi.items.length > 0) {
      const t = vi.items.shift();
      Gd(
        t == null ? void 0 : t.toastContent,
        t == null ? void 0 : t.toastProps
      );
    }
  }
  const Yt = Ar({}),
    vi = Ar({items: []});
  function Ac() {
    const t = He(Yt);
    return Object.values(t).reduce((e, n) => [...e, ...n], []);
  }
  function zF(t) {
    return Ac().find((e) => e.toastId === t);
  }
  function Gd(t, e = {}) {
    if (qF(e)) {
      const n = $v(e.containerId);
      n && n.addEventListener('animationend', Ig.bind(null, t, e), !1);
    } else Ig(t, e);
  }
  function Ig(t, e = {}) {
    const n = $v(e.containerId);
    n && n.removeEventListener('animationend', Ig.bind(null, t, e), !1);
    const r = Yt[e.containerId] || [],
      i = r.length > 0;
    if (!i && !BF(e.position)) {
      const s = $F(e),
        o = xA(h$, e);
      (e.useHandler && e.useHandler(o), o.mount(s), HF(o, s.id));
    }
    (i && !e.updateId && (e.position = r[0].position),
      ia(() => {
        e.updateId ? Xn.update(e) : Xn.add(t, e);
      }));
  }
  const Xn = {
      add(t, e) {
        const {containerId: n = ''} = e;
        n &&
          ((Yt[n] = Yt[n] || []),
          Yt[n].find((r) => r.toastId === e.toastId) ||
            setTimeout(() => {
              var r, i;
              (e.newestOnTop
                ? (r = Yt[n]) == null || r.unshift(e)
                : (i = Yt[n]) == null || i.push(e),
                e.onOpen && e.onOpen(jw(e)));
            }, e.delay || 0));
      },
      remove(t) {
        if (t) {
          const e = KF(t);
          if (e) {
            const n = Yt[e];
            let r = n.find((i) => i.toastId === t);
            ((Yt[e] = n.filter((i) => i.toastId !== t)),
              !Yt[e].length && !VF(e) && Tg(e, !1),
              GF(),
              ia(() => {
                r != null && r.onClose && (r.onClose(jw(r)), (r = void 0));
              }));
          }
        }
      },
      update(t = {}) {
        const {containerId: e = ''} = t;
        if (e && t.updateId) {
          Yt[e] = Yt[e] || [];
          const n = Yt[e].find((s) => s.toastId === t.toastId),
            r =
              (n == null ? void 0 : n.position) !== t.position ||
              (n == null ? void 0 : n.transition) !== t.transition,
            i = {...t, disabledEnterTransition: !r, updateId: void 0};
          (Xn.dismissForce(t == null ? void 0 : t.toastId),
            setTimeout(() => {
              $e(i.content, i);
            }, t.delay || 0));
        }
      },
      clear(t, e = !0) {
        t ? Tg(t, e) : jF(e);
      },
      dismissCallback(t) {
        var e;
        const n = (e = t.currentTarget) == null ? void 0 : e.id,
          r = document.getElementById(n);
        r &&
          (r.removeEventListener('animationend', Xn.dismissCallback, !1),
          setTimeout(() => {
            Xn.remove(n);
          }));
      },
      dismiss(t) {
        if (t) {
          const e = Ac();
          for (const n of e)
            if (n.toastId === t) {
              Kx(n, (r) => {
                r.addEventListener('animationend', Xn.dismissCallback, !1);
              });
              break;
            }
        }
      },
      dismissForce(t) {
        if (t) {
          const e = Ac();
          for (const n of e)
            if (n.toastId === t) {
              const r = document.getElementById(t);
              r &&
                (r.remove(),
                r.removeEventListener('animationend', Xn.dismissCallback, !1),
                Xn.remove(t));
              break;
            }
        }
      }
    },
    WF = Ar({useHandler: void 0}),
    qx = Ar({}),
    _h = Ar({});
  function Vx() {
    return Math.random().toString(36).substring(2, 9);
  }
  function ZF(t) {
    return typeof t == 'number' && !isNaN(t);
  }
  function kg(t) {
    return typeof t == 'string';
  }
  function Ya(t) {
    return typeof t == 'function';
  }
  function Bp(...t) {
    return as(...t);
  }
  function zd(t) {
    return (
      typeof t == 'object' &&
      (!!(t != null && t.render) ||
        !!(t != null && t.setup) ||
        typeof (t == null ? void 0 : t.type) == 'object')
    );
  }
  function YF(t = {}) {
    qx[`${dt.CSS_NAMESPACE}-default-options`] = t;
  }
  function QF() {
    return qx[`${dt.CSS_NAMESPACE}-default-options`] || jx;
  }
  function JF() {
    const t =
      window.matchMedia &&
      window.matchMedia('(prefers-color-scheme: dark)').matches;
    return document.documentElement.classList.contains('dark') || t
      ? 'dark'
      : 'light';
  }
  var Wd = ((t) => (
    (t[(t.Enter = 0)] = 'Enter'),
    (t[(t.Exit = 1)] = 'Exit'),
    t
  ))(Wd || {});
  const Gx = {
      containerId: {type: [String, Number], required: !1, default: ''},
      clearOnUrlChange: {type: Boolean, required: !1, default: !0},
      disabledEnterTransition: {type: Boolean, required: !1, default: !1},
      dangerouslyHTMLString: {type: Boolean, required: !1, default: !1},
      multiple: {type: Boolean, required: !1, default: !0},
      limit: {type: Number, required: !1, default: void 0},
      position: {type: String, required: !1, default: $u.TOP_LEFT},
      bodyClassName: {type: String, required: !1, default: ''},
      autoClose: {type: [Number, Boolean], required: !1, default: !1},
      closeButton: {
        type: [Boolean, Function, Object],
        required: !1,
        default: void 0
      },
      transition: {type: [String, Object], required: !1, default: 'bounce'},
      hideProgressBar: {type: Boolean, required: !1, default: !1},
      pauseOnHover: {type: Boolean, required: !1, default: !0},
      pauseOnFocusLoss: {type: Boolean, required: !1, default: !0},
      closeOnClick: {type: Boolean, required: !1, default: !0},
      progress: {type: Number, required: !1, default: void 0},
      progressClassName: {type: String, required: !1, default: ''},
      toastStyle: {
        type: Object,
        required: !1,
        default() {
          return {};
        }
      },
      progressStyle: {
        type: Object,
        required: !1,
        default() {
          return {};
        }
      },
      role: {type: String, required: !1, default: 'alert'},
      theme: {type: String, required: !1, default: Ec.AUTO},
      content: {type: [String, Object, Function], required: !1, default: ''},
      toastId: {type: [String, Number], required: !1, default: ''},
      data: {
        type: [Object, String],
        required: !1,
        default() {
          return {};
        }
      },
      type: {type: String, required: !1, default: On.DEFAULT},
      icon: {
        type: [Boolean, String, Number, Object, Function],
        required: !1,
        default: void 0
      },
      delay: {type: Number, required: !1, default: void 0},
      onOpen: {type: Function, required: !1, default: void 0},
      onClose: {type: Function, required: !1, default: void 0},
      onClick: {type: Function, required: !1, default: void 0},
      isLoading: {type: Boolean, required: !1, default: void 0},
      rtl: {type: Boolean, required: !1, default: !1},
      toastClassName: {type: String, required: !1, default: ''},
      updateId: {type: [String, Number], required: !1, default: ''},
      contentProps: {type: Object, required: !1, default: null},
      expandCustomProps: {type: Boolean, required: !1, default: !1}
    },
    XF = {
      autoClose: {type: [Number, Boolean], required: !0},
      isRunning: {type: Boolean, required: !1, default: void 0},
      type: {type: String, required: !1, default: On.DEFAULT},
      theme: {type: String, required: !1, default: Ec.AUTO},
      hide: {type: Boolean, required: !1, default: void 0},
      className: {type: [String, Function], required: !1, default: ''},
      controlledProgress: {type: Boolean, required: !1, default: void 0},
      rtl: {type: Boolean, required: !1, default: void 0},
      isIn: {type: Boolean, required: !1, default: void 0},
      progress: {type: Number, required: !1, default: void 0},
      closeToast: {type: Function, required: !1, default: void 0}
    },
    e$ = xt({
      name: 'ProgressBar',
      props: XF,
      setup(t, {attrs: e}) {
        const n = Pr(),
          r = ht(() => (t.hide ? 'true' : 'false')),
          i = ht(() => ({
            ...(e.style || {}),
            animationDuration: `${t.autoClose === !0 ? 5e3 : t.autoClose}ms`,
            animationPlayState: t.isRunning ? 'running' : 'paused',
            opacity: t.hide || t.autoClose === !1 ? 0 : 1,
            transform: t.controlledProgress ? `scaleX(${t.progress})` : 'none'
          })),
          s = ht(() =>
            [
              `${dt.CSS_NAMESPACE}__progress-bar`,
              t.controlledProgress
                ? `${dt.CSS_NAMESPACE}__progress-bar--controlled`
                : `${dt.CSS_NAMESPACE}__progress-bar--animated`,
              `${dt.CSS_NAMESPACE}__progress-bar-theme--${t.theme}`,
              `${dt.CSS_NAMESPACE}__progress-bar--${t.type}`,
              t.rtl ? `${dt.CSS_NAMESPACE}__progress-bar--rtl` : null
            ]
              .filter(Boolean)
              .join(' ')
          ),
          o = ht(() => `${s.value} ${(e == null ? void 0 : e.class) || ''}`),
          a = () => {
            n.value &&
              ((n.value.onanimationend = null),
              (n.value.ontransitionend = null));
          },
          c = () => {
            t.isIn &&
              t.closeToast &&
              t.autoClose !== !1 &&
              (t.closeToast(), a());
          },
          l = ht(() => (t.controlledProgress ? null : c)),
          u = ht(() => (t.controlledProgress ? c : null));
        return (
          Od(() => {
            n.value &&
              (a(),
              (n.value.onanimationend = l.value),
              (n.value.ontransitionend = u.value));
          }),
          () =>
            ke(
              'div',
              {
                ref: n,
                role: 'progressbar',
                'aria-hidden': r.value,
                'aria-label': 'notification timer',
                class: o.value,
                style: i.value
              },
              null
            )
        );
      }
    }),
    t$ = xt({
      name: 'CloseButton',
      inheritAttrs: !1,
      props: {
        theme: {type: String, required: !1, default: Ec.AUTO},
        type: {type: String, required: !1, default: Ec.LIGHT},
        ariaLabel: {type: String, required: !1, default: 'close'},
        closeToast: {type: Function, required: !1, default: void 0}
      },
      setup(t) {
        return () =>
          ke(
            'button',
            {
              class: `${dt.CSS_NAMESPACE}__close-button ${dt.CSS_NAMESPACE}__close-button--${t.theme}`,
              type: 'button',
              onClick: (e) => {
                (e.stopPropagation(), t.closeToast && t.closeToast(e));
              },
              'aria-label': t.ariaLabel
            },
            [
              ke('svg', {'aria-hidden': 'true', viewBox: '0 0 14 16'}, [
                ke(
                  'path',
                  {
                    'fill-rule': 'evenodd',
                    d: 'M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z'
                  },
                  null
                )
              ])
            ]
          );
      }
    }),
    Dp = ({theme: t, type: e, path: n, ...r}) =>
      ke(
        'svg',
        as(
          {
            viewBox: '0 0 24 24',
            width: '100%',
            height: '100%',
            fill:
              t === 'colored'
                ? 'currentColor'
                : `var(--toastify-icon-color-${e})`
          },
          r
        ),
        [ke('path', {d: n}, null)]
      );
  function n$(t) {
    return ke(
      Dp,
      as(t, {
        path: 'M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z'
      }),
      null
    );
  }
  function r$(t) {
    return ke(
      Dp,
      as(t, {
        path: 'M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z'
      }),
      null
    );
  }
  function i$(t) {
    return ke(
      Dp,
      as(t, {
        path: 'M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z'
      }),
      null
    );
  }
  function s$(t) {
    return ke(
      Dp,
      as(t, {
        path: 'M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z'
      }),
      null
    );
  }
  function o$() {
    return ke('div', {class: `${dt.CSS_NAMESPACE}__spinner`}, null);
  }
  const Zd = {info: r$, warning: n$, success: i$, error: s$, spinner: o$},
    a$ = (t) => t in Zd;
  function c$({theme: t, type: e, isLoading: n, icon: r}) {
    let i;
    const s = !!n || e === 'loading',
      o = {theme: t, type: e};
    if (s && (r === void 0 || typeof r == 'boolean')) return Zd.spinner();
    if (r !== !1) {
      if (zd(r)) i = He(r);
      else if (Ya(r)) {
        const a = r;
        ((o.type = s ? 'loading' : e),
          (i = a(o)),
          (i = !i && s ? Zd.spinner() : i));
      } else
        Ko(r)
          ? (i = qo(r, o))
          : kg(r) || ZF(r)
            ? (i = r)
            : a$(e) && (i = Zd[e](o));
      return i;
    }
  }
  const l$ = () => {};
  function u$(t, e, n = dt.COLLAPSE_DURATION) {
    const {scrollHeight: r, style: i} = t,
      s = n;
    requestAnimationFrame(() => {
      ((i.minHeight = 'initial'),
        (i.height = r + 'px'),
        (i.transition = `all ${s}ms`),
        requestAnimationFrame(() => {
          ((i.height = '0'),
            (i.padding = '0'),
            (i.margin = '0'),
            setTimeout(e, s));
        }));
    });
  }
  function d$(t) {
    const e = Pr(!1),
      n = Pr(!1),
      r = Pr(!1),
      i = Pr(Wd.Enter),
      s = Ar({
        ...t,
        appendPosition: t.appendPosition || !1,
        collapse: typeof t.collapse > 'u' ? !0 : t.collapse,
        collapseDuration: t.collapseDuration || dt.COLLAPSE_DURATION
      }),
      o = s.done || l$,
      a = ht(() => (s.appendPosition ? `${s.enter}--${s.position}` : s.enter)),
      c = ht(() => (s.appendPosition ? `${s.exit}--${s.position}` : s.exit)),
      l = ht(() => (t.pauseOnHover ? {onMouseenter: y, onMouseleave: m} : {}));
    function u() {
      const b = a.value.split(' ');
      f().addEventListener(xg.ENTRANCE_ANIMATION_END, m, {once: !0});
      const v = (C) => {
          const $ = f();
          C.target === $ &&
            ($.dispatchEvent(new Event(xg.ENTRANCE_ANIMATION_END)),
            $.removeEventListener('animationend', v),
            $.removeEventListener('animationcancel', v),
            i.value === Wd.Enter &&
              C.type !== 'animationcancel' &&
              $.classList.remove(...b));
        },
        x = () => {
          const C = f();
          (C.classList.add(...b),
            C.addEventListener('animationend', v),
            C.addEventListener('animationcancel', v));
        };
      (t.pauseOnFocusLoss && h(), x());
    }
    function d() {
      if (!f()) return;
      const b = () => {
          const x = f();
          (x.removeEventListener('animationend', b),
            s.collapse ? u$(x, o, s.collapseDuration) : o());
        },
        v = () => {
          const x = f();
          ((i.value = Wd.Exit),
            x &&
              ((x.className += ` ${c.value}`),
              x.addEventListener('animationend', b)));
        };
      n.value || (r.value ? b() : setTimeout(v));
    }
    function f() {
      return t.toastRef.value;
    }
    function h() {
      (document.hasFocus() || y(),
        window.addEventListener('focus', m),
        window.addEventListener('blur', y));
    }
    function g() {
      (window.removeEventListener('focus', m),
        window.removeEventListener('blur', y));
    }
    function m() {
      (!t.loading.value || t.isLoading === void 0) && (e.value = !0);
    }
    function y() {
      e.value = !1;
    }
    function p(b) {
      (b && (b.stopPropagation(), b.preventDefault()), (n.value = !1));
    }
    return (
      Od(d),
      Od(() => {
        const b = Ac();
        n.value = b.findIndex((v) => v.toastId === s.toastId) > -1;
      }),
      Od(() => {
        t.isLoading !== void 0 && (t.loading.value ? y() : m());
      }),
      Ic(u),
      rp(() => {
        t.pauseOnFocusLoss && g();
      }),
      {isIn: n, isRunning: e, hideToast: p, eventHandlers: l}
    );
  }
  const f$ = xt({
    name: 'ToastItem',
    inheritAttrs: !1,
    props: Gx,
    setup(t) {
      const e = Pr(),
        n = ht(() => !!t.isLoading),
        r = ht(() => t.progress !== void 0 && t.progress !== null),
        i = ht(() => c$(t)),
        s = ht(() =>
          [
            `${dt.CSS_NAMESPACE}__toast`,
            `${dt.CSS_NAMESPACE}__toast-theme--${t.theme}`,
            `${dt.CSS_NAMESPACE}__toast--${t.type}`,
            t.rtl ? `${dt.CSS_NAMESPACE}__toast--rtl` : void 0,
            t.toastClassName || ''
          ]
            .filter(Boolean)
            .join(' ')
        ),
        {
          isRunning: o,
          isIn: a,
          hideToast: c,
          eventHandlers: l
        } = d$({
          toastRef: e,
          loading: n,
          done: () => {
            Xn.remove(t.toastId);
          },
          ...Ux(t.transition, t.disabledEnterTransition),
          ...t
        });
      return () =>
        ke(
          'div',
          as(
            {
              id: t.toastId,
              class: s.value,
              style: t.toastStyle || {},
              ref: e,
              'data-testid': `toast-item-${t.toastId}`,
              onClick: (u) => {
                (t.closeOnClick && c(), t.onClick && t.onClick(u));
              }
            },
            l.value
          ),
          [
            ke(
              'div',
              {
                role: t.role,
                'data-testid': 'toast-body',
                class: `${dt.CSS_NAMESPACE}__toast-body ${t.bodyClassName || ''}`
              },
              [
                i.value != null &&
                  ke(
                    'div',
                    {
                      'data-testid': `toast-icon-${t.type}`,
                      class: [
                        `${dt.CSS_NAMESPACE}__toast-icon`,
                        t.isLoading
                          ? ''
                          : `${dt.CSS_NAMESPACE}--animate-icon ${dt.CSS_NAMESPACE}__zoom-enter`
                      ].join(' ')
                    },
                    [
                      zd(i.value)
                        ? Ra(He(i.value), {theme: t.theme, type: t.type})
                        : Ya(i.value)
                          ? i.value({theme: t.theme, type: t.type})
                          : i.value
                    ]
                  ),
                ke('div', {'data-testid': 'toast-content'}, [
                  zd(t.content)
                    ? Ra(He(t.content), {
                        toastProps: He(t),
                        closeToast: c,
                        data: t.data,
                        ...(t.expandCustomProps
                          ? t.contentProps
                          : {contentProps: t.contentProps || {}})
                      })
                    : Ya(t.content)
                      ? t.content({
                          toastProps: He(t),
                          closeToast: c,
                          data: t.data
                        })
                      : t.dangerouslyHTMLString
                        ? Ra('div', {innerHTML: t.content})
                        : t.content
                ])
              ]
            ),
            (t.closeButton === void 0 || t.closeButton === !0) &&
              ke(
                t$,
                {
                  theme: t.theme,
                  closeToast: (u) => {
                    (u.stopPropagation(), u.preventDefault(), c());
                  }
                },
                null
              ),
            zd(t.closeButton)
              ? Ra(He(t.closeButton), {
                  closeToast: c,
                  type: t.type,
                  theme: t.theme
                })
              : Ya(t.closeButton)
                ? t.closeButton({closeToast: c, type: t.type, theme: t.theme})
                : null,
            ke(
              e$,
              {
                className: t.progressClassName,
                style: t.progressStyle,
                rtl: t.rtl,
                theme: t.theme,
                isIn: a.value,
                type: t.type,
                hide: t.hideProgressBar,
                isRunning: o.value,
                autoClose: t.autoClose,
                controlledProgress: r.value,
                progress: t.progress,
                closeToast: t.isLoading ? void 0 : c
              },
              null
            )
          ]
        );
    }
  });
  let El = 0;
  function zx() {
    typeof window > 'u' ||
      (El && window.cancelAnimationFrame(El),
      (El = window.requestAnimationFrame(zx)),
      _h.lastUrl !== window.location.href &&
        ((_h.lastUrl = window.location.href), Xn.clear()));
  }
  const h$ = xt({
    name: 'ToastifyContainer',
    inheritAttrs: !1,
    props: Gx,
    setup(t) {
      const e = ht(() => t.containerId),
        n = ht(() => Yt[e.value] || []),
        r = ht(() => n.value.filter((i) => i.position === t.position));
      return (
        Ic(() => {
          typeof window < 'u' &&
            t.clearOnUrlChange &&
            window.requestAnimationFrame(zx);
        }),
        rp(() => {
          typeof window < 'u' &&
            El &&
            (window.cancelAnimationFrame(El), (_h.lastUrl = ''));
        }),
        () =>
          ke(Dt, null, [
            r.value.map((i) => {
              const {toastId: s = ''} = i;
              return ke(f$, as({key: s}, i), null);
            })
          ])
      );
    }
  });
  let Pm = !1;
  const Wx = {
    isLoading: !0,
    autoClose: !1,
    closeOnClick: !1,
    closeButton: !1,
    draggable: !1
  };
  function Zx() {
    const t = [];
    return (
      Ac().forEach((e) => {
        const n = document.getElementById(e.containerId);
        n && !n.classList.contains(Lp) && t.push(e);
      }),
      t
    );
  }
  function p$(t) {
    const e = Zx().length,
      n = t ?? 0;
    return n > 0 && e + vi.items.length >= n;
  }
  function m$(t) {
    p$(t.limit) &&
      !t.updateId &&
      vi.items.push({
        toastId: t.toastId,
        containerId: t.containerId,
        toastContent: t.content,
        toastProps: t
      });
  }
  function uo(t, e, n = {}) {
    if (Pm) return;
    ((n = Bp(QF(), {type: e}, He(n))),
      (!n.toastId ||
        (typeof n.toastId != 'string' && typeof n.toastId != 'number')) &&
        (n.toastId = Vx()),
      (n = {
        ...n,
        ...(n.type === 'loading' ? Wx : {}),
        content: t,
        containerId: n.containerId || String(n.position)
      }));
    const r = Number(n == null ? void 0 : n.progress);
    return (
      !isNaN(r) && r < 0 && (n.progress = 0),
      r > 1 && (n.progress = 1),
      n.theme === 'auto' && (n.theme = JF()),
      m$(n),
      (_h.lastUrl = window.location.href),
      n.multiple
        ? vi.items.length
          ? n.updateId && Gd(t, n)
          : Gd(t, n)
        : ((Pm = !0),
          $e.clearAll(void 0, !1),
          setTimeout(() => {
            Gd(t, n);
          }, 0),
          setTimeout(() => {
            Pm = !1;
          }, 390)),
      n.toastId
    );
  }
  const $e = (t, e) => uo(t, On.DEFAULT, e);
  $e.info = (t, e) => uo(t, On.DEFAULT, {...e, type: On.INFO});
  $e.error = (t, e) => uo(t, On.DEFAULT, {...e, type: On.ERROR});
  $e.warning = (t, e) => uo(t, On.DEFAULT, {...e, type: On.WARNING});
  $e.warn = $e.warning;
  $e.success = (t, e) => uo(t, On.DEFAULT, {...e, type: On.SUCCESS});
  $e.loading = (t, e) => uo(t, On.DEFAULT, Bp(e, Wx));
  $e.dark = (t, e) => uo(t, On.DEFAULT, Bp(e, {theme: Ec.DARK}));
  $e.remove = (t) => {
    t ? Xn.dismiss(t) : Xn.clear();
  };
  $e.clearAll = (t, e) => {
    ia(() => {
      Xn.clear(t, e);
    });
  };
  $e.isActive = (t) => {
    let e = !1;
    return ((e = Zx().findIndex((n) => n.toastId === t) > -1), e);
  };
  $e.update = (t, e = {}) => {
    setTimeout(() => {
      const n = zF(t);
      if (n) {
        const r = He(n),
          {content: i} = r,
          s = {...r, ...e, toastId: e.toastId || t, updateId: Vx()},
          o = s.render || i;
        (delete s.render, uo(o, s.type, s));
      }
    }, 0);
  };
  $e.done = (t) => {
    $e.update(t, {isLoading: !1, progress: 1});
  };
  $e.promise = g$;
  function g$(t, {pending: e, error: n, success: r}, i) {
    var s, o, a;
    let c;
    const l = {...(i || {}), autoClose: !1};
    e && (c = kg(e) ? $e.loading(e, l) : $e.loading(e.render, {...l, ...e}));
    const u = {
        autoClose: (s = i == null ? void 0 : i.autoClose) != null ? s : !0,
        closeOnClick:
          (o = i == null ? void 0 : i.closeOnClick) != null ? o : !0,
        closeButton: (a = i == null ? void 0 : i.autoClose) != null ? a : null,
        isLoading: void 0,
        draggable: null,
        delay: 100
      },
      d = (h, g, m) => {
        if (g == null) {
          $e.remove(c);
          return;
        }
        const y = {type: h, ...u, ...i, data: m},
          p = kg(g) ? {render: g} : g;
        return (
          c
            ? $e.update(c, {...y, ...p, isLoading: !1})
            : $e(p.render, {...y, ...p, isLoading: !1}),
          m
        );
      },
      f = Ya(t) ? t() : t;
    return (
      f
        .then((h) => {
          d('success', r, h);
        })
        .catch((h) => {
          d('error', n, h);
        }),
      f
    );
  }
  $e.POSITION = $u;
  $e.THEME = Ec;
  $e.TYPE = On;
  $e.TRANSITIONS = IF;
  const y$ = {
    install(t, e = {}) {
      ((WF.useHandler = e.useHandler || (() => {})), v$(e));
    }
  };
  typeof window < 'u' && (window.Vue3Toastify = y$);
  function v$(t = {}) {
    const e = Bp(jx, t);
    YF(e);
  }
  var Rg = ((t) => (
    (t[(t.ETHEREUM = 0)] = 'ETHEREUM'),
    (t[(t.GOERLI = 5)] = 'GOERLI'),
    (t[(t.OPTIMISM = 10)] = 'OPTIMISM'),
    (t[(t.BINANCE_SMART_CHAIN = 56)] = 'BINANCE_SMART_CHAIN'),
    (t[(t.BSC = 97)] = 'BSC'),
    (t[(t.POLYGON = 137)] = 'POLYGON'),
    (t[(t.FANTOM_OPERA = 250)] = 'FANTOM_OPERA'),
    (t[(t.MEGA = 6342)] = 'MEGA'),
    (t[(t.ARBITRUM = 42151)] = 'ARBITRUM'),
    t
  ))(Rg || {});
  const nd = {
      1: {
        id: 'ethereum',
        symbol: 'ETH',
        name: 'Ethereum',
        icon: './img/icons/ethereum-eth-logo.png'
      },
      5: {
        id: 'ethereum',
        symbol: 'ETH',
        name: 'Goerli Testnet',
        icon: './img/icons/ethereum-eth-logo.png'
      },
      10: {
        id: 'optimistic-ethereum',
        symbol: 'OP',
        name: 'Optimism',
        icon: './img/icons/optimism-ethereum-op-logo.png'
      },
      56: {
        id: 'binancecoin',
        symbol: 'BNB',
        name: 'Binance Smart Chain',
        icon: './img/icons/binance-coin-bnb-logo.png'
      },
      97: {
        id: 'binancecoin',
        symbol: 'BNB',
        name: 'BSC Testnet',
        icon: './img/icons/binance-coin-bnb-logo.png'
      },
      137: {
        id: 'polygon',
        symbol: 'POL',
        name: 'Polygon',
        icon: './img/icons/polygon-matic-logo.png'
      },
      250: {
        id: 'fantom',
        symbol: 'FTM',
        name: 'Fantom Opera',
        icon: './img/icons/fantom-ftm-logo.png'
      },
      6342: {
        id: 'mega',
        symbol: 'MEGA',
        name: 'Mega Testnet',
        icon: './img/icons/bitcoin-btc-logo.png'
      },
      42151: {
        id: 'arbitrum',
        symbol: 'ARB',
        name: 'Arbitrum One',
        icon: './img/icons/arbitrum-arb-logo.png'
      },
      43114: {
        id: 'avalanche-2',
        symbol: 'AVAX',
        name: 'Avalanche C-Chain',
        icon: './img/icons/avalanche-avax-logo.png'
      },
      59141: {
        id: 'linea',
        symbol: 'ETH',
        name: 'Linea Testnet',
        icon: './img/icons/ethereum-eth-logo.png'
      },
      59144: {
        id: 'linea',
        symbol: 'ETH',
        name: 'Linea Mainnet',
        icon: './img/icons/ethereum-eth-logo.png'
      },
      80001: {
        id: 'polygon',
        symbol: 'POL',
        name: 'Polygon Mumbai',
        icon: './img/icons/polygon-matic-logo.png'
      },
      80002: {
        id: 'polygon',
        symbol: 'POL',
        name: 'Amoy Testnet',
        icon: './img/icons/polygon-matic-logo.png'
      },
      84532: {
        id: 'base',
        symbol: 'ETH',
        name: 'Base Sepolia',
        icon: './img/icons/base-eth-logo.png'
      },
      11155111: {
        id: 'ethereum',
        symbol: 'SepoliaETH',
        name: 'Sepolia Testnet',
        icon: './img/icons/ethereum-eth-logo.png'
      }
    },
    Yd = {
      chainId: '0x89',
      chainName: 'Polygon Mainnet',
      nativeCurrency: {name: 'POL', symbol: 'POL', decimals: 18},
      rpcUrls: ['https://polygon-rpc.com/'],
      blockExplorerUrls: ['https://polygonscan.com/']
    },
    b$ = '0x68eA8A05D52CFe66031383FEA4e3256cFE9ff5Ce',
    rd = '0xc2132d05d31c914a87c6611c10748aeb04b58e8f',
    w$ = 'modulepreload',
    _$ = function (t) {
      return '/naka-web-wallet/' + t;
    },
    Uw = {},
    E$ = function (e, n, r) {
      let i = Promise.resolve();
      if (n && n.length > 0) {
        let o = function (l) {
          return Promise.all(
            l.map((u) =>
              Promise.resolve(u).then(
                (d) => ({status: 'fulfilled', value: d}),
                (d) => ({status: 'rejected', reason: d})
              )
            )
          );
        };
        document.getElementsByTagName('link');
        const a = document.querySelector('meta[property=csp-nonce]'),
          c =
            (a == null ? void 0 : a.nonce) ||
            (a == null ? void 0 : a.getAttribute('nonce'));
        i = o(
          n.map((l) => {
            if (((l = _$(l)), l in Uw)) return;
            Uw[l] = !0;
            const u = l.endsWith('.css'),
              d = u ? '[rel="stylesheet"]' : '';
            if (document.querySelector(`link[href="${l}"]${d}`)) return;
            const f = document.createElement('link');
            if (
              ((f.rel = u ? 'stylesheet' : w$),
              u || (f.as = 'script'),
              (f.crossOrigin = ''),
              (f.href = l),
              c && f.setAttribute('nonce', c),
              document.head.appendChild(f),
              u)
            )
              return new Promise((h, g) => {
                (f.addEventListener('load', h),
                  f.addEventListener('error', () =>
                    g(new Error(`Unable to preload CSS for ${l}`))
                  ));
              });
          })
        );
      }
      function s(o) {
        const a = new Event('vite:preloadError', {cancelable: !0});
        if (((a.payload = o), window.dispatchEvent(a), !a.defaultPrevented))
          throw o;
      }
      return i.then((o) => {
        for (const a of o || []) a.status === 'rejected' && s(a.reason);
        return e().catch(s);
      });
    };
  var id = {exports: {}},
    Mm,
    Kw;
  function A$() {
    if (Kw) return Mm;
    Kw = 1;
    var t = 1e3,
      e = t * 60,
      n = e * 60,
      r = n * 24,
      i = r * 7,
      s = r * 365.25;
    Mm = function (u, d) {
      d = d || {};
      var f = typeof u;
      if (f === 'string' && u.length > 0) return o(u);
      if (f === 'number' && isFinite(u)) return d.long ? c(u) : a(u);
      throw new Error(
        'val is not a non-empty string or a valid number. val=' +
          JSON.stringify(u)
      );
    };
    function o(u) {
      if (((u = String(u)), !(u.length > 100))) {
        var d =
          /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
            u
          );
        if (d) {
          var f = parseFloat(d[1]),
            h = (d[2] || 'ms').toLowerCase();
          switch (h) {
            case 'years':
            case 'year':
            case 'yrs':
            case 'yr':
            case 'y':
              return f * s;
            case 'weeks':
            case 'week':
            case 'w':
              return f * i;
            case 'days':
            case 'day':
            case 'd':
              return f * r;
            case 'hours':
            case 'hour':
            case 'hrs':
            case 'hr':
            case 'h':
              return f * n;
            case 'minutes':
            case 'minute':
            case 'mins':
            case 'min':
            case 'm':
              return f * e;
            case 'seconds':
            case 'second':
            case 'secs':
            case 'sec':
            case 's':
              return f * t;
            case 'milliseconds':
            case 'millisecond':
            case 'msecs':
            case 'msec':
            case 'ms':
              return f;
            default:
              return;
          }
        }
      }
    }
    function a(u) {
      var d = Math.abs(u);
      return d >= r
        ? Math.round(u / r) + 'd'
        : d >= n
          ? Math.round(u / n) + 'h'
          : d >= e
            ? Math.round(u / e) + 'm'
            : d >= t
              ? Math.round(u / t) + 's'
              : u + 'ms';
    }
    function c(u) {
      var d = Math.abs(u);
      return d >= r
        ? l(u, d, r, 'day')
        : d >= n
          ? l(u, d, n, 'hour')
          : d >= e
            ? l(u, d, e, 'minute')
            : d >= t
              ? l(u, d, t, 'second')
              : u + ' ms';
    }
    function l(u, d, f, h) {
      var g = d >= f * 1.5;
      return Math.round(u / f) + ' ' + h + (g ? 's' : '');
    }
    return Mm;
  }
  var Om, qw;
  function S$() {
    if (qw) return Om;
    qw = 1;
    function t(e) {
      ((r.debug = r),
        (r.default = r),
        (r.coerce = l),
        (r.disable = a),
        (r.enable = s),
        (r.enabled = c),
        (r.humanize = A$()),
        (r.destroy = u),
        Object.keys(e).forEach((d) => {
          r[d] = e[d];
        }),
        (r.names = []),
        (r.skips = []),
        (r.formatters = {}));
      function n(d) {
        let f = 0;
        for (let h = 0; h < d.length; h++)
          ((f = (f << 5) - f + d.charCodeAt(h)), (f |= 0));
        return r.colors[Math.abs(f) % r.colors.length];
      }
      r.selectColor = n;
      function r(d) {
        let f,
          h = null,
          g,
          m;
        function y(...p) {
          if (!y.enabled) return;
          const b = y,
            v = Number(new Date()),
            x = v - (f || v);
          ((b.diff = x),
            (b.prev = f),
            (b.curr = v),
            (f = v),
            (p[0] = r.coerce(p[0])),
            typeof p[0] != 'string' && p.unshift('%O'));
          let C = 0;
          ((p[0] = p[0].replace(/%([a-zA-Z%])/g, (G, L) => {
            if (G === '%%') return '%';
            C++;
            const F = r.formatters[L];
            if (typeof F == 'function') {
              const k = p[C];
              ((G = F.call(b, k)), p.splice(C, 1), C--);
            }
            return G;
          })),
            r.formatArgs.call(b, p),
            (b.log || r.log).apply(b, p));
        }
        return (
          (y.namespace = d),
          (y.useColors = r.useColors()),
          (y.color = r.selectColor(d)),
          (y.extend = i),
          (y.destroy = r.destroy),
          Object.defineProperty(y, 'enabled', {
            enumerable: !0,
            configurable: !1,
            get: () =>
              h !== null
                ? h
                : (g !== r.namespaces &&
                    ((g = r.namespaces), (m = r.enabled(d))),
                  m),
            set: (p) => {
              h = p;
            }
          }),
          typeof r.init == 'function' && r.init(y),
          y
        );
      }
      function i(d, f) {
        const h = r(this.namespace + (typeof f > 'u' ? ':' : f) + d);
        return ((h.log = this.log), h);
      }
      function s(d) {
        (r.save(d), (r.namespaces = d), (r.names = []), (r.skips = []));
        const f = (typeof d == 'string' ? d : '')
          .trim()
          .replace(/\s+/g, ',')
          .split(',')
          .filter(Boolean);
        for (const h of f)
          h[0] === '-' ? r.skips.push(h.slice(1)) : r.names.push(h);
      }
      function o(d, f) {
        let h = 0,
          g = 0,
          m = -1,
          y = 0;
        for (; h < d.length; )
          if (g < f.length && (f[g] === d[h] || f[g] === '*'))
            f[g] === '*' ? ((m = g), (y = h), g++) : (h++, g++);
          else if (m !== -1) ((g = m + 1), y++, (h = y));
          else return !1;
        for (; g < f.length && f[g] === '*'; ) g++;
        return g === f.length;
      }
      function a() {
        const d = [...r.names, ...r.skips.map((f) => '-' + f)].join(',');
        return (r.enable(''), d);
      }
      function c(d) {
        for (const f of r.skips) if (o(d, f)) return !1;
        for (const f of r.names) if (o(d, f)) return !0;
        return !1;
      }
      function l(d) {
        return d instanceof Error ? d.stack || d.message : d;
      }
      function u() {
        console.warn(
          'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
        );
      }
      return (r.enable(r.load()), r);
    }
    return ((Om = t), Om);
  }
  var Vw;
  function x$() {
    return (
      Vw ||
        ((Vw = 1),
        (function (t, e) {
          var n = {};
          ((e.formatArgs = i),
            (e.save = s),
            (e.load = o),
            (e.useColors = r),
            (e.storage = a()),
            (e.destroy = (() => {
              let l = !1;
              return () => {
                l ||
                  ((l = !0),
                  console.warn(
                    'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
                  ));
              };
            })()),
            (e.colors = [
              '#0000CC',
              '#0000FF',
              '#0033CC',
              '#0033FF',
              '#0066CC',
              '#0066FF',
              '#0099CC',
              '#0099FF',
              '#00CC00',
              '#00CC33',
              '#00CC66',
              '#00CC99',
              '#00CCCC',
              '#00CCFF',
              '#3300CC',
              '#3300FF',
              '#3333CC',
              '#3333FF',
              '#3366CC',
              '#3366FF',
              '#3399CC',
              '#3399FF',
              '#33CC00',
              '#33CC33',
              '#33CC66',
              '#33CC99',
              '#33CCCC',
              '#33CCFF',
              '#6600CC',
              '#6600FF',
              '#6633CC',
              '#6633FF',
              '#66CC00',
              '#66CC33',
              '#9900CC',
              '#9900FF',
              '#9933CC',
              '#9933FF',
              '#99CC00',
              '#99CC33',
              '#CC0000',
              '#CC0033',
              '#CC0066',
              '#CC0099',
              '#CC00CC',
              '#CC00FF',
              '#CC3300',
              '#CC3333',
              '#CC3366',
              '#CC3399',
              '#CC33CC',
              '#CC33FF',
              '#CC6600',
              '#CC6633',
              '#CC9900',
              '#CC9933',
              '#CCCC00',
              '#CCCC33',
              '#FF0000',
              '#FF0033',
              '#FF0066',
              '#FF0099',
              '#FF00CC',
              '#FF00FF',
              '#FF3300',
              '#FF3333',
              '#FF3366',
              '#FF3399',
              '#FF33CC',
              '#FF33FF',
              '#FF6600',
              '#FF6633',
              '#FF9900',
              '#FF9933',
              '#FFCC00',
              '#FFCC33'
            ]));
          function r() {
            if (
              typeof window < 'u' &&
              window.process &&
              (window.process.type === 'renderer' || window.process.__nwjs)
            )
              return !0;
            if (
              typeof navigator < 'u' &&
              navigator.userAgent &&
              navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
            )
              return !1;
            let l;
            return (
              (typeof document < 'u' &&
                document.documentElement &&
                document.documentElement.style &&
                document.documentElement.style.WebkitAppearance) ||
              (typeof window < 'u' &&
                window.console &&
                (window.console.firebug ||
                  (window.console.exception && window.console.table))) ||
              (typeof navigator < 'u' &&
                navigator.userAgent &&
                (l = navigator.userAgent
                  .toLowerCase()
                  .match(/firefox\/(\d+)/)) &&
                parseInt(l[1], 10) >= 31) ||
              (typeof navigator < 'u' &&
                navigator.userAgent &&
                navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
            );
          }
          function i(l) {
            if (
              ((l[0] =
                (this.useColors ? '%c' : '') +
                this.namespace +
                (this.useColors ? ' %c' : ' ') +
                l[0] +
                (this.useColors ? '%c ' : ' ') +
                '+' +
                t.exports.humanize(this.diff)),
              !this.useColors)
            )
              return;
            const u = 'color: ' + this.color;
            l.splice(1, 0, u, 'color: inherit');
            let d = 0,
              f = 0;
            (l[0].replace(/%[a-zA-Z%]/g, (h) => {
              h !== '%%' && (d++, h === '%c' && (f = d));
            }),
              l.splice(f, 0, u));
          }
          e.log = console.debug || console.log || (() => {});
          function s(l) {
            try {
              l ? e.storage.setItem('debug', l) : e.storage.removeItem('debug');
            } catch {}
          }
          function o() {
            let l;
            try {
              l = e.storage.getItem('debug') || e.storage.getItem('DEBUG');
            } catch {}
            return (
              !l && typeof process < 'u' && 'env' in process && (l = n.DEBUG),
              l
            );
          }
          function a() {
            try {
              return localStorage;
            } catch {}
          }
          t.exports = S$()(e);
          const {formatters: c} = t.exports;
          c.j = function (l) {
            try {
              return JSON.stringify(l);
            } catch (u) {
              return '[UnexpectedJSONParseError]: ' + u.message;
            }
          };
        })(id, id.exports)),
      id.exports
    );
  }
  var C$ = x$();
  const Cn = Ou(C$);
  var Nm, Gw;
  function T$() {
    if (Gw) return Nm;
    Gw = 1;
    var t = Object.defineProperty,
      e = Object.getOwnPropertyDescriptor,
      n = Object.getOwnPropertyNames,
      r = Object.prototype.hasOwnProperty,
      i = (F, k) => {
        for (var V in k) t(F, V, {get: k[V], enumerable: !0});
      },
      s = (F, k, V, K) => {
        if ((k && typeof k == 'object') || typeof k == 'function')
          for (let B of n(k))
            !r.call(F, B) &&
              B !== V &&
              t(F, B, {
                get: () => k[B],
                enumerable: !(K = e(k, B)) || K.enumerable
              });
        return F;
      },
      o = (F) => s(t({}, '__esModule', {value: !0}), F),
      a = {};
    (i(a, {
      createFinalURL: () => $,
      createPathBasedClient: () => m,
      createQuerySerializer: () => v,
      default: () => d,
      defaultBodySerializer: () => C,
      defaultPathSerializer: () => x,
      mergeHeaders: () => G,
      randomID: () => u,
      removeTrailingSlash: () => L,
      serializeArrayParam: () => b,
      serializeObjectParam: () => p,
      serializePrimitiveParam: () => y,
      wrapAsPathBasedClient: () => g
    }),
      (Nm = o(a)));
    var c = /\{[^{}]+\}/g,
      l = () => {
        var F, k;
        return (
          typeof process == 'object' &&
          Number.parseInt(
            (k =
              (F = process == null ? void 0 : process.versions) == null
                ? void 0
                : F.node) == null
              ? void 0
              : k.substring(0, 2)
          ) >= 18 &&
          process.versions.undici
        );
      };
    function u() {
      return Math.random().toString(36).slice(2, 11);
    }
    function d(F) {
      let {
        baseUrl: k = '',
        Request: V = globalThis.Request,
        fetch: K = globalThis.fetch,
        querySerializer: B,
        bodySerializer: D,
        headers: E,
        requestInitExt: P = void 0,
        ...U
      } = {...F};
      ((P = l() ? P : void 0), (k = L(k)));
      const w = [];
      async function A(T, R) {
        const {
          baseUrl: _,
          fetch: S = K,
          Request: I = V,
          headers: O,
          params: H = {},
          parseAs: M = 'json',
          querySerializer: q,
          bodySerializer: z = D ?? C,
          body: Z,
          ...X
        } = R || {};
        let N = k;
        _ && (N = L(_) ?? k);
        let j = typeof B == 'function' ? B : v(B);
        q &&
          (j =
            typeof q == 'function'
              ? q
              : v({...(typeof B == 'object' ? B : {}), ...q}));
        const W = Z === void 0 ? void 0 : z(Z, G(E, O, H.header)),
          J = G(
            W === void 0 || W instanceof FormData
              ? {}
              : {'Content-Type': 'application/json'},
            E,
            O,
            H.header
          ),
          Q = {redirect: 'follow', ...U, ...X, body: W, headers: J};
        let Y,
          se,
          ne = new V($(T, {baseUrl: N, params: H, querySerializer: j}), Q),
          oe;
        for (const fe in X) fe in ne || (ne[fe] = X[fe]);
        if (w.length) {
          ((Y = u()),
            (se = Object.freeze({
              baseUrl: N,
              fetch: S,
              parseAs: M,
              querySerializer: j,
              bodySerializer: z
            })));
          for (const fe of w)
            if (
              fe &&
              typeof fe == 'object' &&
              typeof fe.onRequest == 'function'
            ) {
              const le = await fe.onRequest({
                request: ne,
                schemaPath: T,
                params: H,
                options: se,
                id: Y
              });
              if (le)
                if (le instanceof V) ne = le;
                else if (le instanceof Response) {
                  oe = le;
                  break;
                } else
                  throw new Error(
                    'onRequest: must return new Request() or Response() when modifying the request'
                  );
            }
        }
        if (!oe) {
          try {
            oe = await S(ne, P);
          } catch (fe) {
            let le = fe;
            if (w.length)
              for (let ve = w.length - 1; ve >= 0; ve--) {
                const _e = w[ve];
                if (
                  _e &&
                  typeof _e == 'object' &&
                  typeof _e.onError == 'function'
                ) {
                  const Te = await _e.onError({
                    request: ne,
                    error: le,
                    schemaPath: T,
                    params: H,
                    options: se,
                    id: Y
                  });
                  if (Te) {
                    if (Te instanceof Response) {
                      ((le = void 0), (oe = Te));
                      break;
                    }
                    if (Te instanceof Error) {
                      le = Te;
                      continue;
                    }
                    throw new Error(
                      'onError: must return new Response() or instance of Error'
                    );
                  }
                }
              }
            if (le) throw le;
          }
          if (w.length)
            for (let fe = w.length - 1; fe >= 0; fe--) {
              const le = w[fe];
              if (
                le &&
                typeof le == 'object' &&
                typeof le.onResponse == 'function'
              ) {
                const ve = await le.onResponse({
                  request: ne,
                  response: oe,
                  schemaPath: T,
                  params: H,
                  options: se,
                  id: Y
                });
                if (ve) {
                  if (!(ve instanceof Response))
                    throw new Error(
                      'onResponse: must return new Response() when modifying the response'
                    );
                  oe = ve;
                }
              }
            }
        }
        if (
          oe.status === 204 ||
          ne.method === 'HEAD' ||
          oe.headers.get('Content-Length') === '0'
        )
          return oe.ok
            ? {data: void 0, response: oe}
            : {error: void 0, response: oe};
        if (oe.ok)
          return M === 'stream'
            ? {data: oe.body, response: oe}
            : {data: await oe[M](), response: oe};
        let ce = await oe.text();
        try {
          ce = JSON.parse(ce);
        } catch {}
        return {error: ce, response: oe};
      }
      return {
        request(T, R, _) {
          return A(R, {..._, method: T.toUpperCase()});
        },
        GET(T, R) {
          return A(T, {...R, method: 'GET'});
        },
        PUT(T, R) {
          return A(T, {...R, method: 'PUT'});
        },
        POST(T, R) {
          return A(T, {...R, method: 'POST'});
        },
        DELETE(T, R) {
          return A(T, {...R, method: 'DELETE'});
        },
        OPTIONS(T, R) {
          return A(T, {...R, method: 'OPTIONS'});
        },
        HEAD(T, R) {
          return A(T, {...R, method: 'HEAD'});
        },
        PATCH(T, R) {
          return A(T, {...R, method: 'PATCH'});
        },
        TRACE(T, R) {
          return A(T, {...R, method: 'TRACE'});
        },
        use(...T) {
          for (const R of T)
            if (R) {
              if (
                typeof R != 'object' ||
                !('onRequest' in R || 'onResponse' in R || 'onError' in R)
              )
                throw new Error(
                  'Middleware must be an object with one of `onRequest()`, `onResponse() or `onError()`'
                );
              w.push(R);
            }
        },
        eject(...T) {
          for (const R of T) {
            const _ = w.indexOf(R);
            _ !== -1 && w.splice(_, 1);
          }
        }
      };
    }
    var f = class {
        constructor(F, k) {
          Ai(this, 'GET', (F) => this.client.GET(this.url, F));
          Ai(this, 'PUT', (F) => this.client.PUT(this.url, F));
          Ai(this, 'POST', (F) => this.client.POST(this.url, F));
          Ai(this, 'DELETE', (F) => this.client.DELETE(this.url, F));
          Ai(this, 'OPTIONS', (F) => this.client.OPTIONS(this.url, F));
          Ai(this, 'HEAD', (F) => this.client.HEAD(this.url, F));
          Ai(this, 'PATCH', (F) => this.client.PATCH(this.url, F));
          Ai(this, 'TRACE', (F) => this.client.TRACE(this.url, F));
          ((this.client = F), (this.url = k));
        }
      },
      h = class {
        constructor() {
          this.client = null;
        }
        get(F, k) {
          const V = new f(F, k);
          return ((this.client[k] = V), V);
        }
      };
    function g(F) {
      const k = new h(),
        V = new Proxy(F, k);
      function K() {}
      K.prototype = V;
      const B = new K();
      return ((k.client = B), B);
    }
    function m(F) {
      return g(d(F));
    }
    function y(F, k, V) {
      if (k == null) return '';
      if (typeof k == 'object')
        throw new Error(
          'Deeply-nested arrays/objects aren’t supported. Provide your own `querySerializer()` to handle these.'
        );
      return `${F}=${(V == null ? void 0 : V.allowReserved) === !0 ? k : encodeURIComponent(k)}`;
    }
    function p(F, k, V) {
      if (!k || typeof k != 'object') return '';
      const K = [],
        B = {simple: ',', label: '.', matrix: ';'}[V.style] || '&';
      if (V.style !== 'deepObject' && V.explode === !1) {
        for (const P in k)
          K.push(P, V.allowReserved === !0 ? k[P] : encodeURIComponent(k[P]));
        const E = K.join(',');
        switch (V.style) {
          case 'form':
            return `${F}=${E}`;
          case 'label':
            return `.${E}`;
          case 'matrix':
            return `;${F}=${E}`;
          default:
            return E;
        }
      }
      for (const E in k) {
        const P = V.style === 'deepObject' ? `${F}[${E}]` : E;
        K.push(y(P, k[E], V));
      }
      const D = K.join(B);
      return V.style === 'label' || V.style === 'matrix' ? `${B}${D}` : D;
    }
    function b(F, k, V) {
      if (!Array.isArray(k)) return '';
      if (V.explode === !1) {
        const D =
            {form: ',', spaceDelimited: '%20', pipeDelimited: '|'}[V.style] ||
            ',',
          E = (
            V.allowReserved === !0 ? k : k.map((P) => encodeURIComponent(P))
          ).join(D);
        switch (V.style) {
          case 'simple':
            return E;
          case 'label':
            return `.${E}`;
          case 'matrix':
            return `;${F}=${E}`;
          default:
            return `${F}=${E}`;
        }
      }
      const K = {simple: ',', label: '.', matrix: ';'}[V.style] || '&',
        B = [];
      for (const D of k)
        V.style === 'simple' || V.style === 'label'
          ? B.push(V.allowReserved === !0 ? D : encodeURIComponent(D))
          : B.push(y(F, D, V));
      return V.style === 'label' || V.style === 'matrix'
        ? `${K}${B.join(K)}`
        : B.join(K);
    }
    function v(F) {
      return function (V) {
        const K = [];
        if (V && typeof V == 'object')
          for (const B in V) {
            const D = V[B];
            if (D != null) {
              if (Array.isArray(D)) {
                if (D.length === 0) continue;
                K.push(
                  b(B, D, {
                    style: 'form',
                    explode: !0,
                    ...(F == null ? void 0 : F.array),
                    allowReserved: (F == null ? void 0 : F.allowReserved) || !1
                  })
                );
                continue;
              }
              if (typeof D == 'object') {
                K.push(
                  p(B, D, {
                    style: 'deepObject',
                    explode: !0,
                    ...(F == null ? void 0 : F.object),
                    allowReserved: (F == null ? void 0 : F.allowReserved) || !1
                  })
                );
                continue;
              }
              K.push(y(B, D, F));
            }
          }
        return K.join('&');
      };
    }
    function x(F, k) {
      let V = F;
      for (const K of F.match(c) ?? []) {
        let B = K.substring(1, K.length - 1),
          D = !1,
          E = 'simple';
        if (
          (B.endsWith('*') && ((D = !0), (B = B.substring(0, B.length - 1))),
          B.startsWith('.')
            ? ((E = 'label'), (B = B.substring(1)))
            : B.startsWith(';') && ((E = 'matrix'), (B = B.substring(1))),
          !k || k[B] === void 0 || k[B] === null)
        )
          continue;
        const P = k[B];
        if (Array.isArray(P)) {
          V = V.replace(K, b(B, P, {style: E, explode: D}));
          continue;
        }
        if (typeof P == 'object') {
          V = V.replace(K, p(B, P, {style: E, explode: D}));
          continue;
        }
        if (E === 'matrix') {
          V = V.replace(K, `;${y(B, P)}`);
          continue;
        }
        V = V.replace(
          K,
          E === 'label' ? `.${encodeURIComponent(P)}` : encodeURIComponent(P)
        );
      }
      return V;
    }
    function C(F, k) {
      return F instanceof FormData
        ? F
        : k &&
            (k.get instanceof Function
              ? (k.get('Content-Type') ?? k.get('content-type'))
              : (k['Content-Type'] ?? k['content-type'])) ===
              'application/x-www-form-urlencoded'
          ? new URLSearchParams(F).toString()
          : JSON.stringify(F);
    }
    function $(F, k) {
      var B;
      let V = `${k.baseUrl}${F}`;
      (B = k.params) != null && B.path && (V = x(V, k.params.path));
      let K = k.querySerializer(k.params.query ?? {});
      return (
        K.startsWith('?') && (K = K.substring(1)),
        K && (V += `?${K}`),
        V
      );
    }
    function G(...F) {
      const k = new Headers();
      for (const V of F) {
        if (!V || typeof V != 'object') continue;
        const K = V instanceof Headers ? V.entries() : Object.entries(V);
        for (const [B, D] of K)
          if (D === null) k.delete(B);
          else if (Array.isArray(D)) for (const E of D) k.append(B, E);
          else D !== void 0 && k.set(B, D);
      }
      return k;
    }
    function L(F) {
      return F.endsWith('/') ? F.substring(0, F.length - 1) : F;
    }
    return Nm;
  }
  var Lm, zw;
  function I$() {
    if (zw) return Lm;
    zw = 1;
    var t = {},
      e = Object.create,
      n = Object.defineProperty,
      r = Object.getOwnPropertyDescriptor,
      i = Object.getOwnPropertyNames,
      s = Object.getPrototypeOf,
      o = Object.prototype.hasOwnProperty,
      a = ($, G) => {
        for (var L in G) n($, L, {get: G[L], enumerable: !0});
      },
      c = ($, G, L, F) => {
        if ((G && typeof G == 'object') || typeof G == 'function')
          for (let k of i(G))
            !o.call($, k) &&
              k !== L &&
              n($, k, {
                get: () => G[k],
                enumerable: !(F = r(G, k)) || F.enumerable
              });
        return $;
      },
      l = ($, G, L) => (
        (L = $ != null ? e(s($)) : {}),
        c(
          !$ || !$.__esModule ? n(L, 'default', {value: $, enumerable: !0}) : L,
          $
        )
      ),
      u = ($) => c(n({}, '__esModule', {value: !0}), $),
      d = {};
    (a(d, {analytics: () => C}), (Lm = u(d)));
    var f = l(T$()),
      h = class {
        constructor($) {
          ((this.batch = []),
            (this.maxTimeoutMs = 3e4),
            (this.timeoutId = null),
            (this.isSending = !1),
            (this.batchSize = $.batchSize),
            (this.baseTimeoutMs = $.baseTimeoutMs),
            (this.currentTimeoutMs = $.baseTimeoutMs),
            (this.sendFn = $.sendFn));
        }
        enqueue($) {
          (this.batch.push($), this.schedule());
        }
        schedule() {
          this.batch.length > 0 &&
            !this.timeoutId &&
            (this.timeoutId = setTimeout(() => {
              ((this.timeoutId = null), this.flush());
            }, this.currentTimeoutMs));
        }
        async flush() {
          if (this.isSending || this.batch.length === 0) return;
          this.isSending = !0;
          const $ = [...this.batch.slice(0, this.batchSize)];
          this.batch = this.batch.slice(this.batchSize);
          try {
            (await this.sendFn($),
              (this.currentTimeoutMs = this.baseTimeoutMs));
          } catch (G) {
            (console.error('Sender: Failed to send batch', G),
              (this.batch = [...$, ...this.batch]),
              (this.currentTimeoutMs = Math.min(
                this.currentTimeoutMs * 2,
                this.maxTimeoutMs
              )));
          } finally {
            ((this.isSending = !1), this.schedule());
          }
        }
      },
      g = h,
      m = class {
        constructor($) {
          ((this.enabled = !1), (this.properties = {}));
          const G = (0, f.default)({baseUrl: $}),
            L = async (F) => {
              const k = await G.POST('/v1/events', {body: F});
              if (k.response.status !== 200) throw new Error(k.error);
            };
          this.sender = new g({batchSize: 100, baseTimeoutMs: 200, sendFn: L});
        }
        enable() {
          this.enabled = !0;
        }
        setGlobalProperty($, G) {
          this.properties[$] = G;
        }
        track($, G) {
          if (!this.enabled) return;
          const L = {name: $, ...this.properties, ...G};
          this.sender.enqueue(L);
        }
      },
      y = m,
      p,
      b;
    typeof process < 'u' &&
      t &&
      (p =
        (b = t.METAMASK_ANALYTICS_ENDPOINT) != null
          ? b
          : t.NEXT_PUBLIC_METAMASK_ANALYTICS_ENDPOINT);
    var v = p ?? 'https://mm-sdk-analytics.api.cx.metamask.io/',
      x = new y(v),
      C = x;
    return Lm;
  }
  var kt = I$(),
    Bm = {exports: {}};
  /*!
   * EventEmitter2
   * https://github.com/hij1nx/EventEmitter2
   *
   * Copyright (c) 2013 hij1nx
   * Licensed under the MIT license.
   */ var Ww;
  function k$() {
    return (
      Ww ||
        ((Ww = 1),
        (function (t, e) {
          (function (n) {
            var r = Object.hasOwnProperty,
              i = Array.isArray
                ? Array.isArray
                : function (A) {
                    return (
                      Object.prototype.toString.call(A) === '[object Array]'
                    );
                  },
              s = 10,
              o =
                typeof process == 'object' &&
                typeof process.nextTick == 'function',
              a = typeof Symbol == 'function',
              c = typeof Reflect == 'object',
              l = typeof setImmediate == 'function',
              u = l ? setImmediate : setTimeout,
              d = a
                ? c && typeof Reflect.ownKeys == 'function'
                  ? Reflect.ownKeys
                  : function (w) {
                      var A = Object.getOwnPropertyNames(w);
                      return (
                        A.push.apply(A, Object.getOwnPropertySymbols(w)),
                        A
                      );
                    }
                : Object.keys;
            function f() {
              ((this._events = {}), this._conf && h.call(this, this._conf));
            }
            function h(w) {
              w &&
                ((this._conf = w),
                w.delimiter && (this.delimiter = w.delimiter),
                w.maxListeners !== n && (this._maxListeners = w.maxListeners),
                w.wildcard && (this.wildcard = w.wildcard),
                w.newListener && (this._newListener = w.newListener),
                w.removeListener && (this._removeListener = w.removeListener),
                w.verboseMemoryLeak &&
                  (this.verboseMemoryLeak = w.verboseMemoryLeak),
                w.ignoreErrors && (this.ignoreErrors = w.ignoreErrors),
                this.wildcard && (this.listenerTree = {}));
            }
            function g(w, A) {
              var T =
                '(node) warning: possible EventEmitter memory leak detected. ' +
                w +
                ' listeners added. Use emitter.setMaxListeners() to increase limit.';
              if (
                (this.verboseMemoryLeak && (T += ' Event name: ' + A + '.'),
                typeof process < 'u' && process.emitWarning)
              ) {
                var R = new Error(T);
                ((R.name = 'MaxListenersExceededWarning'),
                  (R.emitter = this),
                  (R.count = w),
                  process.emitWarning(R));
              } else (console.error(T), console.trace && console.trace());
            }
            var m = function (w, A, T) {
              var R = arguments.length;
              switch (R) {
                case 0:
                  return [];
                case 1:
                  return [w];
                case 2:
                  return [w, A];
                case 3:
                  return [w, A, T];
                default:
                  for (var _ = new Array(R); R--; ) _[R] = arguments[R];
                  return _;
              }
            };
            function y(w, A) {
              for (var T = {}, R, _ = w.length, S = 0, I = 0; I < _; I++)
                ((R = w[I]), (T[R] = I < S ? A[I] : n));
              return T;
            }
            function p(w, A, T) {
              ((this._emitter = w),
                (this._target = A),
                (this._listeners = {}),
                (this._listenersCount = 0));
              var R, _;
              if (
                ((T.on || T.off) && ((R = T.on), (_ = T.off)),
                A.addEventListener
                  ? ((R = A.addEventListener), (_ = A.removeEventListener))
                  : A.addListener
                    ? ((R = A.addListener), (_ = A.removeListener))
                    : A.on && ((R = A.on), (_ = A.off)),
                !R && !_)
              )
                throw Error('target does not implement any known event API');
              if (typeof R != 'function')
                throw TypeError('on method must be a function');
              if (typeof _ != 'function')
                throw TypeError('off method must be a function');
              ((this._on = R), (this._off = _));
              var S = w._observers;
              S ? S.push(this) : (w._observers = [this]);
            }
            Object.assign(p.prototype, {
              subscribe: function (w, A, T) {
                var R = this,
                  _ = this._target,
                  S = this._emitter,
                  I = this._listeners,
                  O = function () {
                    var H = m.apply(null, arguments),
                      M = {data: H, name: A, original: w};
                    if (T) {
                      var q = T.call(_, M);
                      q !== !1 && S.emit.apply(S, [M.name].concat(H));
                      return;
                    }
                    S.emit.apply(S, [A].concat(H));
                  };
                if (I[w]) throw Error("Event '" + w + "' is already listening");
                (this._listenersCount++,
                  S._newListener && S._removeListener && !R._onNewListener
                    ? ((this._onNewListener = function (H) {
                        H === A &&
                          I[w] === null &&
                          ((I[w] = O), R._on.call(_, w, O));
                      }),
                      S.on('newListener', this._onNewListener),
                      (this._onRemoveListener = function (H) {
                        H === A &&
                          !S.hasListeners(H) &&
                          I[w] &&
                          ((I[w] = null), R._off.call(_, w, O));
                      }),
                      (I[w] = null),
                      S.on('removeListener', this._onRemoveListener))
                    : ((I[w] = O), R._on.call(_, w, O)));
              },
              unsubscribe: function (w) {
                var A = this,
                  T = this._listeners,
                  R = this._emitter,
                  _,
                  S,
                  I = this._off,
                  O = this._target,
                  H;
                if (w && typeof w != 'string')
                  throw TypeError('event must be a string');
                function M() {
                  A._onNewListener &&
                    (R.off('newListener', A._onNewListener),
                    R.off('removeListener', A._onRemoveListener),
                    (A._onNewListener = null),
                    (A._onRemoveListener = null));
                  var q = L.call(R, A);
                  R._observers.splice(q, 1);
                }
                if (w) {
                  if (((_ = T[w]), !_)) return;
                  (I.call(O, w, _), delete T[w], --this._listenersCount || M());
                } else {
                  for (S = d(T), H = S.length; H-- > 0; )
                    ((w = S[H]), I.call(O, w, T[w]));
                  ((this._listeners = {}), (this._listenersCount = 0), M());
                }
              }
            });
            function b(w, A, T, R) {
              var _ = Object.assign({}, A);
              if (!w) return _;
              if (typeof w != 'object')
                throw TypeError('options must be an object');
              var S = Object.keys(w),
                I = S.length,
                O,
                H,
                M;
              function q(Z) {
                throw Error(
                  'Invalid "' +
                    O +
                    '" option value' +
                    (Z ? '. Reason: ' + Z : '')
                );
              }
              for (var z = 0; z < I; z++) {
                if (((O = S[z]), !r.call(A, O)))
                  throw Error('Unknown "' + O + '" option');
                ((H = w[O]), H !== n && ((M = T[O]), (_[O] = M ? M(H, q) : H)));
              }
              return _;
            }
            function v(w, A) {
              return (
                (typeof w != 'function' || !w.hasOwnProperty('prototype')) &&
                  A('value must be a constructor'),
                w
              );
            }
            function x(w) {
              var A = 'value must be type of ' + w.join('|'),
                T = w.length,
                R = w[0],
                _ = w[1];
              return T === 1
                ? function (S, I) {
                    if (typeof S === R) return S;
                    I(A);
                  }
                : T === 2
                  ? function (S, I) {
                      var O = typeof S;
                      if (O === R || O === _) return S;
                      I(A);
                    }
                  : function (S, I) {
                      for (var O = typeof S, H = T; H-- > 0; )
                        if (O === w[H]) return S;
                      I(A);
                    };
            }
            var C = x(['function']),
              $ = x(['object', 'function']);
            function G(w, A, T) {
              var R,
                _,
                S = 0,
                I,
                O = new w(function (H, M, q) {
                  ((T = b(
                    T,
                    {timeout: 0, overload: !1},
                    {
                      timeout: function (N, j) {
                        return (
                          (N *= 1),
                          (typeof N != 'number' ||
                            N < 0 ||
                            !Number.isFinite(N)) &&
                            j('timeout must be a positive number'),
                          N
                        );
                      }
                    }
                  )),
                    (R =
                      !T.overload &&
                      typeof w.prototype.cancel == 'function' &&
                      typeof q == 'function'));
                  function z() {
                    (_ && (_ = null), S && (clearTimeout(S), (S = 0)));
                  }
                  var Z = function (N) {
                      (z(), H(N));
                    },
                    X = function (N) {
                      (z(), M(N));
                    };
                  (R
                    ? A(Z, X, q)
                    : ((_ = [
                        function (N) {
                          X(N || Error('canceled'));
                        }
                      ]),
                      A(Z, X, function (N) {
                        if (I)
                          throw Error(
                            'Unable to subscribe on cancel event asynchronously'
                          );
                        if (typeof N != 'function')
                          throw TypeError(
                            'onCancel callback must be a function'
                          );
                        _.push(N);
                      }),
                      (I = !0)),
                    T.timeout > 0 &&
                      (S = setTimeout(function () {
                        var N = Error('timeout');
                        ((N.code = 'ETIMEDOUT'), (S = 0), O.cancel(N), M(N));
                      }, T.timeout)));
                });
              return (
                R ||
                  (O.cancel = function (H) {
                    if (_) {
                      for (var M = _.length, q = 1; q < M; q++) _[q](H);
                      (_[0](H), (_ = null));
                    }
                  }),
                O
              );
            }
            function L(w) {
              var A = this._observers;
              if (!A) return -1;
              for (var T = A.length, R = 0; R < T; R++)
                if (A[R]._target === w) return R;
              return -1;
            }
            function F(w, A, T, R, _) {
              if (!T) return null;
              if (R === 0) {
                var S = typeof A;
                if (S === 'string') {
                  var I,
                    O,
                    H = 0,
                    M = 0,
                    q = this.delimiter,
                    z = q.length;
                  if ((O = A.indexOf(q)) !== -1) {
                    I = new Array(5);
                    do ((I[H++] = A.slice(M, O)), (M = O + z));
                    while ((O = A.indexOf(q, M)) !== -1);
                    ((I[H++] = A.slice(M)), (A = I), (_ = H));
                  } else ((A = [A]), (_ = 1));
                } else S === 'object' ? (_ = A.length) : ((A = [A]), (_ = 1));
              }
              var Z = null,
                X,
                N,
                j,
                W,
                J,
                Q = A[R],
                Y = A[R + 1],
                se,
                ne;
              if (R === _)
                T._listeners &&
                  (typeof T._listeners == 'function'
                    ? (w && w.push(T._listeners), (Z = [T]))
                    : (w && w.push.apply(w, T._listeners), (Z = [T])));
              else if (Q === '*') {
                for (se = d(T), O = se.length; O-- > 0; )
                  ((X = se[O]),
                    X !== '_listeners' &&
                      ((ne = F(w, A, T[X], R + 1, _)),
                      ne && (Z ? Z.push.apply(Z, ne) : (Z = ne))));
                return Z;
              } else if (Q === '**') {
                for (
                  J = R + 1 === _ || (R + 2 === _ && Y === '*'),
                    J && T._listeners && (Z = F(w, A, T, _, _)),
                    se = d(T),
                    O = se.length;
                  O-- > 0;

                )
                  ((X = se[O]),
                    X !== '_listeners' &&
                      (X === '*' || X === '**'
                        ? (T[X]._listeners &&
                            !J &&
                            ((ne = F(w, A, T[X], _, _)),
                            ne && (Z ? Z.push.apply(Z, ne) : (Z = ne))),
                          (ne = F(w, A, T[X], R, _)))
                        : X === Y
                          ? (ne = F(w, A, T[X], R + 2, _))
                          : (ne = F(w, A, T[X], R, _)),
                      ne && (Z ? Z.push.apply(Z, ne) : (Z = ne))));
                return Z;
              } else T[Q] && (Z = F(w, A, T[Q], R + 1, _));
              if (((N = T['*']), N && F(w, A, N, R + 1, _), (j = T['**']), j))
                if (R < _)
                  for (
                    j._listeners && F(w, A, j, _, _), se = d(j), O = se.length;
                    O-- > 0;

                  )
                    ((X = se[O]),
                      X !== '_listeners' &&
                        (X === Y
                          ? F(w, A, j[X], R + 2, _)
                          : X === Q
                            ? F(w, A, j[X], R + 1, _)
                            : ((W = {}),
                              (W[X] = j[X]),
                              F(w, A, {'**': W}, R + 1, _))));
                else
                  j._listeners
                    ? F(w, A, j, _, _)
                    : j['*'] && j['*']._listeners && F(w, A, j['*'], _, _);
              return Z;
            }
            function k(w, A, T) {
              var R = 0,
                _ = 0,
                S,
                I = this.delimiter,
                O = I.length,
                H;
              if (typeof w == 'string')
                if ((S = w.indexOf(I)) !== -1) {
                  H = new Array(5);
                  do ((H[R++] = w.slice(_, S)), (_ = S + O));
                  while ((S = w.indexOf(I, _)) !== -1);
                  H[R++] = w.slice(_);
                } else ((H = [w]), (R = 1));
              else ((H = w), (R = w.length));
              if (R > 1) {
                for (S = 0; S + 1 < R; S++)
                  if (H[S] === '**' && H[S + 1] === '**') return;
              }
              var M = this.listenerTree,
                q;
              for (S = 0; S < R; S++)
                if (((q = H[S]), (M = M[q] || (M[q] = {})), S === R - 1))
                  return (
                    M._listeners
                      ? (typeof M._listeners == 'function' &&
                          (M._listeners = [M._listeners]),
                        T ? M._listeners.unshift(A) : M._listeners.push(A),
                        !M._listeners.warned &&
                          this._maxListeners > 0 &&
                          M._listeners.length > this._maxListeners &&
                          ((M._listeners.warned = !0),
                          g.call(this, M._listeners.length, q)))
                      : (M._listeners = A),
                    !0
                  );
              return !0;
            }
            function V(w, A, T, R) {
              for (
                var _ = d(w), S = _.length, I, O, H, M = w._listeners, q;
                S-- > 0;

              )
                ((O = _[S]),
                  (I = w[O]),
                  O === '_listeners' ? (H = T) : (H = T ? T.concat(O) : [O]),
                  (q = R || typeof O == 'symbol'),
                  M && A.push(q ? H : H.join(this.delimiter)),
                  typeof I == 'object' && V.call(this, I, A, H, q));
              return A;
            }
            function K(w) {
              for (var A = d(w), T = A.length, R, _, S; T-- > 0; )
                ((_ = A[T]),
                  (R = w[_]),
                  R && ((S = !0), _ !== '_listeners' && !K(R) && delete w[_]));
              return S;
            }
            function B(w, A, T) {
              ((this.emitter = w), (this.event = A), (this.listener = T));
            }
            B.prototype.off = function () {
              return (this.emitter.off(this.event, this.listener), this);
            };
            function D(w, A, T) {
              if (T === !0) _ = !0;
              else if (T === !1) R = !0;
              else {
                if (!T || typeof T != 'object')
                  throw TypeError('options should be an object or true');
                var R = T.async,
                  _ = T.promisify,
                  S = T.nextTick,
                  I = T.objectify;
              }
              if (R || S || _) {
                var O = A,
                  H = A._origin || A;
                if (S && !o) throw Error('process.nextTick is not supported');
                (_ === n && (_ = A.constructor.name === 'AsyncFunction'),
                  (A = function () {
                    var M = arguments,
                      q = this,
                      z = this.event;
                    return _
                      ? S
                        ? Promise.resolve()
                        : new Promise(function (Z) {
                            u(Z);
                          }).then(function () {
                            return ((q.event = z), O.apply(q, M));
                          })
                      : (S ? process.nextTick : u)(function () {
                          ((q.event = z), O.apply(q, M));
                        });
                  }),
                  (A._async = !0),
                  (A._origin = H));
              }
              return [A, I ? new B(this, w, A) : this];
            }
            function E(w) {
              ((this._events = {}),
                (this._newListener = !1),
                (this._removeListener = !1),
                (this.verboseMemoryLeak = !1),
                h.call(this, w));
            }
            ((E.EventEmitter2 = E),
              (E.prototype.listenTo = function (w, A, T) {
                if (typeof w != 'object')
                  throw TypeError('target musts be an object');
                var R = this;
                T = b(
                  T,
                  {on: n, off: n, reducers: n},
                  {on: C, off: C, reducers: $}
                );
                function _(S) {
                  if (typeof S != 'object')
                    throw TypeError('events must be an object');
                  var I = T.reducers,
                    O = L.call(R, w),
                    H;
                  O === -1 ? (H = new p(R, w, T)) : (H = R._observers[O]);
                  for (
                    var M = d(S),
                      q = M.length,
                      z,
                      Z = typeof I == 'function',
                      X = 0;
                    X < q;
                    X++
                  )
                    ((z = M[X]), H.subscribe(z, S[z] || z, Z ? I : I && I[z]));
                }
                return (
                  i(A)
                    ? _(y(A))
                    : _(typeof A == 'string' ? y(A.split(/\s+/)) : A),
                  this
                );
              }),
              (E.prototype.stopListeningTo = function (w, A) {
                var T = this._observers;
                if (!T) return !1;
                var R = T.length,
                  _,
                  S = !1;
                if (w && typeof w != 'object')
                  throw TypeError('target should be an object');
                for (; R-- > 0; )
                  ((_ = T[R]),
                    (!w || _._target === w) && (_.unsubscribe(A), (S = !0)));
                return S;
              }),
              (E.prototype.delimiter = '.'),
              (E.prototype.setMaxListeners = function (w) {
                w !== n &&
                  ((this._maxListeners = w),
                  this._conf || (this._conf = {}),
                  (this._conf.maxListeners = w));
              }),
              (E.prototype.getMaxListeners = function () {
                return this._maxListeners;
              }),
              (E.prototype.event = ''),
              (E.prototype.once = function (w, A, T) {
                return this._once(w, A, !1, T);
              }),
              (E.prototype.prependOnceListener = function (w, A, T) {
                return this._once(w, A, !0, T);
              }),
              (E.prototype._once = function (w, A, T, R) {
                return this._many(w, 1, A, T, R);
              }),
              (E.prototype.many = function (w, A, T, R) {
                return this._many(w, A, T, !1, R);
              }),
              (E.prototype.prependMany = function (w, A, T, R) {
                return this._many(w, A, T, !0, R);
              }),
              (E.prototype._many = function (w, A, T, R, _) {
                var S = this;
                if (typeof T != 'function')
                  throw new Error('many only accepts instances of Function');
                function I() {
                  return (--A === 0 && S.off(w, I), T.apply(this, arguments));
                }
                return ((I._origin = T), this._on(w, I, R, _));
              }),
              (E.prototype.emit = function () {
                if (!this._events && !this._all) return !1;
                this._events || f.call(this);
                var w = arguments[0],
                  A,
                  T = this.wildcard,
                  R,
                  _,
                  S,
                  I,
                  O;
                if (
                  w === 'newListener' &&
                  !this._newListener &&
                  !this._events.newListener
                )
                  return !1;
                if (
                  T &&
                  ((A = w),
                  w !== 'newListener' &&
                    w !== 'removeListener' &&
                    typeof w == 'object')
                ) {
                  if (((_ = w.length), a)) {
                    for (S = 0; S < _; S++)
                      if (typeof w[S] == 'symbol') {
                        O = !0;
                        break;
                      }
                  }
                  O || (w = w.join(this.delimiter));
                }
                var H = arguments.length,
                  M;
                if (this._all && this._all.length)
                  for (M = this._all.slice(), S = 0, _ = M.length; S < _; S++)
                    switch (((this.event = w), H)) {
                      case 1:
                        M[S].call(this, w);
                        break;
                      case 2:
                        M[S].call(this, w, arguments[1]);
                        break;
                      case 3:
                        M[S].call(this, w, arguments[1], arguments[2]);
                        break;
                      default:
                        M[S].apply(this, arguments);
                    }
                if (T) ((M = []), F.call(this, M, A, this.listenerTree, 0, _));
                else if (((M = this._events[w]), typeof M == 'function')) {
                  switch (((this.event = w), H)) {
                    case 1:
                      M.call(this);
                      break;
                    case 2:
                      M.call(this, arguments[1]);
                      break;
                    case 3:
                      M.call(this, arguments[1], arguments[2]);
                      break;
                    default:
                      for (R = new Array(H - 1), I = 1; I < H; I++)
                        R[I - 1] = arguments[I];
                      M.apply(this, R);
                  }
                  return !0;
                } else M && (M = M.slice());
                if (M && M.length) {
                  if (H > 3)
                    for (R = new Array(H - 1), I = 1; I < H; I++)
                      R[I - 1] = arguments[I];
                  for (S = 0, _ = M.length; S < _; S++)
                    switch (((this.event = w), H)) {
                      case 1:
                        M[S].call(this);
                        break;
                      case 2:
                        M[S].call(this, arguments[1]);
                        break;
                      case 3:
                        M[S].call(this, arguments[1], arguments[2]);
                        break;
                      default:
                        M[S].apply(this, R);
                    }
                  return !0;
                } else if (!this.ignoreErrors && !this._all && w === 'error')
                  throw arguments[1] instanceof Error
                    ? arguments[1]
                    : new Error("Uncaught, unspecified 'error' event.");
                return !!this._all;
              }),
              (E.prototype.emitAsync = function () {
                if (!this._events && !this._all) return !1;
                this._events || f.call(this);
                var w = arguments[0],
                  A = this.wildcard,
                  T,
                  R,
                  _,
                  S,
                  I,
                  O;
                if (
                  w === 'newListener' &&
                  !this._newListener &&
                  !this._events.newListener
                )
                  return Promise.resolve([!1]);
                if (
                  A &&
                  ((T = w),
                  w !== 'newListener' &&
                    w !== 'removeListener' &&
                    typeof w == 'object')
                ) {
                  if (((S = w.length), a)) {
                    for (I = 0; I < S; I++)
                      if (typeof w[I] == 'symbol') {
                        R = !0;
                        break;
                      }
                  }
                  R || (w = w.join(this.delimiter));
                }
                var H = [],
                  M = arguments.length,
                  q;
                if (this._all)
                  for (I = 0, S = this._all.length; I < S; I++)
                    switch (((this.event = w), M)) {
                      case 1:
                        H.push(this._all[I].call(this, w));
                        break;
                      case 2:
                        H.push(this._all[I].call(this, w, arguments[1]));
                        break;
                      case 3:
                        H.push(
                          this._all[I].call(this, w, arguments[1], arguments[2])
                        );
                        break;
                      default:
                        H.push(this._all[I].apply(this, arguments));
                    }
                if (
                  (A
                    ? ((q = []), F.call(this, q, T, this.listenerTree, 0))
                    : (q = this._events[w]),
                  typeof q == 'function')
                )
                  switch (((this.event = w), M)) {
                    case 1:
                      H.push(q.call(this));
                      break;
                    case 2:
                      H.push(q.call(this, arguments[1]));
                      break;
                    case 3:
                      H.push(q.call(this, arguments[1], arguments[2]));
                      break;
                    default:
                      for (_ = new Array(M - 1), O = 1; O < M; O++)
                        _[O - 1] = arguments[O];
                      H.push(q.apply(this, _));
                  }
                else if (q && q.length) {
                  if (((q = q.slice()), M > 3))
                    for (_ = new Array(M - 1), O = 1; O < M; O++)
                      _[O - 1] = arguments[O];
                  for (I = 0, S = q.length; I < S; I++)
                    switch (((this.event = w), M)) {
                      case 1:
                        H.push(q[I].call(this));
                        break;
                      case 2:
                        H.push(q[I].call(this, arguments[1]));
                        break;
                      case 3:
                        H.push(q[I].call(this, arguments[1], arguments[2]));
                        break;
                      default:
                        H.push(q[I].apply(this, _));
                    }
                } else if (!this.ignoreErrors && !this._all && w === 'error')
                  return arguments[1] instanceof Error
                    ? Promise.reject(arguments[1])
                    : Promise.reject("Uncaught, unspecified 'error' event.");
                return Promise.all(H);
              }),
              (E.prototype.on = function (w, A, T) {
                return this._on(w, A, !1, T);
              }),
              (E.prototype.prependListener = function (w, A, T) {
                return this._on(w, A, !0, T);
              }),
              (E.prototype.onAny = function (w) {
                return this._onAny(w, !1);
              }),
              (E.prototype.prependAny = function (w) {
                return this._onAny(w, !0);
              }),
              (E.prototype.addListener = E.prototype.on),
              (E.prototype._onAny = function (w, A) {
                if (typeof w != 'function')
                  throw new Error('onAny only accepts instances of Function');
                return (
                  this._all || (this._all = []),
                  A ? this._all.unshift(w) : this._all.push(w),
                  this
                );
              }),
              (E.prototype._on = function (w, A, T, R) {
                if (typeof w == 'function') return (this._onAny(w, A), this);
                if (typeof A != 'function')
                  throw new Error('on only accepts instances of Function');
                this._events || f.call(this);
                var _ = this,
                  S;
                return (
                  R !== n &&
                    ((S = D.call(this, w, A, R)), (A = S[0]), (_ = S[1])),
                  this._newListener && this.emit('newListener', w, A),
                  this.wildcard
                    ? (k.call(this, w, A, T), _)
                    : (this._events[w]
                        ? (typeof this._events[w] == 'function' &&
                            (this._events[w] = [this._events[w]]),
                          T
                            ? this._events[w].unshift(A)
                            : this._events[w].push(A),
                          !this._events[w].warned &&
                            this._maxListeners > 0 &&
                            this._events[w].length > this._maxListeners &&
                            ((this._events[w].warned = !0),
                            g.call(this, this._events[w].length, w)))
                        : (this._events[w] = A),
                      _)
                );
              }),
              (E.prototype.off = function (w, A) {
                if (typeof A != 'function')
                  throw new Error(
                    'removeListener only takes instances of Function'
                  );
                var T,
                  R = [];
                if (this.wildcard) {
                  var _ =
                    typeof w == 'string' ? w.split(this.delimiter) : w.slice();
                  if (((R = F.call(this, null, _, this.listenerTree, 0)), !R))
                    return this;
                } else {
                  if (!this._events[w]) return this;
                  ((T = this._events[w]), R.push({_listeners: T}));
                }
                for (var S = 0; S < R.length; S++) {
                  var I = R[S];
                  if (((T = I._listeners), i(T))) {
                    for (var O = -1, H = 0, M = T.length; H < M; H++)
                      if (
                        T[H] === A ||
                        (T[H].listener && T[H].listener === A) ||
                        (T[H]._origin && T[H]._origin === A)
                      ) {
                        O = H;
                        break;
                      }
                    if (O < 0) continue;
                    return (
                      this.wildcard
                        ? I._listeners.splice(O, 1)
                        : this._events[w].splice(O, 1),
                      T.length === 0 &&
                        (this.wildcard
                          ? delete I._listeners
                          : delete this._events[w]),
                      this._removeListener && this.emit('removeListener', w, A),
                      this
                    );
                  } else
                    (T === A ||
                      (T.listener && T.listener === A) ||
                      (T._origin && T._origin === A)) &&
                      (this.wildcard
                        ? delete I._listeners
                        : delete this._events[w],
                      this._removeListener &&
                        this.emit('removeListener', w, A));
                }
                return (this.listenerTree && K(this.listenerTree), this);
              }),
              (E.prototype.offAny = function (w) {
                var A = 0,
                  T = 0,
                  R;
                if (w && this._all && this._all.length > 0) {
                  for (R = this._all, A = 0, T = R.length; A < T; A++)
                    if (w === R[A])
                      return (
                        R.splice(A, 1),
                        this._removeListener &&
                          this.emit('removeListenerAny', w),
                        this
                      );
                } else {
                  if (((R = this._all), this._removeListener))
                    for (A = 0, T = R.length; A < T; A++)
                      this.emit('removeListenerAny', R[A]);
                  this._all = [];
                }
                return this;
              }),
              (E.prototype.removeListener = E.prototype.off),
              (E.prototype.removeAllListeners = function (w) {
                if (w === n) return (!this._events || f.call(this), this);
                if (this.wildcard) {
                  var A = F.call(this, null, w, this.listenerTree, 0),
                    T,
                    R;
                  if (!A) return this;
                  for (R = 0; R < A.length; R++)
                    ((T = A[R]), (T._listeners = null));
                  this.listenerTree && K(this.listenerTree);
                } else this._events && (this._events[w] = null);
                return this;
              }),
              (E.prototype.listeners = function (w) {
                var A = this._events,
                  T,
                  R,
                  _,
                  S,
                  I;
                if (w === n) {
                  if (this.wildcard)
                    throw Error('event name required for wildcard emitter');
                  if (!A) return [];
                  for (T = d(A), S = T.length, _ = []; S-- > 0; )
                    ((R = A[T[S]]),
                      typeof R == 'function' ? _.push(R) : _.push.apply(_, R));
                  return _;
                } else {
                  if (this.wildcard) {
                    if (((I = this.listenerTree), !I)) return [];
                    var O = [],
                      H =
                        typeof w == 'string'
                          ? w.split(this.delimiter)
                          : w.slice();
                    return (F.call(this, O, H, I, 0), O);
                  }
                  return A
                    ? ((R = A[w]), R ? (typeof R == 'function' ? [R] : R) : [])
                    : [];
                }
              }),
              (E.prototype.eventNames = function (w) {
                var A = this._events;
                return this.wildcard
                  ? V.call(this, this.listenerTree, [], null, w)
                  : A
                    ? d(A)
                    : [];
              }),
              (E.prototype.listenerCount = function (w) {
                return this.listeners(w).length;
              }),
              (E.prototype.hasListeners = function (w) {
                if (this.wildcard) {
                  var A = [],
                    T =
                      typeof w == 'string'
                        ? w.split(this.delimiter)
                        : w.slice();
                  return (
                    F.call(this, A, T, this.listenerTree, 0),
                    A.length > 0
                  );
                }
                var R = this._events,
                  _ = this._all;
                return !!(
                  (_ && _.length) ||
                  (R && (w === n ? d(R).length : R[w]))
                );
              }),
              (E.prototype.listenersAny = function () {
                return this._all ? this._all : [];
              }),
              (E.prototype.waitFor = function (w, A) {
                var T = this,
                  R = typeof A;
                return (
                  R === 'number'
                    ? (A = {timeout: A})
                    : R === 'function' && (A = {filter: A}),
                  (A = b(
                    A,
                    {
                      timeout: 0,
                      filter: n,
                      handleError: !1,
                      Promise,
                      overload: !1
                    },
                    {filter: C, Promise: v}
                  )),
                  G(
                    A.Promise,
                    function (_, S, I) {
                      function O() {
                        var H = A.filter;
                        if (!(H && !H.apply(T, arguments)))
                          if ((T.off(w, O), A.handleError)) {
                            var M = arguments[0];
                            M ? S(M) : _(m.apply(null, arguments).slice(1));
                          } else _(m.apply(null, arguments));
                      }
                      (I(function () {
                        T.off(w, O);
                      }),
                        T._on(w, O, !1));
                    },
                    {timeout: A.timeout, overload: A.overload}
                  )
                );
              }));
            function P(w, A, T) {
              T = b(T, {Promise, timeout: 0, overload: !1}, {Promise: v});
              var R = T.Promise;
              return G(
                R,
                function (_, S, I) {
                  var O;
                  if (typeof w.addEventListener == 'function') {
                    ((O = function () {
                      _(m.apply(null, arguments));
                    }),
                      I(function () {
                        w.removeEventListener(A, O);
                      }),
                      w.addEventListener(A, O, {once: !0}));
                    return;
                  }
                  var H = function () {
                      (M && w.removeListener('error', M),
                        _(m.apply(null, arguments)));
                    },
                    M;
                  (A !== 'error' &&
                    ((M = function (q) {
                      (w.removeListener(A, H), S(q));
                    }),
                    w.once('error', M)),
                    I(function () {
                      (M && w.removeListener('error', M),
                        w.removeListener(A, H));
                    }),
                    w.once(A, H));
                },
                {timeout: T.timeout, overload: T.overload}
              );
            }
            var U = E.prototype;
            (Object.defineProperties(E, {
              defaultMaxListeners: {
                get: function () {
                  return U._maxListeners;
                },
                set: function (w) {
                  if (typeof w != 'number' || w < 0 || Number.isNaN(w))
                    throw TypeError('n must be a non-negative number');
                  U._maxListeners = w;
                },
                enumerable: !0
              },
              once: {value: P, writable: !0, configurable: !0}
            }),
              Object.defineProperties(U, {
                _maxListeners: {value: s, writable: !0, configurable: !0},
                _observers: {value: null, writable: !0, configurable: !0}
              }),
              (t.exports = E));
          })();
        })(Bm)),
      Bm.exports
    );
  }
  var Fp = k$();
  const R$ = Ou(Fp);
  var sd,
    P$ = new Uint8Array(16);
  function M$() {
    if (
      !sd &&
      ((sd =
        (typeof crypto < 'u' &&
          crypto.getRandomValues &&
          crypto.getRandomValues.bind(crypto)) ||
        (typeof msCrypto < 'u' &&
          typeof msCrypto.getRandomValues == 'function' &&
          msCrypto.getRandomValues.bind(msCrypto))),
      !sd)
    )
      throw new Error(
        'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported'
      );
    return sd(P$);
  }
  const O$ =
    /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  function Pg(t) {
    return typeof t == 'string' && O$.test(t);
  }
  var Zt = [];
  for (var Dm = 0; Dm < 256; ++Dm) Zt.push((Dm + 256).toString(16).substr(1));
  function N$(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
      n = (
        Zt[t[e + 0]] +
        Zt[t[e + 1]] +
        Zt[t[e + 2]] +
        Zt[t[e + 3]] +
        '-' +
        Zt[t[e + 4]] +
        Zt[t[e + 5]] +
        '-' +
        Zt[t[e + 6]] +
        Zt[t[e + 7]] +
        '-' +
        Zt[t[e + 8]] +
        Zt[t[e + 9]] +
        '-' +
        Zt[t[e + 10]] +
        Zt[t[e + 11]] +
        Zt[t[e + 12]] +
        Zt[t[e + 13]] +
        Zt[t[e + 14]] +
        Zt[t[e + 15]]
      ).toLowerCase();
    if (!Pg(n)) throw TypeError('Stringified UUID is invalid');
    return n;
  }
  function Ls(t, e, n) {
    t = t || {};
    var r = t.random || (t.rng || M$)();
    return ((r[6] = (r[6] & 15) | 64), (r[8] = (r[8] & 63) | 128), N$(r));
  }
  const bi = Object.create(null);
  bi.open = '0';
  bi.close = '1';
  bi.ping = '2';
  bi.pong = '3';
  bi.message = '4';
  bi.upgrade = '5';
  bi.noop = '6';
  const Qd = Object.create(null);
  Object.keys(bi).forEach((t) => {
    Qd[bi[t]] = t;
  });
  const Mg = {type: 'error', data: 'parser error'},
    Yx =
      typeof Blob == 'function' ||
      (typeof Blob < 'u' &&
        Object.prototype.toString.call(Blob) === '[object BlobConstructor]'),
    Qx = typeof ArrayBuffer == 'function',
    Jx = (t) =>
      typeof ArrayBuffer.isView == 'function'
        ? ArrayBuffer.isView(t)
        : t && t.buffer instanceof ArrayBuffer,
    Hv = ({type: t, data: e}, n, r) =>
      Yx && e instanceof Blob
        ? n
          ? r(e)
          : Zw(e, r)
        : Qx && (e instanceof ArrayBuffer || Jx(e))
          ? n
            ? r(e)
            : Zw(new Blob([e]), r)
          : r(bi[t] + (e || '')),
    Zw = (t, e) => {
      const n = new FileReader();
      return (
        (n.onload = function () {
          const r = n.result.split(',')[1];
          e('b' + (r || ''));
        }),
        n.readAsDataURL(t)
      );
    };
  function Yw(t) {
    return t instanceof Uint8Array
      ? t
      : t instanceof ArrayBuffer
        ? new Uint8Array(t)
        : new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  }
  let Fm;
  function L$(t, e) {
    if (Yx && t.data instanceof Blob)
      return t.data.arrayBuffer().then(Yw).then(e);
    if (Qx && (t.data instanceof ArrayBuffer || Jx(t.data)))
      return e(Yw(t.data));
    Hv(t, !1, (n) => {
      (Fm || (Fm = new TextEncoder()), e(Fm.encode(n)));
    });
  }
  const Qw = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    nl = typeof Uint8Array > 'u' ? [] : new Uint8Array(256);
  for (let t = 0; t < Qw.length; t++) nl[Qw.charCodeAt(t)] = t;
  const B$ = (t) => {
      let e = t.length * 0.75,
        n = t.length,
        r,
        i = 0,
        s,
        o,
        a,
        c;
      t[t.length - 1] === '=' && (e--, t[t.length - 2] === '=' && e--);
      const l = new ArrayBuffer(e),
        u = new Uint8Array(l);
      for (r = 0; r < n; r += 4)
        ((s = nl[t.charCodeAt(r)]),
          (o = nl[t.charCodeAt(r + 1)]),
          (a = nl[t.charCodeAt(r + 2)]),
          (c = nl[t.charCodeAt(r + 3)]),
          (u[i++] = (s << 2) | (o >> 4)),
          (u[i++] = ((o & 15) << 4) | (a >> 2)),
          (u[i++] = ((a & 3) << 6) | (c & 63)));
      return l;
    },
    D$ = typeof ArrayBuffer == 'function',
    jv = (t, e) => {
      if (typeof t != 'string') return {type: 'message', data: Xx(t, e)};
      const n = t.charAt(0);
      return n === 'b'
        ? {type: 'message', data: F$(t.substring(1), e)}
        : Qd[n]
          ? t.length > 1
            ? {type: Qd[n], data: t.substring(1)}
            : {type: Qd[n]}
          : Mg;
    },
    F$ = (t, e) => {
      if (D$) {
        const n = B$(t);
        return Xx(n, e);
      } else return {base64: !0, data: t};
    },
    Xx = (t, e) => {
      switch (e) {
        case 'blob':
          return t instanceof Blob ? t : new Blob([t]);
        case 'arraybuffer':
        default:
          return t instanceof ArrayBuffer ? t : t.buffer;
      }
    },
    eC = '',
    $$ = (t, e) => {
      const n = t.length,
        r = new Array(n);
      let i = 0;
      t.forEach((s, o) => {
        Hv(s, !1, (a) => {
          ((r[o] = a), ++i === n && e(r.join(eC)));
        });
      });
    },
    H$ = (t, e) => {
      const n = t.split(eC),
        r = [];
      for (let i = 0; i < n.length; i++) {
        const s = jv(n[i], e);
        if ((r.push(s), s.type === 'error')) break;
      }
      return r;
    };
  function j$() {
    return new TransformStream({
      transform(t, e) {
        L$(t, (n) => {
          const r = n.length;
          let i;
          if (r < 126)
            ((i = new Uint8Array(1)), new DataView(i.buffer).setUint8(0, r));
          else if (r < 65536) {
            i = new Uint8Array(3);
            const s = new DataView(i.buffer);
            (s.setUint8(0, 126), s.setUint16(1, r));
          } else {
            i = new Uint8Array(9);
            const s = new DataView(i.buffer);
            (s.setUint8(0, 127), s.setBigUint64(1, BigInt(r)));
          }
          (t.data && typeof t.data != 'string' && (i[0] |= 128),
            e.enqueue(i),
            e.enqueue(n));
        });
      }
    });
  }
  let $m;
  function od(t) {
    return t.reduce((e, n) => e + n.length, 0);
  }
  function ad(t, e) {
    if (t[0].length === e) return t.shift();
    const n = new Uint8Array(e);
    let r = 0;
    for (let i = 0; i < e; i++)
      ((n[i] = t[0][r++]), r === t[0].length && (t.shift(), (r = 0)));
    return (t.length && r < t[0].length && (t[0] = t[0].slice(r)), n);
  }
  function U$(t, e) {
    $m || ($m = new TextDecoder());
    const n = [];
    let r = 0,
      i = -1,
      s = !1;
    return new TransformStream({
      transform(o, a) {
        for (n.push(o); ; ) {
          if (r === 0) {
            if (od(n) < 1) break;
            const c = ad(n, 1);
            ((s = (c[0] & 128) === 128),
              (i = c[0] & 127),
              i < 126 ? (r = 3) : i === 126 ? (r = 1) : (r = 2));
          } else if (r === 1) {
            if (od(n) < 2) break;
            const c = ad(n, 2);
            ((i = new DataView(c.buffer, c.byteOffset, c.length).getUint16(0)),
              (r = 3));
          } else if (r === 2) {
            if (od(n) < 8) break;
            const c = ad(n, 8),
              l = new DataView(c.buffer, c.byteOffset, c.length),
              u = l.getUint32(0);
            if (u > Math.pow(2, 21) - 1) {
              a.enqueue(Mg);
              break;
            }
            ((i = u * Math.pow(2, 32) + l.getUint32(4)), (r = 3));
          } else {
            if (od(n) < i) break;
            const c = ad(n, i);
            (a.enqueue(jv(s ? c : $m.decode(c), e)), (r = 0));
          }
          if (i === 0 || i > t) {
            a.enqueue(Mg);
            break;
          }
        }
      }
    });
  }
  const tC = 4;
  function Nt(t) {
    if (t) return K$(t);
  }
  function K$(t) {
    for (var e in Nt.prototype) t[e] = Nt.prototype[e];
    return t;
  }
  Nt.prototype.on = Nt.prototype.addEventListener = function (t, e) {
    return (
      (this._callbacks = this._callbacks || {}),
      (this._callbacks['$' + t] = this._callbacks['$' + t] || []).push(e),
      this
    );
  };
  Nt.prototype.once = function (t, e) {
    function n() {
      (this.off(t, n), e.apply(this, arguments));
    }
    return ((n.fn = e), this.on(t, n), this);
  };
  Nt.prototype.off =
    Nt.prototype.removeListener =
    Nt.prototype.removeAllListeners =
    Nt.prototype.removeEventListener =
      function (t, e) {
        if (((this._callbacks = this._callbacks || {}), arguments.length == 0))
          return ((this._callbacks = {}), this);
        var n = this._callbacks['$' + t];
        if (!n) return this;
        if (arguments.length == 1)
          return (delete this._callbacks['$' + t], this);
        for (var r, i = 0; i < n.length; i++)
          if (((r = n[i]), r === e || r.fn === e)) {
            n.splice(i, 1);
            break;
          }
        return (n.length === 0 && delete this._callbacks['$' + t], this);
      };
  Nt.prototype.emit = function (t) {
    this._callbacks = this._callbacks || {};
    for (
      var e = new Array(arguments.length - 1),
        n = this._callbacks['$' + t],
        r = 1;
      r < arguments.length;
      r++
    )
      e[r - 1] = arguments[r];
    if (n) {
      n = n.slice(0);
      for (var r = 0, i = n.length; r < i; ++r) n[r].apply(this, e);
    }
    return this;
  };
  Nt.prototype.emitReserved = Nt.prototype.emit;
  Nt.prototype.listeners = function (t) {
    return (
      (this._callbacks = this._callbacks || {}),
      this._callbacks['$' + t] || []
    );
  };
  Nt.prototype.hasListeners = function (t) {
    return !!this.listeners(t).length;
  };
  const $p =
      typeof Promise == 'function' && typeof Promise.resolve == 'function'
        ? (e) => Promise.resolve().then(e)
        : (e, n) => n(e, 0),
    br =
      typeof self < 'u'
        ? self
        : typeof window < 'u'
          ? window
          : Function('return this')(),
    q$ = 'arraybuffer';
  function nC(t, ...e) {
    return e.reduce((n, r) => (t.hasOwnProperty(r) && (n[r] = t[r]), n), {});
  }
  const V$ = br.setTimeout,
    G$ = br.clearTimeout;
  function Hp(t, e) {
    e.useNativeTimers
      ? ((t.setTimeoutFn = V$.bind(br)), (t.clearTimeoutFn = G$.bind(br)))
      : ((t.setTimeoutFn = br.setTimeout.bind(br)),
        (t.clearTimeoutFn = br.clearTimeout.bind(br)));
  }
  const z$ = 1.33;
  function W$(t) {
    return typeof t == 'string'
      ? Z$(t)
      : Math.ceil((t.byteLength || t.size) * z$);
  }
  function Z$(t) {
    let e = 0,
      n = 0;
    for (let r = 0, i = t.length; r < i; r++)
      ((e = t.charCodeAt(r)),
        e < 128
          ? (n += 1)
          : e < 2048
            ? (n += 2)
            : e < 55296 || e >= 57344
              ? (n += 3)
              : (r++, (n += 4)));
    return n;
  }
  function rC() {
    return (
      Date.now().toString(36).substring(3) +
      Math.random().toString(36).substring(2, 5)
    );
  }
  function Y$(t) {
    let e = '';
    for (let n in t)
      t.hasOwnProperty(n) &&
        (e.length && (e += '&'),
        (e += encodeURIComponent(n) + '=' + encodeURIComponent(t[n])));
    return e;
  }
  function Q$(t) {
    let e = {},
      n = t.split('&');
    for (let r = 0, i = n.length; r < i; r++) {
      let s = n[r].split('=');
      e[decodeURIComponent(s[0])] = decodeURIComponent(s[1]);
    }
    return e;
  }
  class J$ extends Error {
    constructor(e, n, r) {
      (super(e),
        (this.description = n),
        (this.context = r),
        (this.type = 'TransportError'));
    }
  }
  class Uv extends Nt {
    constructor(e) {
      (super(),
        (this.writable = !1),
        Hp(this, e),
        (this.opts = e),
        (this.query = e.query),
        (this.socket = e.socket),
        (this.supportsBinary = !e.forceBase64));
    }
    onError(e, n, r) {
      return (super.emitReserved('error', new J$(e, n, r)), this);
    }
    open() {
      return ((this.readyState = 'opening'), this.doOpen(), this);
    }
    close() {
      return (
        (this.readyState === 'opening' || this.readyState === 'open') &&
          (this.doClose(), this.onClose()),
        this
      );
    }
    send(e) {
      this.readyState === 'open' && this.write(e);
    }
    onOpen() {
      ((this.readyState = 'open'),
        (this.writable = !0),
        super.emitReserved('open'));
    }
    onData(e) {
      const n = jv(e, this.socket.binaryType);
      this.onPacket(n);
    }
    onPacket(e) {
      super.emitReserved('packet', e);
    }
    onClose(e) {
      ((this.readyState = 'closed'), super.emitReserved('close', e));
    }
    pause(e) {}
    createUri(e, n = {}) {
      return (
        e +
        '://' +
        this._hostname() +
        this._port() +
        this.opts.path +
        this._query(n)
      );
    }
    _hostname() {
      const e = this.opts.hostname;
      return e.indexOf(':') === -1 ? e : '[' + e + ']';
    }
    _port() {
      return this.opts.port &&
        ((this.opts.secure && +(this.opts.port !== 443)) ||
          (!this.opts.secure && Number(this.opts.port) !== 80))
        ? ':' + this.opts.port
        : '';
    }
    _query(e) {
      const n = Y$(e);
      return n.length ? '?' + n : '';
    }
  }
  class X$ extends Uv {
    constructor() {
      (super(...arguments), (this._polling = !1));
    }
    get name() {
      return 'polling';
    }
    doOpen() {
      this._poll();
    }
    pause(e) {
      this.readyState = 'pausing';
      const n = () => {
        ((this.readyState = 'paused'), e());
      };
      if (this._polling || !this.writable) {
        let r = 0;
        (this._polling &&
          (r++,
          this.once('pollComplete', function () {
            --r || n();
          })),
          this.writable ||
            (r++,
            this.once('drain', function () {
              --r || n();
            })));
      } else n();
    }
    _poll() {
      ((this._polling = !0), this.doPoll(), this.emitReserved('poll'));
    }
    onData(e) {
      const n = (r) => {
        if (
          (this.readyState === 'opening' && r.type === 'open' && this.onOpen(),
          r.type === 'close')
        )
          return (
            this.onClose({description: 'transport closed by the server'}),
            !1
          );
        this.onPacket(r);
      };
      (H$(e, this.socket.binaryType).forEach(n),
        this.readyState !== 'closed' &&
          ((this._polling = !1),
          this.emitReserved('pollComplete'),
          this.readyState === 'open' && this._poll()));
    }
    doClose() {
      const e = () => {
        this.write([{type: 'close'}]);
      };
      this.readyState === 'open' ? e() : this.once('open', e);
    }
    write(e) {
      ((this.writable = !1),
        $$(e, (n) => {
          this.doWrite(n, () => {
            ((this.writable = !0), this.emitReserved('drain'));
          });
        }));
    }
    uri() {
      const e = this.opts.secure ? 'https' : 'http',
        n = this.query || {};
      return (
        this.opts.timestampRequests !== !1 &&
          (n[this.opts.timestampParam] = rC()),
        !this.supportsBinary && !n.sid && (n.b64 = 1),
        this.createUri(e, n)
      );
    }
  }
  let iC = !1;
  try {
    iC =
      typeof XMLHttpRequest < 'u' && 'withCredentials' in new XMLHttpRequest();
  } catch {}
  const eH = iC;
  function tH() {}
  class nH extends X$ {
    constructor(e) {
      if ((super(e), typeof location < 'u')) {
        const n = location.protocol === 'https:';
        let r = location.port;
        (r || (r = n ? '443' : '80'),
          (this.xd =
            (typeof location < 'u' && e.hostname !== location.hostname) ||
            r !== e.port));
      }
    }
    doWrite(e, n) {
      const r = this.request({method: 'POST', data: e});
      (r.on('success', n),
        r.on('error', (i, s) => {
          this.onError('xhr post error', i, s);
        }));
    }
    doPoll() {
      const e = this.request();
      (e.on('data', this.onData.bind(this)),
        e.on('error', (n, r) => {
          this.onError('xhr poll error', n, r);
        }),
        (this.pollXhr = e));
    }
  }
  class di extends Nt {
    constructor(e, n, r) {
      (super(),
        (this.createRequest = e),
        Hp(this, r),
        (this._opts = r),
        (this._method = r.method || 'GET'),
        (this._uri = n),
        (this._data = r.data !== void 0 ? r.data : null),
        this._create());
    }
    _create() {
      var e;
      const n = nC(
        this._opts,
        'agent',
        'pfx',
        'key',
        'passphrase',
        'cert',
        'ca',
        'ciphers',
        'rejectUnauthorized',
        'autoUnref'
      );
      n.xdomain = !!this._opts.xd;
      const r = (this._xhr = this.createRequest(n));
      try {
        r.open(this._method, this._uri, !0);
        try {
          if (this._opts.extraHeaders) {
            r.setDisableHeaderCheck && r.setDisableHeaderCheck(!0);
            for (let i in this._opts.extraHeaders)
              this._opts.extraHeaders.hasOwnProperty(i) &&
                r.setRequestHeader(i, this._opts.extraHeaders[i]);
          }
        } catch {}
        if (this._method === 'POST')
          try {
            r.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
          } catch {}
        try {
          r.setRequestHeader('Accept', '*/*');
        } catch {}
        ((e = this._opts.cookieJar) === null || e === void 0 || e.addCookies(r),
          'withCredentials' in r &&
            (r.withCredentials = this._opts.withCredentials),
          this._opts.requestTimeout && (r.timeout = this._opts.requestTimeout),
          (r.onreadystatechange = () => {
            var i;
            (r.readyState === 3 &&
              ((i = this._opts.cookieJar) === null ||
                i === void 0 ||
                i.parseCookies(r.getResponseHeader('set-cookie'))),
              r.readyState === 4 &&
                (r.status === 200 || r.status === 1223
                  ? this._onLoad()
                  : this.setTimeoutFn(() => {
                      this._onError(typeof r.status == 'number' ? r.status : 0);
                    }, 0)));
          }),
          r.send(this._data));
      } catch (i) {
        this.setTimeoutFn(() => {
          this._onError(i);
        }, 0);
        return;
      }
      typeof document < 'u' &&
        ((this._index = di.requestsCount++), (di.requests[this._index] = this));
    }
    _onError(e) {
      (this.emitReserved('error', e, this._xhr), this._cleanup(!0));
    }
    _cleanup(e) {
      if (!(typeof this._xhr > 'u' || this._xhr === null)) {
        if (((this._xhr.onreadystatechange = tH), e))
          try {
            this._xhr.abort();
          } catch {}
        (typeof document < 'u' && delete di.requests[this._index],
          (this._xhr = null));
      }
    }
    _onLoad() {
      const e = this._xhr.responseText;
      e !== null &&
        (this.emitReserved('data', e),
        this.emitReserved('success'),
        this._cleanup());
    }
    abort() {
      this._cleanup();
    }
  }
  di.requestsCount = 0;
  di.requests = {};
  if (typeof document < 'u') {
    if (typeof attachEvent == 'function') attachEvent('onunload', Jw);
    else if (typeof addEventListener == 'function') {
      const t = 'onpagehide' in br ? 'pagehide' : 'unload';
      addEventListener(t, Jw, !1);
    }
  }
  function Jw() {
    for (let t in di.requests)
      di.requests.hasOwnProperty(t) && di.requests[t].abort();
  }
  const rH = (function () {
    const t = sC({xdomain: !1});
    return t && t.responseType !== null;
  })();
  class iH extends nH {
    constructor(e) {
      super(e);
      const n = e && e.forceBase64;
      this.supportsBinary = rH && !n;
    }
    request(e = {}) {
      return (
        Object.assign(e, {xd: this.xd}, this.opts),
        new di(sC, this.uri(), e)
      );
    }
  }
  function sC(t) {
    const e = t.xdomain;
    try {
      if (typeof XMLHttpRequest < 'u' && (!e || eH))
        return new XMLHttpRequest();
    } catch {}
    if (!e)
      try {
        return new br[['Active'].concat('Object').join('X')](
          'Microsoft.XMLHTTP'
        );
      } catch {}
  }
  const oC =
    typeof navigator < 'u' &&
    typeof navigator.product == 'string' &&
    navigator.product.toLowerCase() === 'reactnative';
  class sH extends Uv {
    get name() {
      return 'websocket';
    }
    doOpen() {
      const e = this.uri(),
        n = this.opts.protocols,
        r = oC
          ? {}
          : nC(
              this.opts,
              'agent',
              'perMessageDeflate',
              'pfx',
              'key',
              'passphrase',
              'cert',
              'ca',
              'ciphers',
              'rejectUnauthorized',
              'localAddress',
              'protocolVersion',
              'origin',
              'maxPayload',
              'family',
              'checkServerIdentity'
            );
      this.opts.extraHeaders && (r.headers = this.opts.extraHeaders);
      try {
        this.ws = this.createSocket(e, n, r);
      } catch (i) {
        return this.emitReserved('error', i);
      }
      ((this.ws.binaryType = this.socket.binaryType), this.addEventListeners());
    }
    addEventListeners() {
      ((this.ws.onopen = () => {
        (this.opts.autoUnref && this.ws._socket.unref(), this.onOpen());
      }),
        (this.ws.onclose = (e) =>
          this.onClose({
            description: 'websocket connection closed',
            context: e
          })),
        (this.ws.onmessage = (e) => this.onData(e.data)),
        (this.ws.onerror = (e) => this.onError('websocket error', e)));
    }
    write(e) {
      this.writable = !1;
      for (let n = 0; n < e.length; n++) {
        const r = e[n],
          i = n === e.length - 1;
        Hv(r, this.supportsBinary, (s) => {
          try {
            this.doWrite(r, s);
          } catch {}
          i &&
            $p(() => {
              ((this.writable = !0), this.emitReserved('drain'));
            }, this.setTimeoutFn);
        });
      }
    }
    doClose() {
      typeof this.ws < 'u' &&
        ((this.ws.onerror = () => {}), this.ws.close(), (this.ws = null));
    }
    uri() {
      const e = this.opts.secure ? 'wss' : 'ws',
        n = this.query || {};
      return (
        this.opts.timestampRequests && (n[this.opts.timestampParam] = rC()),
        this.supportsBinary || (n.b64 = 1),
        this.createUri(e, n)
      );
    }
  }
  const Hm = br.WebSocket || br.MozWebSocket;
  class oH extends sH {
    createSocket(e, n, r) {
      return oC ? new Hm(e, n, r) : n ? new Hm(e, n) : new Hm(e);
    }
    doWrite(e, n) {
      this.ws.send(n);
    }
  }
  class aH extends Uv {
    get name() {
      return 'webtransport';
    }
    doOpen() {
      try {
        this._transport = new WebTransport(
          this.createUri('https'),
          this.opts.transportOptions[this.name]
        );
      } catch (e) {
        return this.emitReserved('error', e);
      }
      (this._transport.closed
        .then(() => {
          this.onClose();
        })
        .catch((e) => {
          this.onError('webtransport error', e);
        }),
        this._transport.ready.then(() => {
          this._transport.createBidirectionalStream().then((e) => {
            const n = U$(Number.MAX_SAFE_INTEGER, this.socket.binaryType),
              r = e.readable.pipeThrough(n).getReader(),
              i = j$();
            (i.readable.pipeTo(e.writable),
              (this._writer = i.writable.getWriter()));
            const s = () => {
              r.read()
                .then(({done: a, value: c}) => {
                  a || (this.onPacket(c), s());
                })
                .catch((a) => {});
            };
            s();
            const o = {type: 'open'};
            (this.query.sid && (o.data = `{"sid":"${this.query.sid}"}`),
              this._writer.write(o).then(() => this.onOpen()));
          });
        }));
    }
    write(e) {
      this.writable = !1;
      for (let n = 0; n < e.length; n++) {
        const r = e[n],
          i = n === e.length - 1;
        this._writer.write(r).then(() => {
          i &&
            $p(() => {
              ((this.writable = !0), this.emitReserved('drain'));
            }, this.setTimeoutFn);
        });
      }
    }
    doClose() {
      var e;
      (e = this._transport) === null || e === void 0 || e.close();
    }
  }
  const cH = {websocket: oH, webtransport: aH, polling: iH},
    lH =
      /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
    uH = [
      'source',
      'protocol',
      'authority',
      'userInfo',
      'user',
      'password',
      'host',
      'port',
      'relative',
      'path',
      'directory',
      'file',
      'query',
      'anchor'
    ];
  function Og(t) {
    if (t.length > 8e3) throw 'URI too long';
    const e = t,
      n = t.indexOf('['),
      r = t.indexOf(']');
    n != -1 &&
      r != -1 &&
      (t =
        t.substring(0, n) +
        t.substring(n, r).replace(/:/g, ';') +
        t.substring(r, t.length));
    let i = lH.exec(t || ''),
      s = {},
      o = 14;
    for (; o--; ) s[uH[o]] = i[o] || '';
    return (
      n != -1 &&
        r != -1 &&
        ((s.source = e),
        (s.host = s.host.substring(1, s.host.length - 1).replace(/;/g, ':')),
        (s.authority = s.authority
          .replace('[', '')
          .replace(']', '')
          .replace(/;/g, ':')),
        (s.ipv6uri = !0)),
      (s.pathNames = dH(s, s.path)),
      (s.queryKey = fH(s, s.query)),
      s
    );
  }
  function dH(t, e) {
    const n = /\/{2,9}/g,
      r = e.replace(n, '/').split('/');
    return (
      (e.slice(0, 1) == '/' || e.length === 0) && r.splice(0, 1),
      e.slice(-1) == '/' && r.splice(r.length - 1, 1),
      r
    );
  }
  function fH(t, e) {
    const n = {};
    return (
      e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function (r, i, s) {
        i && (n[i] = s);
      }),
      n
    );
  }
  const Ng =
      typeof addEventListener == 'function' &&
      typeof removeEventListener == 'function',
    Jd = [];
  Ng &&
    addEventListener(
      'offline',
      () => {
        Jd.forEach((t) => t());
      },
      !1
    );
  class zs extends Nt {
    constructor(e, n) {
      if (
        (super(),
        (this.binaryType = q$),
        (this.writeBuffer = []),
        (this._prevBufferLen = 0),
        (this._pingInterval = -1),
        (this._pingTimeout = -1),
        (this._maxPayload = -1),
        (this._pingTimeoutTime = 1 / 0),
        e && typeof e == 'object' && ((n = e), (e = null)),
        e)
      ) {
        const r = Og(e);
        ((n.hostname = r.host),
          (n.secure = r.protocol === 'https' || r.protocol === 'wss'),
          (n.port = r.port),
          r.query && (n.query = r.query));
      } else n.host && (n.hostname = Og(n.host).host);
      (Hp(this, n),
        (this.secure =
          n.secure != null
            ? n.secure
            : typeof location < 'u' && location.protocol === 'https:'),
        n.hostname && !n.port && (n.port = this.secure ? '443' : '80'),
        (this.hostname =
          n.hostname ||
          (typeof location < 'u' ? location.hostname : 'localhost')),
        (this.port =
          n.port ||
          (typeof location < 'u' && location.port
            ? location.port
            : this.secure
              ? '443'
              : '80')),
        (this.transports = []),
        (this._transportsByName = {}),
        n.transports.forEach((r) => {
          const i = r.prototype.name;
          (this.transports.push(i), (this._transportsByName[i] = r));
        }),
        (this.opts = Object.assign(
          {
            path: '/engine.io',
            agent: !1,
            withCredentials: !1,
            upgrade: !0,
            timestampParam: 't',
            rememberUpgrade: !1,
            addTrailingSlash: !0,
            rejectUnauthorized: !0,
            perMessageDeflate: {threshold: 1024},
            transportOptions: {},
            closeOnBeforeunload: !1
          },
          n
        )),
        (this.opts.path =
          this.opts.path.replace(/\/$/, '') +
          (this.opts.addTrailingSlash ? '/' : '')),
        typeof this.opts.query == 'string' &&
          (this.opts.query = Q$(this.opts.query)),
        Ng &&
          (this.opts.closeOnBeforeunload &&
            ((this._beforeunloadEventListener = () => {
              this.transport &&
                (this.transport.removeAllListeners(), this.transport.close());
            }),
            addEventListener(
              'beforeunload',
              this._beforeunloadEventListener,
              !1
            )),
          this.hostname !== 'localhost' &&
            ((this._offlineEventListener = () => {
              this._onClose('transport close', {
                description: 'network connection lost'
              });
            }),
            Jd.push(this._offlineEventListener))),
        this.opts.withCredentials && (this._cookieJar = void 0),
        this._open());
    }
    createTransport(e) {
      const n = Object.assign({}, this.opts.query);
      ((n.EIO = tC), (n.transport = e), this.id && (n.sid = this.id));
      const r = Object.assign(
        {},
        this.opts,
        {
          query: n,
          socket: this,
          hostname: this.hostname,
          secure: this.secure,
          port: this.port
        },
        this.opts.transportOptions[e]
      );
      return new this._transportsByName[e](r);
    }
    _open() {
      if (this.transports.length === 0) {
        this.setTimeoutFn(() => {
          this.emitReserved('error', 'No transports available');
        }, 0);
        return;
      }
      const e =
        this.opts.rememberUpgrade &&
        zs.priorWebsocketSuccess &&
        this.transports.indexOf('websocket') !== -1
          ? 'websocket'
          : this.transports[0];
      this.readyState = 'opening';
      const n = this.createTransport(e);
      (n.open(), this.setTransport(n));
    }
    setTransport(e) {
      (this.transport && this.transport.removeAllListeners(),
        (this.transport = e),
        e
          .on('drain', this._onDrain.bind(this))
          .on('packet', this._onPacket.bind(this))
          .on('error', this._onError.bind(this))
          .on('close', (n) => this._onClose('transport close', n)));
    }
    onOpen() {
      ((this.readyState = 'open'),
        (zs.priorWebsocketSuccess = this.transport.name === 'websocket'),
        this.emitReserved('open'),
        this.flush());
    }
    _onPacket(e) {
      if (
        this.readyState === 'opening' ||
        this.readyState === 'open' ||
        this.readyState === 'closing'
      )
        switch (
          (this.emitReserved('packet', e),
          this.emitReserved('heartbeat'),
          e.type)
        ) {
          case 'open':
            this.onHandshake(JSON.parse(e.data));
            break;
          case 'ping':
            (this._sendPacket('pong'),
              this.emitReserved('ping'),
              this.emitReserved('pong'),
              this._resetPingTimeout());
            break;
          case 'error':
            const n = new Error('server error');
            ((n.code = e.data), this._onError(n));
            break;
          case 'message':
            (this.emitReserved('data', e.data),
              this.emitReserved('message', e.data));
            break;
        }
    }
    onHandshake(e) {
      (this.emitReserved('handshake', e),
        (this.id = e.sid),
        (this.transport.query.sid = e.sid),
        (this._pingInterval = e.pingInterval),
        (this._pingTimeout = e.pingTimeout),
        (this._maxPayload = e.maxPayload),
        this.onOpen(),
        this.readyState !== 'closed' && this._resetPingTimeout());
    }
    _resetPingTimeout() {
      this.clearTimeoutFn(this._pingTimeoutTimer);
      const e = this._pingInterval + this._pingTimeout;
      ((this._pingTimeoutTime = Date.now() + e),
        (this._pingTimeoutTimer = this.setTimeoutFn(() => {
          this._onClose('ping timeout');
        }, e)),
        this.opts.autoUnref && this._pingTimeoutTimer.unref());
    }
    _onDrain() {
      (this.writeBuffer.splice(0, this._prevBufferLen),
        (this._prevBufferLen = 0),
        this.writeBuffer.length === 0
          ? this.emitReserved('drain')
          : this.flush());
    }
    flush() {
      if (
        this.readyState !== 'closed' &&
        this.transport.writable &&
        !this.upgrading &&
        this.writeBuffer.length
      ) {
        const e = this._getWritablePackets();
        (this.transport.send(e),
          (this._prevBufferLen = e.length),
          this.emitReserved('flush'));
      }
    }
    _getWritablePackets() {
      if (
        !(
          this._maxPayload &&
          this.transport.name === 'polling' &&
          this.writeBuffer.length > 1
        )
      )
        return this.writeBuffer;
      let n = 1;
      for (let r = 0; r < this.writeBuffer.length; r++) {
        const i = this.writeBuffer[r].data;
        if ((i && (n += W$(i)), r > 0 && n > this._maxPayload))
          return this.writeBuffer.slice(0, r);
        n += 2;
      }
      return this.writeBuffer;
    }
    _hasPingExpired() {
      if (!this._pingTimeoutTime) return !0;
      const e = Date.now() > this._pingTimeoutTime;
      return (
        e &&
          ((this._pingTimeoutTime = 0),
          $p(() => {
            this._onClose('ping timeout');
          }, this.setTimeoutFn)),
        e
      );
    }
    write(e, n, r) {
      return (this._sendPacket('message', e, n, r), this);
    }
    send(e, n, r) {
      return (this._sendPacket('message', e, n, r), this);
    }
    _sendPacket(e, n, r, i) {
      if (
        (typeof n == 'function' && ((i = n), (n = void 0)),
        typeof r == 'function' && ((i = r), (r = null)),
        this.readyState === 'closing' || this.readyState === 'closed')
      )
        return;
      ((r = r || {}), (r.compress = r.compress !== !1));
      const s = {type: e, data: n, options: r};
      (this.emitReserved('packetCreate', s),
        this.writeBuffer.push(s),
        i && this.once('flush', i),
        this.flush());
    }
    close() {
      const e = () => {
          (this._onClose('forced close'), this.transport.close());
        },
        n = () => {
          (this.off('upgrade', n), this.off('upgradeError', n), e());
        },
        r = () => {
          (this.once('upgrade', n), this.once('upgradeError', n));
        };
      return (
        (this.readyState === 'opening' || this.readyState === 'open') &&
          ((this.readyState = 'closing'),
          this.writeBuffer.length
            ? this.once('drain', () => {
                this.upgrading ? r() : e();
              })
            : this.upgrading
              ? r()
              : e()),
        this
      );
    }
    _onError(e) {
      if (
        ((zs.priorWebsocketSuccess = !1),
        this.opts.tryAllTransports &&
          this.transports.length > 1 &&
          this.readyState === 'opening')
      )
        return (this.transports.shift(), this._open());
      (this.emitReserved('error', e), this._onClose('transport error', e));
    }
    _onClose(e, n) {
      if (
        this.readyState === 'opening' ||
        this.readyState === 'open' ||
        this.readyState === 'closing'
      ) {
        if (
          (this.clearTimeoutFn(this._pingTimeoutTimer),
          this.transport.removeAllListeners('close'),
          this.transport.close(),
          this.transport.removeAllListeners(),
          Ng &&
            (this._beforeunloadEventListener &&
              removeEventListener(
                'beforeunload',
                this._beforeunloadEventListener,
                !1
              ),
            this._offlineEventListener))
        ) {
          const r = Jd.indexOf(this._offlineEventListener);
          r !== -1 && Jd.splice(r, 1);
        }
        ((this.readyState = 'closed'),
          (this.id = null),
          this.emitReserved('close', e, n),
          (this.writeBuffer = []),
          (this._prevBufferLen = 0));
      }
    }
  }
  zs.protocol = tC;
  class hH extends zs {
    constructor() {
      (super(...arguments), (this._upgrades = []));
    }
    onOpen() {
      if ((super.onOpen(), this.readyState === 'open' && this.opts.upgrade))
        for (let e = 0; e < this._upgrades.length; e++)
          this._probe(this._upgrades[e]);
    }
    _probe(e) {
      let n = this.createTransport(e),
        r = !1;
      zs.priorWebsocketSuccess = !1;
      const i = () => {
        r ||
          (n.send([{type: 'ping', data: 'probe'}]),
          n.once('packet', (d) => {
            if (!r)
              if (d.type === 'pong' && d.data === 'probe') {
                if (
                  ((this.upgrading = !0), this.emitReserved('upgrading', n), !n)
                )
                  return;
                ((zs.priorWebsocketSuccess = n.name === 'websocket'),
                  this.transport.pause(() => {
                    r ||
                      (this.readyState !== 'closed' &&
                        (u(),
                        this.setTransport(n),
                        n.send([{type: 'upgrade'}]),
                        this.emitReserved('upgrade', n),
                        (n = null),
                        (this.upgrading = !1),
                        this.flush()));
                  }));
              } else {
                const f = new Error('probe error');
                ((f.transport = n.name), this.emitReserved('upgradeError', f));
              }
          }));
      };
      function s() {
        r || ((r = !0), u(), n.close(), (n = null));
      }
      const o = (d) => {
        const f = new Error('probe error: ' + d);
        ((f.transport = n.name), s(), this.emitReserved('upgradeError', f));
      };
      function a() {
        o('transport closed');
      }
      function c() {
        o('socket closed');
      }
      function l(d) {
        n && d.name !== n.name && s();
      }
      const u = () => {
        (n.removeListener('open', i),
          n.removeListener('error', o),
          n.removeListener('close', a),
          this.off('close', c),
          this.off('upgrading', l));
      };
      (n.once('open', i),
        n.once('error', o),
        n.once('close', a),
        this.once('close', c),
        this.once('upgrading', l),
        this._upgrades.indexOf('webtransport') !== -1 && e !== 'webtransport'
          ? this.setTimeoutFn(() => {
              r || n.open();
            }, 200)
          : n.open());
    }
    onHandshake(e) {
      ((this._upgrades = this._filterUpgrades(e.upgrades)),
        super.onHandshake(e));
    }
    _filterUpgrades(e) {
      const n = [];
      for (let r = 0; r < e.length; r++)
        ~this.transports.indexOf(e[r]) && n.push(e[r]);
      return n;
    }
  }
  let pH = class extends hH {
    constructor(e, n = {}) {
      const r = typeof e == 'object' ? e : n;
      ((!r.transports ||
        (r.transports && typeof r.transports[0] == 'string')) &&
        (r.transports = (
          r.transports || ['polling', 'websocket', 'webtransport']
        )
          .map((i) => cH[i])
          .filter((i) => !!i)),
        super(e, r));
    }
  };
  function mH(t, e = '', n) {
    let r = t;
    ((n = n || (typeof location < 'u' && location)),
      t == null && (t = n.protocol + '//' + n.host),
      typeof t == 'string' &&
        (t.charAt(0) === '/' &&
          (t.charAt(1) === '/' ? (t = n.protocol + t) : (t = n.host + t)),
        /^(https?|wss?):\/\//.test(t) ||
          (typeof n < 'u' ? (t = n.protocol + '//' + t) : (t = 'https://' + t)),
        (r = Og(t))),
      r.port ||
        (/^(http|ws)$/.test(r.protocol)
          ? (r.port = '80')
          : /^(http|ws)s$/.test(r.protocol) && (r.port = '443')),
      (r.path = r.path || '/'));
    const s = r.host.indexOf(':') !== -1 ? '[' + r.host + ']' : r.host;
    return (
      (r.id = r.protocol + '://' + s + ':' + r.port + e),
      (r.href =
        r.protocol + '://' + s + (n && n.port === r.port ? '' : ':' + r.port)),
      r
    );
  }
  const gH = typeof ArrayBuffer == 'function',
    yH = (t) =>
      typeof ArrayBuffer.isView == 'function'
        ? ArrayBuffer.isView(t)
        : t.buffer instanceof ArrayBuffer,
    aC = Object.prototype.toString,
    vH =
      typeof Blob == 'function' ||
      (typeof Blob < 'u' && aC.call(Blob) === '[object BlobConstructor]'),
    bH =
      typeof File == 'function' ||
      (typeof File < 'u' && aC.call(File) === '[object FileConstructor]');
  function Kv(t) {
    return (
      (gH && (t instanceof ArrayBuffer || yH(t))) ||
      (vH && t instanceof Blob) ||
      (bH && t instanceof File)
    );
  }
  function Xd(t, e) {
    if (!t || typeof t != 'object') return !1;
    if (Array.isArray(t)) {
      for (let n = 0, r = t.length; n < r; n++) if (Xd(t[n])) return !0;
      return !1;
    }
    if (Kv(t)) return !0;
    if (t.toJSON && typeof t.toJSON == 'function' && arguments.length === 1)
      return Xd(t.toJSON(), !0);
    for (const n in t)
      if (Object.prototype.hasOwnProperty.call(t, n) && Xd(t[n])) return !0;
    return !1;
  }
  function wH(t) {
    const e = [],
      n = t.data,
      r = t;
    return (
      (r.data = Lg(n, e)),
      (r.attachments = e.length),
      {packet: r, buffers: e}
    );
  }
  function Lg(t, e) {
    if (!t) return t;
    if (Kv(t)) {
      const n = {_placeholder: !0, num: e.length};
      return (e.push(t), n);
    } else if (Array.isArray(t)) {
      const n = new Array(t.length);
      for (let r = 0; r < t.length; r++) n[r] = Lg(t[r], e);
      return n;
    } else if (typeof t == 'object' && !(t instanceof Date)) {
      const n = {};
      for (const r in t)
        Object.prototype.hasOwnProperty.call(t, r) && (n[r] = Lg(t[r], e));
      return n;
    }
    return t;
  }
  function _H(t, e) {
    return ((t.data = Bg(t.data, e)), delete t.attachments, t);
  }
  function Bg(t, e) {
    if (!t) return t;
    if (t && t._placeholder === !0) {
      if (typeof t.num == 'number' && t.num >= 0 && t.num < e.length)
        return e[t.num];
      throw new Error('illegal attachments');
    } else if (Array.isArray(t))
      for (let n = 0; n < t.length; n++) t[n] = Bg(t[n], e);
    else if (typeof t == 'object')
      for (const n in t)
        Object.prototype.hasOwnProperty.call(t, n) && (t[n] = Bg(t[n], e));
    return t;
  }
  const EH = [
      'connect',
      'connect_error',
      'disconnect',
      'disconnecting',
      'newListener',
      'removeListener'
    ],
    AH = 5;
  var Ye;
  (function (t) {
    ((t[(t.CONNECT = 0)] = 'CONNECT'),
      (t[(t.DISCONNECT = 1)] = 'DISCONNECT'),
      (t[(t.EVENT = 2)] = 'EVENT'),
      (t[(t.ACK = 3)] = 'ACK'),
      (t[(t.CONNECT_ERROR = 4)] = 'CONNECT_ERROR'),
      (t[(t.BINARY_EVENT = 5)] = 'BINARY_EVENT'),
      (t[(t.BINARY_ACK = 6)] = 'BINARY_ACK'));
  })(Ye || (Ye = {}));
  class SH {
    constructor(e) {
      this.replacer = e;
    }
    encode(e) {
      return (e.type === Ye.EVENT || e.type === Ye.ACK) && Xd(e)
        ? this.encodeAsBinary({
            type: e.type === Ye.EVENT ? Ye.BINARY_EVENT : Ye.BINARY_ACK,
            nsp: e.nsp,
            data: e.data,
            id: e.id
          })
        : [this.encodeAsString(e)];
    }
    encodeAsString(e) {
      let n = '' + e.type;
      return (
        (e.type === Ye.BINARY_EVENT || e.type === Ye.BINARY_ACK) &&
          (n += e.attachments + '-'),
        e.nsp && e.nsp !== '/' && (n += e.nsp + ','),
        e.id != null && (n += e.id),
        e.data != null && (n += JSON.stringify(e.data, this.replacer)),
        n
      );
    }
    encodeAsBinary(e) {
      const n = wH(e),
        r = this.encodeAsString(n.packet),
        i = n.buffers;
      return (i.unshift(r), i);
    }
  }
  function Xw(t) {
    return Object.prototype.toString.call(t) === '[object Object]';
  }
  class qv extends Nt {
    constructor(e) {
      (super(), (this.reviver = e));
    }
    add(e) {
      let n;
      if (typeof e == 'string') {
        if (this.reconstructor)
          throw new Error('got plaintext data when reconstructing a packet');
        n = this.decodeString(e);
        const r = n.type === Ye.BINARY_EVENT;
        r || n.type === Ye.BINARY_ACK
          ? ((n.type = r ? Ye.EVENT : Ye.ACK),
            (this.reconstructor = new xH(n)),
            n.attachments === 0 && super.emitReserved('decoded', n))
          : super.emitReserved('decoded', n);
      } else if (Kv(e) || e.base64)
        if (this.reconstructor)
          ((n = this.reconstructor.takeBinaryData(e)),
            n &&
              ((this.reconstructor = null), super.emitReserved('decoded', n)));
        else
          throw new Error('got binary data when not reconstructing a packet');
      else throw new Error('Unknown type: ' + e);
    }
    decodeString(e) {
      let n = 0;
      const r = {type: Number(e.charAt(0))};
      if (Ye[r.type] === void 0)
        throw new Error('unknown packet type ' + r.type);
      if (r.type === Ye.BINARY_EVENT || r.type === Ye.BINARY_ACK) {
        const s = n + 1;
        for (; e.charAt(++n) !== '-' && n != e.length; );
        const o = e.substring(s, n);
        if (o != Number(o) || e.charAt(n) !== '-')
          throw new Error('Illegal attachments');
        r.attachments = Number(o);
      }
      if (e.charAt(n + 1) === '/') {
        const s = n + 1;
        for (; ++n && !(e.charAt(n) === ',' || n === e.length); );
        r.nsp = e.substring(s, n);
      } else r.nsp = '/';
      const i = e.charAt(n + 1);
      if (i !== '' && Number(i) == i) {
        const s = n + 1;
        for (; ++n; ) {
          const o = e.charAt(n);
          if (o == null || Number(o) != o) {
            --n;
            break;
          }
          if (n === e.length) break;
        }
        r.id = Number(e.substring(s, n + 1));
      }
      if (e.charAt(++n)) {
        const s = this.tryParse(e.substr(n));
        if (qv.isPayloadValid(r.type, s)) r.data = s;
        else throw new Error('invalid payload');
      }
      return r;
    }
    tryParse(e) {
      try {
        return JSON.parse(e, this.reviver);
      } catch {
        return !1;
      }
    }
    static isPayloadValid(e, n) {
      switch (e) {
        case Ye.CONNECT:
          return Xw(n);
        case Ye.DISCONNECT:
          return n === void 0;
        case Ye.CONNECT_ERROR:
          return typeof n == 'string' || Xw(n);
        case Ye.EVENT:
        case Ye.BINARY_EVENT:
          return (
            Array.isArray(n) &&
            (typeof n[0] == 'number' ||
              (typeof n[0] == 'string' && EH.indexOf(n[0]) === -1))
          );
        case Ye.ACK:
        case Ye.BINARY_ACK:
          return Array.isArray(n);
      }
    }
    destroy() {
      this.reconstructor &&
        (this.reconstructor.finishedReconstruction(),
        (this.reconstructor = null));
    }
  }
  class xH {
    constructor(e) {
      ((this.packet = e), (this.buffers = []), (this.reconPack = e));
    }
    takeBinaryData(e) {
      if (
        (this.buffers.push(e),
        this.buffers.length === this.reconPack.attachments)
      ) {
        const n = _H(this.reconPack, this.buffers);
        return (this.finishedReconstruction(), n);
      }
      return null;
    }
    finishedReconstruction() {
      ((this.reconPack = null), (this.buffers = []));
    }
  }
  const CH = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Decoder: qv,
        Encoder: SH,
        get PacketType() {
          return Ye;
        },
        protocol: AH
      },
      Symbol.toStringTag,
      {value: 'Module'}
    )
  );
  function Ir(t, e, n) {
    return (
      t.on(e, n),
      function () {
        t.off(e, n);
      }
    );
  }
  const TH = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    newListener: 1,
    removeListener: 1
  });
  class cC extends Nt {
    constructor(e, n, r) {
      (super(),
        (this.connected = !1),
        (this.recovered = !1),
        (this.receiveBuffer = []),
        (this.sendBuffer = []),
        (this._queue = []),
        (this._queueSeq = 0),
        (this.ids = 0),
        (this.acks = {}),
        (this.flags = {}),
        (this.io = e),
        (this.nsp = n),
        r && r.auth && (this.auth = r.auth),
        (this._opts = Object.assign({}, r)),
        this.io._autoConnect && this.open());
    }
    get disconnected() {
      return !this.connected;
    }
    subEvents() {
      if (this.subs) return;
      const e = this.io;
      this.subs = [
        Ir(e, 'open', this.onopen.bind(this)),
        Ir(e, 'packet', this.onpacket.bind(this)),
        Ir(e, 'error', this.onerror.bind(this)),
        Ir(e, 'close', this.onclose.bind(this))
      ];
    }
    get active() {
      return !!this.subs;
    }
    connect() {
      return this.connected
        ? this
        : (this.subEvents(),
          this.io._reconnecting || this.io.open(),
          this.io._readyState === 'open' && this.onopen(),
          this);
    }
    open() {
      return this.connect();
    }
    send(...e) {
      return (e.unshift('message'), this.emit.apply(this, e), this);
    }
    emit(e, ...n) {
      var r, i, s;
      if (TH.hasOwnProperty(e))
        throw new Error('"' + e.toString() + '" is a reserved event name');
      if (
        (n.unshift(e),
        this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
      )
        return (this._addToQueue(n), this);
      const o = {type: Ye.EVENT, data: n};
      if (
        ((o.options = {}),
        (o.options.compress = this.flags.compress !== !1),
        typeof n[n.length - 1] == 'function')
      ) {
        const u = this.ids++,
          d = n.pop();
        (this._registerAckCallback(u, d), (o.id = u));
      }
      const a =
          (i =
            (r = this.io.engine) === null || r === void 0
              ? void 0
              : r.transport) === null || i === void 0
            ? void 0
            : i.writable,
        c =
          this.connected &&
          !(
            !((s = this.io.engine) === null || s === void 0) &&
            s._hasPingExpired()
          );
      return (
        (this.flags.volatile && !a) ||
          (c
            ? (this.notifyOutgoingListeners(o), this.packet(o))
            : this.sendBuffer.push(o)),
        (this.flags = {}),
        this
      );
    }
    _registerAckCallback(e, n) {
      var r;
      const i =
        (r = this.flags.timeout) !== null && r !== void 0
          ? r
          : this._opts.ackTimeout;
      if (i === void 0) {
        this.acks[e] = n;
        return;
      }
      const s = this.io.setTimeoutFn(() => {
          delete this.acks[e];
          for (let a = 0; a < this.sendBuffer.length; a++)
            this.sendBuffer[a].id === e && this.sendBuffer.splice(a, 1);
          n.call(this, new Error('operation has timed out'));
        }, i),
        o = (...a) => {
          (this.io.clearTimeoutFn(s), n.apply(this, a));
        };
      ((o.withError = !0), (this.acks[e] = o));
    }
    emitWithAck(e, ...n) {
      return new Promise((r, i) => {
        const s = (o, a) => (o ? i(o) : r(a));
        ((s.withError = !0), n.push(s), this.emit(e, ...n));
      });
    }
    _addToQueue(e) {
      let n;
      typeof e[e.length - 1] == 'function' && (n = e.pop());
      const r = {
        id: this._queueSeq++,
        tryCount: 0,
        pending: !1,
        args: e,
        flags: Object.assign({fromQueue: !0}, this.flags)
      };
      (e.push((i, ...s) =>
        r !== this._queue[0]
          ? void 0
          : (i !== null
              ? r.tryCount > this._opts.retries &&
                (this._queue.shift(), n && n(i))
              : (this._queue.shift(), n && n(null, ...s)),
            (r.pending = !1),
            this._drainQueue())
      ),
        this._queue.push(r),
        this._drainQueue());
    }
    _drainQueue(e = !1) {
      if (!this.connected || this._queue.length === 0) return;
      const n = this._queue[0];
      (n.pending && !e) ||
        ((n.pending = !0),
        n.tryCount++,
        (this.flags = n.flags),
        this.emit.apply(this, n.args));
    }
    packet(e) {
      ((e.nsp = this.nsp), this.io._packet(e));
    }
    onopen() {
      typeof this.auth == 'function'
        ? this.auth((e) => {
            this._sendConnectPacket(e);
          })
        : this._sendConnectPacket(this.auth);
    }
    _sendConnectPacket(e) {
      this.packet({
        type: Ye.CONNECT,
        data: this._pid
          ? Object.assign({pid: this._pid, offset: this._lastOffset}, e)
          : e
      });
    }
    onerror(e) {
      this.connected || this.emitReserved('connect_error', e);
    }
    onclose(e, n) {
      ((this.connected = !1),
        delete this.id,
        this.emitReserved('disconnect', e, n),
        this._clearAcks());
    }
    _clearAcks() {
      Object.keys(this.acks).forEach((e) => {
        if (!this.sendBuffer.some((r) => String(r.id) === e)) {
          const r = this.acks[e];
          (delete this.acks[e],
            r.withError &&
              r.call(this, new Error('socket has been disconnected')));
        }
      });
    }
    onpacket(e) {
      if (e.nsp === this.nsp)
        switch (e.type) {
          case Ye.CONNECT:
            e.data && e.data.sid
              ? this.onconnect(e.data.sid, e.data.pid)
              : this.emitReserved(
                  'connect_error',
                  new Error(
                    'It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)'
                  )
                );
            break;
          case Ye.EVENT:
          case Ye.BINARY_EVENT:
            this.onevent(e);
            break;
          case Ye.ACK:
          case Ye.BINARY_ACK:
            this.onack(e);
            break;
          case Ye.DISCONNECT:
            this.ondisconnect();
            break;
          case Ye.CONNECT_ERROR:
            this.destroy();
            const r = new Error(e.data.message);
            ((r.data = e.data.data), this.emitReserved('connect_error', r));
            break;
        }
    }
    onevent(e) {
      const n = e.data || [];
      (e.id != null && n.push(this.ack(e.id)),
        this.connected
          ? this.emitEvent(n)
          : this.receiveBuffer.push(Object.freeze(n)));
    }
    emitEvent(e) {
      if (this._anyListeners && this._anyListeners.length) {
        const n = this._anyListeners.slice();
        for (const r of n) r.apply(this, e);
      }
      (super.emit.apply(this, e),
        this._pid &&
          e.length &&
          typeof e[e.length - 1] == 'string' &&
          (this._lastOffset = e[e.length - 1]));
    }
    ack(e) {
      const n = this;
      let r = !1;
      return function (...i) {
        r || ((r = !0), n.packet({type: Ye.ACK, id: e, data: i}));
      };
    }
    onack(e) {
      const n = this.acks[e.id];
      typeof n == 'function' &&
        (delete this.acks[e.id],
        n.withError && e.data.unshift(null),
        n.apply(this, e.data));
    }
    onconnect(e, n) {
      ((this.id = e),
        (this.recovered = n && this._pid === n),
        (this._pid = n),
        (this.connected = !0),
        this.emitBuffered(),
        this.emitReserved('connect'),
        this._drainQueue(!0));
    }
    emitBuffered() {
      (this.receiveBuffer.forEach((e) => this.emitEvent(e)),
        (this.receiveBuffer = []),
        this.sendBuffer.forEach((e) => {
          (this.notifyOutgoingListeners(e), this.packet(e));
        }),
        (this.sendBuffer = []));
    }
    ondisconnect() {
      (this.destroy(), this.onclose('io server disconnect'));
    }
    destroy() {
      (this.subs && (this.subs.forEach((e) => e()), (this.subs = void 0)),
        this.io._destroy(this));
    }
    disconnect() {
      return (
        this.connected && this.packet({type: Ye.DISCONNECT}),
        this.destroy(),
        this.connected && this.onclose('io client disconnect'),
        this
      );
    }
    close() {
      return this.disconnect();
    }
    compress(e) {
      return ((this.flags.compress = e), this);
    }
    get volatile() {
      return ((this.flags.volatile = !0), this);
    }
    timeout(e) {
      return ((this.flags.timeout = e), this);
    }
    onAny(e) {
      return (
        (this._anyListeners = this._anyListeners || []),
        this._anyListeners.push(e),
        this
      );
    }
    prependAny(e) {
      return (
        (this._anyListeners = this._anyListeners || []),
        this._anyListeners.unshift(e),
        this
      );
    }
    offAny(e) {
      if (!this._anyListeners) return this;
      if (e) {
        const n = this._anyListeners;
        for (let r = 0; r < n.length; r++)
          if (e === n[r]) return (n.splice(r, 1), this);
      } else this._anyListeners = [];
      return this;
    }
    listenersAny() {
      return this._anyListeners || [];
    }
    onAnyOutgoing(e) {
      return (
        (this._anyOutgoingListeners = this._anyOutgoingListeners || []),
        this._anyOutgoingListeners.push(e),
        this
      );
    }
    prependAnyOutgoing(e) {
      return (
        (this._anyOutgoingListeners = this._anyOutgoingListeners || []),
        this._anyOutgoingListeners.unshift(e),
        this
      );
    }
    offAnyOutgoing(e) {
      if (!this._anyOutgoingListeners) return this;
      if (e) {
        const n = this._anyOutgoingListeners;
        for (let r = 0; r < n.length; r++)
          if (e === n[r]) return (n.splice(r, 1), this);
      } else this._anyOutgoingListeners = [];
      return this;
    }
    listenersAnyOutgoing() {
      return this._anyOutgoingListeners || [];
    }
    notifyOutgoingListeners(e) {
      if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
        const n = this._anyOutgoingListeners.slice();
        for (const r of n) r.apply(this, e.data);
      }
    }
  }
  function Bc(t) {
    ((t = t || {}),
      (this.ms = t.min || 100),
      (this.max = t.max || 1e4),
      (this.factor = t.factor || 2),
      (this.jitter = t.jitter > 0 && t.jitter <= 1 ? t.jitter : 0),
      (this.attempts = 0));
  }
  Bc.prototype.duration = function () {
    var t = this.ms * Math.pow(this.factor, this.attempts++);
    if (this.jitter) {
      var e = Math.random(),
        n = Math.floor(e * this.jitter * t);
      t = (Math.floor(e * 10) & 1) == 0 ? t - n : t + n;
    }
    return Math.min(t, this.max) | 0;
  };
  Bc.prototype.reset = function () {
    this.attempts = 0;
  };
  Bc.prototype.setMin = function (t) {
    this.ms = t;
  };
  Bc.prototype.setMax = function (t) {
    this.max = t;
  };
  Bc.prototype.setJitter = function (t) {
    this.jitter = t;
  };
  class Dg extends Nt {
    constructor(e, n) {
      var r;
      (super(),
        (this.nsps = {}),
        (this.subs = []),
        e && typeof e == 'object' && ((n = e), (e = void 0)),
        (n = n || {}),
        (n.path = n.path || '/socket.io'),
        (this.opts = n),
        Hp(this, n),
        this.reconnection(n.reconnection !== !1),
        this.reconnectionAttempts(n.reconnectionAttempts || 1 / 0),
        this.reconnectionDelay(n.reconnectionDelay || 1e3),
        this.reconnectionDelayMax(n.reconnectionDelayMax || 5e3),
        this.randomizationFactor(
          (r = n.randomizationFactor) !== null && r !== void 0 ? r : 0.5
        ),
        (this.backoff = new Bc({
          min: this.reconnectionDelay(),
          max: this.reconnectionDelayMax(),
          jitter: this.randomizationFactor()
        })),
        this.timeout(n.timeout == null ? 2e4 : n.timeout),
        (this._readyState = 'closed'),
        (this.uri = e));
      const i = n.parser || CH;
      ((this.encoder = new i.Encoder()),
        (this.decoder = new i.Decoder()),
        (this._autoConnect = n.autoConnect !== !1),
        this._autoConnect && this.open());
    }
    reconnection(e) {
      return arguments.length
        ? ((this._reconnection = !!e), e || (this.skipReconnect = !0), this)
        : this._reconnection;
    }
    reconnectionAttempts(e) {
      return e === void 0
        ? this._reconnectionAttempts
        : ((this._reconnectionAttempts = e), this);
    }
    reconnectionDelay(e) {
      var n;
      return e === void 0
        ? this._reconnectionDelay
        : ((this._reconnectionDelay = e),
          (n = this.backoff) === null || n === void 0 || n.setMin(e),
          this);
    }
    randomizationFactor(e) {
      var n;
      return e === void 0
        ? this._randomizationFactor
        : ((this._randomizationFactor = e),
          (n = this.backoff) === null || n === void 0 || n.setJitter(e),
          this);
    }
    reconnectionDelayMax(e) {
      var n;
      return e === void 0
        ? this._reconnectionDelayMax
        : ((this._reconnectionDelayMax = e),
          (n = this.backoff) === null || n === void 0 || n.setMax(e),
          this);
    }
    timeout(e) {
      return arguments.length ? ((this._timeout = e), this) : this._timeout;
    }
    maybeReconnectOnOpen() {
      !this._reconnecting &&
        this._reconnection &&
        this.backoff.attempts === 0 &&
        this.reconnect();
    }
    open(e) {
      if (~this._readyState.indexOf('open')) return this;
      this.engine = new pH(this.uri, this.opts);
      const n = this.engine,
        r = this;
      ((this._readyState = 'opening'), (this.skipReconnect = !1));
      const i = Ir(n, 'open', function () {
          (r.onopen(), e && e());
        }),
        s = (a) => {
          (this.cleanup(),
            (this._readyState = 'closed'),
            this.emitReserved('error', a),
            e ? e(a) : this.maybeReconnectOnOpen());
        },
        o = Ir(n, 'error', s);
      if (this._timeout !== !1) {
        const a = this._timeout,
          c = this.setTimeoutFn(() => {
            (i(), s(new Error('timeout')), n.close());
          }, a);
        (this.opts.autoUnref && c.unref(),
          this.subs.push(() => {
            this.clearTimeoutFn(c);
          }));
      }
      return (this.subs.push(i), this.subs.push(o), this);
    }
    connect(e) {
      return this.open(e);
    }
    onopen() {
      (this.cleanup(), (this._readyState = 'open'), this.emitReserved('open'));
      const e = this.engine;
      this.subs.push(
        Ir(e, 'ping', this.onping.bind(this)),
        Ir(e, 'data', this.ondata.bind(this)),
        Ir(e, 'error', this.onerror.bind(this)),
        Ir(e, 'close', this.onclose.bind(this)),
        Ir(this.decoder, 'decoded', this.ondecoded.bind(this))
      );
    }
    onping() {
      this.emitReserved('ping');
    }
    ondata(e) {
      try {
        this.decoder.add(e);
      } catch (n) {
        this.onclose('parse error', n);
      }
    }
    ondecoded(e) {
      $p(() => {
        this.emitReserved('packet', e);
      }, this.setTimeoutFn);
    }
    onerror(e) {
      this.emitReserved('error', e);
    }
    socket(e, n) {
      let r = this.nsps[e];
      return (
        r
          ? this._autoConnect && !r.active && r.connect()
          : ((r = new cC(this, e, n)), (this.nsps[e] = r)),
        r
      );
    }
    _destroy(e) {
      const n = Object.keys(this.nsps);
      for (const r of n) if (this.nsps[r].active) return;
      this._close();
    }
    _packet(e) {
      const n = this.encoder.encode(e);
      for (let r = 0; r < n.length; r++) this.engine.write(n[r], e.options);
    }
    cleanup() {
      (this.subs.forEach((e) => e()),
        (this.subs.length = 0),
        this.decoder.destroy());
    }
    _close() {
      ((this.skipReconnect = !0),
        (this._reconnecting = !1),
        this.onclose('forced close'));
    }
    disconnect() {
      return this._close();
    }
    onclose(e, n) {
      var r;
      (this.cleanup(),
        (r = this.engine) === null || r === void 0 || r.close(),
        this.backoff.reset(),
        (this._readyState = 'closed'),
        this.emitReserved('close', e, n),
        this._reconnection && !this.skipReconnect && this.reconnect());
    }
    reconnect() {
      if (this._reconnecting || this.skipReconnect) return this;
      const e = this;
      if (this.backoff.attempts >= this._reconnectionAttempts)
        (this.backoff.reset(),
          this.emitReserved('reconnect_failed'),
          (this._reconnecting = !1));
      else {
        const n = this.backoff.duration();
        this._reconnecting = !0;
        const r = this.setTimeoutFn(() => {
          e.skipReconnect ||
            (this.emitReserved('reconnect_attempt', e.backoff.attempts),
            !e.skipReconnect &&
              e.open((i) => {
                i
                  ? ((e._reconnecting = !1),
                    e.reconnect(),
                    this.emitReserved('reconnect_error', i))
                  : e.onreconnect();
              }));
        }, n);
        (this.opts.autoUnref && r.unref(),
          this.subs.push(() => {
            this.clearTimeoutFn(r);
          }));
      }
    }
    onreconnect() {
      const e = this.backoff.attempts;
      ((this._reconnecting = !1),
        this.backoff.reset(),
        this.emitReserved('reconnect', e));
    }
  }
  const zc = {};
  function ef(t, e) {
    (typeof t == 'object' && ((e = t), (t = void 0)), (e = e || {}));
    const n = mH(t, e.path || '/socket.io'),
      r = n.source,
      i = n.id,
      s = n.path,
      o = zc[i] && s in zc[i].nsps,
      a = e.forceNew || e['force new connection'] || e.multiplex === !1 || o;
    let c;
    return (
      a ? (c = new Dg(r, e)) : (zc[i] || (zc[i] = new Dg(r, e)), (c = zc[i])),
      n.query && !e.query && (e.query = n.queryKey),
      c.socket(n.path, e)
    );
  }
  Object.assign(ef, {Manager: Dg, Socket: cC, io: ef, connect: ef});
  function ue(t, e, n, r) {
    return new (n || (n = Promise))(function (i, s) {
      function o(l) {
        try {
          c(r.next(l));
        } catch (u) {
          s(u);
        }
      }
      function a(l) {
        try {
          c(r.throw(l));
        } catch (u) {
          s(u);
        }
      }
      function c(l) {
        var u;
        l.done
          ? i(l.value)
          : ((u = l.value),
            u instanceof n
              ? u
              : new n(function (d) {
                  d(u);
                })).then(o, a);
      }
      c((r = r.apply(t, e || [])).next());
    });
  }
  var kn =
      typeof global < 'u'
        ? global
        : typeof self < 'u'
          ? self
          : typeof window < 'u'
            ? window
            : {},
    ei = [],
    hr = [],
    IH = typeof Uint8Array < 'u' ? Uint8Array : Array,
    Vv = !1;
  function lC() {
    Vv = !0;
    for (
      var t =
          'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
        e = 0;
      e < 64;
      ++e
    )
      ((ei[e] = t[e]), (hr[t.charCodeAt(e)] = e));
    ((hr[45] = 62), (hr[95] = 63));
  }
  function kH(t, e, n) {
    for (var r, i, s = [], o = e; o < n; o += 3)
      ((r = (t[o] << 16) + (t[o + 1] << 8) + t[o + 2]),
        s.push(
          ei[((i = r) >> 18) & 63] +
            ei[(i >> 12) & 63] +
            ei[(i >> 6) & 63] +
            ei[63 & i]
        ));
    return s.join('');
  }
  function e_(t) {
    var e;
    Vv || lC();
    for (
      var n = t.length, r = n % 3, i = '', s = [], o = 16383, a = 0, c = n - r;
      a < c;
      a += o
    )
      s.push(kH(t, a, a + o > c ? c : a + o));
    return (
      r === 1
        ? ((e = t[n - 1]),
          (i += ei[e >> 2]),
          (i += ei[(e << 4) & 63]),
          (i += '=='))
        : r === 2 &&
          ((e = (t[n - 2] << 8) + t[n - 1]),
          (i += ei[e >> 10]),
          (i += ei[(e >> 4) & 63]),
          (i += ei[(e << 2) & 63]),
          (i += '=')),
      s.push(i),
      s.join('')
    );
  }
  function cd(t, e, n, r, i) {
    var s,
      o,
      a = 8 * i - r - 1,
      c = (1 << a) - 1,
      l = c >> 1,
      u = -7,
      d = n ? i - 1 : 0,
      f = n ? -1 : 1,
      h = t[e + d];
    for (
      d += f, s = h & ((1 << -u) - 1), h >>= -u, u += a;
      u > 0;
      s = 256 * s + t[e + d], d += f, u -= 8
    );
    for (
      o = s & ((1 << -u) - 1), s >>= -u, u += r;
      u > 0;
      o = 256 * o + t[e + d], d += f, u -= 8
    );
    if (s === 0) s = 1 - l;
    else {
      if (s === c) return o ? NaN : (1 / 0) * (h ? -1 : 1);
      ((o += Math.pow(2, r)), (s -= l));
    }
    return (h ? -1 : 1) * o * Math.pow(2, s - r);
  }
  function uC(t, e, n, r, i, s) {
    var o,
      a,
      c,
      l = 8 * s - i - 1,
      u = (1 << l) - 1,
      d = u >> 1,
      f = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
      h = r ? 0 : s - 1,
      g = r ? 1 : -1,
      m = e < 0 || (e === 0 && 1 / e < 0) ? 1 : 0;
    for (
      e = Math.abs(e),
        isNaN(e) || e === 1 / 0
          ? ((a = isNaN(e) ? 1 : 0), (o = u))
          : ((o = Math.floor(Math.log(e) / Math.LN2)),
            e * (c = Math.pow(2, -o)) < 1 && (o--, (c *= 2)),
            (e += o + d >= 1 ? f / c : f * Math.pow(2, 1 - d)) * c >= 2 &&
              (o++, (c /= 2)),
            o + d >= u
              ? ((a = 0), (o = u))
              : o + d >= 1
                ? ((a = (e * c - 1) * Math.pow(2, i)), (o += d))
                : ((a = e * Math.pow(2, d - 1) * Math.pow(2, i)), (o = 0)));
      i >= 8;
      t[n + h] = 255 & a, h += g, a /= 256, i -= 8
    );
    for (
      o = (o << i) | a, l += i;
      l > 0;
      t[n + h] = 255 & o, h += g, o /= 256, l -= 8
    );
    t[n + h - g] |= 128 * m;
  }
  var RH = {}.toString,
    dC =
      Array.isArray ||
      function (t) {
        return RH.call(t) == '[object Array]';
      };
  de.TYPED_ARRAY_SUPPORT =
    kn.TYPED_ARRAY_SUPPORT === void 0 || kn.TYPED_ARRAY_SUPPORT;
  var PH = Eh();
  function Eh() {
    return de.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
  }
  function Gi(t, e) {
    if (Eh() < e) throw new RangeError('Invalid typed array length');
    return (
      de.TYPED_ARRAY_SUPPORT
        ? ((t = new Uint8Array(e)).__proto__ = de.prototype)
        : (t === null && (t = new de(e)), (t.length = e)),
      t
    );
  }
  function de(t, e, n) {
    if (!(de.TYPED_ARRAY_SUPPORT || this instanceof de)) return new de(t, e, n);
    if (typeof t == 'number') {
      if (typeof e == 'string')
        throw new Error(
          'If encoding is specified then the first argument must be a string'
        );
      return Fg(this, t);
    }
    return fC(this, t, e, n);
  }
  function fC(t, e, n, r) {
    if (typeof e == 'number')
      throw new TypeError('"value" argument must not be a number');
    return typeof ArrayBuffer < 'u' && e instanceof ArrayBuffer
      ? (function (i, s, o, a) {
          if ((s.byteLength, o < 0 || s.byteLength < o))
            throw new RangeError("'offset' is out of bounds");
          if (s.byteLength < o + (a || 0))
            throw new RangeError("'length' is out of bounds");
          return (
            (s =
              o === void 0 && a === void 0
                ? new Uint8Array(s)
                : a === void 0
                  ? new Uint8Array(s, o)
                  : new Uint8Array(s, o, a)),
            de.TYPED_ARRAY_SUPPORT
              ? ((i = s).__proto__ = de.prototype)
              : (i = jm(i, s)),
            i
          );
        })(t, e, n, r)
      : typeof e == 'string'
        ? (function (i, s, o) {
            if (
              ((typeof o == 'string' && o !== '') || (o = 'utf8'),
              !de.isEncoding(o))
            )
              throw new TypeError('"encoding" must be a valid string encoding');
            var a = 0 | pC(s, o);
            i = Gi(i, a);
            var c = i.write(s, o);
            return (c !== a && (i = i.slice(0, c)), i);
          })(t, e, n)
        : (function (i, s) {
            if (ti(s)) {
              var o = 0 | Gv(s.length);
              return ((i = Gi(i, o)).length === 0 || s.copy(i, 0, 0, o), i);
            }
            if (s) {
              if (
                (typeof ArrayBuffer < 'u' && s.buffer instanceof ArrayBuffer) ||
                'length' in s
              )
                return typeof s.length != 'number' || (a = s.length) != a
                  ? Gi(i, 0)
                  : jm(i, s);
              if (s.type === 'Buffer' && dC(s.data)) return jm(i, s.data);
            }
            var a;
            throw new TypeError(
              'First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.'
            );
          })(t, e);
  }
  function hC(t) {
    if (typeof t != 'number')
      throw new TypeError('"size" argument must be a number');
    if (t < 0) throw new RangeError('"size" argument must not be negative');
  }
  function Fg(t, e) {
    if ((hC(e), (t = Gi(t, e < 0 ? 0 : 0 | Gv(e))), !de.TYPED_ARRAY_SUPPORT))
      for (var n = 0; n < e; ++n) t[n] = 0;
    return t;
  }
  function jm(t, e) {
    var n = e.length < 0 ? 0 : 0 | Gv(e.length);
    t = Gi(t, n);
    for (var r = 0; r < n; r += 1) t[r] = 255 & e[r];
    return t;
  }
  function Gv(t) {
    if (t >= Eh())
      throw new RangeError(
        'Attempt to allocate Buffer larger than maximum size: 0x' +
          Eh().toString(16) +
          ' bytes'
      );
    return 0 | t;
  }
  function ti(t) {
    return !(t == null || !t._isBuffer);
  }
  function pC(t, e) {
    if (ti(t)) return t.length;
    if (
      typeof ArrayBuffer < 'u' &&
      typeof ArrayBuffer.isView == 'function' &&
      (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)
    )
      return t.byteLength;
    typeof t != 'string' && (t = '' + t);
    var n = t.length;
    if (n === 0) return 0;
    for (var r = !1; ; )
      switch (e) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return n;
        case 'utf8':
        case 'utf-8':
        case void 0:
          return Ah(t).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return 2 * n;
        case 'hex':
          return n >>> 1;
        case 'base64':
          return vC(t).length;
        default:
          if (r) return Ah(t).length;
          ((e = ('' + e).toLowerCase()), (r = !0));
      }
  }
  function MH(t, e, n) {
    var r = !1;
    if (
      ((e === void 0 || e < 0) && (e = 0),
      e > this.length ||
        ((n === void 0 || n > this.length) && (n = this.length), n <= 0) ||
        (n >>>= 0) <= (e >>>= 0))
    )
      return '';
    for (t || (t = 'utf8'); ; )
      switch (t) {
        case 'hex':
          return jH(this, e, n);
        case 'utf8':
        case 'utf-8':
          return gC(this, e, n);
        case 'ascii':
          return $H(this, e, n);
        case 'latin1':
        case 'binary':
          return HH(this, e, n);
        case 'base64':
          return FH(this, e, n);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return UH(this, e, n);
        default:
          if (r) throw new TypeError('Unknown encoding: ' + t);
          ((t = (t + '').toLowerCase()), (r = !0));
      }
  }
  function yo(t, e, n) {
    var r = t[e];
    ((t[e] = t[n]), (t[n] = r));
  }
  function t_(t, e, n, r, i) {
    if (t.length === 0) return -1;
    if (
      (typeof n == 'string'
        ? ((r = n), (n = 0))
        : n > 2147483647
          ? (n = 2147483647)
          : n < -2147483648 && (n = -2147483648),
      (n = +n),
      isNaN(n) && (n = i ? 0 : t.length - 1),
      n < 0 && (n = t.length + n),
      n >= t.length)
    ) {
      if (i) return -1;
      n = t.length - 1;
    } else if (n < 0) {
      if (!i) return -1;
      n = 0;
    }
    if ((typeof e == 'string' && (e = de.from(e, r)), ti(e)))
      return e.length === 0 ? -1 : n_(t, e, n, r, i);
    if (typeof e == 'number')
      return (
        (e &= 255),
        de.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf == 'function'
          ? i
            ? Uint8Array.prototype.indexOf.call(t, e, n)
            : Uint8Array.prototype.lastIndexOf.call(t, e, n)
          : n_(t, [e], n, r, i)
      );
    throw new TypeError('val must be string, number or Buffer');
  }
  function n_(t, e, n, r, i) {
    var s,
      o = 1,
      a = t.length,
      c = e.length;
    if (
      r !== void 0 &&
      ((r = String(r).toLowerCase()) === 'ucs2' ||
        r === 'ucs-2' ||
        r === 'utf16le' ||
        r === 'utf-16le')
    ) {
      if (t.length < 2 || e.length < 2) return -1;
      ((o = 2), (a /= 2), (c /= 2), (n /= 2));
    }
    function l(h, g) {
      return o === 1 ? h[g] : h.readUInt16BE(g * o);
    }
    if (i) {
      var u = -1;
      for (s = n; s < a; s++)
        if (l(t, s) === l(e, u === -1 ? 0 : s - u)) {
          if ((u === -1 && (u = s), s - u + 1 === c)) return u * o;
        } else (u !== -1 && (s -= s - u), (u = -1));
    } else
      for (n + c > a && (n = a - c), s = n; s >= 0; s--) {
        for (var d = !0, f = 0; f < c; f++)
          if (l(t, s + f) !== l(e, f)) {
            d = !1;
            break;
          }
        if (d) return s;
      }
    return -1;
  }
  function OH(t, e, n, r) {
    n = Number(n) || 0;
    var i = t.length - n;
    r ? (r = Number(r)) > i && (r = i) : (r = i);
    var s = e.length;
    if (s % 2 != 0) throw new TypeError('Invalid hex string');
    r > s / 2 && (r = s / 2);
    for (var o = 0; o < r; ++o) {
      var a = parseInt(e.substr(2 * o, 2), 16);
      if (isNaN(a)) return o;
      t[n + o] = a;
    }
    return o;
  }
  function NH(t, e, n, r) {
    return jp(Ah(e, t.length - n), t, n, r);
  }
  function mC(t, e, n, r) {
    return jp(
      (function (i) {
        for (var s = [], o = 0; o < i.length; ++o)
          s.push(255 & i.charCodeAt(o));
        return s;
      })(e),
      t,
      n,
      r
    );
  }
  function LH(t, e, n, r) {
    return mC(t, e, n, r);
  }
  function BH(t, e, n, r) {
    return jp(vC(e), t, n, r);
  }
  function DH(t, e, n, r) {
    return jp(
      (function (i, s) {
        for (var o, a, c, l = [], u = 0; u < i.length && !((s -= 2) < 0); ++u)
          ((a = (o = i.charCodeAt(u)) >> 8),
            (c = o % 256),
            l.push(c),
            l.push(a));
        return l;
      })(e, t.length - n),
      t,
      n,
      r
    );
  }
  function FH(t, e, n) {
    return e === 0 && n === t.length ? e_(t) : e_(t.slice(e, n));
  }
  function gC(t, e, n) {
    n = Math.min(t.length, n);
    for (var r = [], i = e; i < n; ) {
      var s,
        o,
        a,
        c,
        l = t[i],
        u = null,
        d = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;
      if (i + d <= n)
        switch (d) {
          case 1:
            l < 128 && (u = l);
            break;
          case 2:
            (192 & (s = t[i + 1])) == 128 &&
              (c = ((31 & l) << 6) | (63 & s)) > 127 &&
              (u = c);
            break;
          case 3:
            ((s = t[i + 1]),
              (o = t[i + 2]),
              (192 & s) == 128 &&
                (192 & o) == 128 &&
                (c = ((15 & l) << 12) | ((63 & s) << 6) | (63 & o)) > 2047 &&
                (c < 55296 || c > 57343) &&
                (u = c));
            break;
          case 4:
            ((s = t[i + 1]),
              (o = t[i + 2]),
              (a = t[i + 3]),
              (192 & s) == 128 &&
                (192 & o) == 128 &&
                (192 & a) == 128 &&
                (c =
                  ((15 & l) << 18) |
                  ((63 & s) << 12) |
                  ((63 & o) << 6) |
                  (63 & a)) > 65535 &&
                c < 1114112 &&
                (u = c));
        }
      (u === null
        ? ((u = 65533), (d = 1))
        : u > 65535 &&
          ((u -= 65536),
          r.push(((u >>> 10) & 1023) | 55296),
          (u = 56320 | (1023 & u))),
        r.push(u),
        (i += d));
    }
    return (function (f) {
      var h = f.length;
      if (h <= r_) return String.fromCharCode.apply(String, f);
      for (var g = '', m = 0; m < h; )
        g += String.fromCharCode.apply(String, f.slice(m, (m += r_)));
      return g;
    })(r);
  }
  ((de.poolSize = 8192),
    (de._augment = function (t) {
      return ((t.__proto__ = de.prototype), t);
    }),
    (de.from = function (t, e, n) {
      return fC(null, t, e, n);
    }),
    de.TYPED_ARRAY_SUPPORT &&
      ((de.prototype.__proto__ = Uint8Array.prototype),
      (de.__proto__ = Uint8Array),
      typeof Symbol < 'u' && Symbol.species && de[Symbol.species]),
    (de.alloc = function (t, e, n) {
      return (function (r, i, s, o) {
        return (
          hC(i),
          i <= 0
            ? Gi(r, i)
            : s !== void 0
              ? typeof o == 'string'
                ? Gi(r, i).fill(s, o)
                : Gi(r, i).fill(s)
              : Gi(r, i)
        );
      })(null, t, e, n);
    }),
    (de.allocUnsafe = function (t) {
      return Fg(null, t);
    }),
    (de.allocUnsafeSlow = function (t) {
      return Fg(null, t);
    }),
    (de.isBuffer = bC),
    (de.compare = function (t, e) {
      if (!ti(t) || !ti(e)) throw new TypeError('Arguments must be Buffers');
      if (t === e) return 0;
      for (
        var n = t.length, r = e.length, i = 0, s = Math.min(n, r);
        i < s;
        ++i
      )
        if (t[i] !== e[i]) {
          ((n = t[i]), (r = e[i]));
          break;
        }
      return n < r ? -1 : r < n ? 1 : 0;
    }),
    (de.isEncoding = function (t) {
      switch (String(t).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return !0;
        default:
          return !1;
      }
    }),
    (de.concat = function (t, e) {
      if (!dC(t))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (t.length === 0) return de.alloc(0);
      var n;
      if (e === void 0) for (e = 0, n = 0; n < t.length; ++n) e += t[n].length;
      var r = de.allocUnsafe(e),
        i = 0;
      for (n = 0; n < t.length; ++n) {
        var s = t[n];
        if (!ti(s))
          throw new TypeError('"list" argument must be an Array of Buffers');
        (s.copy(r, i), (i += s.length));
      }
      return r;
    }),
    (de.byteLength = pC),
    (de.prototype._isBuffer = !0),
    (de.prototype.swap16 = function () {
      var t = this.length;
      if (t % 2 != 0)
        throw new RangeError('Buffer size must be a multiple of 16-bits');
      for (var e = 0; e < t; e += 2) yo(this, e, e + 1);
      return this;
    }),
    (de.prototype.swap32 = function () {
      var t = this.length;
      if (t % 4 != 0)
        throw new RangeError('Buffer size must be a multiple of 32-bits');
      for (var e = 0; e < t; e += 4)
        (yo(this, e, e + 3), yo(this, e + 1, e + 2));
      return this;
    }),
    (de.prototype.swap64 = function () {
      var t = this.length;
      if (t % 8 != 0)
        throw new RangeError('Buffer size must be a multiple of 64-bits');
      for (var e = 0; e < t; e += 8)
        (yo(this, e, e + 7),
          yo(this, e + 1, e + 6),
          yo(this, e + 2, e + 5),
          yo(this, e + 3, e + 4));
      return this;
    }),
    (de.prototype.toString = function () {
      var t = 0 | this.length;
      return t === 0
        ? ''
        : arguments.length === 0
          ? gC(this, 0, t)
          : MH.apply(this, arguments);
    }),
    (de.prototype.equals = function (t) {
      if (!ti(t)) throw new TypeError('Argument must be a Buffer');
      return this === t || de.compare(this, t) === 0;
    }),
    (de.prototype.inspect = function () {
      var t = '';
      return (
        this.length > 0 &&
          ((t = this.toString('hex', 0, 50).match(/.{2}/g).join(' ')),
          this.length > 50 && (t += ' ... ')),
        '<Buffer ' + t + '>'
      );
    }),
    (de.prototype.compare = function (t, e, n, r, i) {
      if (!ti(t)) throw new TypeError('Argument must be a Buffer');
      if (
        (e === void 0 && (e = 0),
        n === void 0 && (n = t ? t.length : 0),
        r === void 0 && (r = 0),
        i === void 0 && (i = this.length),
        e < 0 || n > t.length || r < 0 || i > this.length)
      )
        throw new RangeError('out of range index');
      if (r >= i && e >= n) return 0;
      if (r >= i) return -1;
      if (e >= n) return 1;
      if (this === t) return 0;
      for (
        var s = (i >>>= 0) - (r >>>= 0),
          o = (n >>>= 0) - (e >>>= 0),
          a = Math.min(s, o),
          c = this.slice(r, i),
          l = t.slice(e, n),
          u = 0;
        u < a;
        ++u
      )
        if (c[u] !== l[u]) {
          ((s = c[u]), (o = l[u]));
          break;
        }
      return s < o ? -1 : o < s ? 1 : 0;
    }),
    (de.prototype.includes = function (t, e, n) {
      return this.indexOf(t, e, n) !== -1;
    }),
    (de.prototype.indexOf = function (t, e, n) {
      return t_(this, t, e, n, !0);
    }),
    (de.prototype.lastIndexOf = function (t, e, n) {
      return t_(this, t, e, n, !1);
    }),
    (de.prototype.write = function (t, e, n, r) {
      if (e === void 0) ((r = 'utf8'), (n = this.length), (e = 0));
      else if (n === void 0 && typeof e == 'string')
        ((r = e), (n = this.length), (e = 0));
      else {
        if (!isFinite(e))
          throw new Error(
            'Buffer.write(string, encoding, offset[, length]) is no longer supported'
          );
        ((e |= 0),
          isFinite(n)
            ? ((n |= 0), r === void 0 && (r = 'utf8'))
            : ((r = n), (n = void 0)));
      }
      var i = this.length - e;
      if (
        ((n === void 0 || n > i) && (n = i),
        (t.length > 0 && (n < 0 || e < 0)) || e > this.length)
      )
        throw new RangeError('Attempt to write outside buffer bounds');
      r || (r = 'utf8');
      for (var s = !1; ; )
        switch (r) {
          case 'hex':
            return OH(this, t, e, n);
          case 'utf8':
          case 'utf-8':
            return NH(this, t, e, n);
          case 'ascii':
            return mC(this, t, e, n);
          case 'latin1':
          case 'binary':
            return LH(this, t, e, n);
          case 'base64':
            return BH(this, t, e, n);
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return DH(this, t, e, n);
          default:
            if (s) throw new TypeError('Unknown encoding: ' + r);
            ((r = ('' + r).toLowerCase()), (s = !0));
        }
    }),
    (de.prototype.toJSON = function () {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    }));
  var r_ = 4096;
  function $H(t, e, n) {
    var r = '';
    n = Math.min(t.length, n);
    for (var i = e; i < n; ++i) r += String.fromCharCode(127 & t[i]);
    return r;
  }
  function HH(t, e, n) {
    var r = '';
    n = Math.min(t.length, n);
    for (var i = e; i < n; ++i) r += String.fromCharCode(t[i]);
    return r;
  }
  function jH(t, e, n) {
    var r = t.length;
    ((!e || e < 0) && (e = 0), (!n || n < 0 || n > r) && (n = r));
    for (var i = '', s = e; s < n; ++s) i += qH(t[s]);
    return i;
  }
  function UH(t, e, n) {
    for (var r = t.slice(e, n), i = '', s = 0; s < r.length; s += 2)
      i += String.fromCharCode(r[s] + 256 * r[s + 1]);
    return i;
  }
  function jt(t, e, n) {
    if (t % 1 != 0 || t < 0) throw new RangeError('offset is not uint');
    if (t + e > n)
      throw new RangeError('Trying to access beyond buffer length');
  }
  function Ln(t, e, n, r, i, s) {
    if (!ti(t))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (e > i || e < s)
      throw new RangeError('"value" argument is out of bounds');
    if (n + r > t.length) throw new RangeError('Index out of range');
  }
  function ld(t, e, n, r) {
    e < 0 && (e = 65535 + e + 1);
    for (var i = 0, s = Math.min(t.length - n, 2); i < s; ++i)
      t[n + i] = (e & (255 << (8 * (r ? i : 1 - i)))) >>> (8 * (r ? i : 1 - i));
  }
  function ud(t, e, n, r) {
    e < 0 && (e = 4294967295 + e + 1);
    for (var i = 0, s = Math.min(t.length - n, 4); i < s; ++i)
      t[n + i] = (e >>> (8 * (r ? i : 3 - i))) & 255;
  }
  function yC(t, e, n, r, i, s) {
    if (n + r > t.length) throw new RangeError('Index out of range');
    if (n < 0) throw new RangeError('Index out of range');
  }
  function i_(t, e, n, r, i) {
    return (i || yC(t, 0, n, 4), uC(t, e, n, r, 23, 4), n + 4);
  }
  function s_(t, e, n, r, i) {
    return (i || yC(t, 0, n, 8), uC(t, e, n, r, 52, 8), n + 8);
  }
  ((de.prototype.slice = function (t, e) {
    var n,
      r = this.length;
    if (
      ((t = ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r),
      (e = e === void 0 ? r : ~~e) < 0
        ? (e += r) < 0 && (e = 0)
        : e > r && (e = r),
      e < t && (e = t),
      de.TYPED_ARRAY_SUPPORT)
    )
      (n = this.subarray(t, e)).__proto__ = de.prototype;
    else {
      var i = e - t;
      n = new de(i, void 0);
      for (var s = 0; s < i; ++s) n[s] = this[s + t];
    }
    return n;
  }),
    (de.prototype.readUIntLE = function (t, e, n) {
      ((t |= 0), (e |= 0), n || jt(t, e, this.length));
      for (var r = this[t], i = 1, s = 0; ++s < e && (i *= 256); )
        r += this[t + s] * i;
      return r;
    }),
    (de.prototype.readUIntBE = function (t, e, n) {
      ((t |= 0), (e |= 0), n || jt(t, e, this.length));
      for (var r = this[t + --e], i = 1; e > 0 && (i *= 256); )
        r += this[t + --e] * i;
      return r;
    }),
    (de.prototype.readUInt8 = function (t, e) {
      return (e || jt(t, 1, this.length), this[t]);
    }),
    (de.prototype.readUInt16LE = function (t, e) {
      return (e || jt(t, 2, this.length), this[t] | (this[t + 1] << 8));
    }),
    (de.prototype.readUInt16BE = function (t, e) {
      return (e || jt(t, 2, this.length), (this[t] << 8) | this[t + 1]);
    }),
    (de.prototype.readUInt32LE = function (t, e) {
      return (
        e || jt(t, 4, this.length),
        (this[t] | (this[t + 1] << 8) | (this[t + 2] << 16)) +
          16777216 * this[t + 3]
      );
    }),
    (de.prototype.readUInt32BE = function (t, e) {
      return (
        e || jt(t, 4, this.length),
        16777216 * this[t] +
          ((this[t + 1] << 16) | (this[t + 2] << 8) | this[t + 3])
      );
    }),
    (de.prototype.readIntLE = function (t, e, n) {
      ((t |= 0), (e |= 0), n || jt(t, e, this.length));
      for (var r = this[t], i = 1, s = 0; ++s < e && (i *= 256); )
        r += this[t + s] * i;
      return (r >= (i *= 128) && (r -= Math.pow(2, 8 * e)), r);
    }),
    (de.prototype.readIntBE = function (t, e, n) {
      ((t |= 0), (e |= 0), n || jt(t, e, this.length));
      for (var r = e, i = 1, s = this[t + --r]; r > 0 && (i *= 256); )
        s += this[t + --r] * i;
      return (s >= (i *= 128) && (s -= Math.pow(2, 8 * e)), s);
    }),
    (de.prototype.readInt8 = function (t, e) {
      return (
        e || jt(t, 1, this.length),
        128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
      );
    }),
    (de.prototype.readInt16LE = function (t, e) {
      e || jt(t, 2, this.length);
      var n = this[t] | (this[t + 1] << 8);
      return 32768 & n ? 4294901760 | n : n;
    }),
    (de.prototype.readInt16BE = function (t, e) {
      e || jt(t, 2, this.length);
      var n = this[t + 1] | (this[t] << 8);
      return 32768 & n ? 4294901760 | n : n;
    }),
    (de.prototype.readInt32LE = function (t, e) {
      return (
        e || jt(t, 4, this.length),
        this[t] | (this[t + 1] << 8) | (this[t + 2] << 16) | (this[t + 3] << 24)
      );
    }),
    (de.prototype.readInt32BE = function (t, e) {
      return (
        e || jt(t, 4, this.length),
        (this[t] << 24) | (this[t + 1] << 16) | (this[t + 2] << 8) | this[t + 3]
      );
    }),
    (de.prototype.readFloatLE = function (t, e) {
      return (e || jt(t, 4, this.length), cd(this, t, !0, 23, 4));
    }),
    (de.prototype.readFloatBE = function (t, e) {
      return (e || jt(t, 4, this.length), cd(this, t, !1, 23, 4));
    }),
    (de.prototype.readDoubleLE = function (t, e) {
      return (e || jt(t, 8, this.length), cd(this, t, !0, 52, 8));
    }),
    (de.prototype.readDoubleBE = function (t, e) {
      return (e || jt(t, 8, this.length), cd(this, t, !1, 52, 8));
    }),
    (de.prototype.writeUIntLE = function (t, e, n, r) {
      ((t = +t),
        (e |= 0),
        (n |= 0),
        r || Ln(this, t, e, n, Math.pow(2, 8 * n) - 1, 0));
      var i = 1,
        s = 0;
      for (this[e] = 255 & t; ++s < n && (i *= 256); )
        this[e + s] = (t / i) & 255;
      return e + n;
    }),
    (de.prototype.writeUIntBE = function (t, e, n, r) {
      ((t = +t),
        (e |= 0),
        (n |= 0),
        r || Ln(this, t, e, n, Math.pow(2, 8 * n) - 1, 0));
      var i = n - 1,
        s = 1;
      for (this[e + i] = 255 & t; --i >= 0 && (s *= 256); )
        this[e + i] = (t / s) & 255;
      return e + n;
    }),
    (de.prototype.writeUInt8 = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || Ln(this, t, e, 1, 255, 0),
        de.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
        (this[e] = 255 & t),
        e + 1
      );
    }),
    (de.prototype.writeUInt16LE = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || Ln(this, t, e, 2, 65535, 0),
        de.TYPED_ARRAY_SUPPORT
          ? ((this[e] = 255 & t), (this[e + 1] = t >>> 8))
          : ld(this, t, e, !0),
        e + 2
      );
    }),
    (de.prototype.writeUInt16BE = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || Ln(this, t, e, 2, 65535, 0),
        de.TYPED_ARRAY_SUPPORT
          ? ((this[e] = t >>> 8), (this[e + 1] = 255 & t))
          : ld(this, t, e, !1),
        e + 2
      );
    }),
    (de.prototype.writeUInt32LE = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || Ln(this, t, e, 4, 4294967295, 0),
        de.TYPED_ARRAY_SUPPORT
          ? ((this[e + 3] = t >>> 24),
            (this[e + 2] = t >>> 16),
            (this[e + 1] = t >>> 8),
            (this[e] = 255 & t))
          : ud(this, t, e, !0),
        e + 4
      );
    }),
    (de.prototype.writeUInt32BE = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || Ln(this, t, e, 4, 4294967295, 0),
        de.TYPED_ARRAY_SUPPORT
          ? ((this[e] = t >>> 24),
            (this[e + 1] = t >>> 16),
            (this[e + 2] = t >>> 8),
            (this[e + 3] = 255 & t))
          : ud(this, t, e, !1),
        e + 4
      );
    }),
    (de.prototype.writeIntLE = function (t, e, n, r) {
      if (((t = +t), (e |= 0), !r)) {
        var i = Math.pow(2, 8 * n - 1);
        Ln(this, t, e, n, i - 1, -i);
      }
      var s = 0,
        o = 1,
        a = 0;
      for (this[e] = 255 & t; ++s < n && (o *= 256); )
        (t < 0 && a === 0 && this[e + s - 1] !== 0 && (a = 1),
          (this[e + s] = (((t / o) >> 0) - a) & 255));
      return e + n;
    }),
    (de.prototype.writeIntBE = function (t, e, n, r) {
      if (((t = +t), (e |= 0), !r)) {
        var i = Math.pow(2, 8 * n - 1);
        Ln(this, t, e, n, i - 1, -i);
      }
      var s = n - 1,
        o = 1,
        a = 0;
      for (this[e + s] = 255 & t; --s >= 0 && (o *= 256); )
        (t < 0 && a === 0 && this[e + s + 1] !== 0 && (a = 1),
          (this[e + s] = (((t / o) >> 0) - a) & 255));
      return e + n;
    }),
    (de.prototype.writeInt8 = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || Ln(this, t, e, 1, 127, -128),
        de.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
        t < 0 && (t = 255 + t + 1),
        (this[e] = 255 & t),
        e + 1
      );
    }),
    (de.prototype.writeInt16LE = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || Ln(this, t, e, 2, 32767, -32768),
        de.TYPED_ARRAY_SUPPORT
          ? ((this[e] = 255 & t), (this[e + 1] = t >>> 8))
          : ld(this, t, e, !0),
        e + 2
      );
    }),
    (de.prototype.writeInt16BE = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || Ln(this, t, e, 2, 32767, -32768),
        de.TYPED_ARRAY_SUPPORT
          ? ((this[e] = t >>> 8), (this[e + 1] = 255 & t))
          : ld(this, t, e, !1),
        e + 2
      );
    }),
    (de.prototype.writeInt32LE = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || Ln(this, t, e, 4, 2147483647, -2147483648),
        de.TYPED_ARRAY_SUPPORT
          ? ((this[e] = 255 & t),
            (this[e + 1] = t >>> 8),
            (this[e + 2] = t >>> 16),
            (this[e + 3] = t >>> 24))
          : ud(this, t, e, !0),
        e + 4
      );
    }),
    (de.prototype.writeInt32BE = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || Ln(this, t, e, 4, 2147483647, -2147483648),
        t < 0 && (t = 4294967295 + t + 1),
        de.TYPED_ARRAY_SUPPORT
          ? ((this[e] = t >>> 24),
            (this[e + 1] = t >>> 16),
            (this[e + 2] = t >>> 8),
            (this[e + 3] = 255 & t))
          : ud(this, t, e, !1),
        e + 4
      );
    }),
    (de.prototype.writeFloatLE = function (t, e, n) {
      return i_(this, t, e, !0, n);
    }),
    (de.prototype.writeFloatBE = function (t, e, n) {
      return i_(this, t, e, !1, n);
    }),
    (de.prototype.writeDoubleLE = function (t, e, n) {
      return s_(this, t, e, !0, n);
    }),
    (de.prototype.writeDoubleBE = function (t, e, n) {
      return s_(this, t, e, !1, n);
    }),
    (de.prototype.copy = function (t, e, n, r) {
      if (
        (n || (n = 0),
        r || r === 0 || (r = this.length),
        e >= t.length && (e = t.length),
        e || (e = 0),
        r > 0 && r < n && (r = n),
        r === n || t.length === 0 || this.length === 0)
      )
        return 0;
      if (e < 0) throw new RangeError('targetStart out of bounds');
      if (n < 0 || n >= this.length)
        throw new RangeError('sourceStart out of bounds');
      if (r < 0) throw new RangeError('sourceEnd out of bounds');
      (r > this.length && (r = this.length),
        t.length - e < r - n && (r = t.length - e + n));
      var i,
        s = r - n;
      if (this === t && n < e && e < r)
        for (i = s - 1; i >= 0; --i) t[i + e] = this[i + n];
      else if (s < 1e3 || !de.TYPED_ARRAY_SUPPORT)
        for (i = 0; i < s; ++i) t[i + e] = this[i + n];
      else Uint8Array.prototype.set.call(t, this.subarray(n, n + s), e);
      return s;
    }),
    (de.prototype.fill = function (t, e, n, r) {
      if (typeof t == 'string') {
        if (
          (typeof e == 'string'
            ? ((r = e), (e = 0), (n = this.length))
            : typeof n == 'string' && ((r = n), (n = this.length)),
          t.length === 1)
        ) {
          var i = t.charCodeAt(0);
          i < 256 && (t = i);
        }
        if (r !== void 0 && typeof r != 'string')
          throw new TypeError('encoding must be a string');
        if (typeof r == 'string' && !de.isEncoding(r))
          throw new TypeError('Unknown encoding: ' + r);
      } else typeof t == 'number' && (t &= 255);
      if (e < 0 || this.length < e || this.length < n)
        throw new RangeError('Out of range index');
      if (n <= e) return this;
      var s;
      if (
        ((e >>>= 0),
        (n = n === void 0 ? this.length : n >>> 0),
        t || (t = 0),
        typeof t == 'number')
      )
        for (s = e; s < n; ++s) this[s] = t;
      else {
        var o = ti(t) ? t : Ah(new de(t, r).toString()),
          a = o.length;
        for (s = 0; s < n - e; ++s) this[s + e] = o[s % a];
      }
      return this;
    }));
  var KH = /[^+\/0-9A-Za-z-_]/g;
  function qH(t) {
    return t < 16 ? '0' + t.toString(16) : t.toString(16);
  }
  function Ah(t, e) {
    var n;
    e = e || 1 / 0;
    for (var r = t.length, i = null, s = [], o = 0; o < r; ++o) {
      if ((n = t.charCodeAt(o)) > 55295 && n < 57344) {
        if (!i) {
          if (n > 56319) {
            (e -= 3) > -1 && s.push(239, 191, 189);
            continue;
          }
          if (o + 1 === r) {
            (e -= 3) > -1 && s.push(239, 191, 189);
            continue;
          }
          i = n;
          continue;
        }
        if (n < 56320) {
          ((e -= 3) > -1 && s.push(239, 191, 189), (i = n));
          continue;
        }
        n = 65536 + (((i - 55296) << 10) | (n - 56320));
      } else i && (e -= 3) > -1 && s.push(239, 191, 189);
      if (((i = null), n < 128)) {
        if ((e -= 1) < 0) break;
        s.push(n);
      } else if (n < 2048) {
        if ((e -= 2) < 0) break;
        s.push((n >> 6) | 192, (63 & n) | 128);
      } else if (n < 65536) {
        if ((e -= 3) < 0) break;
        s.push((n >> 12) | 224, ((n >> 6) & 63) | 128, (63 & n) | 128);
      } else {
        if (!(n < 1114112)) throw new Error('Invalid code point');
        if ((e -= 4) < 0) break;
        s.push(
          (n >> 18) | 240,
          ((n >> 12) & 63) | 128,
          ((n >> 6) & 63) | 128,
          (63 & n) | 128
        );
      }
    }
    return s;
  }
  function vC(t) {
    return (function (e) {
      var n, r, i, s, o, a;
      Vv || lC();
      var c = e.length;
      if (c % 4 > 0)
        throw new Error('Invalid string. Length must be a multiple of 4');
      ((o = e[c - 2] === '=' ? 2 : e[c - 1] === '=' ? 1 : 0),
        (a = new IH((3 * c) / 4 - o)),
        (i = o > 0 ? c - 4 : c));
      var l = 0;
      for (n = 0, r = 0; n < i; n += 4, r += 3)
        ((s =
          (hr[e.charCodeAt(n)] << 18) |
          (hr[e.charCodeAt(n + 1)] << 12) |
          (hr[e.charCodeAt(n + 2)] << 6) |
          hr[e.charCodeAt(n + 3)]),
          (a[l++] = (s >> 16) & 255),
          (a[l++] = (s >> 8) & 255),
          (a[l++] = 255 & s));
      return (
        o === 2
          ? ((s = (hr[e.charCodeAt(n)] << 2) | (hr[e.charCodeAt(n + 1)] >> 4)),
            (a[l++] = 255 & s))
          : o === 1 &&
            ((s =
              (hr[e.charCodeAt(n)] << 10) |
              (hr[e.charCodeAt(n + 1)] << 4) |
              (hr[e.charCodeAt(n + 2)] >> 2)),
            (a[l++] = (s >> 8) & 255),
            (a[l++] = 255 & s)),
        a
      );
    })(
      (function (e) {
        if (
          (e = (function (n) {
            return n.trim ? n.trim() : n.replace(/^\s+|\s+$/g, '');
          })(e).replace(KH, '')).length < 2
        )
          return '';
        for (; e.length % 4 != 0; ) e += '=';
        return e;
      })(t)
    );
  }
  function jp(t, e, n, r) {
    for (var i = 0; i < r && !(i + n >= e.length || i >= t.length); ++i)
      e[i + n] = t[i];
    return i;
  }
  function bC(t) {
    return (
      t != null &&
      (!!t._isBuffer ||
        o_(t) ||
        (function (e) {
          return (
            typeof e.readFloatLE == 'function' &&
            typeof e.slice == 'function' &&
            o_(e.slice(0, 0))
          );
        })(t))
    );
  }
  function o_(t) {
    return (
      !!t.constructor &&
      typeof t.constructor.isBuffer == 'function' &&
      t.constructor.isBuffer(t)
    );
  }
  var VH = Object.freeze({
      __proto__: null,
      Buffer: de,
      INSPECT_MAX_BYTES: 50,
      SlowBuffer: function (t) {
        return (+t != t && (t = 0), de.alloc(+t));
      },
      isBuffer: bC,
      kMaxLength: PH
    }),
    _r =
      typeof globalThis < 'u'
        ? globalThis
        : typeof window < 'u'
          ? window
          : typeof global < 'u'
            ? global
            : typeof self < 'u'
              ? self
              : {};
  function Up(t) {
    return t &&
      t.__esModule &&
      Object.prototype.hasOwnProperty.call(t, 'default')
      ? t.default
      : t;
  }
  function Hu(t) {
    if (t.__esModule) return t;
    var e = t.default;
    if (typeof e == 'function') {
      var n = function r() {
        return this instanceof r
          ? Reflect.construct(e, arguments, this.constructor)
          : e.apply(this, arguments);
      };
      n.prototype = e.prototype;
    } else n = {};
    return (
      Object.defineProperty(n, '__esModule', {value: !0}),
      Object.keys(t).forEach(function (r) {
        var i = Object.getOwnPropertyDescriptor(t, r);
        Object.defineProperty(
          n,
          r,
          i.get
            ? i
            : {
                enumerable: !0,
                get: function () {
                  return t[r];
                }
              }
        );
      }),
      n
    );
  }
  var Ta = {},
    sr = {},
    un = {};
  function Sh(t) {
    if (!Number.isSafeInteger(t) || t < 0)
      throw new Error(`positive integer expected, not ${t}`);
  }
  function wC(t) {
    if (typeof t != 'boolean') throw new Error(`boolean expected, not ${t}`);
  }
  function _C(t) {
    return (
      t instanceof Uint8Array ||
      (t != null && typeof t == 'object' && t.constructor.name === 'Uint8Array')
    );
  }
  function zv(t, ...e) {
    if (!_C(t)) throw new Error('Uint8Array expected');
    if (e.length > 0 && !e.includes(t.length))
      throw new Error(
        `Uint8Array expected of length ${e}, not of length=${t.length}`
      );
  }
  function EC(t) {
    if (typeof t != 'function' || typeof t.create != 'function')
      throw new Error('hash must be wrapped by utils.wrapConstructor');
    (Sh(t.outputLen), Sh(t.blockLen));
  }
  function AC(t, e = !0) {
    if (t.destroyed) throw new Error('Hash instance has been destroyed');
    if (e && t.finished)
      throw new Error('Hash#digest() has already been called');
  }
  function SC(t, e) {
    zv(t);
    const n = e.outputLen;
    if (t.length < n)
      throw new Error(
        `digestInto() expects output buffer of length at least ${n}`
      );
  }
  (Object.defineProperty(un, '__esModule', {value: !0}),
    (un.isBytes = _C),
    (un.number = Sh),
    (un.bool = wC),
    (un.bytes = zv),
    (un.hash = EC),
    (un.exists = AC),
    (un.output = SC));
  const GH = {
    number: Sh,
    bool: wC,
    bytes: zv,
    hash: EC,
    exists: AC,
    output: SC
  };
  ((un.default = GH),
    (function (t) {
      (Object.defineProperty(t, '__esModule', {value: !0}),
        (t.wrapCipher =
          t.Hash =
          t.nextTick =
          t.isLE =
          t.createView =
          t.u32 =
          t.u16 =
          t.u8 =
            void 0),
        (t.bytesToHex = r),
        (t.hexToBytes = o),
        (t.hexToNumber = a),
        (t.bytesToNumberBE = function (d) {
          return a(r(d));
        }),
        (t.numberToBytesBE = function (d, f) {
          return o(d.toString(16).padStart(2 * f, '0'));
        }),
        (t.asyncLoop = async function (d, f, h) {
          let g = Date.now();
          for (let m = 0; m < d; m++) {
            h(m);
            const y = Date.now() - g;
            (y >= 0 && y < f) || (await (0, t.nextTick)(), (g += y));
          }
        }),
        (t.utf8ToBytes = c),
        (t.bytesToUtf8 = function (d) {
          return new TextDecoder().decode(d);
        }),
        (t.toBytes = function (d) {
          if (typeof d == 'string') d = c(d);
          else {
            if (!(0, e.isBytes)(d))
              throw new Error('Uint8Array expected, got ' + typeof d);
            d = u(d);
          }
          return d;
        }),
        (t.concatBytes = function (...d) {
          let f = 0;
          for (let g = 0; g < d.length; g++) {
            const m = d[g];
            ((0, e.bytes)(m), (f += m.length));
          }
          const h = new Uint8Array(f);
          for (let g = 0, m = 0; g < d.length; g++) {
            const y = d[g];
            (h.set(y, m), (m += y.length));
          }
          return h;
        }),
        (t.checkOpts = function (d, f) {
          if (f == null || typeof f != 'object')
            throw new Error('options must be defined');
          return Object.assign(d, f);
        }),
        (t.equalBytes = function (d, f) {
          if (d.length !== f.length) return !1;
          let h = 0;
          for (let g = 0; g < d.length; g++) h |= d[g] ^ f[g];
          return h === 0;
        }),
        (t.setBigUint64 = l),
        (t.u64Lengths = function (d, f) {
          const h = new Uint8Array(16),
            g = (0, t.createView)(h);
          return (
            l(g, 0, BigInt(f ? f.length : 0), !0),
            l(g, 8, BigInt(d.length), !0),
            h
          );
        }),
        (t.isAligned32 = function (d) {
          return d.byteOffset % 4 == 0;
        }),
        (t.copyBytes = u),
        (t.clean = function (...d) {
          for (let f = 0; f < d.length; f++) d[f].fill(0);
        }));
      const e = un;
      if (
        ((t.u8 = (d) => new Uint8Array(d.buffer, d.byteOffset, d.byteLength)),
        (t.u16 = (d) =>
          new Uint16Array(
            d.buffer,
            d.byteOffset,
            Math.floor(d.byteLength / 2)
          )),
        (t.u32 = (d) =>
          new Uint32Array(
            d.buffer,
            d.byteOffset,
            Math.floor(d.byteLength / 4)
          )),
        (t.createView = (d) =>
          new DataView(d.buffer, d.byteOffset, d.byteLength)),
        (t.isLE =
          new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68),
        !t.isLE)
      )
        throw new Error('Non little-endian hardware is not supported');
      const n = Array.from({length: 256}, (d, f) =>
        f.toString(16).padStart(2, '0')
      );
      function r(d) {
        (0, e.bytes)(d);
        let f = '';
        for (let h = 0; h < d.length; h++) f += n[d[h]];
        return f;
      }
      const i = {_0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102};
      function s(d) {
        return d >= i._0 && d <= i._9
          ? d - i._0
          : d >= i._A && d <= i._F
            ? d - (i._A - 10)
            : d >= i._a && d <= i._f
              ? d - (i._a - 10)
              : void 0;
      }
      function o(d) {
        if (typeof d != 'string')
          throw new Error('hex string expected, got ' + typeof d);
        const f = d.length,
          h = f / 2;
        if (f % 2)
          throw new Error(
            'padded hex string expected, got unpadded hex of length ' + f
          );
        const g = new Uint8Array(h);
        for (let m = 0, y = 0; m < h; m++, y += 2) {
          const p = s(d.charCodeAt(y)),
            b = s(d.charCodeAt(y + 1));
          if (p === void 0 || b === void 0) {
            const v = d[y] + d[y + 1];
            throw new Error(
              'hex string expected, got non-hex character "' +
                v +
                '" at index ' +
                y
            );
          }
          g[m] = 16 * p + b;
        }
        return g;
      }
      function a(d) {
        if (typeof d != 'string')
          throw new Error('hex string expected, got ' + typeof d);
        return BigInt(d === '' ? '0' : `0x${d}`);
      }
      function c(d) {
        if (typeof d != 'string')
          throw new Error('string expected, got ' + typeof d);
        return new Uint8Array(new TextEncoder().encode(d));
      }
      ((t.nextTick = async () => {}), (t.Hash = class {}));
      function l(d, f, h, g) {
        if (typeof d.setBigUint64 == 'function') return d.setBigUint64(f, h, g);
        const m = BigInt(32),
          y = BigInt(4294967295),
          p = Number((h >> m) & y),
          b = Number(h & y),
          v = g ? 4 : 0,
          x = g ? 0 : 4;
        (d.setUint32(f + v, p, g), d.setUint32(f + x, b, g));
      }
      function u(d) {
        return Uint8Array.from(d);
      }
      t.wrapCipher = (d, f) => (Object.assign(f, d), f);
    })(sr));
  var du = {},
    Ut = {};
  (Object.defineProperty(Ut, '__esModule', {value: !0}),
    (Ut.AEAD_TAG_LENGTH =
      Ut.XCHACHA20_NONCE_LENGTH =
      Ut.CURVE25519_PUBLIC_KEY_SIZE =
      Ut.ETH_PUBLIC_KEY_SIZE =
      Ut.UNCOMPRESSED_PUBLIC_KEY_SIZE =
      Ut.COMPRESSED_PUBLIC_KEY_SIZE =
      Ut.SECRET_KEY_LENGTH =
        void 0),
    (Ut.SECRET_KEY_LENGTH = 32),
    (Ut.COMPRESSED_PUBLIC_KEY_SIZE = 33),
    (Ut.UNCOMPRESSED_PUBLIC_KEY_SIZE = 65),
    (Ut.ETH_PUBLIC_KEY_SIZE = 64),
    (Ut.CURVE25519_PUBLIC_KEY_SIZE = 32),
    (Ut.XCHACHA20_NONCE_LENGTH = 24),
    (Ut.AEAD_TAG_LENGTH = 16),
    (function (t) {
      (Object.defineProperty(t, '__esModule', {value: !0}),
        (t.ephemeralKeySize =
          t.symmetricNonceLength =
          t.symmetricAlgorithm =
          t.isHkdfKeyCompressed =
          t.isEphemeralKeyCompressed =
          t.ellipticCurve =
          t.ECIES_CONFIG =
            void 0));
      var e = Ut,
        n = function () {
          ((this.ellipticCurve = 'secp256k1'),
            (this.isEphemeralKeyCompressed = !1),
            (this.isHkdfKeyCompressed = !1),
            (this.symmetricAlgorithm = 'aes-256-gcm'),
            (this.symmetricNonceLength = 16));
        };
      ((t.ECIES_CONFIG = new n()),
        (t.ellipticCurve = function () {
          return t.ECIES_CONFIG.ellipticCurve;
        }),
        (t.isEphemeralKeyCompressed = function () {
          return t.ECIES_CONFIG.isEphemeralKeyCompressed;
        }),
        (t.isHkdfKeyCompressed = function () {
          return t.ECIES_CONFIG.isHkdfKeyCompressed;
        }),
        (t.symmetricAlgorithm = function () {
          return t.ECIES_CONFIG.symmetricAlgorithm;
        }),
        (t.symmetricNonceLength = function () {
          return t.ECIES_CONFIG.symmetricNonceLength;
        }),
        (t.ephemeralKeySize = function () {
          var r = {
            secp256k1: t.ECIES_CONFIG.isEphemeralKeyCompressed
              ? e.COMPRESSED_PUBLIC_KEY_SIZE
              : e.UNCOMPRESSED_PUBLIC_KEY_SIZE,
            x25519: e.CURVE25519_PUBLIC_KEY_SIZE,
            ed25519: e.CURVE25519_PUBLIC_KEY_SIZE
          };
          if (t.ECIES_CONFIG.ellipticCurve in r)
            return r[t.ECIES_CONFIG.ellipticCurve];
          throw new Error('Not implemented');
        }));
    })(du));
  var Um = {},
    xh = {},
    Kp = {},
    xC = {},
    Wv = {},
    dd = {};
  (Object.defineProperty(dd, '__esModule', {value: !0}),
    (dd.crypto = void 0),
    (dd.crypto =
      typeof globalThis == 'object' && 'crypto' in globalThis
        ? globalThis.crypto
        : void 0),
    (function (t) {
      (Object.defineProperty(t, '__esModule', {value: !0}),
        (t.gcm = t.ctr = t.cbc = t.utils = void 0),
        (t.randomBytes = i),
        (t.getWebcryptoSubtle = s),
        (t.managedNonce = function (c) {
          return (
            (0, n.number)(c.nonceLength),
            (l, ...u) => ({
              encrypt(d, ...f) {
                const {nonceLength: h} = c,
                  g = i(h),
                  m = c(l, g, ...u).encrypt(d, ...f),
                  y = (0, r.concatBytes)(g, m);
                return (m.fill(0), y);
              },
              decrypt(d, ...f) {
                const {nonceLength: h} = c,
                  g = d.subarray(0, h),
                  m = d.subarray(h);
                return c(l, g, ...u).decrypt(m, ...f);
              }
            })
          );
        }));
      const e = dd,
        n = un,
        r = sr;
      function i(c = 32) {
        if (e.crypto && typeof e.crypto.getRandomValues == 'function')
          return e.crypto.getRandomValues(new Uint8Array(c));
        if (e.crypto && typeof e.crypto.randomBytes == 'function')
          return e.crypto.randomBytes(c);
        throw new Error('crypto.getRandomValues must be defined');
      }
      function s() {
        if (
          e.crypto &&
          typeof e.crypto.subtle == 'object' &&
          e.crypto.subtle != null
        )
          return e.crypto.subtle;
        throw new Error('crypto.subtle must be defined');
      }
      t.utils = {
        async encrypt(c, l, u, d) {
          const f = s(),
            h = await f.importKey('raw', c, l, !0, ['encrypt']),
            g = await f.encrypt(u, h, d);
          return new Uint8Array(g);
        },
        async decrypt(c, l, u, d) {
          const f = s(),
            h = await f.importKey('raw', c, l, !0, ['decrypt']),
            g = await f.decrypt(u, h, d);
          return new Uint8Array(g);
        }
      };
      const o = {CBC: 'AES-CBC', CTR: 'AES-CTR', GCM: 'AES-GCM'};
      function a(c) {
        return (l, u, d) => {
          ((0, n.bytes)(l), (0, n.bytes)(u));
          const f = {name: c, length: 8 * l.length},
            h = (function (g, m, y) {
              if (g === o.CBC) return {name: o.CBC, iv: m};
              if (g === o.CTR) return {name: o.CTR, counter: m, length: 64};
              if (g === o.GCM)
                return y
                  ? {name: o.GCM, iv: m, additionalData: y}
                  : {name: o.GCM, iv: m};
              throw new Error('unknown aes block mode');
            })(c, u, d);
          return {
            encrypt: (g) => ((0, n.bytes)(g), t.utils.encrypt(l, f, h, g)),
            decrypt: (g) => ((0, n.bytes)(g), t.utils.decrypt(l, f, h, g))
          };
        };
      }
      ((t.cbc = a(o.CBC)), (t.ctr = a(o.CTR)), (t.gcm = a(o.GCM)));
    })(Wv));
  var CC = {},
    Kt = {},
    zi = {},
    Qn = {};
  function Ch(t) {
    if (!Number.isSafeInteger(t) || t < 0)
      throw new Error(`positive integer expected, not ${t}`);
  }
  function TC(t) {
    if (typeof t != 'boolean') throw new Error(`boolean expected, not ${t}`);
  }
  function IC(t) {
    return (
      t instanceof Uint8Array ||
      (t != null && typeof t == 'object' && t.constructor.name === 'Uint8Array')
    );
  }
  function Zv(t, ...e) {
    if (!IC(t)) throw new Error('Uint8Array expected');
    if (e.length > 0 && !e.includes(t.length))
      throw new Error(
        `Uint8Array expected of length ${e}, not of length=${t.length}`
      );
  }
  function kC(t) {
    if (typeof t != 'function' || typeof t.create != 'function')
      throw new Error('Hash should be wrapped by utils.wrapConstructor');
    (Ch(t.outputLen), Ch(t.blockLen));
  }
  function RC(t, e = !0) {
    if (t.destroyed) throw new Error('Hash instance has been destroyed');
    if (e && t.finished)
      throw new Error('Hash#digest() has already been called');
  }
  function PC(t, e) {
    Zv(t);
    const n = e.outputLen;
    if (t.length < n)
      throw new Error(
        `digestInto() expects output buffer of length at least ${n}`
      );
  }
  (Object.defineProperty(Qn, '__esModule', {value: !0}),
    (Qn.isBytes = IC),
    (Qn.number = Ch),
    (Qn.bool = TC),
    (Qn.bytes = Zv),
    (Qn.hash = kC),
    (Qn.exists = RC),
    (Qn.output = PC));
  const zH = {
    number: Ch,
    bool: TC,
    bytes: Zv,
    hash: kC,
    exists: RC,
    output: PC
  };
  Qn.default = zH;
  var fs = {},
    fd = {};
  (Object.defineProperty(fd, '__esModule', {value: !0}),
    (fd.crypto = void 0),
    (fd.crypto =
      typeof globalThis == 'object' && 'crypto' in globalThis
        ? globalThis.crypto
        : void 0),
    (function (t) {
      (Object.defineProperty(t, '__esModule', {value: !0}),
        (t.Hash =
          t.nextTick =
          t.byteSwapIfBE =
          t.byteSwap =
          t.isLE =
          t.rotl =
          t.rotr =
          t.createView =
          t.u32 =
          t.u8 =
            void 0),
        (t.isBytes = function (l) {
          return (
            l instanceof Uint8Array ||
            (l != null &&
              typeof l == 'object' &&
              l.constructor.name === 'Uint8Array')
          );
        }),
        (t.byteSwap32 = function (l) {
          for (let u = 0; u < l.length; u++) l[u] = (0, t.byteSwap)(l[u]);
        }),
        (t.bytesToHex = function (l) {
          (0, n.bytes)(l);
          let u = '';
          for (let d = 0; d < l.length; d++) u += r[l[d]];
          return u;
        }),
        (t.hexToBytes = function (l) {
          if (typeof l != 'string')
            throw new Error('hex string expected, got ' + typeof l);
          const u = l.length,
            d = u / 2;
          if (u % 2)
            throw new Error(
              'padded hex string expected, got unpadded hex of length ' + u
            );
          const f = new Uint8Array(d);
          for (let h = 0, g = 0; h < d; h++, g += 2) {
            const m = s(l.charCodeAt(g)),
              y = s(l.charCodeAt(g + 1));
            if (m === void 0 || y === void 0) {
              const p = l[g] + l[g + 1];
              throw new Error(
                'hex string expected, got non-hex character "' +
                  p +
                  '" at index ' +
                  g
              );
            }
            f[h] = 16 * m + y;
          }
          return f;
        }),
        (t.asyncLoop = async function (l, u, d) {
          let f = Date.now();
          for (let h = 0; h < l; h++) {
            d(h);
            const g = Date.now() - f;
            (g >= 0 && g < u) || (await (0, t.nextTick)(), (f += g));
          }
        }),
        (t.utf8ToBytes = o),
        (t.toBytes = a),
        (t.concatBytes = function (...l) {
          let u = 0;
          for (let f = 0; f < l.length; f++) {
            const h = l[f];
            ((0, n.bytes)(h), (u += h.length));
          }
          const d = new Uint8Array(u);
          for (let f = 0, h = 0; f < l.length; f++) {
            const g = l[f];
            (d.set(g, h), (h += g.length));
          }
          return d;
        }),
        (t.checkOpts = function (l, u) {
          if (u !== void 0 && c.call(u) !== '[object Object]')
            throw new Error('Options should be object or undefined');
          return Object.assign(l, u);
        }),
        (t.wrapConstructor = function (l) {
          const u = (f) => l().update(a(f)).digest(),
            d = l();
          return (
            (u.outputLen = d.outputLen),
            (u.blockLen = d.blockLen),
            (u.create = () => l()),
            u
          );
        }),
        (t.wrapConstructorWithOpts = function (l) {
          const u = (f, h) => l(h).update(a(f)).digest(),
            d = l({});
          return (
            (u.outputLen = d.outputLen),
            (u.blockLen = d.blockLen),
            (u.create = (f) => l(f)),
            u
          );
        }),
        (t.wrapXOFConstructorWithOpts = function (l) {
          const u = (f, h) => l(h).update(a(f)).digest(),
            d = l({});
          return (
            (u.outputLen = d.outputLen),
            (u.blockLen = d.blockLen),
            (u.create = (f) => l(f)),
            u
          );
        }),
        (t.randomBytes = function (l = 32) {
          if (e.crypto && typeof e.crypto.getRandomValues == 'function')
            return e.crypto.getRandomValues(new Uint8Array(l));
          if (e.crypto && typeof e.crypto.randomBytes == 'function')
            return e.crypto.randomBytes(l);
          throw new Error('crypto.getRandomValues must be defined');
        }));
      const e = fd,
        n = Qn;
      ((t.u8 = (l) => new Uint8Array(l.buffer, l.byteOffset, l.byteLength)),
        (t.u32 = (l) =>
          new Uint32Array(
            l.buffer,
            l.byteOffset,
            Math.floor(l.byteLength / 4)
          )),
        (t.createView = (l) =>
          new DataView(l.buffer, l.byteOffset, l.byteLength)),
        (t.rotr = (l, u) => (l << (32 - u)) | (l >>> u)),
        (t.rotl = (l, u) => (l << u) | ((l >>> (32 - u)) >>> 0)),
        (t.isLE =
          new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68),
        (t.byteSwap = (l) =>
          ((l << 24) & 4278190080) |
          ((l << 8) & 16711680) |
          ((l >>> 8) & 65280) |
          ((l >>> 24) & 255)),
        (t.byteSwapIfBE = t.isLE ? (l) => l : (l) => (0, t.byteSwap)(l)));
      const r = Array.from({length: 256}, (l, u) =>
          u.toString(16).padStart(2, '0')
        ),
        i = {_0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102};
      function s(l) {
        return l >= i._0 && l <= i._9
          ? l - i._0
          : l >= i._A && l <= i._F
            ? l - (i._A - 10)
            : l >= i._a && l <= i._f
              ? l - (i._a - 10)
              : void 0;
      }
      function o(l) {
        if (typeof l != 'string')
          throw new Error('utf8ToBytes expected string, got ' + typeof l);
        return new Uint8Array(new TextEncoder().encode(l));
      }
      function a(l) {
        return (typeof l == 'string' && (l = o(l)), (0, n.bytes)(l), l);
      }
      ((t.nextTick = async () => {}),
        (t.Hash = class {
          clone() {
            return this._cloneInto();
          }
        }));
      const c = {}.toString;
    })(fs),
    Object.defineProperty(zi, '__esModule', {value: !0}),
    (zi.HashMD = zi.Maj = zi.Chi = void 0));
  const Km = Qn,
    Wc = fs;
  zi.Chi = (t, e, n) => (t & e) ^ (~t & n);
  zi.Maj = (t, e, n) => (t & e) ^ (t & n) ^ (e & n);
  zi.HashMD = class extends Wc.Hash {
    constructor(t, e, n, r) {
      (super(),
        (this.blockLen = t),
        (this.outputLen = e),
        (this.padOffset = n),
        (this.isLE = r),
        (this.finished = !1),
        (this.length = 0),
        (this.pos = 0),
        (this.destroyed = !1),
        (this.buffer = new Uint8Array(t)),
        (this.view = (0, Wc.createView)(this.buffer)));
    }
    update(t) {
      (0, Km.exists)(this);
      const {view: e, buffer: n, blockLen: r} = this,
        i = (t = (0, Wc.toBytes)(t)).length;
      for (let s = 0; s < i; ) {
        const o = Math.min(r - this.pos, i - s);
        if (o !== r)
          (n.set(t.subarray(s, s + o), this.pos),
            (this.pos += o),
            (s += o),
            this.pos === r && (this.process(e, 0), (this.pos = 0)));
        else {
          const a = (0, Wc.createView)(t);
          for (; r <= i - s; s += r) this.process(a, s);
        }
      }
      return ((this.length += t.length), this.roundClean(), this);
    }
    digestInto(t) {
      ((0, Km.exists)(this), (0, Km.output)(t, this), (this.finished = !0));
      const {buffer: e, view: n, blockLen: r, isLE: i} = this;
      let {pos: s} = this;
      ((e[s++] = 128),
        this.buffer.subarray(s).fill(0),
        this.padOffset > r - s && (this.process(n, 0), (s = 0)));
      for (let u = s; u < r; u++) e[u] = 0;
      ((function (u, d, f, h) {
        if (typeof u.setBigUint64 == 'function') return u.setBigUint64(d, f, h);
        const g = BigInt(32),
          m = BigInt(4294967295),
          y = Number((f >> g) & m),
          p = Number(f & m),
          b = h ? 4 : 0,
          v = h ? 0 : 4;
        (u.setUint32(d + b, y, h), u.setUint32(d + v, p, h));
      })(n, r - 8, BigInt(8 * this.length), i),
        this.process(n, 0));
      const o = (0, Wc.createView)(t),
        a = this.outputLen;
      if (a % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
      const c = a / 4,
        l = this.get();
      if (c > l.length) throw new Error('_sha2: outputLen bigger than state');
      for (let u = 0; u < c; u++) o.setUint32(4 * u, l[u], i);
    }
    digest() {
      const {buffer: t, outputLen: e} = this;
      this.digestInto(t);
      const n = t.slice(0, e);
      return (this.destroy(), n);
    }
    _cloneInto(t) {
      (t || (t = new this.constructor()), t.set(...this.get()));
      const {
        blockLen: e,
        buffer: n,
        length: r,
        finished: i,
        destroyed: s,
        pos: o
      } = this;
      return (
        (t.length = r),
        (t.pos = o),
        (t.finished = i),
        (t.destroyed = s),
        r % e && t.buffer.set(n),
        t
      );
    }
  };
  var Fe = {};
  (Object.defineProperty(Fe, '__esModule', {value: !0}),
    (Fe.add5L =
      Fe.add5H =
      Fe.add4H =
      Fe.add4L =
      Fe.add3H =
      Fe.add3L =
      Fe.rotlBL =
      Fe.rotlBH =
      Fe.rotlSL =
      Fe.rotlSH =
      Fe.rotr32L =
      Fe.rotr32H =
      Fe.rotrBL =
      Fe.rotrBH =
      Fe.rotrSL =
      Fe.rotrSH =
      Fe.shrSL =
      Fe.shrSH =
      Fe.toBig =
        void 0),
    (Fe.fromBig = Yv),
    (Fe.split = MC),
    (Fe.add = GC));
  const hd = BigInt(2 ** 32 - 1),
    $g = BigInt(32);
  function Yv(t, e = !1) {
    return e
      ? {h: Number(t & hd), l: Number((t >> $g) & hd)}
      : {h: 0 | Number((t >> $g) & hd), l: 0 | Number(t & hd)};
  }
  function MC(t, e = !1) {
    let n = new Uint32Array(t.length),
      r = new Uint32Array(t.length);
    for (let i = 0; i < t.length; i++) {
      const {h: s, l: o} = Yv(t[i], e);
      [n[i], r[i]] = [s, o];
    }
    return [n, r];
  }
  const OC = (t, e) => (BigInt(t >>> 0) << $g) | BigInt(e >>> 0);
  Fe.toBig = OC;
  const NC = (t, e, n) => t >>> n;
  Fe.shrSH = NC;
  const LC = (t, e, n) => (t << (32 - n)) | (e >>> n);
  Fe.shrSL = LC;
  const BC = (t, e, n) => (t >>> n) | (e << (32 - n));
  Fe.rotrSH = BC;
  const DC = (t, e, n) => (t << (32 - n)) | (e >>> n);
  Fe.rotrSL = DC;
  const FC = (t, e, n) => (t << (64 - n)) | (e >>> (n - 32));
  Fe.rotrBH = FC;
  const $C = (t, e, n) => (t >>> (n - 32)) | (e << (64 - n));
  Fe.rotrBL = $C;
  const HC = (t, e) => e;
  Fe.rotr32H = HC;
  const jC = (t, e) => t;
  Fe.rotr32L = jC;
  const UC = (t, e, n) => (t << n) | (e >>> (32 - n));
  Fe.rotlSH = UC;
  const KC = (t, e, n) => (e << n) | (t >>> (32 - n));
  Fe.rotlSL = KC;
  const qC = (t, e, n) => (e << (n - 32)) | (t >>> (64 - n));
  Fe.rotlBH = qC;
  const VC = (t, e, n) => (t << (n - 32)) | (e >>> (64 - n));
  function GC(t, e, n, r) {
    const i = (e >>> 0) + (r >>> 0);
    return {h: (t + n + ((i / 2 ** 32) | 0)) | 0, l: 0 | i};
  }
  Fe.rotlBL = VC;
  const zC = (t, e, n) => (t >>> 0) + (e >>> 0) + (n >>> 0);
  Fe.add3L = zC;
  const WC = (t, e, n, r) => (e + n + r + ((t / 2 ** 32) | 0)) | 0;
  Fe.add3H = WC;
  const ZC = (t, e, n, r) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0);
  Fe.add4L = ZC;
  const YC = (t, e, n, r, i) => (e + n + r + i + ((t / 2 ** 32) | 0)) | 0;
  Fe.add4H = YC;
  const QC = (t, e, n, r, i) =>
    (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0);
  Fe.add5L = QC;
  const JC = (t, e, n, r, i, s) =>
    (e + n + r + i + s + ((t / 2 ** 32) | 0)) | 0;
  Fe.add5H = JC;
  const WH = {
    fromBig: Yv,
    split: MC,
    toBig: OC,
    shrSH: NC,
    shrSL: LC,
    rotrSH: BC,
    rotrSL: DC,
    rotrBH: FC,
    rotrBL: $C,
    rotr32H: HC,
    rotr32L: jC,
    rotlSH: UC,
    rotlSL: KC,
    rotlBH: qC,
    rotlBL: VC,
    add: GC,
    add3L: zC,
    add3H: WC,
    add4L: ZC,
    add4H: YC,
    add5H: JC,
    add5L: QC
  };
  ((Fe.default = WH),
    Object.defineProperty(Kt, '__esModule', {value: !0}),
    (Kt.sha384 =
      Kt.sha512_256 =
      Kt.sha512_224 =
      Kt.sha512 =
      Kt.SHA384 =
      Kt.SHA512_256 =
      Kt.SHA512_224 =
      Kt.SHA512 =
        void 0));
  const ZH = zi,
    Ke = Fe,
    pd = fs,
    [YH, QH] = Ke.default.split(
      [
        '0x428a2f98d728ae22',
        '0x7137449123ef65cd',
        '0xb5c0fbcfec4d3b2f',
        '0xe9b5dba58189dbbc',
        '0x3956c25bf348b538',
        '0x59f111f1b605d019',
        '0x923f82a4af194f9b',
        '0xab1c5ed5da6d8118',
        '0xd807aa98a3030242',
        '0x12835b0145706fbe',
        '0x243185be4ee4b28c',
        '0x550c7dc3d5ffb4e2',
        '0x72be5d74f27b896f',
        '0x80deb1fe3b1696b1',
        '0x9bdc06a725c71235',
        '0xc19bf174cf692694',
        '0xe49b69c19ef14ad2',
        '0xefbe4786384f25e3',
        '0x0fc19dc68b8cd5b5',
        '0x240ca1cc77ac9c65',
        '0x2de92c6f592b0275',
        '0x4a7484aa6ea6e483',
        '0x5cb0a9dcbd41fbd4',
        '0x76f988da831153b5',
        '0x983e5152ee66dfab',
        '0xa831c66d2db43210',
        '0xb00327c898fb213f',
        '0xbf597fc7beef0ee4',
        '0xc6e00bf33da88fc2',
        '0xd5a79147930aa725',
        '0x06ca6351e003826f',
        '0x142929670a0e6e70',
        '0x27b70a8546d22ffc',
        '0x2e1b21385c26c926',
        '0x4d2c6dfc5ac42aed',
        '0x53380d139d95b3df',
        '0x650a73548baf63de',
        '0x766a0abb3c77b2a8',
        '0x81c2c92e47edaee6',
        '0x92722c851482353b',
        '0xa2bfe8a14cf10364',
        '0xa81a664bbc423001',
        '0xc24b8b70d0f89791',
        '0xc76c51a30654be30',
        '0xd192e819d6ef5218',
        '0xd69906245565a910',
        '0xf40e35855771202a',
        '0x106aa07032bbd1b8',
        '0x19a4c116b8d2d0c8',
        '0x1e376c085141ab53',
        '0x2748774cdf8eeb99',
        '0x34b0bcb5e19b48a8',
        '0x391c0cb3c5c95a63',
        '0x4ed8aa4ae3418acb',
        '0x5b9cca4f7763e373',
        '0x682e6ff3d6b2b8a3',
        '0x748f82ee5defb2fc',
        '0x78a5636f43172f60',
        '0x84c87814a1f0ab72',
        '0x8cc702081a6439ec',
        '0x90befffa23631e28',
        '0xa4506cebde82bde9',
        '0xbef9a3f7b2c67915',
        '0xc67178f2e372532b',
        '0xca273eceea26619c',
        '0xd186b8c721c0c207',
        '0xeada7dd6cde0eb1e',
        '0xf57d4f7fee6ed178',
        '0x06f067aa72176fba',
        '0x0a637dc5a2c898a6',
        '0x113f9804bef90dae',
        '0x1b710b35131c471b',
        '0x28db77f523047d84',
        '0x32caab7b40c72493',
        '0x3c9ebe0a15c9bebc',
        '0x431d67c49c100d4c',
        '0x4cc5d4becb3e42b6',
        '0x597f299cfc657e2a',
        '0x5fcb6fab3ad6faec',
        '0x6c44198c4a475817'
      ].map((t) => BigInt(t))
    ),
    gs = new Uint32Array(80),
    ys = new Uint32Array(80);
  class ju extends ZH.HashMD {
    constructor() {
      (super(128, 64, 16, !1),
        (this.Ah = 1779033703),
        (this.Al = -205731576),
        (this.Bh = -1150833019),
        (this.Bl = -2067093701),
        (this.Ch = 1013904242),
        (this.Cl = -23791573),
        (this.Dh = -1521486534),
        (this.Dl = 1595750129),
        (this.Eh = 1359893119),
        (this.El = -1377402159),
        (this.Fh = -1694144372),
        (this.Fl = 725511199),
        (this.Gh = 528734635),
        (this.Gl = -79577749),
        (this.Hh = 1541459225),
        (this.Hl = 327033209));
    }
    get() {
      const {
        Ah: e,
        Al: n,
        Bh: r,
        Bl: i,
        Ch: s,
        Cl: o,
        Dh: a,
        Dl: c,
        Eh: l,
        El: u,
        Fh: d,
        Fl: f,
        Gh: h,
        Gl: g,
        Hh: m,
        Hl: y
      } = this;
      return [e, n, r, i, s, o, a, c, l, u, d, f, h, g, m, y];
    }
    set(e, n, r, i, s, o, a, c, l, u, d, f, h, g, m, y) {
      ((this.Ah = 0 | e),
        (this.Al = 0 | n),
        (this.Bh = 0 | r),
        (this.Bl = 0 | i),
        (this.Ch = 0 | s),
        (this.Cl = 0 | o),
        (this.Dh = 0 | a),
        (this.Dl = 0 | c),
        (this.Eh = 0 | l),
        (this.El = 0 | u),
        (this.Fh = 0 | d),
        (this.Fl = 0 | f),
        (this.Gh = 0 | h),
        (this.Gl = 0 | g),
        (this.Hh = 0 | m),
        (this.Hl = 0 | y));
    }
    process(e, n) {
      for (let v = 0; v < 16; v++, n += 4)
        ((gs[v] = e.getUint32(n)), (ys[v] = e.getUint32((n += 4))));
      for (let v = 16; v < 80; v++) {
        const x = 0 | gs[v - 15],
          C = 0 | ys[v - 15],
          $ =
            Ke.default.rotrSH(x, C, 1) ^
            Ke.default.rotrSH(x, C, 8) ^
            Ke.default.shrSH(x, C, 7),
          G =
            Ke.default.rotrSL(x, C, 1) ^
            Ke.default.rotrSL(x, C, 8) ^
            Ke.default.shrSL(x, C, 7),
          L = 0 | gs[v - 2],
          F = 0 | ys[v - 2],
          k =
            Ke.default.rotrSH(L, F, 19) ^
            Ke.default.rotrBH(L, F, 61) ^
            Ke.default.shrSH(L, F, 6),
          V =
            Ke.default.rotrSL(L, F, 19) ^
            Ke.default.rotrBL(L, F, 61) ^
            Ke.default.shrSL(L, F, 6),
          K = Ke.default.add4L(G, V, ys[v - 7], ys[v - 16]),
          B = Ke.default.add4H(K, $, k, gs[v - 7], gs[v - 16]);
        ((gs[v] = 0 | B), (ys[v] = 0 | K));
      }
      let {
        Ah: r,
        Al: i,
        Bh: s,
        Bl: o,
        Ch: a,
        Cl: c,
        Dh: l,
        Dl: u,
        Eh: d,
        El: f,
        Fh: h,
        Fl: g,
        Gh: m,
        Gl: y,
        Hh: p,
        Hl: b
      } = this;
      for (let v = 0; v < 80; v++) {
        const x =
            Ke.default.rotrSH(d, f, 14) ^
            Ke.default.rotrSH(d, f, 18) ^
            Ke.default.rotrBH(d, f, 41),
          C =
            Ke.default.rotrSL(d, f, 14) ^
            Ke.default.rotrSL(d, f, 18) ^
            Ke.default.rotrBL(d, f, 41),
          $ = (d & h) ^ (~d & m),
          G = (f & g) ^ (~f & y),
          L = Ke.default.add5L(b, C, G, QH[v], ys[v]),
          F = Ke.default.add5H(L, p, x, $, YH[v], gs[v]),
          k = 0 | L,
          V =
            Ke.default.rotrSH(r, i, 28) ^
            Ke.default.rotrBH(r, i, 34) ^
            Ke.default.rotrBH(r, i, 39),
          K =
            Ke.default.rotrSL(r, i, 28) ^
            Ke.default.rotrBL(r, i, 34) ^
            Ke.default.rotrBL(r, i, 39),
          B = (r & s) ^ (r & a) ^ (s & a),
          D = (i & o) ^ (i & c) ^ (o & c);
        ((p = 0 | m),
          (b = 0 | y),
          (m = 0 | h),
          (y = 0 | g),
          (h = 0 | d),
          (g = 0 | f),
          ({h: d, l: f} = Ke.default.add(0 | l, 0 | u, 0 | F, 0 | k)),
          (l = 0 | a),
          (u = 0 | c),
          (a = 0 | s),
          (c = 0 | o),
          (s = 0 | r),
          (o = 0 | i));
        const E = Ke.default.add3L(k, K, D);
        ((r = Ke.default.add3H(E, F, V, B)), (i = 0 | E));
      }
      (({h: r, l: i} = Ke.default.add(0 | this.Ah, 0 | this.Al, 0 | r, 0 | i)),
        ({h: s, l: o} = Ke.default.add(0 | this.Bh, 0 | this.Bl, 0 | s, 0 | o)),
        ({h: a, l: c} = Ke.default.add(0 | this.Ch, 0 | this.Cl, 0 | a, 0 | c)),
        ({h: l, l: u} = Ke.default.add(0 | this.Dh, 0 | this.Dl, 0 | l, 0 | u)),
        ({h: d, l: f} = Ke.default.add(0 | this.Eh, 0 | this.El, 0 | d, 0 | f)),
        ({h, l: g} = Ke.default.add(0 | this.Fh, 0 | this.Fl, 0 | h, 0 | g)),
        ({h: m, l: y} = Ke.default.add(0 | this.Gh, 0 | this.Gl, 0 | m, 0 | y)),
        ({h: p, l: b} = Ke.default.add(0 | this.Hh, 0 | this.Hl, 0 | p, 0 | b)),
        this.set(r, i, s, o, a, c, l, u, d, f, h, g, m, y, p, b));
    }
    roundClean() {
      (gs.fill(0), ys.fill(0));
    }
    destroy() {
      (this.buffer.fill(0),
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0));
    }
  }
  Kt.SHA512 = ju;
  class XC extends ju {
    constructor() {
      (super(),
        (this.Ah = -1942145080),
        (this.Al = 424955298),
        (this.Bh = 1944164710),
        (this.Bl = -1982016298),
        (this.Ch = 502970286),
        (this.Cl = 855612546),
        (this.Dh = 1738396948),
        (this.Dl = 1479516111),
        (this.Eh = 258812777),
        (this.El = 2077511080),
        (this.Fh = 2011393907),
        (this.Fl = 79989058),
        (this.Gh = 1067287976),
        (this.Gl = 1780299464),
        (this.Hh = 286451373),
        (this.Hl = -1848208735),
        (this.outputLen = 28));
    }
  }
  Kt.SHA512_224 = XC;
  class e5 extends ju {
    constructor() {
      (super(),
        (this.Ah = 573645204),
        (this.Al = -64227540),
        (this.Bh = -1621794909),
        (this.Bl = -934517566),
        (this.Ch = 596883563),
        (this.Cl = 1867755857),
        (this.Dh = -1774684391),
        (this.Dl = 1497426621),
        (this.Eh = -1775747358),
        (this.El = -1467023389),
        (this.Fh = -1101128155),
        (this.Fl = 1401305490),
        (this.Gh = 721525244),
        (this.Gl = 746961066),
        (this.Hh = 246885852),
        (this.Hl = -2117784414),
        (this.outputLen = 32));
    }
  }
  Kt.SHA512_256 = e5;
  class a_ extends ju {
    constructor() {
      (super(),
        (this.Ah = -876896931),
        (this.Al = -1056596264),
        (this.Bh = 1654270250),
        (this.Bl = 914150663),
        (this.Ch = -1856437926),
        (this.Cl = 812702999),
        (this.Dh = 355462360),
        (this.Dl = -150054599),
        (this.Eh = 1731405415),
        (this.El = -4191439),
        (this.Fh = -1900787065),
        (this.Fl = 1750603025),
        (this.Gh = -619958771),
        (this.Gl = 1694076839),
        (this.Hh = 1203062813),
        (this.Hl = -1090891868),
        (this.outputLen = 48));
    }
  }
  ((Kt.SHA384 = a_),
    (Kt.sha512 = (0, pd.wrapConstructor)(() => new ju())),
    (Kt.sha512_224 = (0, pd.wrapConstructor)(() => new XC())),
    (Kt.sha512_256 = (0, pd.wrapConstructor)(() => new e5())),
    (Kt.sha384 = (0, pd.wrapConstructor)(() => new a_())));
  var Hg = {},
    Na = {},
    ct = {},
    Ge = {};
  (Object.defineProperty(Ge, '__esModule', {value: !0}),
    (Ge.notImplemented = Ge.bitMask = void 0),
    (Ge.isBytes = Th),
    (Ge.abytes = Ih),
    (Ge.abool = function (t, e) {
      if (typeof e != 'boolean')
        throw new Error(`${t} must be valid boolean, got "${e}".`);
    }),
    (Ge.bytesToHex = qm),
    (Ge.numberToHexUnpadded = c_),
    (Ge.hexToNumber = Vm),
    (Ge.hexToBytes = nf),
    (Ge.bytesToNumberBE = function (t) {
      return Vm(qm(t));
    }),
    (Ge.bytesToNumberLE = function (t) {
      return (Ih(t), Vm(qm(Uint8Array.from(t).reverse())));
    }),
    (Ge.numberToBytesBE = u_),
    (Ge.numberToBytesLE = function (t, e) {
      return u_(t, e).reverse();
    }),
    (Ge.numberToVarBytesBE = function (t) {
      return nf(c_(t));
    }),
    (Ge.ensureBytes = function (t, e, n) {
      let r;
      if (typeof e == 'string')
        try {
          r = nf(e);
        } catch (s) {
          throw new Error(
            `${t} must be valid hex string, got "${e}". Cause: ${s}`
          );
        }
      else {
        if (!Th(e)) throw new Error(`${t} must be hex string or Uint8Array`);
        r = Uint8Array.from(e);
      }
      const i = r.length;
      if (typeof n == 'number' && i !== n)
        throw new Error(`${t} expected ${n} bytes, got ${i}`);
      return r;
    }),
    (Ge.concatBytes = d_),
    (Ge.equalBytes = function (t, e) {
      if (t.length !== e.length) return !1;
      let n = 0;
      for (let r = 0; r < t.length; r++) n |= t[r] ^ e[r];
      return n === 0;
    }),
    (Ge.utf8ToBytes = function (t) {
      if (typeof t != 'string')
        throw new Error('utf8ToBytes expected string, got ' + typeof t);
      return new Uint8Array(new TextEncoder().encode(t));
    }),
    (Ge.inRange = f_),
    (Ge.aInRange = function (t, e, n, r) {
      if (!f_(e, n, r))
        throw new Error(
          `expected valid ${t}: ${n} <= n < ${r}, got ${typeof e} ${e}`
        );
    }),
    (Ge.bitLen = function (t) {
      let e;
      for (e = 0; t > jg; t >>= tf, e += 1);
      return e;
    }),
    (Ge.bitGet = function (t, e) {
      return (t >> BigInt(e)) & tf;
    }),
    (Ge.bitSet = function (t, e, n) {
      return t | ((n ? tf : jg) << BigInt(e));
    }),
    (Ge.createHmacDrbg = function (t, e, n) {
      if (typeof t != 'number' || t < 2)
        throw new Error('hashLen must be a number');
      if (typeof e != 'number' || e < 2)
        throw new Error('qByteLen must be a number');
      if (typeof n != 'function') throw new Error('hmacFn must be a function');
      let r = zm(t),
        i = zm(t),
        s = 0;
      const o = () => {
          (r.fill(1), i.fill(0), (s = 0));
        },
        a = (...u) => n(i, r, ...u),
        c = (u = zm()) => {
          ((i = a(h_([0]), u)),
            (r = a()),
            u.length !== 0 && ((i = a(h_([1]), u)), (r = a())));
        },
        l = () => {
          if (s++ >= 1e3) throw new Error('drbg: tried 1000 values');
          let u = 0;
          const d = [];
          for (; u < e; ) {
            r = a();
            const f = r.slice();
            (d.push(f), (u += r.length));
          }
          return d_(...d);
        };
      return (u, d) => {
        let f;
        for (o(), c(u); !(f = d(l())); ) c();
        return (o(), f);
      };
    }),
    (Ge.validateObject = function (t, e, n = {}) {
      const r = (i, s, o) => {
        const a = ej[s];
        if (typeof a != 'function')
          throw new Error(`Invalid validator "${s}", expected function`);
        const c = t[i];
        if (!((o && c === void 0) || a(c, t)))
          throw new Error(
            `Invalid param ${String(i)}=${c} (${typeof c}), expected ${s}`
          );
      };
      for (const [i, s] of Object.entries(e)) r(i, s, !1);
      for (const [i, s] of Object.entries(n)) r(i, s, !0);
      return t;
    }),
    (Ge.memoized = function (t) {
      const e = new WeakMap();
      return (n, ...r) => {
        const i = e.get(n);
        if (i !== void 0) return i;
        const s = t(n, ...r);
        return (e.set(n, s), s);
      };
    }));
  const jg = BigInt(0),
    tf = BigInt(1),
    JH = BigInt(2);
  function Th(t) {
    return (
      t instanceof Uint8Array ||
      (t != null && typeof t == 'object' && t.constructor.name === 'Uint8Array')
    );
  }
  function Ih(t) {
    if (!Th(t)) throw new Error('Uint8Array expected');
  }
  const XH = Array.from({length: 256}, (t, e) =>
    e.toString(16).padStart(2, '0')
  );
  function qm(t) {
    Ih(t);
    let e = '';
    for (let n = 0; n < t.length; n++) e += XH[t[n]];
    return e;
  }
  function c_(t) {
    const e = t.toString(16);
    return 1 & e.length ? `0${e}` : e;
  }
  function Vm(t) {
    if (typeof t != 'string')
      throw new Error('hex string expected, got ' + typeof t);
    return BigInt(t === '' ? '0' : `0x${t}`);
  }
  const Pi = {_0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102};
  function l_(t) {
    return t >= Pi._0 && t <= Pi._9
      ? t - Pi._0
      : t >= Pi._A && t <= Pi._F
        ? t - (Pi._A - 10)
        : t >= Pi._a && t <= Pi._f
          ? t - (Pi._a - 10)
          : void 0;
  }
  function nf(t) {
    if (typeof t != 'string')
      throw new Error('hex string expected, got ' + typeof t);
    const e = t.length,
      n = e / 2;
    if (e % 2)
      throw new Error(
        'padded hex string expected, got unpadded hex of length ' + e
      );
    const r = new Uint8Array(n);
    for (let i = 0, s = 0; i < n; i++, s += 2) {
      const o = l_(t.charCodeAt(s)),
        a = l_(t.charCodeAt(s + 1));
      if (o === void 0 || a === void 0) {
        const c = t[s] + t[s + 1];
        throw new Error(
          'hex string expected, got non-hex character "' + c + '" at index ' + s
        );
      }
      r[i] = 16 * o + a;
    }
    return r;
  }
  function u_(t, e) {
    return nf(t.toString(16).padStart(2 * e, '0'));
  }
  function d_(...t) {
    let e = 0;
    for (let r = 0; r < t.length; r++) {
      const i = t[r];
      (Ih(i), (e += i.length));
    }
    const n = new Uint8Array(e);
    for (let r = 0, i = 0; r < t.length; r++) {
      const s = t[r];
      (n.set(s, i), (i += s.length));
    }
    return n;
  }
  const Gm = (t) => typeof t == 'bigint' && jg <= t;
  function f_(t, e, n) {
    return Gm(t) && Gm(e) && Gm(n) && e <= t && t < n;
  }
  Ge.bitMask = (t) => (JH << BigInt(t - 1)) - tf;
  const zm = (t) => new Uint8Array(t),
    h_ = (t) => Uint8Array.from(t),
    ej = {
      bigint: (t) => typeof t == 'bigint',
      function: (t) => typeof t == 'function',
      boolean: (t) => typeof t == 'boolean',
      string: (t) => typeof t == 'string',
      stringOrUint8Array: (t) => typeof t == 'string' || Th(t),
      isSafeInteger: (t) => Number.isSafeInteger(t),
      array: (t) => Array.isArray(t),
      field: (t, e) => e.Fp.isValid(t),
      hash: (t) => typeof t == 'function' && Number.isSafeInteger(t.outputLen)
    };
  ((Ge.notImplemented = () => {
    throw new Error('not implemented');
  }),
    Object.defineProperty(ct, '__esModule', {value: !0}),
    (ct.isNegativeLE = void 0),
    (ct.mod = Zn),
    (ct.pow = t5),
    (ct.pow2 = function (t, e, n) {
      let r = t;
      for (; e-- > qt; ) ((r *= r), (r %= n));
      return r;
    }),
    (ct.invert = md),
    (ct.tonelliShanks = n5),
    (ct.FpSqrt = g_),
    (ct.validateField = function (t) {
      const e = nj.reduce((n, r) => ((n[r] = 'function'), n), {
        ORDER: 'bigint',
        MASK: 'bigint',
        BYTES: 'isSafeInteger',
        BITS: 'isSafeInteger'
      });
      return (0, Gn.validateObject)(t, e);
    }),
    (ct.FpPow = y_),
    (ct.FpInvertBatch = v_),
    (ct.FpDiv = function (t, e, n) {
      return t.mul(e, typeof n == 'bigint' ? md(n, t.ORDER) : t.inv(n));
    }),
    (ct.FpLegendre = b_),
    (ct.FpIsSquare = function (t) {
      const e = b_(t.ORDER);
      return (n) => {
        const r = e(t, n);
        return t.eql(r, t.ZERO) || t.eql(r, t.ONE);
      };
    }),
    (ct.nLength = Wm),
    (ct.Field = function (t, e, n = !1, r = {}) {
      if (t <= qt) throw new Error(`Expected Field ORDER > 0, got ${t}`);
      const {nBitLength: i, nByteLength: s} = Wm(t, e);
      if (s > 2048)
        throw new Error('Field lengths over 2048 bytes are not supported');
      const o = g_(t),
        a = Object.freeze({
          ORDER: t,
          BITS: i,
          BYTES: s,
          MASK: (0, Gn.bitMask)(i),
          ZERO: qt,
          ONE: vt,
          create: (c) => Zn(c, t),
          isValid: (c) => {
            if (typeof c != 'bigint')
              throw new Error(
                'Invalid field element: expected bigint, got ' + typeof c
              );
            return qt <= c && c < t;
          },
          is0: (c) => c === qt,
          isOdd: (c) => (c & vt) === vt,
          neg: (c) => Zn(-c, t),
          eql: (c, l) => c === l,
          sqr: (c) => Zn(c * c, t),
          add: (c, l) => Zn(c + l, t),
          sub: (c, l) => Zn(c - l, t),
          mul: (c, l) => Zn(c * l, t),
          pow: (c, l) => y_(a, c, l),
          div: (c, l) => Zn(c * md(l, t), t),
          sqrN: (c) => c * c,
          addN: (c, l) => c + l,
          subN: (c, l) => c - l,
          mulN: (c, l) => c * l,
          inv: (c) => md(c, t),
          sqrt: r.sqrt || ((c) => o(a, c)),
          invertBatch: (c) => v_(a, c),
          cmov: (c, l, u) => (u ? l : c),
          toBytes: (c) =>
            n ? (0, Gn.numberToBytesLE)(c, s) : (0, Gn.numberToBytesBE)(c, s),
          fromBytes: (c) => {
            if (c.length !== s)
              throw new Error(`Fp.fromBytes: expected ${s}, got ${c.length}`);
            return n ? (0, Gn.bytesToNumberLE)(c) : (0, Gn.bytesToNumberBE)(c);
          }
        });
      return Object.freeze(a);
    }),
    (ct.FpSqrtOdd = function (t, e) {
      if (!t.isOdd) throw new Error("Field doesn't have isOdd");
      const n = t.sqrt(e);
      return t.isOdd(n) ? n : t.neg(n);
    }),
    (ct.FpSqrtEven = function (t, e) {
      if (!t.isOdd) throw new Error("Field doesn't have isOdd");
      const n = t.sqrt(e);
      return t.isOdd(n) ? t.neg(n) : n;
    }),
    (ct.hashToPrivateScalar = function (t, e, n = !1) {
      t = (0, Gn.ensureBytes)('privateHash', t);
      const r = t.length,
        i = Wm(e).nByteLength + 8;
      if (i < 24 || r < i || r > 1024)
        throw new Error(
          `hashToPrivateScalar: expected ${i}-1024 bytes of input, got ${r}`
        );
      const s = n ? (0, Gn.bytesToNumberLE)(t) : (0, Gn.bytesToNumberBE)(t);
      return Zn(s, e - vt) + vt;
    }),
    (ct.getFieldBytesLength = Kg),
    (ct.getMinHashLength = w_),
    (ct.mapHashToField = function (t, e, n = !1) {
      const r = t.length,
        i = Kg(e),
        s = w_(e);
      if (r < 16 || r < s || r > 1024)
        throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);
      const o =
        Zn(
          n ? (0, Gn.bytesToNumberBE)(t) : (0, Gn.bytesToNumberLE)(t),
          e - vt
        ) + vt;
      return n ? (0, Gn.numberToBytesLE)(o, i) : (0, Gn.numberToBytesBE)(o, i);
    }));
  const Gn = Ge,
    qt = BigInt(0),
    vt = BigInt(1),
    Bs = BigInt(2),
    tj = BigInt(3),
    Ug = BigInt(4),
    p_ = BigInt(5),
    m_ = BigInt(8);
  function Zn(t, e) {
    const n = t % e;
    return n >= qt ? n : e + n;
  }
  function t5(t, e, n) {
    if (n <= qt || e < qt) throw new Error('Expected power/modulo > 0');
    if (n === vt) return qt;
    let r = vt;
    for (; e > qt; )
      (e & vt && (r = (r * t) % n), (t = (t * t) % n), (e >>= vt));
    return r;
  }
  function md(t, e) {
    if (t === qt || e <= qt)
      throw new Error(
        `invert: expected positive integers, got n=${t} mod=${e}`
      );
    let n = Zn(t, e),
      r = e,
      i = qt,
      s = vt;
    for (; n !== qt; ) {
      const o = r % n,
        a = i - s * (r / n);
      ((r = n), (n = o), (i = s), (s = a));
    }
    if (r !== vt) throw new Error('invert: does not exist');
    return Zn(i, e);
  }
  function n5(t) {
    const e = (t - vt) / Bs;
    let n, r, i;
    for (n = t - vt, r = 0; n % Bs === qt; n /= Bs, r++);
    for (i = Bs; i < t && t5(i, e, t) !== t - vt; i++);
    if (r === 1) {
      const o = (t + vt) / Ug;
      return function (a, c) {
        const l = a.pow(c, o);
        if (!a.eql(a.sqr(l), c)) throw new Error('Cannot find square root');
        return l;
      };
    }
    const s = (n + vt) / Bs;
    return function (o, a) {
      if (o.pow(a, e) === o.neg(o.ONE))
        throw new Error('Cannot find square root');
      let c = r,
        l = o.pow(o.mul(o.ONE, i), n),
        u = o.pow(a, s),
        d = o.pow(a, n);
      for (; !o.eql(d, o.ONE); ) {
        if (o.eql(d, o.ZERO)) return o.ZERO;
        let f = 1;
        for (let g = o.sqr(d); f < c && !o.eql(g, o.ONE); f++) g = o.sqr(g);
        const h = o.pow(l, vt << BigInt(c - f - 1));
        ((l = o.sqr(h)), (u = o.mul(u, h)), (d = o.mul(d, l)), (c = f));
      }
      return u;
    };
  }
  function g_(t) {
    if (t % Ug === tj) {
      const e = (t + vt) / Ug;
      return function (n, r) {
        const i = n.pow(r, e);
        if (!n.eql(n.sqr(i), r)) throw new Error('Cannot find square root');
        return i;
      };
    }
    if (t % m_ === p_) {
      const e = (t - p_) / m_;
      return function (n, r) {
        const i = n.mul(r, Bs),
          s = n.pow(i, e),
          o = n.mul(r, s),
          a = n.mul(n.mul(o, Bs), s),
          c = n.mul(o, n.sub(a, n.ONE));
        if (!n.eql(n.sqr(c), r)) throw new Error('Cannot find square root');
        return c;
      };
    }
    return n5(t);
  }
  (BigInt(9), BigInt(16));
  ct.isNegativeLE = (t, e) => (Zn(t, e) & vt) === vt;
  const nj = [
    'create',
    'isValid',
    'is0',
    'neg',
    'inv',
    'sqrt',
    'sqr',
    'eql',
    'add',
    'sub',
    'mul',
    'pow',
    'div',
    'addN',
    'subN',
    'mulN',
    'sqrN'
  ];
  function y_(t, e, n) {
    if (n < qt) throw new Error('Expected power > 0');
    if (n === qt) return t.ONE;
    if (n === vt) return e;
    let r = t.ONE,
      i = e;
    for (; n > qt; ) (n & vt && (r = t.mul(r, i)), (i = t.sqr(i)), (n >>= vt));
    return r;
  }
  function v_(t, e) {
    const n = new Array(e.length),
      r = e.reduce(
        (s, o, a) => (t.is0(o) ? s : ((n[a] = s), t.mul(s, o))),
        t.ONE
      ),
      i = t.inv(r);
    return (
      e.reduceRight(
        (s, o, a) => (t.is0(o) ? s : ((n[a] = t.mul(s, n[a])), t.mul(s, o))),
        i
      ),
      n
    );
  }
  function b_(t) {
    const e = (t - vt) / Bs;
    return (n, r) => n.pow(r, e);
  }
  function Wm(t, e) {
    const n = e !== void 0 ? e : t.toString(2).length;
    return {nBitLength: n, nByteLength: Math.ceil(n / 8)};
  }
  function Kg(t) {
    if (typeof t != 'bigint') throw new Error('field order must be bigint');
    const e = t.toString(2).length;
    return Math.ceil(e / 8);
  }
  function w_(t) {
    const e = Kg(t);
    return e + Math.ceil(e / 2);
  }
  (Object.defineProperty(Na, '__esModule', {value: !0}),
    (Na.wNAF = function (t, e) {
      const n = (s, o) => {
          const a = o.negate();
          return s ? a : o;
        },
        r = (s) => {
          if (!Number.isSafeInteger(s) || s <= 0 || s > e)
            throw new Error(`Wrong window size=${s}, should be [1..${e}]`);
        },
        i = (s) => (
          r(s),
          {windows: Math.ceil(e / s) + 1, windowSize: 2 ** (s - 1)}
        );
      return {
        constTimeNegate: n,
        unsafeLadder(s, o) {
          let a = t.ZERO,
            c = s;
          for (; o > rj; )
            (o & Zm && (a = a.add(c)), (c = c.double()), (o >>= Zm));
          return a;
        },
        precomputeWindow(s, o) {
          const {windows: a, windowSize: c} = i(o),
            l = [];
          let u = s,
            d = u;
          for (let f = 0; f < a; f++) {
            ((d = u), l.push(d));
            for (let h = 1; h < c; h++) ((d = d.add(u)), l.push(d));
            u = d.double();
          }
          return l;
        },
        wNAF(s, o, a) {
          const {windows: c, windowSize: l} = i(s);
          let u = t.ZERO,
            d = t.BASE;
          const f = BigInt(2 ** s - 1),
            h = 2 ** s,
            g = BigInt(s);
          for (let m = 0; m < c; m++) {
            const y = m * l;
            let p = Number(a & f);
            ((a >>= g), p > l && ((p -= h), (a += Zm)));
            const b = y,
              v = y + Math.abs(p) - 1,
              x = m % 2 != 0,
              C = p < 0;
            p === 0 ? (d = d.add(n(x, o[b]))) : (u = u.add(n(C, o[v])));
          }
          return {p: u, f: d};
        },
        wNAFCached(s, o, a) {
          const c = A_.get(s) || 1;
          let l = Ym.get(s);
          return (
            l ||
              ((l = this.precomputeWindow(s, c)), c !== 1 && Ym.set(s, a(l))),
            this.wNAF(c, l, o)
          );
        },
        setWindowSize(s, o) {
          (r(o), A_.set(s, o), Ym.delete(s));
        }
      };
    }),
    (Na.pippenger = function (t, e, n, r) {
      if (!Array.isArray(n) || !Array.isArray(r) || r.length !== n.length)
        throw new Error('arrays of points and scalars must have equal length');
      (r.forEach((u, d) => {
        if (!e.isValid(u)) throw new Error(`wrong scalar at index ${d}`);
      }),
        n.forEach((u, d) => {
          if (!(u instanceof t)) throw new Error(`wrong point at index ${d}`);
        }));
      const i = (0, E_.bitLen)(BigInt(n.length)),
        s = i > 12 ? i - 3 : i > 4 ? i - 2 : i ? 2 : 1,
        o = (1 << s) - 1,
        a = new Array(o + 1).fill(t.ZERO),
        c = Math.floor((e.BITS - 1) / s) * s;
      let l = t.ZERO;
      for (let u = c; u >= 0; u -= s) {
        a.fill(t.ZERO);
        for (let f = 0; f < r.length; f++) {
          const h = r[f],
            g = Number((h >> BigInt(u)) & BigInt(o));
          a[g] = a[g].add(n[f]);
        }
        let d = t.ZERO;
        for (let f = a.length - 1, h = t.ZERO; f > 0; f--)
          ((h = h.add(a[f])), (d = d.add(h)));
        if (((l = l.add(d)), u !== 0))
          for (let f = 0; f < s; f++) l = l.double();
      }
      return l;
    }),
    (Na.validateBasic = function (t) {
      return (
        (0, __.validateField)(t.Fp),
        (0, E_.validateObject)(
          t,
          {n: 'bigint', h: 'bigint', Gx: 'field', Gy: 'field'},
          {nBitLength: 'isSafeInteger', nByteLength: 'isSafeInteger'}
        ),
        Object.freeze({
          ...(0, __.nLength)(t.n, t.nBitLength),
          ...t,
          p: t.Fp.ORDER
        })
      );
    }));
  const __ = ct,
    E_ = Ge,
    rj = BigInt(0),
    Zm = BigInt(1),
    Ym = new WeakMap(),
    A_ = new WeakMap();
  (Object.defineProperty(Hg, '__esModule', {value: !0}),
    (Hg.twistedEdwards = function (t) {
      const e = (function (B) {
          const D = (0, Qm.validateBasic)(B);
          return (
            Bn.validateObject(
              B,
              {
                hash: 'function',
                a: 'bigint',
                d: 'bigint',
                randomBytes: 'function'
              },
              {
                adjustScalarBytes: 'function',
                domain: 'function',
                uvRatio: 'function',
                mapToCurve: 'function'
              }
            ),
            Object.freeze({...D})
          );
        })(t),
        {
          Fp: n,
          n: r,
          prehash: i,
          hash: s,
          randomBytes: o,
          nByteLength: a,
          h: c
        } = e,
        l = gd << (BigInt(8 * a) - Dn),
        u = n.create,
        d = (0, S_.Field)(e.n, e.nBitLength),
        f =
          e.uvRatio ||
          ((B, D) => {
            try {
              return {isValid: !0, value: n.sqrt(B * n.inv(D))};
            } catch {
              return {isValid: !1, value: xr};
            }
          }),
        h = e.adjustScalarBytes || ((B) => B),
        g =
          e.domain ||
          ((B, D, E) => {
            if (((0, zn.abool)('phflag', E), D.length || E))
              throw new Error('Contexts/pre-hash are not supported');
            return B;
          });
      function m(B, D) {
        Bn.aInRange('coordinate ' + B, D, xr, l);
      }
      function y(B) {
        if (!(B instanceof v)) throw new Error('ExtendedPoint expected');
      }
      const p = (0, zn.memoized)((B, D) => {
          const {ex: E, ey: P, ez: U} = B,
            w = B.is0();
          D == null && (D = w ? ij : n.inv(U));
          const A = u(E * D),
            T = u(P * D),
            R = u(U * D);
          if (w) return {x: xr, y: Dn};
          if (R !== Dn) throw new Error('invZ was invalid');
          return {x: A, y: T};
        }),
        b = (0, zn.memoized)((B) => {
          const {a: D, d: E} = e;
          if (B.is0()) throw new Error('bad point: ZERO');
          const {ex: P, ey: U, ez: w, et: A} = B,
            T = u(P * P),
            R = u(U * U),
            _ = u(w * w),
            S = u(_ * _),
            I = u(T * D);
          if (u(_ * u(I + R)) !== u(S + u(E * u(T * R))))
            throw new Error('bad point: equation left != right (1)');
          if (u(P * U) !== u(w * A))
            throw new Error('bad point: equation left != right (2)');
          return !0;
        });
      class v {
        constructor(D, E, P, U) {
          ((this.ex = D),
            (this.ey = E),
            (this.ez = P),
            (this.et = U),
            m('x', D),
            m('y', E),
            m('z', P),
            m('t', U),
            Object.freeze(this));
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        static fromAffine(D) {
          if (D instanceof v) throw new Error('extended point not allowed');
          const {x: E, y: P} = D || {};
          return (m('x', E), m('y', P), new v(E, P, Dn, u(E * P)));
        }
        static normalizeZ(D) {
          const E = n.invertBatch(D.map((P) => P.ez));
          return D.map((P, U) => P.toAffine(E[U])).map(v.fromAffine);
        }
        static msm(D, E) {
          return (0, Qm.pippenger)(v, d, D, E);
        }
        _setWindowSize(D) {
          $.setWindowSize(this, D);
        }
        assertValidity() {
          b(this);
        }
        equals(D) {
          y(D);
          const {ex: E, ey: P, ez: U} = this,
            {ex: w, ey: A, ez: T} = D,
            R = u(E * T),
            _ = u(w * U),
            S = u(P * T),
            I = u(A * U);
          return R === _ && S === I;
        }
        is0() {
          return this.equals(v.ZERO);
        }
        negate() {
          return new v(u(-this.ex), this.ey, this.ez, u(-this.et));
        }
        double() {
          const {a: D} = e,
            {ex: E, ey: P, ez: U} = this,
            w = u(E * E),
            A = u(P * P),
            T = u(gd * u(U * U)),
            R = u(D * w),
            _ = E + P,
            S = u(u(_ * _) - w - A),
            I = R + A,
            O = I - T,
            H = R - A,
            M = u(S * O),
            q = u(I * H),
            z = u(S * H),
            Z = u(O * I);
          return new v(M, q, Z, z);
        }
        add(D) {
          y(D);
          const {a: E, d: P} = e,
            {ex: U, ey: w, ez: A, et: T} = this,
            {ex: R, ey: _, ez: S, et: I} = D;
          if (E === BigInt(-1)) {
            const Y = u((w - U) * (_ + R)),
              se = u((w + U) * (_ - R)),
              ne = u(se - Y);
            if (ne === xr) return this.double();
            const oe = u(A * gd * I),
              ce = u(T * gd * S),
              fe = ce + oe,
              le = se + Y,
              ve = ce - oe,
              _e = u(fe * ne),
              Te = u(le * ve),
              st = u(fe * ve),
              et = u(ne * le);
            return new v(_e, Te, et, st);
          }
          const O = u(U * R),
            H = u(w * _),
            M = u(T * P * I),
            q = u(A * S),
            z = u((U + w) * (R + _) - O - H),
            Z = q - M,
            X = q + M,
            N = u(H - E * O),
            j = u(z * Z),
            W = u(X * N),
            J = u(z * N),
            Q = u(Z * X);
          return new v(j, W, Q, J);
        }
        subtract(D) {
          return this.add(D.negate());
        }
        wNAF(D) {
          return $.wNAFCached(this, D, v.normalizeZ);
        }
        multiply(D) {
          const E = D;
          Bn.aInRange('scalar', E, Dn, r);
          const {p: P, f: U} = this.wNAF(E);
          return v.normalizeZ([P, U])[0];
        }
        multiplyUnsafe(D) {
          const E = D;
          return (
            Bn.aInRange('scalar', E, xr, r),
            E === xr
              ? C
              : this.equals(C) || E === Dn
                ? this
                : this.equals(x)
                  ? this.wNAF(E).p
                  : $.unsafeLadder(this, E)
          );
        }
        isSmallOrder() {
          return this.multiplyUnsafe(c).is0();
        }
        isTorsionFree() {
          return $.unsafeLadder(this, r).is0();
        }
        toAffine(D) {
          return p(this, D);
        }
        clearCofactor() {
          const {h: D} = e;
          return D === Dn ? this : this.multiplyUnsafe(D);
        }
        static fromHex(D, E = !1) {
          const {d: P, a: U} = e,
            w = n.BYTES;
          ((D = (0, zn.ensureBytes)('pointHex', D, w)),
            (0, zn.abool)('zip215', E));
          const A = D.slice(),
            T = D[w - 1];
          A[w - 1] = -129 & T;
          const R = Bn.bytesToNumberLE(A),
            _ = E ? l : n.ORDER;
          Bn.aInRange('pointHex.y', R, xr, _);
          const S = u(R * R),
            I = u(S - Dn),
            O = u(P * S - U);
          let {isValid: H, value: M} = f(I, O);
          if (!H) throw new Error('Point.fromHex: invalid y coordinate');
          const q = (M & Dn) === Dn,
            z = (128 & T) != 0;
          if (!E && M === xr && z)
            throw new Error('Point.fromHex: x=0 and x_0=1');
          return (z !== q && (M = u(-M)), v.fromAffine({x: M, y: R}));
        }
        static fromPrivateKey(D) {
          return F(D).point;
        }
        toRawBytes() {
          const {x: D, y: E} = this.toAffine(),
            P = Bn.numberToBytesLE(E, n.BYTES);
          return ((P[P.length - 1] |= D & Dn ? 128 : 0), P);
        }
        toHex() {
          return Bn.bytesToHex(this.toRawBytes());
        }
      }
      ((v.BASE = new v(e.Gx, e.Gy, Dn, u(e.Gx * e.Gy))),
        (v.ZERO = new v(xr, Dn, Dn, xr)));
      const {BASE: x, ZERO: C} = v,
        $ = (0, Qm.wNAF)(v, 8 * a);
      function G(B) {
        return (0, S_.mod)(B, r);
      }
      function L(B) {
        return G(Bn.bytesToNumberLE(B));
      }
      function F(B) {
        const D = a;
        B = (0, zn.ensureBytes)('private key', B, D);
        const E = (0, zn.ensureBytes)('hashed private key', s(B), 2 * D),
          P = h(E.slice(0, D)),
          U = E.slice(D, 2 * D),
          w = L(P),
          A = x.multiply(w),
          T = A.toRawBytes();
        return {head: P, prefix: U, scalar: w, point: A, pointBytes: T};
      }
      function k(B = new Uint8Array(), ...D) {
        const E = Bn.concatBytes(...D);
        return L(s(g(E, (0, zn.ensureBytes)('context', B), !!i)));
      }
      const V = sj;
      return (
        x._setWindowSize(8),
        {
          CURVE: e,
          getPublicKey: function (B) {
            return F(B).pointBytes;
          },
          sign: function (B, D, E = {}) {
            ((B = (0, zn.ensureBytes)('message', B)), i && (B = i(B)));
            const {prefix: P, scalar: U, pointBytes: w} = F(D),
              A = k(E.context, P, B),
              T = x.multiply(A).toRawBytes(),
              R = G(A + k(E.context, T, w, B) * U);
            Bn.aInRange('signature.s', R, xr, r);
            const _ = Bn.concatBytes(T, Bn.numberToBytesLE(R, n.BYTES));
            return (0, zn.ensureBytes)('result', _, 2 * a);
          },
          verify: function (B, D, E, P = V) {
            const {context: U, zip215: w} = P,
              A = n.BYTES;
            ((B = (0, zn.ensureBytes)('signature', B, 2 * A)),
              (D = (0, zn.ensureBytes)('message', D)),
              w !== void 0 && (0, zn.abool)('zip215', w),
              i && (D = i(D)));
            const T = Bn.bytesToNumberLE(B.slice(A, 2 * A));
            let R, _, S;
            try {
              ((R = v.fromHex(E, w)),
                (_ = v.fromHex(B.slice(0, A), w)),
                (S = x.multiplyUnsafe(T)));
            } catch {
              return !1;
            }
            if (!w && R.isSmallOrder()) return !1;
            const I = k(U, _.toRawBytes(), R.toRawBytes(), D);
            return _.add(R.multiplyUnsafe(I))
              .subtract(S)
              .clearCofactor()
              .equals(v.ZERO);
          },
          ExtendedPoint: v,
          utils: {
            getExtendedPublicKey: F,
            randomPrivateKey: () => o(n.BYTES),
            precompute: (B = 8, D = v.BASE) => (
              D._setWindowSize(B),
              D.multiply(BigInt(3)),
              D
            )
          }
        }
      );
    }));
  const Qm = Na,
    S_ = ct,
    Bn = Ge,
    zn = Ge,
    xr = BigInt(0),
    Dn = BigInt(1),
    gd = BigInt(2),
    ij = BigInt(8),
    sj = {zip215: !0};
  var ks = {};
  (Object.defineProperty(ks, '__esModule', {value: !0}),
    (ks.expand_message_xmd = r5),
    (ks.expand_message_xof = i5),
    (ks.hash_to_field = Jm),
    (ks.isogenyMap = function (t, e) {
      const n = e.map((r) => Array.from(r).reverse());
      return (r, i) => {
        const [s, o, a, c] = n.map((l) =>
          l.reduce((u, d) => t.add(t.mul(u, r), d))
        );
        return ((r = t.div(s, o)), (i = t.mul(i, t.div(a, c))), {x: r, y: i});
      };
    }),
    (ks.createHasher = function (t, e, n) {
      if (typeof e != 'function')
        throw new Error('mapToCurve() must be defined');
      return {
        hashToCurve(r, i) {
          const s = Jm(r, 2, {...n, DST: n.DST, ...i}),
            o = t.fromAffine(e(s[0])),
            a = t.fromAffine(e(s[1])),
            c = o.add(a).clearCofactor();
          return (c.assertValidity(), c);
        },
        encodeToCurve(r, i) {
          const s = Jm(r, 1, {...n, DST: n.encodeDST, ...i}),
            o = t.fromAffine(e(s[0])).clearCofactor();
          return (o.assertValidity(), o);
        },
        mapToCurve(r) {
          if (!Array.isArray(r))
            throw new Error('mapToCurve: expected array of bigints');
          for (const s of r)
            if (typeof s != 'bigint')
              throw new Error(
                `mapToCurve: expected array of bigints, got ${s} in array`
              );
          const i = t.fromAffine(e(r)).clearCofactor();
          return (i.assertValidity(), i);
        }
      };
    }));
  const oj = ct,
    ln = Ge,
    aj = ln.bytesToNumberBE;
  function Rs(t, e) {
    if ((fu(t), fu(e), t < 0 || t >= 1 << (8 * e)))
      throw new Error(`bad I2OSP call: value=${t} length=${e}`);
    const n = Array.from({length: e}).fill(0);
    for (let r = e - 1; r >= 0; r--) ((n[r] = 255 & t), (t >>>= 8));
    return new Uint8Array(n);
  }
  function cj(t, e) {
    const n = new Uint8Array(t.length);
    for (let r = 0; r < t.length; r++) n[r] = t[r] ^ e[r];
    return n;
  }
  function fu(t) {
    if (!Number.isSafeInteger(t)) throw new Error('number expected');
  }
  function r5(t, e, n, r) {
    ((0, ln.abytes)(t),
      (0, ln.abytes)(e),
      fu(n),
      e.length > 255 &&
        (e = r(
          (0, ln.concatBytes)((0, ln.utf8ToBytes)('H2C-OVERSIZE-DST-'), e)
        )));
    const {outputLen: i, blockLen: s} = r,
      o = Math.ceil(n / i);
    if (n > 65535 || o > 255)
      throw new Error('expand_message_xmd: invalid lenInBytes');
    const a = (0, ln.concatBytes)(e, Rs(e.length, 1)),
      c = Rs(0, s),
      l = Rs(n, 2),
      u = new Array(o),
      d = r((0, ln.concatBytes)(c, t, l, Rs(0, 1), a));
    u[0] = r((0, ln.concatBytes)(d, Rs(1, 1), a));
    for (let f = 1; f <= o; f++) {
      const h = [cj(d, u[f - 1]), Rs(f + 1, 1), a];
      u[f] = r((0, ln.concatBytes)(...h));
    }
    return (0, ln.concatBytes)(...u).slice(0, n);
  }
  function i5(t, e, n, r, i) {
    if (((0, ln.abytes)(t), (0, ln.abytes)(e), fu(n), e.length > 255)) {
      const s = Math.ceil((2 * r) / 8);
      e = i
        .create({dkLen: s})
        .update((0, ln.utf8ToBytes)('H2C-OVERSIZE-DST-'))
        .update(e)
        .digest();
    }
    if (n > 65535 || e.length > 255)
      throw new Error('expand_message_xof: invalid lenInBytes');
    return i
      .create({dkLen: n})
      .update(t)
      .update(Rs(n, 2))
      .update(e)
      .update(Rs(e.length, 1))
      .digest();
  }
  function Jm(t, e, n) {
    (0, ln.validateObject)(n, {
      DST: 'stringOrUint8Array',
      p: 'bigint',
      m: 'isSafeInteger',
      k: 'isSafeInteger',
      hash: 'hash'
    });
    const {p: r, k: i, m: s, hash: o, expand: a, DST: c} = n;
    ((0, ln.abytes)(t), fu(e));
    const l = typeof c == 'string' ? (0, ln.utf8ToBytes)(c) : c,
      u = r.toString(2).length,
      d = Math.ceil((u + i) / 8),
      f = e * s * d;
    let h;
    if (a === 'xmd') h = r5(t, l, f, o);
    else if (a === 'xof') h = i5(t, l, f, i, o);
    else {
      if (a !== '_internal_pass')
        throw new Error('expand must be "xmd" or "xof"');
      h = t;
    }
    const g = new Array(e);
    for (let m = 0; m < e; m++) {
      const y = new Array(s);
      for (let p = 0; p < s; p++) {
        const b = d * (p + m * s),
          v = h.subarray(b, b + d);
        y[p] = (0, oj.mod)(aj(v), r);
      }
      g[m] = y;
    }
    return g;
  }
  var qg = {};
  (Object.defineProperty(qg, '__esModule', {value: !0}),
    (qg.montgomery = function (t) {
      const e = (function (m) {
          return (
            (0, vs.validateObject)(
              m,
              {a: 'bigint'},
              {
                montgomeryBits: 'isSafeInteger',
                nByteLength: 'isSafeInteger',
                adjustScalarBytes: 'function',
                domain: 'function',
                powPminus2: 'function',
                Gu: 'bigint'
              }
            ),
            Object.freeze({...m})
          );
        })(t),
        {P: n} = e,
        r = (m) => (0, x_.mod)(m, n),
        i = e.montgomeryBits,
        s = Math.ceil(i / 8),
        o = e.nByteLength,
        a = e.adjustScalarBytes || ((m) => m),
        c = e.powPminus2 || ((m) => (0, x_.pow)(m, n - BigInt(2), n));
      function l(m, y, p) {
        const b = r(m * (y - p));
        return [(y = r(y - b)), (p = r(p + b))];
      }
      const u = (e.a - BigInt(2)) / BigInt(4);
      function d(m) {
        return (0, vs.numberToBytesLE)(r(m), s);
      }
      function f(m, y) {
        const p = (function (x) {
            const C = (0, vs.ensureBytes)('u coordinate', x, s);
            return (o === 32 && (C[31] &= 127), (0, vs.bytesToNumberLE)(C));
          })(y),
          b = (function (x) {
            const C = (0, vs.ensureBytes)('scalar', x),
              $ = C.length;
            if ($ !== s && $ !== o)
              throw new Error(`Expected ${s} or ${o} bytes, got ${$}`);
            return (0, vs.bytesToNumberLE)(a(C));
          })(m),
          v = (function (x, C) {
            ((0, vs.aInRange)('u', x, ya, n),
              (0, vs.aInRange)('scalar', C, ya, n));
            const $ = C,
              G = x;
            let L,
              F = Xm,
              k = ya,
              V = x,
              K = Xm,
              B = ya;
            for (let E = BigInt(i - 1); E >= ya; E--) {
              const P = ($ >> E) & Xm;
              ((B ^= P),
                (L = l(B, F, V)),
                (F = L[0]),
                (V = L[1]),
                (L = l(B, k, K)),
                (k = L[0]),
                (K = L[1]),
                (B = P));
              const U = F + k,
                w = r(U * U),
                A = F - k,
                T = r(A * A),
                R = w - T,
                _ = V + K,
                S = r((V - K) * U),
                I = r(_ * A),
                O = S + I,
                H = S - I;
              ((V = r(O * O)),
                (K = r(G * r(H * H))),
                (F = r(w * T)),
                (k = r(R * (w + r(u * R)))));
            }
            ((L = l(B, F, V)),
              (F = L[0]),
              (V = L[1]),
              (L = l(B, k, K)),
              (k = L[0]),
              (K = L[1]));
            const D = c(k);
            return r(F * D);
          })(p, b);
        if (v === ya) throw new Error('Invalid private or public key received');
        return d(v);
      }
      const h = d(e.Gu);
      function g(m) {
        return f(m, h);
      }
      return {
        scalarMult: f,
        scalarMultBase: g,
        getSharedSecret: (m, y) => f(m, y),
        getPublicKey: (m) => g(m),
        utils: {randomPrivateKey: () => e.randomBytes(e.nByteLength)},
        GuBytes: h
      };
    }));
  const x_ = ct,
    vs = Ge,
    ya = BigInt(0),
    Xm = BigInt(1);
  (function (t) {
    (Object.defineProperty(t, '__esModule', {value: !0}),
      (t.hash_to_ristretto255 =
        t.hashToRistretto255 =
        t.RistrettoPoint =
        t.encodeToCurve =
        t.hashToCurve =
        t.edwardsToMontgomery =
        t.x25519 =
        t.ed25519ph =
        t.ed25519ctx =
        t.ed25519 =
        t.ED25519_TORSION_SUBGROUP =
          void 0),
      (t.edwardsToMontgomeryPub = $),
      (t.edwardsToMontgomeryPriv = function (I) {
        const O = x.hash(I.subarray(0, 32));
        return x.adjustScalarBytes(O).subarray(0, 32);
      }));
    const e = Kt,
      n = fs,
      r = Hg,
      i = ks,
      s = ct,
      o = qg,
      a = Ge,
      c = BigInt(
        '57896044618658097711785492504343953926634992332820282019728792003956564819949'
      ),
      l = BigInt(
        '19681161376707505956807079304988542015446066515923890162744021073123829784752'
      ),
      u = BigInt(0),
      d = BigInt(1),
      f = BigInt(2),
      h = BigInt(3),
      g = BigInt(5),
      m = BigInt(8);
    function y(I) {
      const O = BigInt(10),
        H = BigInt(20),
        M = BigInt(40),
        q = BigInt(80),
        z = c,
        Z = (((I * I) % z) * I) % z,
        X = ((0, s.pow2)(Z, f, z) * Z) % z,
        N = ((0, s.pow2)(X, d, z) * I) % z,
        j = ((0, s.pow2)(N, g, z) * N) % z,
        W = ((0, s.pow2)(j, O, z) * j) % z,
        J = ((0, s.pow2)(W, H, z) * W) % z,
        Q = ((0, s.pow2)(J, M, z) * J) % z,
        Y = ((0, s.pow2)(Q, q, z) * Q) % z,
        se = ((0, s.pow2)(Y, q, z) * Q) % z,
        ne = ((0, s.pow2)(se, O, z) * j) % z;
      return {pow_p_5_8: ((0, s.pow2)(ne, f, z) * I) % z, b2: Z};
    }
    function p(I) {
      return ((I[0] &= 248), (I[31] &= 127), (I[31] |= 64), I);
    }
    function b(I, O) {
      const H = c,
        M = (0, s.mod)(O * O * O, H),
        q = y(I * (0, s.mod)(M * M * O, H)).pow_p_5_8;
      let z = (0, s.mod)(I * M * q, H);
      const Z = (0, s.mod)(O * z * z, H),
        X = z,
        N = (0, s.mod)(z * l, H),
        j = Z === I,
        W = Z === (0, s.mod)(-I, H),
        J = Z === (0, s.mod)(-I * l, H);
      return (
        j && (z = X),
        (W || J) && (z = N),
        (0, s.isNegativeLE)(z, H) && (z = (0, s.mod)(-z, H)),
        {isValid: j || W, value: z}
      );
    }
    t.ED25519_TORSION_SUBGROUP = [
      '0100000000000000000000000000000000000000000000000000000000000000',
      'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',
      '0000000000000000000000000000000000000000000000000000000000000080',
      '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',
      'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',
      '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',
      '0000000000000000000000000000000000000000000000000000000000000000',
      'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa'
    ];
    const v = (0, s.Field)(c, void 0, !0),
      x = {
        a: BigInt(-1),
        d: BigInt(
          '37095705934669439343138083508754565189542113879843219016388785533085940283555'
        ),
        Fp: v,
        n: BigInt(
          '7237005577332262213973186563042994240857116359379907606001950938285454250989'
        ),
        h: m,
        Gx: BigInt(
          '15112221349535400772501151409588531511454012693041857206046113283949847762202'
        ),
        Gy: BigInt(
          '46316835694926478169428394003475163141307993866256225615783033603165251855960'
        ),
        hash: e.sha512,
        randomBytes: n.randomBytes,
        adjustScalarBytes: p,
        uvRatio: b
      };
    function C(I, O, H) {
      if (O.length > 255) throw new Error('Context is too big');
      return (0, n.concatBytes)(
        (0, n.utf8ToBytes)('SigEd25519 no Ed25519 collisions'),
        new Uint8Array([H ? 1 : 0, O.length]),
        O,
        I
      );
    }
    function $(I) {
      const {y: O} = t.ed25519.ExtendedPoint.fromHex(I),
        H = BigInt(1);
      return v.toBytes(v.create((H + O) * v.inv(H - O)));
    }
    ((t.ed25519 = (0, r.twistedEdwards)(x)),
      (t.ed25519ctx = (0, r.twistedEdwards)({...x, domain: C})),
      (t.ed25519ph = (0, r.twistedEdwards)(
        Object.assign({}, x, {domain: C, prehash: e.sha512})
      )),
      (t.x25519 = (0, o.montgomery)({
        P: c,
        a: BigInt(486662),
        montgomeryBits: 255,
        nByteLength: 32,
        Gu: BigInt(9),
        powPminus2: (I) => {
          const O = c,
            {pow_p_5_8: H, b2: M} = y(I);
          return (0, s.mod)((0, s.pow2)(H, h, O) * M, O);
        },
        adjustScalarBytes: p,
        randomBytes: n.randomBytes
      })),
      (t.edwardsToMontgomery = $));
    const G = (v.ORDER + h) / m,
      L = v.pow(f, G),
      F = v.sqrt(v.neg(v.ONE)),
      k = (0, s.FpSqrtEven)(v, v.neg(BigInt(486664)));
    function V(I) {
      const {
        xMn: O,
        xMd: H,
        yMn: M,
        yMd: q
      } = (function (Q) {
        const Y = (v.ORDER - g) / m,
          se = BigInt(486662);
        let ne = v.sqr(Q);
        ne = v.mul(ne, f);
        let oe = v.add(ne, v.ONE),
          ce = v.neg(se),
          fe = v.sqr(oe),
          le = v.mul(fe, oe),
          ve = v.mul(ne, se);
        ((ve = v.mul(ve, ce)), (ve = v.add(ve, fe)), (ve = v.mul(ve, ce)));
        let _e = v.sqr(le);
        ((fe = v.sqr(_e)),
          (_e = v.mul(_e, le)),
          (_e = v.mul(_e, ve)),
          (fe = v.mul(fe, _e)));
        let Te = v.pow(fe, Y);
        Te = v.mul(Te, _e);
        let st = v.mul(Te, F);
        ((fe = v.sqr(Te)), (fe = v.mul(fe, le)));
        let et = v.eql(fe, ve),
          zt = v.cmov(st, Te, et),
          nn = v.mul(ce, ne),
          rn = v.mul(Te, Q);
        rn = v.mul(rn, L);
        let or = v.mul(rn, F),
          fo = v.mul(ve, ne);
        ((fe = v.sqr(rn)), (fe = v.mul(fe, le)));
        let Gu = v.eql(fe, fo),
          vn = v.cmov(or, rn, Gu);
        ((fe = v.sqr(zt)), (fe = v.mul(fe, le)));
        let Nn = v.eql(fe, ve),
          zu = v.cmov(nn, ce, Nn),
          Fc = v.cmov(vn, zt, Nn),
          c6 = v.isOdd(Fc);
        return (
          (Fc = v.cmov(Fc, v.neg(Fc), Nn !== c6)),
          {xMn: zu, xMd: oe, yMn: Fc, yMd: d}
        );
      })(I);
      let z = v.mul(O, q);
      z = v.mul(z, k);
      let Z = v.mul(H, M),
        X = v.sub(O, H),
        N = v.add(O, H),
        j = v.mul(Z, N),
        W = v.eql(j, v.ZERO);
      ((z = v.cmov(z, v.ZERO, W)),
        (Z = v.cmov(Z, v.ONE, W)),
        (X = v.cmov(X, v.ONE, W)),
        (N = v.cmov(N, v.ONE, W)));
      const J = v.invertBatch([Z, N]);
      return {x: v.mul(z, J[0]), y: v.mul(X, J[1])};
    }
    const K = (0, i.createHasher)(t.ed25519.ExtendedPoint, (I) => V(I[0]), {
      DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',
      encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',
      p: v.ORDER,
      m: 1,
      k: 128,
      expand: 'xmd',
      hash: e.sha512
    });
    function B(I) {
      if (!(I instanceof S)) throw new Error('RistrettoPoint expected');
    }
    ((t.hashToCurve = K.hashToCurve), (t.encodeToCurve = K.encodeToCurve));
    const D = l,
      E = BigInt(
        '25063068953384623474111414158702152701244531502492656460079210482610430750235'
      ),
      P = BigInt(
        '54469307008909316920995813868745141605393597292927456921205312896311721017578'
      ),
      U = BigInt(
        '1159843021668779879193775521855586647937357759715417654439879720876111806838'
      ),
      w = BigInt(
        '40440834346308536858101042469323190826248399146238708352240133220865137265952'
      ),
      A = (I) => b(d, I),
      T = BigInt(
        '0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'
      ),
      R = (I) => t.ed25519.CURVE.Fp.create((0, a.bytesToNumberLE)(I) & T);
    function _(I) {
      const {d: O} = t.ed25519.CURVE,
        H = t.ed25519.CURVE.Fp.ORDER,
        M = t.ed25519.CURVE.Fp.create,
        q = M(D * I * I),
        z = M((q + d) * U);
      let Z = BigInt(-1);
      const X = M((Z - O * q) * M(q + O));
      let {isValid: N, value: j} = b(z, X),
        W = M(j * I);
      ((0, s.isNegativeLE)(W, H) || (W = M(-W)), N || (j = W), N || (Z = q));
      const J = M(Z * (q - d) * w - X),
        Q = j * j,
        Y = M((j + j) * X),
        se = M(J * E),
        ne = M(d - Q),
        oe = M(d + Q);
      return new t.ed25519.ExtendedPoint(
        M(Y * oe),
        M(ne * se),
        M(se * oe),
        M(Y * ne)
      );
    }
    class S {
      constructor(O) {
        this.ep = O;
      }
      static fromAffine(O) {
        return new S(t.ed25519.ExtendedPoint.fromAffine(O));
      }
      static hashToCurve(O) {
        O = (0, a.ensureBytes)('ristrettoHash', O, 64);
        const H = _(R(O.slice(0, 32))),
          M = _(R(O.slice(32, 64)));
        return new S(H.add(M));
      }
      static fromHex(O) {
        O = (0, a.ensureBytes)('ristrettoHex', O, 32);
        const {a: H, d: M} = t.ed25519.CURVE,
          q = t.ed25519.CURVE.Fp.ORDER,
          z = t.ed25519.CURVE.Fp.create,
          Z =
            'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint',
          X = R(O);
        if (
          !(0, a.equalBytes)((0, a.numberToBytesLE)(X, 32), O) ||
          (0, s.isNegativeLE)(X, q)
        )
          throw new Error(Z);
        const N = z(X * X),
          j = z(d + H * N),
          W = z(d - H * N),
          J = z(j * j),
          Q = z(W * W),
          Y = z(H * M * J - Q),
          {isValid: se, value: ne} = A(z(Y * Q)),
          oe = z(ne * W),
          ce = z(ne * oe * Y);
        let fe = z((X + X) * oe);
        (0, s.isNegativeLE)(fe, q) && (fe = z(-fe));
        const le = z(j * ce),
          ve = z(fe * le);
        if (!se || (0, s.isNegativeLE)(ve, q) || le === u) throw new Error(Z);
        return new S(new t.ed25519.ExtendedPoint(fe, le, d, ve));
      }
      toRawBytes() {
        let {ex: O, ey: H, ez: M, et: q} = this.ep;
        const z = t.ed25519.CURVE.Fp.ORDER,
          Z = t.ed25519.CURVE.Fp.create,
          X = Z(Z(M + H) * Z(M - H)),
          N = Z(O * H),
          j = Z(N * N),
          {value: W} = A(Z(X * j)),
          J = Z(W * X),
          Q = Z(W * N),
          Y = Z(J * Q * q);
        let se;
        if ((0, s.isNegativeLE)(q * Y, z)) {
          let oe = Z(H * D),
            ce = Z(O * D);
          ((O = oe), (H = ce), (se = Z(J * P)));
        } else se = Q;
        (0, s.isNegativeLE)(O * Y, z) && (H = Z(-H));
        let ne = Z((M - H) * se);
        return (
          (0, s.isNegativeLE)(ne, z) && (ne = Z(-ne)),
          (0, a.numberToBytesLE)(ne, 32)
        );
      }
      toHex() {
        return (0, a.bytesToHex)(this.toRawBytes());
      }
      toString() {
        return this.toHex();
      }
      equals(O) {
        B(O);
        const {ex: H, ey: M} = this.ep,
          {ex: q, ey: z} = O.ep,
          Z = t.ed25519.CURVE.Fp.create,
          X = Z(H * z) === Z(M * q),
          N = Z(M * z) === Z(H * q);
        return X || N;
      }
      add(O) {
        return (B(O), new S(this.ep.add(O.ep)));
      }
      subtract(O) {
        return (B(O), new S(this.ep.subtract(O.ep)));
      }
      multiply(O) {
        return new S(this.ep.multiply(O));
      }
      multiplyUnsafe(O) {
        return new S(this.ep.multiplyUnsafe(O));
      }
      double() {
        return new S(this.ep.double());
      }
      negate() {
        return new S(this.ep.negate());
      }
    }
    ((t.RistrettoPoint =
      (S.BASE || (S.BASE = new S(t.ed25519.ExtendedPoint.BASE)),
      S.ZERO || (S.ZERO = new S(t.ed25519.ExtendedPoint.ZERO)),
      S)),
      (t.hashToRistretto255 = (I, O) => {
        const H = O.DST,
          M = typeof H == 'string' ? (0, n.utf8ToBytes)(H) : H,
          q = (0, i.expand_message_xmd)(I, M, 64, e.sha512);
        return S.hashToCurve(q);
      }),
      (t.hash_to_ristretto255 = t.hashToRistretto255));
  })(CC);
  var s5 = {},
    Wi = {};
  (Object.defineProperty(Wi, '__esModule', {value: !0}),
    (Wi.sha224 = Wi.sha256 = Wi.SHA256 = void 0));
  const e0 = zi,
    dr = fs,
    lj = new Uint32Array([
      1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
      2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
      1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
      264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
      2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
      113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
      1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
      3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
      430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
      1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
      2428436474, 2756734187, 3204031479, 3329325298
    ]),
    bs = new Uint32Array([
      1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
      528734635, 1541459225
    ]),
    ws = new Uint32Array(64);
  class Qv extends e0.HashMD {
    constructor() {
      (super(64, 32, 8, !1),
        (this.A = 0 | bs[0]),
        (this.B = 0 | bs[1]),
        (this.C = 0 | bs[2]),
        (this.D = 0 | bs[3]),
        (this.E = 0 | bs[4]),
        (this.F = 0 | bs[5]),
        (this.G = 0 | bs[6]),
        (this.H = 0 | bs[7]));
    }
    get() {
      const {A: e, B: n, C: r, D: i, E: s, F: o, G: a, H: c} = this;
      return [e, n, r, i, s, o, a, c];
    }
    set(e, n, r, i, s, o, a, c) {
      ((this.A = 0 | e),
        (this.B = 0 | n),
        (this.C = 0 | r),
        (this.D = 0 | i),
        (this.E = 0 | s),
        (this.F = 0 | o),
        (this.G = 0 | a),
        (this.H = 0 | c));
    }
    process(e, n) {
      for (let d = 0; d < 16; d++, n += 4) ws[d] = e.getUint32(n, !1);
      for (let d = 16; d < 64; d++) {
        const f = ws[d - 15],
          h = ws[d - 2],
          g = (0, dr.rotr)(f, 7) ^ (0, dr.rotr)(f, 18) ^ (f >>> 3),
          m = (0, dr.rotr)(h, 17) ^ (0, dr.rotr)(h, 19) ^ (h >>> 10);
        ws[d] = (m + ws[d - 7] + g + ws[d - 16]) | 0;
      }
      let {A: r, B: i, C: s, D: o, E: a, F: c, G: l, H: u} = this;
      for (let d = 0; d < 64; d++) {
        const f =
            (u +
              ((0, dr.rotr)(a, 6) ^ (0, dr.rotr)(a, 11) ^ (0, dr.rotr)(a, 25)) +
              (0, e0.Chi)(a, c, l) +
              lj[d] +
              ws[d]) |
            0,
          h =
            (((0, dr.rotr)(r, 2) ^ (0, dr.rotr)(r, 13) ^ (0, dr.rotr)(r, 22)) +
              (0, e0.Maj)(r, i, s)) |
            0;
        ((u = l),
          (l = c),
          (c = a),
          (a = (o + f) | 0),
          (o = s),
          (s = i),
          (i = r),
          (r = (f + h) | 0));
      }
      ((r = (r + this.A) | 0),
        (i = (i + this.B) | 0),
        (s = (s + this.C) | 0),
        (o = (o + this.D) | 0),
        (a = (a + this.E) | 0),
        (c = (c + this.F) | 0),
        (l = (l + this.G) | 0),
        (u = (u + this.H) | 0),
        this.set(r, i, s, o, a, c, l, u));
    }
    roundClean() {
      ws.fill(0);
    }
    destroy() {
      (this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0));
    }
  }
  Wi.SHA256 = Qv;
  class uj extends Qv {
    constructor() {
      (super(),
        (this.A = -1056596264),
        (this.B = 914150663),
        (this.C = 812702999),
        (this.D = -150054599),
        (this.E = -4191439),
        (this.F = 1750603025),
        (this.G = 1694076839),
        (this.H = -1090891868),
        (this.outputLen = 28));
    }
  }
  ((Wi.sha256 = (0, dr.wrapConstructor)(() => new Qv())),
    (Wi.sha224 = (0, dr.wrapConstructor)(() => new uj())));
  var rf = {},
    Jv = {};
  (function (t) {
    (Object.defineProperty(t, '__esModule', {value: !0}),
      (t.hmac = t.HMAC = void 0));
    const e = Qn,
      n = fs;
    class r extends n.Hash {
      constructor(s, o) {
        (super(), (this.finished = !1), (this.destroyed = !1), (0, e.hash)(s));
        const a = (0, n.toBytes)(o);
        if (((this.iHash = s.create()), typeof this.iHash.update != 'function'))
          throw new Error(
            'Expected instance of class which extends utils.Hash'
          );
        ((this.blockLen = this.iHash.blockLen),
          (this.outputLen = this.iHash.outputLen));
        const c = this.blockLen,
          l = new Uint8Array(c);
        l.set(a.length > c ? s.create().update(a).digest() : a);
        for (let u = 0; u < l.length; u++) l[u] ^= 54;
        (this.iHash.update(l), (this.oHash = s.create()));
        for (let u = 0; u < l.length; u++) l[u] ^= 106;
        (this.oHash.update(l), l.fill(0));
      }
      update(s) {
        return ((0, e.exists)(this), this.iHash.update(s), this);
      }
      digestInto(s) {
        ((0, e.exists)(this),
          (0, e.bytes)(s, this.outputLen),
          (this.finished = !0),
          this.iHash.digestInto(s),
          this.oHash.update(s),
          this.oHash.digestInto(s),
          this.destroy());
      }
      digest() {
        const s = new Uint8Array(this.oHash.outputLen);
        return (this.digestInto(s), s);
      }
      _cloneInto(s) {
        s || (s = Object.create(Object.getPrototypeOf(this), {}));
        const {
          oHash: o,
          iHash: a,
          finished: c,
          destroyed: l,
          blockLen: u,
          outputLen: d
        } = this;
        return (
          (s.finished = c),
          (s.destroyed = l),
          (s.blockLen = u),
          (s.outputLen = d),
          (s.oHash = o._cloneInto(s.oHash)),
          (s.iHash = a._cloneInto(s.iHash)),
          s
        );
      }
      destroy() {
        ((this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy());
      }
    }
    ((t.HMAC = r),
      (t.hmac = (i, s, o) => new r(i, s).update(o).digest()),
      (t.hmac.create = (i, s) => new r(i, s)));
  })(Jv);
  var Xv = {};
  ((function (t) {
    (Object.defineProperty(t, '__esModule', {value: !0}),
      (t.DER = void 0),
      (t.weierstrassPoints = h),
      (t.weierstrass = function (m) {
        const y = (function (I) {
            const O = (0, e.validateBasic)(I);
            return (
              r.validateObject(
                O,
                {hash: 'hash', hmac: 'function', randomBytes: 'function'},
                {
                  bits2int: 'function',
                  bits2int_modN: 'function',
                  lowS: 'boolean'
                }
              ),
              Object.freeze({lowS: !0, ...O})
            );
          })(m),
          {Fp: p, n: b} = y,
          v = p.BYTES + 1,
          x = 2 * p.BYTES + 1;
        function C(I) {
          return n.mod(I, b);
        }
        function $(I) {
          return n.invert(I, b);
        }
        const {
            ProjectivePoint: G,
            normPrivateKeyToScalar: L,
            weierstrassEquation: F,
            isWithinCurveOrder: k
          } = h({
            ...y,
            toBytes(I, O, H) {
              const M = O.toAffine(),
                q = p.toBytes(M.x),
                z = r.concatBytes;
              return (
                (0, i.abool)('isCompressed', H),
                H
                  ? z(Uint8Array.from([O.hasEvenY() ? 2 : 3]), q)
                  : z(Uint8Array.from([4]), q, p.toBytes(M.y))
              );
            },
            fromBytes(I) {
              const O = I.length,
                H = I[0],
                M = I.subarray(1);
              if (O !== v || (H !== 2 && H !== 3)) {
                if (O === x && H === 4)
                  return {
                    x: p.fromBytes(M.subarray(0, p.BYTES)),
                    y: p.fromBytes(M.subarray(p.BYTES, 2 * p.BYTES))
                  };
                throw new Error(
                  `Point of length ${O} was invalid. Expected ${v} compressed bytes or ${x} uncompressed bytes`
                );
              }
              {
                const q = r.bytesToNumberBE(M);
                if (!r.inRange(q, l, p.ORDER))
                  throw new Error('Point is not on curve');
                const z = F(q);
                let Z;
                try {
                  Z = p.sqrt(z);
                } catch (X) {
                  const N = X instanceof Error ? ': ' + X.message : '';
                  throw new Error('Point is not on curve' + N);
                }
                return (
                  ((1 & H) == 1) != ((Z & l) === l) && (Z = p.neg(Z)),
                  {x: q, y: Z}
                );
              }
            }
          }),
          V = (I) => r.bytesToHex(r.numberToBytesBE(I, y.nByteLength));
        function K(I) {
          return I > b >> l;
        }
        const B = (I, O, H) => r.bytesToNumberBE(I.slice(O, H));
        class D {
          constructor(O, H, M) {
            ((this.r = O),
              (this.s = H),
              (this.recovery = M),
              this.assertValidity());
          }
          static fromCompact(O) {
            const H = y.nByteLength;
            return (
              (O = (0, i.ensureBytes)('compactSignature', O, 2 * H)),
              new D(B(O, 0, H), B(O, H, 2 * H))
            );
          }
          static fromDER(O) {
            const {r: H, s: M} = t.DER.toSig((0, i.ensureBytes)('DER', O));
            return new D(H, M);
          }
          assertValidity() {
            (r.aInRange('r', this.r, l, b), r.aInRange('s', this.s, l, b));
          }
          addRecoveryBit(O) {
            return new D(this.r, this.s, O);
          }
          recoverPublicKey(O) {
            const {r: H, s: M, recovery: q} = this,
              z = w((0, i.ensureBytes)('msgHash', O));
            if (q == null || ![0, 1, 2, 3].includes(q))
              throw new Error('recovery id invalid');
            const Z = q === 2 || q === 3 ? H + y.n : H;
            if (Z >= p.ORDER) throw new Error('recovery id 2 or 3 invalid');
            const X = (1 & q) == 0 ? '02' : '03',
              N = G.fromHex(X + V(Z)),
              j = $(Z),
              W = C(-z * j),
              J = C(M * j),
              Q = G.BASE.multiplyAndAddUnsafe(N, W, J);
            if (!Q) throw new Error('point at infinify');
            return (Q.assertValidity(), Q);
          }
          hasHighS() {
            return K(this.s);
          }
          normalizeS() {
            return this.hasHighS()
              ? new D(this.r, C(-this.s), this.recovery)
              : this;
          }
          toDERRawBytes() {
            return r.hexToBytes(this.toDERHex());
          }
          toDERHex() {
            return t.DER.hexFromSig({r: this.r, s: this.s});
          }
          toCompactRawBytes() {
            return r.hexToBytes(this.toCompactHex());
          }
          toCompactHex() {
            return V(this.r) + V(this.s);
          }
        }
        const E = {
          isValidPrivateKey(I) {
            try {
              return (L(I), !0);
            } catch {
              return !1;
            }
          },
          normPrivateKeyToScalar: L,
          randomPrivateKey: () => {
            const I = n.getMinHashLength(y.n);
            return n.mapHashToField(y.randomBytes(I), y.n);
          },
          precompute: (I = 8, O = G.BASE) => (
            O._setWindowSize(I),
            O.multiply(BigInt(3)),
            O
          )
        };
        function P(I) {
          const O = r.isBytes(I),
            H = typeof I == 'string',
            M = (O || H) && I.length;
          return O
            ? M === v || M === x
            : H
              ? M === 2 * v || M === 2 * x
              : I instanceof G;
        }
        const U =
            y.bits2int ||
            function (I) {
              const O = r.bytesToNumberBE(I),
                H = 8 * I.length - y.nBitLength;
              return H > 0 ? O >> BigInt(H) : O;
            },
          w =
            y.bits2int_modN ||
            function (I) {
              return C(U(I));
            },
          A = r.bitMask(y.nBitLength);
        function T(I) {
          return (
            r.aInRange(`num < 2^${y.nBitLength}`, I, c, A),
            r.numberToBytesBE(I, y.nByteLength)
          );
        }
        function R(I, O, H = _) {
          if (['recovered', 'canonical'].some((Y) => Y in H))
            throw new Error('sign() legacy options not supported');
          const {hash: M, randomBytes: q} = y;
          let {lowS: z, prehash: Z, extraEntropy: X} = H;
          (z == null && (z = !0),
            (I = (0, i.ensureBytes)('msgHash', I)),
            s(H),
            Z && (I = (0, i.ensureBytes)('prehashed msgHash', M(I))));
          const N = w(I),
            j = L(O),
            W = [T(j), T(N)];
          if (X != null && X !== !1) {
            const Y = X === !0 ? q(p.BYTES) : X;
            W.push((0, i.ensureBytes)('extraEntropy', Y));
          }
          const J = r.concatBytes(...W),
            Q = N;
          return {
            seed: J,
            k2sig: function (Y) {
              const se = U(Y);
              if (!k(se)) return;
              const ne = $(se),
                oe = G.BASE.multiply(se).toAffine(),
                ce = C(oe.x);
              if (ce === c) return;
              const fe = C(ne * C(Q + ce * j));
              if (fe === c) return;
              let le = (oe.x === ce ? 0 : 2) | Number(oe.y & l),
                ve = fe;
              return (
                z &&
                  K(fe) &&
                  ((ve = (function (_e) {
                    return K(_e) ? C(-_e) : _e;
                  })(fe)),
                  (le ^= 1)),
                new D(ce, ve, le)
              );
            }
          };
        }
        const _ = {lowS: y.lowS, prehash: !1},
          S = {lowS: y.lowS, prehash: !1};
        return (
          G.BASE._setWindowSize(8),
          {
            CURVE: y,
            getPublicKey: function (I, O = !0) {
              return G.fromPrivateKey(I).toRawBytes(O);
            },
            getSharedSecret: function (I, O, H = !0) {
              if (P(I)) throw new Error('first arg must be private key');
              if (!P(O)) throw new Error('second arg must be public key');
              return G.fromHex(O).multiply(L(I)).toRawBytes(H);
            },
            sign: function (I, O, H = _) {
              const {seed: M, k2sig: q} = R(I, O, H),
                z = y;
              return r.createHmacDrbg(
                z.hash.outputLen,
                z.nByteLength,
                z.hmac
              )(M, q);
            },
            verify: function (I, O, H, M = S) {
              var ce;
              const q = I;
              if (
                ((O = (0, i.ensureBytes)('msgHash', O)),
                (H = (0, i.ensureBytes)('publicKey', H)),
                'strict' in M)
              )
                throw new Error('options.strict was renamed to lowS');
              s(M);
              const {lowS: z, prehash: Z} = M;
              let X, N;
              try {
                if (typeof q == 'string' || r.isBytes(q))
                  try {
                    X = D.fromDER(q);
                  } catch (fe) {
                    if (!(fe instanceof t.DER.Err)) throw fe;
                    X = D.fromCompact(q);
                  }
                else {
                  if (
                    typeof q != 'object' ||
                    typeof q.r != 'bigint' ||
                    typeof q.s != 'bigint'
                  )
                    throw new Error('PARSE');
                  {
                    const {r: fe, s: le} = q;
                    X = new D(fe, le);
                  }
                }
                N = G.fromHex(H);
              } catch (fe) {
                if (fe.message === 'PARSE')
                  throw new Error(
                    'signature must be Signature instance, Uint8Array or hex string'
                  );
                return !1;
              }
              if (z && X.hasHighS()) return !1;
              Z && (O = y.hash(O));
              const {r: j, s: W} = X,
                J = w(O),
                Q = $(W),
                Y = C(J * Q),
                se = C(j * Q),
                ne =
                  (ce = G.BASE.multiplyAndAddUnsafe(N, Y, se)) == null
                    ? void 0
                    : ce.toAffine();
              return ne ? C(ne.x) === j : !1;
            },
            ProjectivePoint: G,
            Signature: D,
            utils: E
          }
        );
      }),
      (t.SWUFpSqrtRatio = g),
      (t.mapToCurveSimpleSWU = function (m, y) {
        if (
          (n.validateField(m),
          !m.isValid(y.A) || !m.isValid(y.B) || !m.isValid(y.Z))
        )
          throw new Error('mapToCurveSimpleSWU: invalid opts');
        const p = g(m, y.Z);
        if (!m.isOdd) throw new Error('Fp.isOdd is not implemented!');
        return (b) => {
          let v, x, C, $, G, L, F, k;
          ((v = m.sqr(b)),
            (v = m.mul(v, y.Z)),
            (x = m.sqr(v)),
            (x = m.add(x, v)),
            (C = m.add(x, m.ONE)),
            (C = m.mul(C, y.B)),
            ($ = m.cmov(y.Z, m.neg(x), !m.eql(x, m.ZERO))),
            ($ = m.mul($, y.A)),
            (x = m.sqr(C)),
            (L = m.sqr($)),
            (G = m.mul(L, y.A)),
            (x = m.add(x, G)),
            (x = m.mul(x, C)),
            (L = m.mul(L, $)),
            (G = m.mul(L, y.B)),
            (x = m.add(x, G)),
            (F = m.mul(v, C)));
          const {isValid: V, value: K} = p(x, L);
          ((k = m.mul(v, b)),
            (k = m.mul(k, K)),
            (F = m.cmov(F, C, V)),
            (k = m.cmov(k, K, V)));
          const B = m.isOdd(b) === m.isOdd(k);
          return (
            (k = m.cmov(m.neg(k), k, B)),
            (F = m.div(F, $)),
            {x: F, y: k}
          );
        };
      }));
    const e = Na,
      n = ct,
      r = Ge,
      i = Ge;
    function s(m) {
      (m.lowS !== void 0 && (0, i.abool)('lowS', m.lowS),
        m.prehash !== void 0 && (0, i.abool)('prehash', m.prehash));
    }
    const {bytesToNumberBE: o, hexToBytes: a} = r;
    t.DER = {
      Err: class extends Error {
        constructor(m = '') {
          super(m);
        }
      },
      _tlv: {
        encode: (m, y) => {
          const {Err: p} = t.DER;
          if (m < 0 || m > 256) throw new p('tlv.encode: wrong tag');
          if (1 & y.length) throw new p('tlv.encode: unpadded data');
          const b = y.length / 2,
            v = r.numberToHexUnpadded(b);
          if ((v.length / 2) & 128)
            throw new p('tlv.encode: long form length too big');
          const x = b > 127 ? r.numberToHexUnpadded((v.length / 2) | 128) : '';
          return `${r.numberToHexUnpadded(m)}${x}${v}${y}`;
        },
        decode(m, y) {
          const {Err: p} = t.DER;
          let b = 0;
          if (m < 0 || m > 256) throw new p('tlv.encode: wrong tag');
          if (y.length < 2 || y[b++] !== m)
            throw new p('tlv.decode: wrong tlv');
          const v = y[b++];
          let x = 0;
          if (128 & v) {
            const $ = 127 & v;
            if (!$)
              throw new p('tlv.decode(long): indefinite length not supported');
            if ($ > 4) throw new p('tlv.decode(long): byte length is too big');
            const G = y.subarray(b, b + $);
            if (G.length !== $)
              throw new p('tlv.decode: length bytes not complete');
            if (G[0] === 0) throw new p('tlv.decode(long): zero leftmost byte');
            for (const L of G) x = (x << 8) | L;
            if (((b += $), x < 128))
              throw new p('tlv.decode(long): not minimal encoding');
          } else x = v;
          const C = y.subarray(b, b + x);
          if (C.length !== x) throw new p('tlv.decode: wrong value length');
          return {v: C, l: y.subarray(b + x)};
        }
      },
      _int: {
        encode(m) {
          const {Err: y} = t.DER;
          if (m < c) throw new y('integer: negative integers are not allowed');
          let p = r.numberToHexUnpadded(m);
          if ((8 & Number.parseInt(p[0], 16) && (p = '00' + p), 1 & p.length))
            throw new y('unexpected assertion');
          return p;
        },
        decode(m) {
          const {Err: y} = t.DER;
          if (128 & m[0]) throw new y('Invalid signature integer: negative');
          if (m[0] === 0 && !(128 & m[1]))
            throw new y('Invalid signature integer: unnecessary leading zero');
          return o(m);
        }
      },
      toSig(m) {
        const {Err: y, _int: p, _tlv: b} = t.DER,
          v = typeof m == 'string' ? a(m) : m;
        r.abytes(v);
        const {v: x, l: C} = b.decode(48, v);
        if (C.length)
          throw new y('Invalid signature: left bytes after parsing');
        const {v: $, l: G} = b.decode(2, x),
          {v: L, l: F} = b.decode(2, G);
        if (F.length)
          throw new y('Invalid signature: left bytes after parsing');
        return {r: p.decode($), s: p.decode(L)};
      },
      hexFromSig(m) {
        const {_tlv: y, _int: p} = t.DER,
          b = `${y.encode(2, p.encode(m.r))}${y.encode(2, p.encode(m.s))}`;
        return y.encode(48, b);
      }
    };
    const c = BigInt(0),
      l = BigInt(1),
      u = BigInt(2),
      d = BigInt(3),
      f = BigInt(4);
    function h(m) {
      const y = (function (B) {
          const D = (0, e.validateBasic)(B);
          r.validateObject(
            D,
            {a: 'field', b: 'field'},
            {
              allowedPrivateKeyLengths: 'array',
              wrapPrivateKey: 'boolean',
              isTorsionFree: 'function',
              clearCofactor: 'function',
              allowInfinityPoint: 'boolean',
              fromBytes: 'function',
              toBytes: 'function'
            }
          );
          const {endo: E, Fp: P, a: U} = D;
          if (E) {
            if (!P.eql(U, P.ZERO))
              throw new Error(
                'Endomorphism can only be defined for Koblitz curves that have a=0'
              );
            if (
              typeof E != 'object' ||
              typeof E.beta != 'bigint' ||
              typeof E.splitScalar != 'function'
            )
              throw new Error(
                'Expected endomorphism with beta: bigint and splitScalar: function'
              );
          }
          return Object.freeze({...D});
        })(m),
        {Fp: p} = y,
        b = n.Field(y.n, y.nBitLength),
        v =
          y.toBytes ||
          ((B, D, E) => {
            const P = D.toAffine();
            return r.concatBytes(
              Uint8Array.from([4]),
              p.toBytes(P.x),
              p.toBytes(P.y)
            );
          }),
        x =
          y.fromBytes ||
          ((B) => {
            const D = B.subarray(1);
            return {
              x: p.fromBytes(D.subarray(0, p.BYTES)),
              y: p.fromBytes(D.subarray(p.BYTES, 2 * p.BYTES))
            };
          });
      function C(B) {
        const {a: D, b: E} = y,
          P = p.sqr(B),
          U = p.mul(P, B);
        return p.add(p.add(U, p.mul(B, D)), E);
      }
      if (!p.eql(p.sqr(y.Gy), C(y.Gx)))
        throw new Error('bad generator point: equation left != right');
      function $(B) {
        const {
          allowedPrivateKeyLengths: D,
          nByteLength: E,
          wrapPrivateKey: P,
          n: U
        } = y;
        if (D && typeof B != 'bigint') {
          if (
            (r.isBytes(B) && (B = r.bytesToHex(B)),
            typeof B != 'string' || !D.includes(B.length))
          )
            throw new Error('Invalid key');
          B = B.padStart(2 * E, '0');
        }
        let w;
        try {
          w =
            typeof B == 'bigint'
              ? B
              : r.bytesToNumberBE((0, i.ensureBytes)('private key', B, E));
        } catch {
          throw new Error(
            `private key must be ${E} bytes, hex or bigint, not ${typeof B}`
          );
        }
        return (P && (w = n.mod(w, U)), r.aInRange('private key', w, l, U), w);
      }
      function G(B) {
        if (!(B instanceof k)) throw new Error('ProjectivePoint expected');
      }
      const L = (0, i.memoized)((B, D) => {
          const {px: E, py: P, pz: U} = B;
          if (p.eql(U, p.ONE)) return {x: E, y: P};
          const w = B.is0();
          D == null && (D = w ? p.ONE : p.inv(U));
          const A = p.mul(E, D),
            T = p.mul(P, D),
            R = p.mul(U, D);
          if (w) return {x: p.ZERO, y: p.ZERO};
          if (!p.eql(R, p.ONE)) throw new Error('invZ was invalid');
          return {x: A, y: T};
        }),
        F = (0, i.memoized)((B) => {
          if (B.is0()) {
            if (y.allowInfinityPoint && !p.is0(B.py)) return;
            throw new Error('bad point: ZERO');
          }
          const {x: D, y: E} = B.toAffine();
          if (!p.isValid(D) || !p.isValid(E))
            throw new Error('bad point: x or y not FE');
          const P = p.sqr(E),
            U = C(D);
          if (!p.eql(P, U))
            throw new Error('bad point: equation left != right');
          if (!B.isTorsionFree())
            throw new Error('bad point: not in prime-order subgroup');
          return !0;
        });
      class k {
        constructor(D, E, P) {
          if (
            ((this.px = D),
            (this.py = E),
            (this.pz = P),
            D == null || !p.isValid(D))
          )
            throw new Error('x required');
          if (E == null || !p.isValid(E)) throw new Error('y required');
          if (P == null || !p.isValid(P)) throw new Error('z required');
          Object.freeze(this);
        }
        static fromAffine(D) {
          const {x: E, y: P} = D || {};
          if (!D || !p.isValid(E) || !p.isValid(P))
            throw new Error('invalid affine point');
          if (D instanceof k) throw new Error('projective point not allowed');
          const U = (w) => p.eql(w, p.ZERO);
          return U(E) && U(P) ? k.ZERO : new k(E, P, p.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        static normalizeZ(D) {
          const E = p.invertBatch(D.map((P) => P.pz));
          return D.map((P, U) => P.toAffine(E[U])).map(k.fromAffine);
        }
        static fromHex(D) {
          const E = k.fromAffine(x((0, i.ensureBytes)('pointHex', D)));
          return (E.assertValidity(), E);
        }
        static fromPrivateKey(D) {
          return k.BASE.multiply($(D));
        }
        static msm(D, E) {
          return (0, e.pippenger)(k, b, D, E);
        }
        _setWindowSize(D) {
          K.setWindowSize(this, D);
        }
        assertValidity() {
          F(this);
        }
        hasEvenY() {
          const {y: D} = this.toAffine();
          if (p.isOdd) return !p.isOdd(D);
          throw new Error("Field doesn't support isOdd");
        }
        equals(D) {
          G(D);
          const {px: E, py: P, pz: U} = this,
            {px: w, py: A, pz: T} = D,
            R = p.eql(p.mul(E, T), p.mul(w, U)),
            _ = p.eql(p.mul(P, T), p.mul(A, U));
          return R && _;
        }
        negate() {
          return new k(this.px, p.neg(this.py), this.pz);
        }
        double() {
          const {a: D, b: E} = y,
            P = p.mul(E, d),
            {px: U, py: w, pz: A} = this;
          let T = p.ZERO,
            R = p.ZERO,
            _ = p.ZERO,
            S = p.mul(U, U),
            I = p.mul(w, w),
            O = p.mul(A, A),
            H = p.mul(U, w);
          return (
            (H = p.add(H, H)),
            (_ = p.mul(U, A)),
            (_ = p.add(_, _)),
            (T = p.mul(D, _)),
            (R = p.mul(P, O)),
            (R = p.add(T, R)),
            (T = p.sub(I, R)),
            (R = p.add(I, R)),
            (R = p.mul(T, R)),
            (T = p.mul(H, T)),
            (_ = p.mul(P, _)),
            (O = p.mul(D, O)),
            (H = p.sub(S, O)),
            (H = p.mul(D, H)),
            (H = p.add(H, _)),
            (_ = p.add(S, S)),
            (S = p.add(_, S)),
            (S = p.add(S, O)),
            (S = p.mul(S, H)),
            (R = p.add(R, S)),
            (O = p.mul(w, A)),
            (O = p.add(O, O)),
            (S = p.mul(O, H)),
            (T = p.sub(T, S)),
            (_ = p.mul(O, I)),
            (_ = p.add(_, _)),
            (_ = p.add(_, _)),
            new k(T, R, _)
          );
        }
        add(D) {
          G(D);
          const {px: E, py: P, pz: U} = this,
            {px: w, py: A, pz: T} = D;
          let R = p.ZERO,
            _ = p.ZERO,
            S = p.ZERO;
          const I = y.a,
            O = p.mul(y.b, d);
          let H = p.mul(E, w),
            M = p.mul(P, A),
            q = p.mul(U, T),
            z = p.add(E, P),
            Z = p.add(w, A);
          ((z = p.mul(z, Z)),
            (Z = p.add(H, M)),
            (z = p.sub(z, Z)),
            (Z = p.add(E, U)));
          let X = p.add(w, T);
          return (
            (Z = p.mul(Z, X)),
            (X = p.add(H, q)),
            (Z = p.sub(Z, X)),
            (X = p.add(P, U)),
            (R = p.add(A, T)),
            (X = p.mul(X, R)),
            (R = p.add(M, q)),
            (X = p.sub(X, R)),
            (S = p.mul(I, Z)),
            (R = p.mul(O, q)),
            (S = p.add(R, S)),
            (R = p.sub(M, S)),
            (S = p.add(M, S)),
            (_ = p.mul(R, S)),
            (M = p.add(H, H)),
            (M = p.add(M, H)),
            (q = p.mul(I, q)),
            (Z = p.mul(O, Z)),
            (M = p.add(M, q)),
            (q = p.sub(H, q)),
            (q = p.mul(I, q)),
            (Z = p.add(Z, q)),
            (H = p.mul(M, Z)),
            (_ = p.add(_, H)),
            (H = p.mul(X, Z)),
            (R = p.mul(z, R)),
            (R = p.sub(R, H)),
            (H = p.mul(z, M)),
            (S = p.mul(X, S)),
            (S = p.add(S, H)),
            new k(R, _, S)
          );
        }
        subtract(D) {
          return this.add(D.negate());
        }
        is0() {
          return this.equals(k.ZERO);
        }
        wNAF(D) {
          return K.wNAFCached(this, D, k.normalizeZ);
        }
        multiplyUnsafe(D) {
          r.aInRange('scalar', D, c, y.n);
          const E = k.ZERO;
          if (D === c) return E;
          if (D === l) return this;
          const {endo: P} = y;
          if (!P) return K.unsafeLadder(this, D);
          let {k1neg: U, k1: w, k2neg: A, k2: T} = P.splitScalar(D),
            R = E,
            _ = E,
            S = this;
          for (; w > c || T > c; )
            (w & l && (R = R.add(S)),
              T & l && (_ = _.add(S)),
              (S = S.double()),
              (w >>= l),
              (T >>= l));
          return (
            U && (R = R.negate()),
            A && (_ = _.negate()),
            (_ = new k(p.mul(_.px, P.beta), _.py, _.pz)),
            R.add(_)
          );
        }
        multiply(D) {
          const {endo: E, n: P} = y;
          let U, w;
          if ((r.aInRange('scalar', D, l, P), E)) {
            const {k1neg: A, k1: T, k2neg: R, k2: _} = E.splitScalar(D);
            let {p: S, f: I} = this.wNAF(T),
              {p: O, f: H} = this.wNAF(_);
            ((S = K.constTimeNegate(A, S)),
              (O = K.constTimeNegate(R, O)),
              (O = new k(p.mul(O.px, E.beta), O.py, O.pz)),
              (U = S.add(O)),
              (w = I.add(H)));
          } else {
            const {p: A, f: T} = this.wNAF(D);
            ((U = A), (w = T));
          }
          return k.normalizeZ([U, w])[0];
        }
        multiplyAndAddUnsafe(D, E, P) {
          const U = k.BASE,
            w = (T, R) =>
              R !== c && R !== l && T.equals(U)
                ? T.multiply(R)
                : T.multiplyUnsafe(R),
            A = w(this, E).add(w(D, P));
          return A.is0() ? void 0 : A;
        }
        toAffine(D) {
          return L(this, D);
        }
        isTorsionFree() {
          const {h: D, isTorsionFree: E} = y;
          if (D === l) return !0;
          if (E) return E(k, this);
          throw new Error(
            'isTorsionFree() has not been declared for the elliptic curve'
          );
        }
        clearCofactor() {
          const {h: D, clearCofactor: E} = y;
          return D === l ? this : E ? E(k, this) : this.multiplyUnsafe(y.h);
        }
        toRawBytes(D = !0) {
          return (
            (0, i.abool)('isCompressed', D),
            this.assertValidity(),
            v(k, this, D)
          );
        }
        toHex(D = !0) {
          return (
            (0, i.abool)('isCompressed', D),
            r.bytesToHex(this.toRawBytes(D))
          );
        }
      }
      ((k.BASE = new k(y.Gx, y.Gy, p.ONE)),
        (k.ZERO = new k(p.ZERO, p.ONE, p.ZERO)));
      const V = y.nBitLength,
        K = (0, e.wNAF)(k, y.endo ? Math.ceil(V / 2) : V);
      return {
        CURVE: y,
        ProjectivePoint: k,
        normPrivateKeyToScalar: $,
        weierstrassEquation: C,
        isWithinCurveOrder: function (B) {
          return r.inRange(B, l, y.n);
        }
      };
    }
    function g(m, y) {
      const p = m.ORDER;
      let b = c;
      for (let B = p - l; B % u === c; B /= u) b += l;
      const v = b,
        x = u << (v - l - l),
        C = x * u,
        $ = (p - l) / C,
        G = ($ - l) / u,
        L = C - l,
        F = x,
        k = m.pow(y, $),
        V = m.pow(y, ($ + l) / u);
      let K = (B, D) => {
        let E = k,
          P = m.pow(D, L),
          U = m.sqr(P);
        U = m.mul(U, D);
        let w = m.mul(B, U);
        ((w = m.pow(w, G)),
          (w = m.mul(w, P)),
          (P = m.mul(w, D)),
          (U = m.mul(w, B)));
        let A = m.mul(U, P);
        w = m.pow(A, F);
        let T = m.eql(w, m.ONE);
        ((P = m.mul(U, V)),
          (w = m.mul(A, E)),
          (U = m.cmov(P, U, T)),
          (A = m.cmov(w, A, T)));
        for (let R = v; R > l; R--) {
          let _ = R - u;
          _ = u << (_ - l);
          let S = m.pow(A, _);
          const I = m.eql(S, m.ONE);
          ((P = m.mul(U, E)),
            (E = m.mul(E, E)),
            (S = m.mul(A, E)),
            (U = m.cmov(P, U, I)),
            (A = m.cmov(S, A, I)));
        }
        return {isValid: T, value: U};
      };
      if (m.ORDER % f === d) {
        const B = (m.ORDER - d) / f,
          D = m.sqrt(m.neg(y));
        K = (E, P) => {
          let U = m.sqr(P);
          const w = m.mul(E, P);
          U = m.mul(U, w);
          let A = m.pow(U, B);
          A = m.mul(A, w);
          const T = m.mul(A, D),
            R = m.mul(m.sqr(A), P),
            _ = m.eql(R, E);
          return {isValid: _, value: m.cmov(T, A, _)};
        };
      }
      return K;
    }
  })(Xv),
    Object.defineProperty(rf, '__esModule', {value: !0}),
    (rf.getHash = T_),
    (rf.createCurve = function (t, e) {
      const n = (r) => (0, fj.weierstrass)({...t, ...T_(r)});
      return Object.freeze({...n(e), create: n});
    }));
  const dj = Jv,
    C_ = fs,
    fj = Xv;
  function T_(t) {
    return {
      hash: t,
      hmac: (e, ...n) => (0, dj.hmac)(t, e, (0, C_.concatBytes)(...n)),
      randomBytes: C_.randomBytes
    };
  }
  (function (t) {
    (Object.defineProperty(t, '__esModule', {value: !0}),
      (t.encodeToCurve = t.hashToCurve = t.schnorr = t.secp256k1 = void 0));
    const e = Wi,
      n = fs,
      r = rf,
      i = ks,
      s = ct,
      o = Ge,
      a = Xv,
      c = BigInt(
        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'
      ),
      l = BigInt(
        '0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'
      ),
      u = BigInt(1),
      d = BigInt(2),
      f = (w, A) => (w + A / d) / A;
    function h(w) {
      const A = c,
        T = BigInt(3),
        R = BigInt(6),
        _ = BigInt(11),
        S = BigInt(22),
        I = BigInt(23),
        O = BigInt(44),
        H = BigInt(88),
        M = (w * w * w) % A,
        q = (M * M * w) % A,
        z = ((0, s.pow2)(q, T, A) * q) % A,
        Z = ((0, s.pow2)(z, T, A) * q) % A,
        X = ((0, s.pow2)(Z, d, A) * M) % A,
        N = ((0, s.pow2)(X, _, A) * X) % A,
        j = ((0, s.pow2)(N, S, A) * N) % A,
        W = ((0, s.pow2)(j, O, A) * j) % A,
        J = ((0, s.pow2)(W, H, A) * W) % A,
        Q = ((0, s.pow2)(J, O, A) * j) % A,
        Y = ((0, s.pow2)(Q, T, A) * q) % A,
        se = ((0, s.pow2)(Y, I, A) * N) % A,
        ne = ((0, s.pow2)(se, R, A) * M) % A,
        oe = (0, s.pow2)(ne, d, A);
      if (!g.eql(g.sqr(oe), w)) throw new Error('Cannot find square root');
      return oe;
    }
    const g = (0, s.Field)(c, void 0, void 0, {sqrt: h});
    t.secp256k1 = (0, r.createCurve)(
      {
        a: BigInt(0),
        b: BigInt(7),
        Fp: g,
        n: l,
        Gx: BigInt(
          '55066263022277343669578718895168534326250603453777594175500187360389116729240'
        ),
        Gy: BigInt(
          '32670510020758816978083085130507043184471273380659243275938904335757337482424'
        ),
        h: BigInt(1),
        lowS: !0,
        endo: {
          beta: BigInt(
            '0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'
          ),
          splitScalar: (w) => {
            const A = l,
              T = BigInt('0x3086d221a7d46bcde86c90e49284eb15'),
              R = -u * BigInt('0xe4437ed6010e88286f547fa90abfe4c3'),
              _ = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'),
              S = T,
              I = BigInt('0x100000000000000000000000000000000'),
              O = f(S * w, A),
              H = f(-R * w, A);
            let M = (0, s.mod)(w - O * T - H * _, A),
              q = (0, s.mod)(-O * R - H * S, A);
            const z = M > I,
              Z = q > I;
            if ((z && (M = A - M), Z && (q = A - q), M > I || q > I))
              throw new Error('splitScalar: Endomorphism failed, k=' + w);
            return {k1neg: z, k1: M, k2neg: Z, k2: q};
          }
        }
      },
      e.sha256
    );
    const m = BigInt(0),
      y = {};
    function p(w, ...A) {
      let T = y[w];
      if (T === void 0) {
        const R = (0, e.sha256)(Uint8Array.from(w, (_) => _.charCodeAt(0)));
        ((T = (0, o.concatBytes)(R, R)), (y[w] = T));
      }
      return (0, e.sha256)((0, o.concatBytes)(T, ...A));
    }
    const b = (w) => w.toRawBytes(!0).slice(1),
      v = (w) => (0, o.numberToBytesBE)(w, 32),
      x = (w) => (0, s.mod)(w, c),
      C = (w) => (0, s.mod)(w, l),
      $ = t.secp256k1.ProjectivePoint,
      G = (w, A, T) => $.BASE.multiplyAndAddUnsafe(w, A, T);
    function L(w) {
      let A = t.secp256k1.utils.normPrivateKeyToScalar(w),
        T = $.fromPrivateKey(A);
      return {scalar: T.hasEvenY() ? A : C(-A), bytes: b(T)};
    }
    function F(w) {
      (0, o.aInRange)('x', w, u, c);
      const A = x(w * w);
      let T = h(x(A * w + BigInt(7)));
      T % d !== m && (T = x(-T));
      const R = new $(w, T, u);
      return (R.assertValidity(), R);
    }
    const k = o.bytesToNumberBE;
    function V(...w) {
      return C(k(p('BIP0340/challenge', ...w)));
    }
    function K(w) {
      return L(w).bytes;
    }
    function B(w, A, T = (0, n.randomBytes)(32)) {
      const R = (0, o.ensureBytes)('message', w),
        {bytes: _, scalar: S} = L(A),
        I = (0, o.ensureBytes)('auxRand', T, 32),
        O = v(S ^ k(p('BIP0340/aux', I))),
        H = p('BIP0340/nonce', O, _, R),
        M = C(k(H));
      if (M === m) throw new Error('sign failed: k is zero');
      const {bytes: q, scalar: z} = L(M),
        Z = V(q, _, R),
        X = new Uint8Array(64);
      if ((X.set(q, 0), X.set(v(C(z + Z * S)), 32), !D(X, R, _)))
        throw new Error('sign: Invalid signature produced');
      return X;
    }
    function D(w, A, T) {
      const R = (0, o.ensureBytes)('signature', w, 64),
        _ = (0, o.ensureBytes)('message', A),
        S = (0, o.ensureBytes)('publicKey', T, 32);
      try {
        const I = F(k(S)),
          O = k(R.subarray(0, 32));
        if (!(0, o.inRange)(O, u, c)) return !1;
        const H = k(R.subarray(32, 64));
        if (!(0, o.inRange)(H, u, l)) return !1;
        const M = V(v(O), b(I), _),
          q = G(I, H, C(-M));
        return !(!q || !q.hasEvenY() || q.toAffine().x !== O);
      } catch {
        return !1;
      }
    }
    t.schnorr = {
      getPublicKey: K,
      sign: B,
      verify: D,
      utils: {
        randomPrivateKey: t.secp256k1.utils.randomPrivateKey,
        lift_x: F,
        pointToBytes: b,
        numberToBytesBE: o.numberToBytesBE,
        bytesToNumberBE: o.bytesToNumberBE,
        taggedHash: p,
        mod: s.mod
      }
    };
    const E = (0, i.isogenyMap)(
        g,
        [
          [
            '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',
            '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',
            '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',
            '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c'
          ],
          [
            '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',
            '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',
            '0x0000000000000000000000000000000000000000000000000000000000000001'
          ],
          [
            '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',
            '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',
            '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',
            '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84'
          ],
          [
            '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',
            '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',
            '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',
            '0x0000000000000000000000000000000000000000000000000000000000000001'
          ]
        ].map((w) => w.map((A) => BigInt(A)))
      ),
      P = (0, a.mapToCurveSimpleSWU)(g, {
        A: BigInt(
          '0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'
        ),
        B: BigInt('1771'),
        Z: g.create(BigInt('-11'))
      }),
      U = (0, i.createHasher)(
        t.secp256k1.ProjectivePoint,
        (w) => {
          const {x: A, y: T} = P(g.create(w[0]));
          return E(A, T);
        },
        {
          DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',
          encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',
          p: g.ORDER,
          m: 1,
          k: 128,
          expand: 'xmd',
          hash: e.sha256
        }
      );
    ((t.hashToCurve = U.hashToCurve), (t.encodeToCurve = U.encodeToCurve));
  })(s5);
  var Vg = {};
  ((function (t) {
    (Object.defineProperty(t, '__esModule', {value: !0}),
      (t.decodeHex = t.remove0x = void 0));
    var e = sr;
    ((t.remove0x = function (n) {
      return n.startsWith('0x') || n.startsWith('0X') ? n.slice(2) : n;
    }),
      (t.decodeHex = function (n) {
        return (0, e.hexToBytes)((0, t.remove0x)(n));
      }));
  })(Vg),
    (function (t) {
      (Object.defineProperty(t, '__esModule', {value: !0}),
        (t.hexToPublicKey =
          t.convertPublicKeyFormat =
          t.getSharedPoint =
          t.getPublicKey =
          t.isValidPrivateKey =
          t.getValidSecret =
            void 0));
      var e = Wv,
        n = CC,
        r = s5,
        i = du,
        s = Ut,
        o = Vg;
      ((t.getValidSecret = function () {
        var u;
        do u = (0, e.randomBytes)(s.SECRET_KEY_LENGTH);
        while (!(0, t.isValidPrivateKey)(u));
        return u;
      }),
        (t.isValidPrivateKey = function (u) {
          return a(
            (0, i.ellipticCurve)(),
            function (d) {
              return d.utils.isValidPrivateKey(u);
            },
            function () {
              return !0;
            },
            function () {
              return !0;
            }
          );
        }),
        (t.getPublicKey = function (u) {
          return a(
            (0, i.ellipticCurve)(),
            function (d) {
              return d.getPublicKey(u);
            },
            function (d) {
              return d.getPublicKey(u);
            },
            function (d) {
              return d.getPublicKey(u);
            }
          );
        }),
        (t.getSharedPoint = function (u, d, f) {
          return a(
            (0, i.ellipticCurve)(),
            function (h) {
              return h.getSharedSecret(u, d, f);
            },
            function (h) {
              return h.getSharedSecret(u, d);
            },
            function (h) {
              return l(h, u, d);
            }
          );
        }),
        (t.convertPublicKeyFormat = function (u, d) {
          return a(
            (0, i.ellipticCurve)(),
            function (f) {
              return f.getSharedSecret(BigInt(1), u, d);
            },
            function () {
              return u;
            },
            function () {
              return u;
            }
          );
        }));
      function a(u, d, f, h) {
        if (u === 'secp256k1') return d(r.secp256k1);
        if (u === 'x25519') return f(n.x25519);
        if (u === 'ed25519') return h(n.ed25519);
        throw new Error('Not implemented');
      }
      t.hexToPublicKey = function (u) {
        var d = (0, o.decodeHex)(u);
        return a(
          (0, i.ellipticCurve)(),
          function () {
            return c(d);
          },
          function () {
            return d;
          },
          function () {
            return d;
          }
        );
      };
      var c = function (u) {
          if (u.length === s.ETH_PUBLIC_KEY_SIZE) {
            var d = new Uint8Array(1 + u.length);
            return (d.set([4]), d.set(u, 1), d);
          }
          return u;
        },
        l = function (u, d, f) {
          var h = u.utils.getExtendedPublicKey(d).scalar;
          return u.ExtendedPoint.fromHex(f).multiply(h).toRawBytes();
        };
    })(xC));
  var o5 = {},
    La = {};
  (Object.defineProperty(La, '__esModule', {value: !0}),
    (La.hkdf = void 0),
    (La.extract = c5),
    (La.expand = l5));
  const Gg = Qn,
    I_ = fs,
    a5 = Jv;
  function c5(t, e, n) {
    return (
      (0, Gg.hash)(t),
      n === void 0 && (n = new Uint8Array(t.outputLen)),
      (0, a5.hmac)(t, (0, I_.toBytes)(n), (0, I_.toBytes)(e))
    );
  }
  const t0 = new Uint8Array([0]),
    k_ = new Uint8Array();
  function l5(t, e, n, r = 32) {
    if (((0, Gg.hash)(t), (0, Gg.number)(r), r > 255 * t.outputLen))
      throw new Error('Length should be <= 255*HashLen');
    const i = Math.ceil(r / t.outputLen);
    n === void 0 && (n = k_);
    const s = new Uint8Array(i * t.outputLen),
      o = a5.hmac.create(t, e),
      a = o._cloneInto(),
      c = new Uint8Array(o.outputLen);
    for (let l = 0; l < i; l++)
      ((t0[0] = l + 1),
        a
          .update(l === 0 ? k_ : c)
          .update(n)
          .update(t0)
          .digestInto(c),
        s.set(c, t.outputLen * l),
        o._cloneInto(a));
    return (o.destroy(), a.destroy(), c.fill(0), t0.fill(0), s.slice(0, r));
  }
  ((La.hkdf = (t, e, n, r, i) => l5(t, c5(t, e, n), r, i)),
    (function (t) {
      (Object.defineProperty(t, '__esModule', {value: !0}),
        (t.getSharedKey = t.deriveKey = void 0));
      var e = sr,
        n = La,
        r = Wi;
      ((t.deriveKey = function (i, s, o) {
        return (0, n.hkdf)(r.sha256, i, s, o, 32);
      }),
        (t.getSharedKey = function () {
          for (var i = [], s = 0; s < arguments.length; s++)
            i[s] = arguments[s];
          return (0, t.deriveKey)(e.concatBytes.apply(void 0, i));
        }));
    })(o5));
  var R_ = {},
    Qa = {},
    Ct = {},
    Ro = {};
  (Object.defineProperty(Ro, '__esModule', {value: !0}),
    (Ro.polyval = Ro.ghash = void 0),
    (Ro._toGHASHKey = u5));
  const Po = un,
    _n = sr,
    Fi = 16,
    e1 = new Uint8Array(16),
    ni = (0, _n.u32)(e1),
    mr = (t) =>
      (((t >>> 0) & 255) << 24) |
      (((t >>> 8) & 255) << 16) |
      (((t >>> 16) & 255) << 8) |
      ((t >>> 24) & 255) |
      0;
  function u5(t) {
    t.reverse();
    const e = 1 & t[15];
    let n = 0;
    for (let r = 0; r < t.length; r++) {
      const i = t[r];
      ((t[r] = (i >>> 1) | n), (n = (1 & i) << 7));
    }
    return ((t[0] ^= 225 & -e), t);
  }
  class d5 {
    constructor(e, n) {
      ((this.blockLen = Fi),
        (this.outputLen = Fi),
        (this.s0 = 0),
        (this.s1 = 0),
        (this.s2 = 0),
        (this.s3 = 0),
        (this.finished = !1),
        (e = (0, _n.toBytes)(e)),
        (0, Po.bytes)(e, 16));
      const r = (0, _n.createView)(e);
      let i = r.getUint32(0, !1),
        s = r.getUint32(4, !1),
        o = r.getUint32(8, !1),
        a = r.getUint32(12, !1);
      const c = [];
      for (let p = 0; p < 128; p++)
        (c.push({s0: mr(i), s1: mr(s), s2: mr(o), s3: mr(a)}),
          ({
            s0: i,
            s1: s,
            s2: o,
            s3: a
          } = {
            s3: ((d = o) << 31) | ((f = a) >>> 1),
            s2: ((u = s) << 31) | (d >>> 1),
            s1: ((l = i) << 31) | (u >>> 1),
            s0: (l >>> 1) ^ ((225 << 24) & -(1 & f))
          }));
      var l, u, d, f;
      const h = ((p) => (p > 65536 ? 8 : p > 1024 ? 4 : 2))(n || 1024);
      if (![1, 2, 4, 8].includes(h))
        throw new Error(`ghash: wrong window size=${h}, should be 2, 4 or 8`);
      this.W = h;
      const g = 128 / h,
        m = (this.windowSize = 2 ** h),
        y = [];
      for (let p = 0; p < g; p++)
        for (let b = 0; b < m; b++) {
          let v = 0,
            x = 0,
            C = 0,
            $ = 0;
          for (let G = 0; G < h; G++) {
            if (!((b >>> (h - G - 1)) & 1)) continue;
            const {s0: L, s1: F, s2: k, s3: V} = c[h * p + G];
            ((v ^= L), (x ^= F), (C ^= k), ($ ^= V));
          }
          y.push({s0: v, s1: x, s2: C, s3: $});
        }
      this.t = y;
    }
    _updateBlock(e, n, r, i) {
      ((e ^= this.s0), (n ^= this.s1), (r ^= this.s2), (i ^= this.s3));
      const {W: s, t: o, windowSize: a} = this;
      let c = 0,
        l = 0,
        u = 0,
        d = 0;
      const f = (1 << s) - 1;
      let h = 0;
      for (const g of [e, n, r, i])
        for (let m = 0; m < 4; m++) {
          const y = (g >>> (8 * m)) & 255;
          for (let p = 8 / s - 1; p >= 0; p--) {
            const b = (y >>> (s * p)) & f,
              {s0: v, s1: x, s2: C, s3: $} = o[h * a + b];
            ((c ^= v), (l ^= x), (u ^= C), (d ^= $), (h += 1));
          }
        }
      ((this.s0 = c), (this.s1 = l), (this.s2 = u), (this.s3 = d));
    }
    update(e) {
      ((e = (0, _n.toBytes)(e)), (0, Po.exists)(this));
      const n = (0, _n.u32)(e),
        r = Math.floor(e.length / Fi),
        i = e.length % Fi;
      for (let s = 0; s < r; s++)
        this._updateBlock(
          n[4 * s + 0],
          n[4 * s + 1],
          n[4 * s + 2],
          n[4 * s + 3]
        );
      return (
        i &&
          (e1.set(e.subarray(r * Fi)),
          this._updateBlock(ni[0], ni[1], ni[2], ni[3]),
          (0, _n.clean)(ni)),
        this
      );
    }
    destroy() {
      const {t: e} = this;
      for (const n of e) ((n.s0 = 0), (n.s1 = 0), (n.s2 = 0), (n.s3 = 0));
    }
    digestInto(e) {
      ((0, Po.exists)(this), (0, Po.output)(e, this), (this.finished = !0));
      const {s0: n, s1: r, s2: i, s3: s} = this,
        o = (0, _n.u32)(e);
      return ((o[0] = n), (o[1] = r), (o[2] = i), (o[3] = s), e);
    }
    digest() {
      const e = new Uint8Array(Fi);
      return (this.digestInto(e), this.destroy(), e);
    }
  }
  class hj extends d5 {
    constructor(e, n) {
      e = (0, _n.toBytes)(e);
      const r = u5((0, _n.copyBytes)(e));
      (super(r, n), (0, _n.clean)(r));
    }
    update(e) {
      ((e = (0, _n.toBytes)(e)), (0, Po.exists)(this));
      const n = (0, _n.u32)(e),
        r = e.length % Fi,
        i = Math.floor(e.length / Fi);
      for (let s = 0; s < i; s++)
        this._updateBlock(
          mr(n[4 * s + 3]),
          mr(n[4 * s + 2]),
          mr(n[4 * s + 1]),
          mr(n[4 * s + 0])
        );
      return (
        r &&
          (e1.set(e.subarray(i * Fi)),
          this._updateBlock(mr(ni[3]), mr(ni[2]), mr(ni[1]), mr(ni[0])),
          (0, _n.clean)(ni)),
        this
      );
    }
    digestInto(e) {
      ((0, Po.exists)(this), (0, Po.output)(e, this), (this.finished = !0));
      const {s0: n, s1: r, s2: i, s3: s} = this,
        o = (0, _n.u32)(e);
      return ((o[0] = n), (o[1] = r), (o[2] = i), (o[3] = s), e.reverse());
    }
  }
  function P_(t) {
    const e = (r, i) =>
        t(i, r.length)
          .update((0, _n.toBytes)(r))
          .digest(),
      n = t(new Uint8Array(16), 0);
    return (
      (e.outputLen = n.outputLen),
      (e.blockLen = n.blockLen),
      (e.create = (r, i) => t(r, i)),
      e
    );
  }
  ((Ro.ghash = P_((t, e) => new d5(t, e))),
    (Ro.polyval = P_((t, e) => new hj(t, e))),
    Object.defineProperty(Ct, '__esModule', {value: !0}),
    (Ct.unsafe =
      Ct.aeskwp =
      Ct.aeskw =
      Ct.siv =
      Ct.gcm =
      Ct.cfb =
      Ct.cbc =
      Ct.ecb =
      Ct.ctr =
        void 0),
    (Ct.expandKeyLE = Rr),
    (Ct.expandKeyDecLE = hu));
  const Qe = un,
    zg = Ro,
    pe = sr,
    qn = 16,
    yd = new Uint8Array(qn),
    pj = 283;
  function t1(t) {
    return (t << 1) ^ (pj & -(t >> 7));
  }
  function Ba(t, e) {
    let n = 0;
    for (; e > 0; e >>= 1) ((n ^= t & -(1 & e)), (t = t1(t)));
    return n;
  }
  const Wg = (() => {
      const t = new Uint8Array(256);
      for (let n = 0, r = 1; n < 256; n++, r ^= t1(r)) t[n] = r;
      const e = new Uint8Array(256);
      e[0] = 99;
      for (let n = 0; n < 255; n++) {
        let r = t[255 - n];
        ((r |= r << 8),
          (e[t[n]] =
            255 & (r ^ (r >> 4) ^ (r >> 5) ^ (r >> 6) ^ (r >> 7) ^ 99)));
      }
      return ((0, pe.clean)(t), e);
    })(),
    mj = Wg.map((t, e) => Wg.indexOf(e)),
    gj = (t) => (t << 24) | (t >>> 8),
    n0 = (t) => (t << 8) | (t >>> 24),
    kh = (t) =>
      ((t << 24) & 4278190080) |
      ((t << 8) & 16711680) |
      ((t >>> 8) & 65280) |
      ((t >>> 24) & 255);
  function f5(t, e) {
    if (t.length !== 256) throw new Error('Wrong sbox length');
    const n = new Uint32Array(256).map((l, u) => e(t[u])),
      r = n.map(n0),
      i = r.map(n0),
      s = i.map(n0),
      o = new Uint32Array(65536),
      a = new Uint32Array(65536),
      c = new Uint16Array(65536);
    for (let l = 0; l < 256; l++)
      for (let u = 0; u < 256; u++) {
        const d = 256 * l + u;
        ((o[d] = n[l] ^ r[u]),
          (a[d] = i[l] ^ s[u]),
          (c[d] = (t[l] << 8) | t[u]));
      }
    return {sbox: t, sbox2: c, T0: n, T1: r, T2: i, T3: s, T01: o, T23: a};
  }
  const n1 = f5(Wg, (t) => (Ba(t, 3) << 24) | (t << 16) | (t << 8) | Ba(t, 2)),
    h5 = f5(
      mj,
      (t) => (Ba(t, 11) << 24) | (Ba(t, 13) << 16) | (Ba(t, 9) << 8) | Ba(t, 14)
    ),
    yj = (() => {
      const t = new Uint8Array(16);
      for (let e = 0, n = 1; e < 16; e++, n = t1(n)) t[e] = n;
      return t;
    })();
  function Rr(t) {
    (0, Qe.bytes)(t);
    const e = t.length;
    if (![16, 24, 32].includes(e))
      throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${e}`);
    const {sbox2: n} = n1,
      r = [];
    (0, pe.isAligned32)(t) || r.push((t = (0, pe.copyBytes)(t)));
    const i = (0, pe.u32)(t),
      s = i.length,
      o = (c) => si(n, c, c, c, c),
      a = new Uint32Array(e + 28);
    a.set(i);
    for (let c = s; c < a.length; c++) {
      let l = a[c - 1];
      (c % s == 0
        ? (l = o(gj(l)) ^ yj[c / s - 1])
        : s > 6 && c % s == 4 && (l = o(l)),
        (a[c] = a[c - s] ^ l));
    }
    return ((0, pe.clean)(...r), a);
  }
  function hu(t) {
    const e = Rr(t),
      n = e.slice(),
      r = e.length,
      {sbox2: i} = n1,
      {T0: s, T1: o, T2: a, T3: c} = h5;
    for (let l = 0; l < r; l += 4)
      for (let u = 0; u < 4; u++) n[l + u] = e[r - l - 4 + u];
    (0, pe.clean)(e);
    for (let l = 4; l < r - 4; l++) {
      const u = n[l],
        d = si(i, u, u, u, u);
      n[l] =
        s[255 & d] ^ o[(d >>> 8) & 255] ^ a[(d >>> 16) & 255] ^ c[d >>> 24];
    }
    return n;
  }
  function Hs(t, e, n, r, i, s) {
    return (
      t[((n << 8) & 65280) | ((r >>> 8) & 255)] ^
      e[((i >>> 8) & 65280) | ((s >>> 24) & 255)]
    );
  }
  function si(t, e, n, r, i) {
    return (
      t[(255 & e) | (65280 & n)] |
      (t[((r >>> 16) & 255) | ((i >>> 16) & 65280)] << 16)
    );
  }
  function An(t, e, n, r, i) {
    const {sbox2: s, T01: o, T23: a} = n1;
    let c = 0;
    ((e ^= t[c++]), (n ^= t[c++]), (r ^= t[c++]), (i ^= t[c++]));
    const l = t.length / 4 - 2;
    for (let u = 0; u < l; u++) {
      const d = t[c++] ^ Hs(o, a, e, n, r, i),
        f = t[c++] ^ Hs(o, a, n, r, i, e),
        h = t[c++] ^ Hs(o, a, r, i, e, n),
        g = t[c++] ^ Hs(o, a, i, e, n, r);
      ((e = d), (n = f), (r = h), (i = g));
    }
    return {
      s0: t[c++] ^ si(s, e, n, r, i),
      s1: t[c++] ^ si(s, n, r, i, e),
      s2: t[c++] ^ si(s, r, i, e, n),
      s3: t[c++] ^ si(s, i, e, n, r)
    };
  }
  function pu(t, e, n, r, i) {
    const {sbox2: s, T01: o, T23: a} = h5;
    let c = 0;
    ((e ^= t[c++]), (n ^= t[c++]), (r ^= t[c++]), (i ^= t[c++]));
    const l = t.length / 4 - 2;
    for (let u = 0; u < l; u++) {
      const d = t[c++] ^ Hs(o, a, e, i, r, n),
        f = t[c++] ^ Hs(o, a, n, e, i, r),
        h = t[c++] ^ Hs(o, a, r, n, e, i),
        g = t[c++] ^ Hs(o, a, i, r, n, e);
      ((e = d), (n = f), (r = h), (i = g));
    }
    return {
      s0: t[c++] ^ si(s, e, i, r, n),
      s1: t[c++] ^ si(s, n, e, i, r),
      s2: t[c++] ^ si(s, r, n, e, i),
      s3: t[c++] ^ si(s, i, r, n, e)
    };
  }
  function Ja(t, e) {
    if (e === void 0) return new Uint8Array(t);
    if (((0, Qe.bytes)(e), e.length < t))
      throw new Error(
        `aes: wrong destination length, expected at least ${t}, got: ${e.length}`
      );
    if (!(0, pe.isAligned32)(e)) throw new Error('unaligned dst');
    return e;
  }
  function p5(t, e, n, r) {
    ((0, Qe.bytes)(e, qn), (0, Qe.bytes)(n));
    const i = n.length;
    r = Ja(i, r);
    const s = e,
      o = (0, pe.u32)(s);
    let {s0: a, s1: c, s2: l, s3: u} = An(t, o[0], o[1], o[2], o[3]);
    const d = (0, pe.u32)(n),
      f = (0, pe.u32)(r);
    for (let g = 0; g + 4 <= d.length; g += 4) {
      ((f[g + 0] = d[g + 0] ^ a),
        (f[g + 1] = d[g + 1] ^ c),
        (f[g + 2] = d[g + 2] ^ l),
        (f[g + 3] = d[g + 3] ^ u));
      let m = 1;
      for (let y = s.length - 1; y >= 0; y--)
        ((m = (m + (255 & s[y])) | 0), (s[y] = 255 & m), (m >>>= 8));
      ({s0: a, s1: c, s2: l, s3: u} = An(t, o[0], o[1], o[2], o[3]));
    }
    const h = qn * Math.floor(d.length / 4);
    if (h < i) {
      const g = new Uint32Array([a, c, l, u]),
        m = (0, pe.u8)(g);
      for (let y = h, p = 0; y < i; y++, p++) r[y] = n[y] ^ m[p];
      (0, pe.clean)(g);
    }
    return r;
  }
  function Da(t, e, n, r, i) {
    ((0, Qe.bytes)(n, qn), (0, Qe.bytes)(r), (i = Ja(r.length, i)));
    const s = n,
      o = (0, pe.u32)(s),
      a = (0, pe.createView)(s),
      c = (0, pe.u32)(r),
      l = (0, pe.u32)(i),
      u = e ? 0 : 12,
      d = r.length;
    let f = a.getUint32(u, e),
      {s0: h, s1: g, s2: m, s3: y} = An(t, o[0], o[1], o[2], o[3]);
    for (let b = 0; b + 4 <= c.length; b += 4)
      ((l[b + 0] = c[b + 0] ^ h),
        (l[b + 1] = c[b + 1] ^ g),
        (l[b + 2] = c[b + 2] ^ m),
        (l[b + 3] = c[b + 3] ^ y),
        (f = (f + 1) >>> 0),
        a.setUint32(u, f, e),
        ({s0: h, s1: g, s2: m, s3: y} = An(t, o[0], o[1], o[2], o[3])));
    const p = qn * Math.floor(c.length / 4);
    if (p < d) {
      const b = new Uint32Array([h, g, m, y]),
        v = (0, pe.u8)(b);
      for (let x = p, C = 0; x < d; x++, C++) i[x] = r[x] ^ v[C];
      (0, pe.clean)(b);
    }
    return i;
  }
  function M_(t) {
    if (((0, Qe.bytes)(t), t.length % qn != 0))
      throw new Error(
        'aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size 16'
      );
  }
  function O_(t, e, n) {
    (0, Qe.bytes)(t);
    let r = t.length;
    const i = r % qn;
    if (!e && i !== 0)
      throw new Error(
        'aec/(cbc-ecb): unpadded plaintext with disabled padding'
      );
    (0, pe.isAligned32)(t) || (t = (0, pe.copyBytes)(t));
    const s = (0, pe.u32)(t);
    if (e) {
      let a = qn - i;
      (a || (a = qn), (r += a));
    }
    const o = Ja(r, n);
    return {b: s, o: (0, pe.u32)(o), out: o};
  }
  function N_(t, e) {
    if (!e) return t;
    const n = t.length;
    if (!n) throw new Error('aes/pcks5: empty ciphertext not allowed');
    const r = t[n - 1];
    if (r <= 0 || r > 16) throw new Error('aes/pcks5: wrong padding');
    const i = t.subarray(0, -r);
    for (let s = 0; s < r; s++)
      if (t[n - s - 1] !== r) throw new Error('aes/pcks5: wrong padding');
    return i;
  }
  function L_(t) {
    const e = new Uint8Array(16),
      n = (0, pe.u32)(e);
    e.set(t);
    const r = qn - t.length;
    for (let i = qn - r; i < qn; i++) e[i] = r;
    return n;
  }
  function m5(t, e, n, r, i) {
    const s = i == null ? 0 : i.length,
      o = t.create(n, r.length + s);
    (i && o.update(i), o.update(r));
    const a = new Uint8Array(16),
      c = (0, pe.createView)(a);
    (i && (0, pe.setBigUint64)(c, 0, BigInt(8 * s), e),
      (0, pe.setBigUint64)(c, 8, BigInt(8 * r.length), e),
      o.update(a));
    const l = o.digest();
    return ((0, pe.clean)(a), l);
  }
  ((Ct.ctr = (0, pe.wrapCipher)(
    {blockSize: 16, nonceLength: 16},
    function (t, e) {
      function n(r, i) {
        if (
          ((0, Qe.bytes)(r),
          i !== void 0 && ((0, Qe.bytes)(i), !(0, pe.isAligned32)(i)))
        )
          throw new Error('unaligned destination');
        const s = Rr(t),
          o = (0, pe.copyBytes)(e),
          a = [s, o];
        (0, pe.isAligned32)(r) || a.push((r = (0, pe.copyBytes)(r)));
        const c = p5(s, o, r, i);
        return ((0, pe.clean)(...a), c);
      }
      return (
        (0, Qe.bytes)(t),
        (0, Qe.bytes)(e, qn),
        {encrypt: (r, i) => n(r, i), decrypt: (r, i) => n(r, i)}
      );
    }
  )),
    (Ct.ecb = (0, pe.wrapCipher)({blockSize: 16}, function (t, e = {}) {
      (0, Qe.bytes)(t);
      const n = !e.disablePadding;
      return {
        encrypt(r, i) {
          const {b: s, o, out: a} = O_(r, n, i),
            c = Rr(t);
          let l = 0;
          for (; l + 4 <= s.length; ) {
            const {
              s0: u,
              s1: d,
              s2: f,
              s3: h
            } = An(c, s[l + 0], s[l + 1], s[l + 2], s[l + 3]);
            ((o[l++] = u), (o[l++] = d), (o[l++] = f), (o[l++] = h));
          }
          if (n) {
            const u = L_(r.subarray(4 * l)),
              {s0: d, s1: f, s2: h, s3: g} = An(c, u[0], u[1], u[2], u[3]);
            ((o[l++] = d), (o[l++] = f), (o[l++] = h), (o[l++] = g));
          }
          return ((0, pe.clean)(c), a);
        },
        decrypt(r, i) {
          M_(r);
          const s = hu(t),
            o = Ja(r.length, i),
            a = [s];
          (0, pe.isAligned32)(r) || a.push((r = (0, pe.copyBytes)(r)));
          const c = (0, pe.u32)(r),
            l = (0, pe.u32)(o);
          for (let u = 0; u + 4 <= c.length; ) {
            const {
              s0: d,
              s1: f,
              s2: h,
              s3: g
            } = pu(s, c[u + 0], c[u + 1], c[u + 2], c[u + 3]);
            ((l[u++] = d), (l[u++] = f), (l[u++] = h), (l[u++] = g));
          }
          return ((0, pe.clean)(...a), N_(o, n));
        }
      };
    })),
    (Ct.cbc = (0, pe.wrapCipher)(
      {blockSize: 16, nonceLength: 16},
      function (t, e, n = {}) {
        ((0, Qe.bytes)(t), (0, Qe.bytes)(e, 16));
        const r = !n.disablePadding;
        return {
          encrypt(i, s) {
            const o = Rr(t),
              {b: a, o: c, out: l} = O_(i, r, s);
            let u = e;
            const d = [o];
            (0, pe.isAligned32)(u) || d.push((u = (0, pe.copyBytes)(u)));
            const f = (0, pe.u32)(u);
            let h = f[0],
              g = f[1],
              m = f[2],
              y = f[3],
              p = 0;
            for (; p + 4 <= a.length; )
              ((h ^= a[p + 0]),
                (g ^= a[p + 1]),
                (m ^= a[p + 2]),
                (y ^= a[p + 3]),
                ({s0: h, s1: g, s2: m, s3: y} = An(o, h, g, m, y)),
                (c[p++] = h),
                (c[p++] = g),
                (c[p++] = m),
                (c[p++] = y));
            if (r) {
              const b = L_(i.subarray(4 * p));
              ((h ^= b[0]),
                (g ^= b[1]),
                (m ^= b[2]),
                (y ^= b[3]),
                ({s0: h, s1: g, s2: m, s3: y} = An(o, h, g, m, y)),
                (c[p++] = h),
                (c[p++] = g),
                (c[p++] = m),
                (c[p++] = y));
            }
            return ((0, pe.clean)(...d), l);
          },
          decrypt(i, s) {
            M_(i);
            const o = hu(t);
            let a = e;
            const c = [o];
            (0, pe.isAligned32)(a) || c.push((a = (0, pe.copyBytes)(a)));
            const l = (0, pe.u32)(a),
              u = Ja(i.length, s);
            (0, pe.isAligned32)(i) || c.push((i = (0, pe.copyBytes)(i)));
            const d = (0, pe.u32)(i),
              f = (0, pe.u32)(u);
            let h = l[0],
              g = l[1],
              m = l[2],
              y = l[3];
            for (let p = 0; p + 4 <= d.length; ) {
              const b = h,
                v = g,
                x = m,
                C = y;
              ((h = d[p + 0]), (g = d[p + 1]), (m = d[p + 2]), (y = d[p + 3]));
              const {s0: $, s1: G, s2: L, s3: F} = pu(o, h, g, m, y);
              ((f[p++] = $ ^ b),
                (f[p++] = G ^ v),
                (f[p++] = L ^ x),
                (f[p++] = F ^ C));
            }
            return ((0, pe.clean)(...c), N_(u, r));
          }
        };
      }
    )),
    (Ct.cfb = (0, pe.wrapCipher)(
      {blockSize: 16, nonceLength: 16},
      function (t, e) {
        function n(r, i, s) {
          (0, Qe.bytes)(r);
          const o = r.length;
          s = Ja(o, s);
          const a = Rr(t);
          let c = e;
          const l = [a];
          ((0, pe.isAligned32)(c) || l.push((c = (0, pe.copyBytes)(c))),
            (0, pe.isAligned32)(r) || l.push((r = (0, pe.copyBytes)(r))));
          const u = (0, pe.u32)(r),
            d = (0, pe.u32)(s),
            f = i ? d : u,
            h = (0, pe.u32)(c);
          let g = h[0],
            m = h[1],
            y = h[2],
            p = h[3];
          for (let v = 0; v + 4 <= u.length; ) {
            const {s0: x, s1: C, s2: $, s3: G} = An(a, g, m, y, p);
            ((d[v + 0] = u[v + 0] ^ x),
              (d[v + 1] = u[v + 1] ^ C),
              (d[v + 2] = u[v + 2] ^ $),
              (d[v + 3] = u[v + 3] ^ G),
              (g = f[v++]),
              (m = f[v++]),
              (y = f[v++]),
              (p = f[v++]));
          }
          const b = qn * Math.floor(u.length / 4);
          if (b < o) {
            ({s0: g, s1: m, s2: y, s3: p} = An(a, g, m, y, p));
            const v = (0, pe.u8)(new Uint32Array([g, m, y, p]));
            for (let x = b, C = 0; x < o; x++, C++) s[x] = r[x] ^ v[C];
            (0, pe.clean)(v);
          }
          return ((0, pe.clean)(...l), s);
        }
        return (
          (0, Qe.bytes)(t),
          (0, Qe.bytes)(e, 16),
          {encrypt: (r, i) => n(r, !0, i), decrypt: (r, i) => n(r, !1, i)}
        );
      }
    )),
    (Ct.gcm = (0, pe.wrapCipher)(
      {blockSize: 16, nonceLength: 12, tagLength: 16},
      function (t, e, n) {
        if (
          ((0, Qe.bytes)(t),
          (0, Qe.bytes)(e),
          n !== void 0 && (0, Qe.bytes)(n),
          e.length < 8)
        )
          throw new Error('aes/gcm: invalid nonce length');
        const r = 16;
        function i(o, a, c) {
          const l = m5(zg.ghash, !1, o, c, n);
          for (let u = 0; u < a.length; u++) l[u] ^= a[u];
          return l;
        }
        function s() {
          const o = Rr(t),
            a = yd.slice(),
            c = yd.slice();
          if ((Da(o, !1, c, c, a), e.length === 12)) c.set(e);
          else {
            const l = yd.slice(),
              u = (0, pe.createView)(l);
            (0, pe.setBigUint64)(u, 8, BigInt(8 * e.length), !1);
            const d = zg.ghash.create(a).update(e).update(l);
            (d.digestInto(c), d.destroy());
          }
          return {xk: o, authKey: a, counter: c, tagMask: Da(o, !1, c, yd)};
        }
        return {
          encrypt(o) {
            (0, Qe.bytes)(o);
            const {xk: a, authKey: c, counter: l, tagMask: u} = s(),
              d = new Uint8Array(o.length + r),
              f = [a, c, l, u];
            ((0, pe.isAligned32)(o) || f.push((o = (0, pe.copyBytes)(o))),
              Da(a, !1, l, o, d));
            const h = i(c, u, d.subarray(0, d.length - r));
            return (f.push(h), d.set(h, o.length), (0, pe.clean)(...f), d);
          },
          decrypt(o) {
            if (((0, Qe.bytes)(o), o.length < r))
              throw new Error('aes/gcm: ciphertext less than tagLen (16)');
            const {xk: a, authKey: c, counter: l, tagMask: u} = s(),
              d = [a, c, u, l];
            (0, pe.isAligned32)(o) || d.push((o = (0, pe.copyBytes)(o)));
            const f = o.subarray(0, -16),
              h = o.subarray(-16),
              g = i(c, u, f);
            if ((d.push(g), !(0, pe.equalBytes)(g, h)))
              throw new Error('aes/gcm: invalid ghash tag');
            const m = Da(a, !1, l, f);
            return ((0, pe.clean)(...d), m);
          }
        };
      }
    )));
  const vd = (t, e, n) => (r) => {
    if (!Number.isSafeInteger(r) || e > r || r > n)
      throw new Error(`${t}: invalid value=${r}, must be [${e}..${n}]`);
  };
  function g5(t) {
    return (
      t != null &&
      typeof t == 'object' &&
      (t instanceof Uint32Array || t.constructor.name === 'Uint32Array')
    );
  }
  function y5(t, e) {
    if (((0, Qe.bytes)(e, 16), !g5(t)))
      throw new Error('_encryptBlock accepts result of expandKeyLE');
    const n = (0, pe.u32)(e);
    let {s0: r, s1: i, s2: s, s3: o} = An(t, n[0], n[1], n[2], n[3]);
    return ((n[0] = r), (n[1] = i), (n[2] = s), (n[3] = o), e);
  }
  function v5(t, e) {
    if (((0, Qe.bytes)(e, 16), !g5(t)))
      throw new Error('_decryptBlock accepts result of expandKeyLE');
    const n = (0, pe.u32)(e);
    let {s0: r, s1: i, s2: s, s3: o} = pu(t, n[0], n[1], n[2], n[3]);
    return ((n[0] = r), (n[1] = i), (n[2] = s), (n[3] = o), e);
  }
  Ct.siv = (0, pe.wrapCipher)(
    {blockSize: 16, nonceLength: 12, tagLength: 16},
    function (t, e, n) {
      const r = vd('AAD', 0, 68719476736),
        i = vd('plaintext', 0, 2 ** 36),
        s = vd('nonce', 12, 12),
        o = vd('ciphertext', 16, 2 ** 36 + 16);
      function a() {
        const u = Rr(t),
          d = new Uint8Array(t.length),
          f = new Uint8Array(16),
          h = [u, d];
        let g = e;
        (0, pe.isAligned32)(g) || h.push((g = (0, pe.copyBytes)(g)));
        const m = (0, pe.u32)(g);
        let y = 0,
          p = m[0],
          b = m[1],
          v = m[2],
          x = 0;
        for (const $ of [f, d].map(pe.u32)) {
          const G = (0, pe.u32)($);
          for (let L = 0; L < G.length; L += 2) {
            const {s0: F, s1: k} = An(u, y, p, b, v);
            ((G[L + 0] = F), (G[L + 1] = k), (y = ++x));
          }
        }
        const C = {authKey: f, encKey: Rr(d)};
        return ((0, pe.clean)(...h), C);
      }
      function c(u, d, f) {
        const h = m5(zg.polyval, !0, d, f, n);
        for (let v = 0; v < 12; v++) h[v] ^= e[v];
        h[15] &= 127;
        const g = (0, pe.u32)(h);
        let m = g[0],
          y = g[1],
          p = g[2],
          b = g[3];
        return (
          ({s0: m, s1: y, s2: p, s3: b} = An(u, m, y, p, b)),
          (g[0] = m),
          (g[1] = y),
          (g[2] = p),
          (g[3] = b),
          h
        );
      }
      function l(u, d, f) {
        let h = (0, pe.copyBytes)(d);
        h[15] |= 128;
        const g = Da(u, !0, h, f);
        return ((0, pe.clean)(h), g);
      }
      return (
        (0, Qe.bytes)(t, 16, 24, 32),
        (0, Qe.bytes)(e),
        s(e.length),
        n !== void 0 && ((0, Qe.bytes)(n), r(n.length)),
        {
          encrypt(u) {
            ((0, Qe.bytes)(u), i(u.length));
            const {encKey: d, authKey: f} = a(),
              h = c(d, f, u),
              g = [d, f, h];
            (0, pe.isAligned32)(u) || g.push((u = (0, pe.copyBytes)(u)));
            const m = new Uint8Array(u.length + 16);
            return (
              m.set(h, u.length),
              m.set(l(d, h, u)),
              (0, pe.clean)(...g),
              m
            );
          },
          decrypt(u) {
            ((0, Qe.bytes)(u), o(u.length));
            const d = u.subarray(-16),
              {encKey: f, authKey: h} = a(),
              g = [f, h];
            (0, pe.isAligned32)(u) || g.push((u = (0, pe.copyBytes)(u)));
            const m = l(f, d, u.subarray(0, -16)),
              y = c(f, h, m);
            if ((g.push(y), !(0, pe.equalBytes)(d, y)))
              throw ((0, pe.clean)(...g), new Error('invalid polyval tag'));
            return ((0, pe.clean)(...g), m);
          }
        }
      );
    }
  );
  const Rh = {
      encrypt(t, e) {
        if (e.length >= 2 ** 32)
          throw new Error('plaintext should be less than 4gb');
        const n = Rr(t);
        if (e.length === 16) y5(n, e);
        else {
          const r = (0, pe.u32)(e);
          let i = r[0],
            s = r[1];
          for (let o = 0, a = 1; o < 6; o++)
            for (let c = 2; c < r.length; c += 2, a++) {
              const {s0: l, s1: u, s2: d, s3: f} = An(n, i, s, r[c], r[c + 1]);
              ((i = l), (s = u ^ kh(a)), (r[c] = d), (r[c + 1] = f));
            }
          ((r[0] = i), (r[1] = s));
        }
        n.fill(0);
      },
      decrypt(t, e) {
        if (e.length - 8 >= 2 ** 32)
          throw new Error('ciphertext should be less than 4gb');
        const n = hu(t),
          r = e.length / 8 - 1;
        if (r === 1) v5(n, e);
        else {
          const i = (0, pe.u32)(e);
          let s = i[0],
            o = i[1];
          for (let a = 0, c = 6 * r; a < 6; a++)
            for (let l = 2 * r; l >= 1; l -= 2, c--) {
              o ^= kh(c);
              const {s0: u, s1: d, s2: f, s3: h} = pu(n, s, o, i[l], i[l + 1]);
              ((s = u), (o = d), (i[l] = f), (i[l + 1] = h));
            }
          ((i[0] = s), (i[1] = o));
        }
        n.fill(0);
      }
    },
    B_ = new Uint8Array(8).fill(166);
  Ct.aeskw = (0, pe.wrapCipher)({blockSize: 8}, (t) => ({
    encrypt(e) {
      if (((0, Qe.bytes)(e), !e.length || e.length % 8 != 0))
        throw new Error('invalid plaintext length');
      if (e.length === 8)
        throw new Error('8-byte keys not allowed in AESKW, use AESKWP instead');
      const n = (0, pe.concatBytes)(B_, e);
      return (Rh.encrypt(t, n), n);
    },
    decrypt(e) {
      if (((0, Qe.bytes)(e), e.length % 8 != 0 || e.length < 24))
        throw new Error('invalid ciphertext length');
      const n = (0, pe.copyBytes)(e);
      if ((Rh.decrypt(t, n), !(0, pe.equalBytes)(n.subarray(0, 8), B_)))
        throw new Error('integrity check failed');
      return (n.subarray(0, 8).fill(0), n.subarray(8));
    }
  }));
  const D_ = 2790873510;
  ((Ct.aeskwp = (0, pe.wrapCipher)({blockSize: 8}, (t) => ({
    encrypt(e) {
      if (((0, Qe.bytes)(e), !e.length))
        throw new Error('invalid plaintext length');
      const n = 8 * Math.ceil(e.length / 8),
        r = new Uint8Array(8 + n);
      r.set(e, 8);
      const i = (0, pe.u32)(r);
      return ((i[0] = D_), (i[1] = kh(e.length)), Rh.encrypt(t, r), r);
    },
    decrypt(e) {
      if (((0, Qe.bytes)(e), e.length < 16))
        throw new Error('invalid ciphertext length');
      const n = (0, pe.copyBytes)(e),
        r = (0, pe.u32)(n);
      Rh.decrypt(t, n);
      const i = kh(r[1]) >>> 0,
        s = 8 * Math.ceil(i / 8);
      if (r[0] !== D_ || n.length - 8 !== s)
        throw new Error('integrity check failed');
      for (let o = i; o < s; o++)
        if (n[8 + o] !== 0) throw new Error('integrity check failed');
      return (n.subarray(0, 8).fill(0), n.subarray(8, 8 + i));
    }
  }))),
    (Ct.unsafe = {
      expandKeyLE: Rr,
      expandKeyDecLE: hu,
      encrypt: An,
      decrypt: pu,
      encryptBlock: y5,
      decryptBlock: v5,
      ctrCounter: p5,
      ctr32: Da
    }),
    Object.defineProperty(Qa, '__esModule', {value: !0}),
    (Qa.aes256cbc = Qa.aes256gcm = void 0));
  var b5 = Ct;
  Qa.aes256gcm = function (t, e, n) {
    return (0, b5.gcm)(t, e, n);
  };
  Qa.aes256cbc = function (t, e, n) {
    return (0, b5.cbc)(t, e);
  };
  var Ph = {},
    w5 = {},
    Fa = {};
  (Object.defineProperty(Fa, '__esModule', {value: !0}),
    (Fa.sigma = void 0),
    (Fa.rotl = function (t, e) {
      return (t << e) | (t >>> (32 - e));
    }),
    (Fa.createCipher = function (t, e) {
      const {
        allowShortKeys: n,
        extendNonceFn: r,
        counterLength: i,
        counterRight: s,
        rounds: o
      } = (0, fr.checkOpts)(
        {allowShortKeys: !1, counterLength: 8, counterRight: !1, rounds: 20},
        e
      );
      if (typeof t != 'function') throw new Error('core must be a function');
      return (
        (0, Mi.number)(i),
        (0, Mi.number)(o),
        (0, Mi.bool)(s),
        (0, Mi.bool)(n),
        (a, c, l, u, d = 0) => {
          ((0, Mi.bytes)(a), (0, Mi.bytes)(c), (0, Mi.bytes)(l));
          const f = l.length;
          if (
            (u === void 0 && (u = new Uint8Array(f)),
            (0, Mi.bytes)(u),
            (0, Mi.number)(d),
            d < 0 || d >= F_)
          )
            throw new Error('arx: counter overflow');
          if (u.length < f)
            throw new Error(
              `arx: output (${u.length}) is shorter than data (${f})`
            );
          const h = [];
          let g,
            m,
            y = a.length;
          if (y === 32) (h.push((g = (0, fr.copyBytes)(a))), (m = E5));
          else {
            if (y !== 16 || !n)
              throw new Error(`arx: invalid 32-byte key, got length=${y}`);
            ((g = new Uint8Array(32)),
              g.set(a),
              g.set(a, 16),
              (m = wj),
              h.push(g));
          }
          r0(c) || h.push((c = (0, fr.copyBytes)(c)));
          const p = (0, fr.u32)(g);
          if (r) {
            if (c.length !== 24)
              throw new Error('arx: extended nonce must be 24 bytes');
            (r(m, p, (0, fr.u32)(c.subarray(0, 16)), p), (c = c.subarray(16)));
          }
          const b = 16 - i;
          if (b !== c.length)
            throw new Error(`arx: nonce must be ${b} or 16 bytes`);
          if (b !== 12) {
            const x = new Uint8Array(12);
            (x.set(c, s ? 0 : 12 - c.length), (c = x), h.push(c));
          }
          const v = (0, fr.u32)(c);
          return (
            (function (x, C, $, G, L, F, k, V) {
              const K = L.length,
                B = new Uint8Array(bd),
                D = (0, fr.u32)(B),
                E = r0(L) && r0(F),
                P = E ? (0, fr.u32)(L) : $_,
                U = E ? (0, fr.u32)(F) : $_;
              for (let w = 0; w < K; k++) {
                if ((x(C, $, G, D, k, V), k >= F_))
                  throw new Error('arx: counter overflow');
                const A = Math.min(bd, K - w);
                if (E && A === bd) {
                  const T = w / 4;
                  if (w % 4 != 0)
                    throw new Error('arx: invalid block position');
                  for (let R, _ = 0; _ < _j; _++)
                    ((R = T + _), (U[R] = P[R] ^ D[_]));
                  w += bd;
                } else {
                  for (let T, R = 0; R < A; R++)
                    ((T = w + R), (F[T] = L[T] ^ B[R]));
                  w += A;
                }
              }
            })(t, m, p, v, l, u, d, o),
            (0, fr.clean)(...h),
            u
          );
        }
      );
    }));
  const Mi = un,
    fr = sr,
    _5 = (t) => Uint8Array.from(t.split('').map((e) => e.charCodeAt(0))),
    vj = _5('expand 16-byte k'),
    bj = _5('expand 32-byte k'),
    wj = (0, fr.u32)(vj),
    E5 = (0, fr.u32)(bj);
  function r0(t) {
    return t.byteOffset % 4 == 0;
  }
  Fa.sigma = E5.slice();
  const bd = 64,
    _j = 16,
    F_ = 2 ** 32 - 1,
    $_ = new Uint32Array();
  var Al = {};
  (Object.defineProperty(Al, '__esModule', {value: !0}),
    (Al.poly1305 = void 0),
    (Al.wrapConstructorWithKey = A5));
  const wd = un,
    rl = sr,
    Wt = (t, e) => (255 & t[e++]) | ((255 & t[e++]) << 8);
  class Ej {
    constructor(e) {
      ((this.blockLen = 16),
        (this.outputLen = 16),
        (this.buffer = new Uint8Array(16)),
        (this.r = new Uint16Array(10)),
        (this.h = new Uint16Array(10)),
        (this.pad = new Uint16Array(8)),
        (this.pos = 0),
        (this.finished = !1),
        (e = (0, rl.toBytes)(e)),
        (0, wd.bytes)(e, 32));
      const n = Wt(e, 0),
        r = Wt(e, 2),
        i = Wt(e, 4),
        s = Wt(e, 6),
        o = Wt(e, 8),
        a = Wt(e, 10),
        c = Wt(e, 12),
        l = Wt(e, 14);
      ((this.r[0] = 8191 & n),
        (this.r[1] = 8191 & ((n >>> 13) | (r << 3))),
        (this.r[2] = 7939 & ((r >>> 10) | (i << 6))),
        (this.r[3] = 8191 & ((i >>> 7) | (s << 9))),
        (this.r[4] = 255 & ((s >>> 4) | (o << 12))),
        (this.r[5] = (o >>> 1) & 8190),
        (this.r[6] = 8191 & ((o >>> 14) | (a << 2))),
        (this.r[7] = 8065 & ((a >>> 11) | (c << 5))),
        (this.r[8] = 8191 & ((c >>> 8) | (l << 8))),
        (this.r[9] = (l >>> 5) & 127));
      for (let u = 0; u < 8; u++) this.pad[u] = Wt(e, 16 + 2 * u);
    }
    process(e, n, r = !1) {
      const i = r ? 0 : 2048,
        {h: s, r: o} = this,
        a = o[0],
        c = o[1],
        l = o[2],
        u = o[3],
        d = o[4],
        f = o[5],
        h = o[6],
        g = o[7],
        m = o[8],
        y = o[9],
        p = Wt(e, n + 0),
        b = Wt(e, n + 2),
        v = Wt(e, n + 4),
        x = Wt(e, n + 6),
        C = Wt(e, n + 8),
        $ = Wt(e, n + 10),
        G = Wt(e, n + 12),
        L = Wt(e, n + 14);
      let F = s[0] + (8191 & p),
        k = s[1] + (8191 & ((p >>> 13) | (b << 3))),
        V = s[2] + (8191 & ((b >>> 10) | (v << 6))),
        K = s[3] + (8191 & ((v >>> 7) | (x << 9))),
        B = s[4] + (8191 & ((x >>> 4) | (C << 12))),
        D = s[5] + ((C >>> 1) & 8191),
        E = s[6] + (8191 & ((C >>> 14) | ($ << 2))),
        P = s[7] + (8191 & (($ >>> 11) | (G << 5))),
        U = s[8] + (8191 & ((G >>> 8) | (L << 8))),
        w = s[9] + ((L >>> 5) | i),
        A = 0,
        T = A + F * a + k * (5 * y) + V * (5 * m) + K * (5 * g) + B * (5 * h);
      ((A = T >>> 13),
        (T &= 8191),
        (T +=
          D * (5 * f) + E * (5 * d) + P * (5 * u) + U * (5 * l) + w * (5 * c)),
        (A += T >>> 13),
        (T &= 8191));
      let R = A + F * c + k * a + V * (5 * y) + K * (5 * m) + B * (5 * g);
      ((A = R >>> 13),
        (R &= 8191),
        (R +=
          D * (5 * h) + E * (5 * f) + P * (5 * d) + U * (5 * u) + w * (5 * l)),
        (A += R >>> 13),
        (R &= 8191));
      let _ = A + F * l + k * c + V * a + K * (5 * y) + B * (5 * m);
      ((A = _ >>> 13),
        (_ &= 8191),
        (_ +=
          D * (5 * g) + E * (5 * h) + P * (5 * f) + U * (5 * d) + w * (5 * u)),
        (A += _ >>> 13),
        (_ &= 8191));
      let S = A + F * u + k * l + V * c + K * a + B * (5 * y);
      ((A = S >>> 13),
        (S &= 8191),
        (S +=
          D * (5 * m) + E * (5 * g) + P * (5 * h) + U * (5 * f) + w * (5 * d)),
        (A += S >>> 13),
        (S &= 8191));
      let I = A + F * d + k * u + V * l + K * c + B * a;
      ((A = I >>> 13),
        (I &= 8191),
        (I +=
          D * (5 * y) + E * (5 * m) + P * (5 * g) + U * (5 * h) + w * (5 * f)),
        (A += I >>> 13),
        (I &= 8191));
      let O = A + F * f + k * d + V * u + K * l + B * c;
      ((A = O >>> 13),
        (O &= 8191),
        (O += D * a + E * (5 * y) + P * (5 * m) + U * (5 * g) + w * (5 * h)),
        (A += O >>> 13),
        (O &= 8191));
      let H = A + F * h + k * f + V * d + K * u + B * l;
      ((A = H >>> 13),
        (H &= 8191),
        (H += D * c + E * a + P * (5 * y) + U * (5 * m) + w * (5 * g)),
        (A += H >>> 13),
        (H &= 8191));
      let M = A + F * g + k * h + V * f + K * d + B * u;
      ((A = M >>> 13),
        (M &= 8191),
        (M += D * l + E * c + P * a + U * (5 * y) + w * (5 * m)),
        (A += M >>> 13),
        (M &= 8191));
      let q = A + F * m + k * g + V * h + K * f + B * d;
      ((A = q >>> 13),
        (q &= 8191),
        (q += D * u + E * l + P * c + U * a + w * (5 * y)),
        (A += q >>> 13),
        (q &= 8191));
      let z = A + F * y + k * m + V * g + K * h + B * f;
      ((A = z >>> 13),
        (z &= 8191),
        (z += D * d + E * u + P * l + U * c + w * a),
        (A += z >>> 13),
        (z &= 8191),
        (A = ((A << 2) + A) | 0),
        (A = (A + T) | 0),
        (T = 8191 & A),
        (A >>>= 13),
        (R += A),
        (s[0] = T),
        (s[1] = R),
        (s[2] = _),
        (s[3] = S),
        (s[4] = I),
        (s[5] = O),
        (s[6] = H),
        (s[7] = M),
        (s[8] = q),
        (s[9] = z));
    }
    finalize() {
      const {h: e, pad: n} = this,
        r = new Uint16Array(10);
      let i = e[1] >>> 13;
      e[1] &= 8191;
      for (let a = 2; a < 10; a++)
        ((e[a] += i), (i = e[a] >>> 13), (e[a] &= 8191));
      ((e[0] += 5 * i),
        (i = e[0] >>> 13),
        (e[0] &= 8191),
        (e[1] += i),
        (i = e[1] >>> 13),
        (e[1] &= 8191),
        (e[2] += i),
        (r[0] = e[0] + 5),
        (i = r[0] >>> 13),
        (r[0] &= 8191));
      for (let a = 1; a < 10; a++)
        ((r[a] = e[a] + i), (i = r[a] >>> 13), (r[a] &= 8191));
      r[9] -= 8192;
      let s = (1 ^ i) - 1;
      for (let a = 0; a < 10; a++) r[a] &= s;
      s = ~s;
      for (let a = 0; a < 10; a++) e[a] = (e[a] & s) | r[a];
      ((e[0] = 65535 & (e[0] | (e[1] << 13))),
        (e[1] = 65535 & ((e[1] >>> 3) | (e[2] << 10))),
        (e[2] = 65535 & ((e[2] >>> 6) | (e[3] << 7))),
        (e[3] = 65535 & ((e[3] >>> 9) | (e[4] << 4))),
        (e[4] = 65535 & ((e[4] >>> 12) | (e[5] << 1) | (e[6] << 14))),
        (e[5] = 65535 & ((e[6] >>> 2) | (e[7] << 11))),
        (e[6] = 65535 & ((e[7] >>> 5) | (e[8] << 8))),
        (e[7] = 65535 & ((e[8] >>> 8) | (e[9] << 5))));
      let o = e[0] + n[0];
      e[0] = 65535 & o;
      for (let a = 1; a < 8; a++)
        ((o = (((e[a] + n[a]) | 0) + (o >>> 16)) | 0), (e[a] = 65535 & o));
      (0, rl.clean)(r);
    }
    update(e) {
      (0, wd.exists)(this);
      const {buffer: n, blockLen: r} = this,
        i = (e = (0, rl.toBytes)(e)).length;
      for (let s = 0; s < i; ) {
        const o = Math.min(r - this.pos, i - s);
        if (o !== r)
          (n.set(e.subarray(s, s + o), this.pos),
            (this.pos += o),
            (s += o),
            this.pos === r && (this.process(n, 0, !1), (this.pos = 0)));
        else for (; r <= i - s; s += r) this.process(e, s);
      }
      return this;
    }
    destroy() {
      (0, rl.clean)(this.h, this.r, this.buffer, this.pad);
    }
    digestInto(e) {
      ((0, wd.exists)(this), (0, wd.output)(e, this), (this.finished = !0));
      const {buffer: n, h: r} = this;
      let {pos: i} = this;
      if (i) {
        for (n[i++] = 1; i < 16; i++) n[i] = 0;
        this.process(n, 0, !0);
      }
      this.finalize();
      let s = 0;
      for (let o = 0; o < 8; o++)
        ((e[s++] = r[o] >>> 0), (e[s++] = r[o] >>> 8));
      return e;
    }
    digest() {
      const {buffer: e, outputLen: n} = this;
      this.digestInto(e);
      const r = e.slice(0, n);
      return (this.destroy(), r);
    }
  }
  function A5(t) {
    const e = (r, i) =>
        t(i)
          .update((0, rl.toBytes)(r))
          .digest(),
      n = t(new Uint8Array(32));
    return (
      (e.outputLen = n.outputLen),
      (e.blockLen = n.blockLen),
      (e.create = (r) => t(r)),
      e
    );
  }
  ((Al.poly1305 = A5((t) => new Ej(t))),
    (function (t) {
      (Object.defineProperty(t, '__esModule', {value: !0}),
        (t.xchacha20poly1305 =
          t.chacha20poly1305 =
          t._poly1305_aead =
          t.chacha12 =
          t.chacha8 =
          t.xchacha20 =
          t.chacha20 =
          t.chacha20orig =
            void 0),
        (t.hchacha = o));
      const e = Fa,
        n = un,
        r = Al,
        i = sr;
      function s(d, f, h, g, m, y = 20) {
        let p = d[0],
          b = d[1],
          v = d[2],
          x = d[3],
          C = f[0],
          $ = f[1],
          G = f[2],
          L = f[3],
          F = f[4],
          k = f[5],
          V = f[6],
          K = f[7],
          B = m,
          D = h[0],
          E = h[1],
          P = h[2],
          U = p,
          w = b,
          A = v,
          T = x,
          R = C,
          _ = $,
          S = G,
          I = L,
          O = F,
          H = k,
          M = V,
          q = K,
          z = B,
          Z = D,
          X = E,
          N = P;
        for (let W = 0; W < y; W += 2)
          ((U = (U + R) | 0),
            (z = (0, e.rotl)(z ^ U, 16)),
            (O = (O + z) | 0),
            (R = (0, e.rotl)(R ^ O, 12)),
            (U = (U + R) | 0),
            (z = (0, e.rotl)(z ^ U, 8)),
            (O = (O + z) | 0),
            (R = (0, e.rotl)(R ^ O, 7)),
            (w = (w + _) | 0),
            (Z = (0, e.rotl)(Z ^ w, 16)),
            (H = (H + Z) | 0),
            (_ = (0, e.rotl)(_ ^ H, 12)),
            (w = (w + _) | 0),
            (Z = (0, e.rotl)(Z ^ w, 8)),
            (H = (H + Z) | 0),
            (_ = (0, e.rotl)(_ ^ H, 7)),
            (A = (A + S) | 0),
            (X = (0, e.rotl)(X ^ A, 16)),
            (M = (M + X) | 0),
            (S = (0, e.rotl)(S ^ M, 12)),
            (A = (A + S) | 0),
            (X = (0, e.rotl)(X ^ A, 8)),
            (M = (M + X) | 0),
            (S = (0, e.rotl)(S ^ M, 7)),
            (T = (T + I) | 0),
            (N = (0, e.rotl)(N ^ T, 16)),
            (q = (q + N) | 0),
            (I = (0, e.rotl)(I ^ q, 12)),
            (T = (T + I) | 0),
            (N = (0, e.rotl)(N ^ T, 8)),
            (q = (q + N) | 0),
            (I = (0, e.rotl)(I ^ q, 7)),
            (U = (U + _) | 0),
            (N = (0, e.rotl)(N ^ U, 16)),
            (M = (M + N) | 0),
            (_ = (0, e.rotl)(_ ^ M, 12)),
            (U = (U + _) | 0),
            (N = (0, e.rotl)(N ^ U, 8)),
            (M = (M + N) | 0),
            (_ = (0, e.rotl)(_ ^ M, 7)),
            (w = (w + S) | 0),
            (z = (0, e.rotl)(z ^ w, 16)),
            (q = (q + z) | 0),
            (S = (0, e.rotl)(S ^ q, 12)),
            (w = (w + S) | 0),
            (z = (0, e.rotl)(z ^ w, 8)),
            (q = (q + z) | 0),
            (S = (0, e.rotl)(S ^ q, 7)),
            (A = (A + I) | 0),
            (Z = (0, e.rotl)(Z ^ A, 16)),
            (O = (O + Z) | 0),
            (I = (0, e.rotl)(I ^ O, 12)),
            (A = (A + I) | 0),
            (Z = (0, e.rotl)(Z ^ A, 8)),
            (O = (O + Z) | 0),
            (I = (0, e.rotl)(I ^ O, 7)),
            (T = (T + R) | 0),
            (X = (0, e.rotl)(X ^ T, 16)),
            (H = (H + X) | 0),
            (R = (0, e.rotl)(R ^ H, 12)),
            (T = (T + R) | 0),
            (X = (0, e.rotl)(X ^ T, 8)),
            (H = (H + X) | 0),
            (R = (0, e.rotl)(R ^ H, 7)));
        let j = 0;
        ((g[j++] = (p + U) | 0),
          (g[j++] = (b + w) | 0),
          (g[j++] = (v + A) | 0),
          (g[j++] = (x + T) | 0),
          (g[j++] = (C + R) | 0),
          (g[j++] = ($ + _) | 0),
          (g[j++] = (G + S) | 0),
          (g[j++] = (L + I) | 0),
          (g[j++] = (F + O) | 0),
          (g[j++] = (k + H) | 0),
          (g[j++] = (V + M) | 0),
          (g[j++] = (K + q) | 0),
          (g[j++] = (B + z) | 0),
          (g[j++] = (D + Z) | 0),
          (g[j++] = (E + X) | 0),
          (g[j++] = (P + N) | 0));
      }
      function o(d, f, h, g) {
        let m = d[0],
          y = d[1],
          p = d[2],
          b = d[3],
          v = f[0],
          x = f[1],
          C = f[2],
          $ = f[3],
          G = f[4],
          L = f[5],
          F = f[6],
          k = f[7],
          V = h[0],
          K = h[1],
          B = h[2],
          D = h[3];
        for (let P = 0; P < 20; P += 2)
          ((m = (m + v) | 0),
            (V = (0, e.rotl)(V ^ m, 16)),
            (G = (G + V) | 0),
            (v = (0, e.rotl)(v ^ G, 12)),
            (m = (m + v) | 0),
            (V = (0, e.rotl)(V ^ m, 8)),
            (G = (G + V) | 0),
            (v = (0, e.rotl)(v ^ G, 7)),
            (y = (y + x) | 0),
            (K = (0, e.rotl)(K ^ y, 16)),
            (L = (L + K) | 0),
            (x = (0, e.rotl)(x ^ L, 12)),
            (y = (y + x) | 0),
            (K = (0, e.rotl)(K ^ y, 8)),
            (L = (L + K) | 0),
            (x = (0, e.rotl)(x ^ L, 7)),
            (p = (p + C) | 0),
            (B = (0, e.rotl)(B ^ p, 16)),
            (F = (F + B) | 0),
            (C = (0, e.rotl)(C ^ F, 12)),
            (p = (p + C) | 0),
            (B = (0, e.rotl)(B ^ p, 8)),
            (F = (F + B) | 0),
            (C = (0, e.rotl)(C ^ F, 7)),
            (b = (b + $) | 0),
            (D = (0, e.rotl)(D ^ b, 16)),
            (k = (k + D) | 0),
            ($ = (0, e.rotl)($ ^ k, 12)),
            (b = (b + $) | 0),
            (D = (0, e.rotl)(D ^ b, 8)),
            (k = (k + D) | 0),
            ($ = (0, e.rotl)($ ^ k, 7)),
            (m = (m + x) | 0),
            (D = (0, e.rotl)(D ^ m, 16)),
            (F = (F + D) | 0),
            (x = (0, e.rotl)(x ^ F, 12)),
            (m = (m + x) | 0),
            (D = (0, e.rotl)(D ^ m, 8)),
            (F = (F + D) | 0),
            (x = (0, e.rotl)(x ^ F, 7)),
            (y = (y + C) | 0),
            (V = (0, e.rotl)(V ^ y, 16)),
            (k = (k + V) | 0),
            (C = (0, e.rotl)(C ^ k, 12)),
            (y = (y + C) | 0),
            (V = (0, e.rotl)(V ^ y, 8)),
            (k = (k + V) | 0),
            (C = (0, e.rotl)(C ^ k, 7)),
            (p = (p + $) | 0),
            (K = (0, e.rotl)(K ^ p, 16)),
            (G = (G + K) | 0),
            ($ = (0, e.rotl)($ ^ G, 12)),
            (p = (p + $) | 0),
            (K = (0, e.rotl)(K ^ p, 8)),
            (G = (G + K) | 0),
            ($ = (0, e.rotl)($ ^ G, 7)),
            (b = (b + v) | 0),
            (B = (0, e.rotl)(B ^ b, 16)),
            (L = (L + B) | 0),
            (v = (0, e.rotl)(v ^ L, 12)),
            (b = (b + v) | 0),
            (B = (0, e.rotl)(B ^ b, 8)),
            (L = (L + B) | 0),
            (v = (0, e.rotl)(v ^ L, 7)));
        let E = 0;
        ((g[E++] = m),
          (g[E++] = y),
          (g[E++] = p),
          (g[E++] = b),
          (g[E++] = V),
          (g[E++] = K),
          (g[E++] = B),
          (g[E++] = D));
      }
      ((t.chacha20orig = (0, e.createCipher)(s, {
        counterRight: !1,
        counterLength: 8,
        allowShortKeys: !0
      })),
        (t.chacha20 = (0, e.createCipher)(s, {
          counterRight: !1,
          counterLength: 4,
          allowShortKeys: !1
        })),
        (t.xchacha20 = (0, e.createCipher)(s, {
          counterRight: !1,
          counterLength: 8,
          extendNonceFn: o,
          allowShortKeys: !1
        })),
        (t.chacha8 = (0, e.createCipher)(s, {
          counterRight: !1,
          counterLength: 4,
          rounds: 8
        })),
        (t.chacha12 = (0, e.createCipher)(s, {
          counterRight: !1,
          counterLength: 4,
          rounds: 12
        })));
      const a = new Uint8Array(16),
        c = (d, f) => {
          d.update(f);
          const h = f.length % 16;
          h && d.update(a.subarray(h));
        },
        l = new Uint8Array(32);
      function u(d, f, h, g, m) {
        const y = d(f, h, l),
          p = r.poly1305.create(y);
        (m && c(p, m), c(p, g));
        const b = new Uint8Array(16),
          v = (0, i.createView)(b);
        ((0, i.setBigUint64)(v, 0, BigInt(m ? m.length : 0), !0),
          (0, i.setBigUint64)(v, 8, BigInt(g.length), !0),
          p.update(b));
        const x = p.digest();
        return ((0, i.clean)(y, b), x);
      }
      ((t._poly1305_aead = (d) => (f, h, g) => (
        (0, n.bytes)(f, 32),
        (0, n.bytes)(h),
        {
          encrypt(y, p) {
            const b = y.length,
              v = b + 16;
            (p ? (0, n.bytes)(p, v) : (p = new Uint8Array(v)),
              d(f, h, y, p, 1));
            const x = u(d, f, h, p.subarray(0, -16), g);
            return (p.set(x, b), (0, i.clean)(x), p);
          },
          decrypt(y, p) {
            const b = y.length,
              v = b - 16;
            if (b < 16)
              throw new Error('encrypted data must be at least 16 bytes');
            p ? (0, n.bytes)(p, v) : (p = new Uint8Array(v));
            const x = y.subarray(0, -16),
              C = y.subarray(-16),
              $ = u(d, f, h, x, g);
            if (!(0, i.equalBytes)(C, $)) throw new Error('invalid tag');
            return (d(f, h, x, p, 1), (0, i.clean)($), p);
          }
        }
      )),
        (t.chacha20poly1305 = (0, i.wrapCipher)(
          {blockSize: 64, nonceLength: 12, tagLength: 16},
          (0, t._poly1305_aead)(t.chacha20)
        )),
        (t.xchacha20poly1305 = (0, i.wrapCipher)(
          {blockSize: 64, nonceLength: 24, tagLength: 16},
          (0, t._poly1305_aead)(t.xchacha20)
        )));
    })(w5),
    Object.defineProperty(Ph, '__esModule', {value: !0}),
    (Ph.xchacha20 = void 0));
  var va,
    H_,
    Zc,
    Aj = w5;
  ((Ph.xchacha20 = function (t, e, n) {
    return (0, Aj.xchacha20poly1305)(t, e, n);
  }),
    (function (t) {
      (Object.defineProperty(t, '__esModule', {value: !0}),
        (t.aesDecrypt = t.aesEncrypt = t.symDecrypt = t.symEncrypt = void 0));
      var e = sr,
        n = Wv,
        r = Qa,
        i = Ph,
        s = du,
        o = Ut;
      t.symEncrypt = function (u, d, f) {
        return a(c, u, d, f);
      };
      function a(u, d, f, h) {
        var g = (0, s.symmetricAlgorithm)();
        if (g === 'aes-256-gcm')
          return u(
            r.aes256gcm,
            d,
            f,
            (0, s.symmetricNonceLength)(),
            o.AEAD_TAG_LENGTH,
            h
          );
        if (g === 'xchacha20')
          return u(
            i.xchacha20,
            d,
            f,
            o.XCHACHA20_NONCE_LENGTH,
            o.AEAD_TAG_LENGTH,
            h
          );
        if (g === 'aes-256-cbc') return u(r.aes256cbc, d, f, 16, 0);
        throw new Error('Not implemented');
      }
      function c(u, d, f, h, g, m) {
        var y = (0, n.randomBytes)(h),
          p = u(d, y, m).encrypt(f);
        if (g === 0) return (0, e.concatBytes)(y, p);
        var b = p.length - g,
          v = p.subarray(0, b),
          x = p.subarray(b);
        return (0, e.concatBytes)(y, x, v);
      }
      function l(u, d, f, h, g, m) {
        var y = f.subarray(0, h),
          p = u(d, Uint8Array.from(y), m),
          b = f.subarray(h);
        if (g === 0) return p.decrypt(b);
        var v = b.subarray(0, g),
          x = b.subarray(g);
        return p.decrypt((0, e.concatBytes)(x, v));
      }
      ((t.symDecrypt = function (u, d, f) {
        return a(l, u, d, f);
      }),
        (t.aesEncrypt = t.symEncrypt),
        (t.aesDecrypt = t.symDecrypt));
    })(R_),
    (va = Kp),
    (H_ =
      (_r && _r.__createBinding) ||
      (Object.create
        ? function (t, e, n, r) {
            r === void 0 && (r = n);
            var i = Object.getOwnPropertyDescriptor(e, n);
            ((i &&
              !('get' in i ? !e.__esModule : i.writable || i.configurable)) ||
              (i = {
                enumerable: !0,
                get: function () {
                  return e[n];
                }
              }),
              Object.defineProperty(t, r, i));
          }
        : function (t, e, n, r) {
            (r === void 0 && (r = n), (t[r] = e[n]));
          })),
    (Zc =
      (_r && _r.__exportStar) ||
      function (t, e) {
        for (var n in t)
          n === 'default' ||
            Object.prototype.hasOwnProperty.call(e, n) ||
            H_(e, t, n);
      }),
    Object.defineProperty(va, '__esModule', {value: !0}),
    Zc(xC, va),
    Zc(o5, va),
    Zc(Vg, va),
    Zc(R_, va));
  var mu = {};
  (Object.defineProperty(mu, '__esModule', {value: !0}),
    (mu.PublicKey = void 0));
  var j_ = sr,
    _d = Kp,
    Sj = (function () {
      function t(e) {
        this.data = (0, _d.convertPublicKeyFormat)(e, !0);
      }
      return (
        (t.fromHex = function (e) {
          return new t((0, _d.hexToPublicKey)(e));
        }),
        Object.defineProperty(t.prototype, 'uncompressed', {
          get: function () {
            return de.from((0, _d.convertPublicKeyFormat)(this.data, !1));
          },
          enumerable: !1,
          configurable: !0
        }),
        Object.defineProperty(t.prototype, 'compressed', {
          get: function () {
            return de.from(this.data);
          },
          enumerable: !1,
          configurable: !0
        }),
        (t.prototype.toHex = function (e) {
          return (
            e === void 0 && (e = !0),
            (0, j_.bytesToHex)(e ? this.data : this.uncompressed)
          );
        }),
        (t.prototype.decapsulate = function (e, n) {
          n === void 0 && (n = !1);
          var r = n ? this.data : this.uncompressed,
            i = e.multiply(this, n);
          return (0, _d.getSharedKey)(r, i);
        }),
        (t.prototype.equals = function (e) {
          return (0, j_.equalBytes)(this.data, e.data);
        }),
        t
      );
    })();
  ((mu.PublicKey = Sj),
    Object.defineProperty(xh, '__esModule', {value: !0}),
    (xh.PrivateKey = void 0));
  var U_ = sr,
    ba = Kp,
    xj = mu,
    Cj = (function () {
      function t(e) {
        if (e === void 0) this.data = (0, ba.getValidSecret)();
        else {
          if (!(0, ba.isValidPrivateKey)(e))
            throw new Error('Invalid private key');
          this.data = e;
        }
        this.publicKey = new xj.PublicKey((0, ba.getPublicKey)(this.data));
      }
      return (
        (t.fromHex = function (e) {
          return new t((0, ba.decodeHex)(e));
        }),
        Object.defineProperty(t.prototype, 'secret', {
          get: function () {
            return de.from(this.data);
          },
          enumerable: !1,
          configurable: !0
        }),
        (t.prototype.toHex = function () {
          return (0, U_.bytesToHex)(this.data);
        }),
        (t.prototype.encapsulate = function (e, n) {
          n === void 0 && (n = !1);
          var r = n ? this.publicKey.compressed : this.publicKey.uncompressed,
            i = this.multiply(e, n);
          return (0, ba.getSharedKey)(r, i);
        }),
        (t.prototype.multiply = function (e, n) {
          return (
            n === void 0 && (n = !1),
            (0, ba.getSharedPoint)(this.data, e.compressed, n)
          );
        }),
        (t.prototype.equals = function (e) {
          return (0, U_.equalBytes)(this.data, e.data);
        }),
        t
      );
    })();
  ((xh.PrivateKey = Cj),
    (function (t) {
      (Object.defineProperty(t, '__esModule', {value: !0}),
        (t.PublicKey = t.PrivateKey = void 0));
      var e = xh;
      Object.defineProperty(t, 'PrivateKey', {
        enumerable: !0,
        get: function () {
          return e.PrivateKey;
        }
      });
      var n = mu;
      Object.defineProperty(t, 'PublicKey', {
        enumerable: !0,
        get: function () {
          return n.PublicKey;
        }
      });
    })(Um),
    (function (t) {
      (Object.defineProperty(t, '__esModule', {value: !0}),
        (t.utils = t.PublicKey = t.PrivateKey = t.ECIES_CONFIG = void 0),
        (t.encrypt = function (a, c) {
          var l = new r.PrivateKey(),
            u =
              a instanceof Uint8Array
                ? new r.PublicKey(a)
                : r.PublicKey.fromHex(a),
            d = l.encapsulate(u, (0, n.isHkdfKeyCompressed)()),
            f = (0, n.isEphemeralKeyCompressed)()
              ? l.publicKey.compressed
              : l.publicKey.uncompressed,
            h = (0, i.symEncrypt)(d, c);
          return de.from((0, e.concatBytes)(f, h));
        }),
        (t.decrypt = function (a, c) {
          var l =
              a instanceof Uint8Array
                ? new r.PrivateKey(a)
                : r.PrivateKey.fromHex(a),
            u = (0, n.ephemeralKeySize)(),
            d = new r.PublicKey(c.subarray(0, u)),
            f = c.subarray(u),
            h = d.decapsulate(l, (0, n.isHkdfKeyCompressed)());
          return de.from((0, i.symDecrypt)(h, f));
        }));
      var e = sr,
        n = du,
        r = Um,
        i = Kp,
        s = du;
      Object.defineProperty(t, 'ECIES_CONFIG', {
        enumerable: !0,
        get: function () {
          return s.ECIES_CONFIG;
        }
      });
      var o = Um;
      (Object.defineProperty(t, 'PrivateKey', {
        enumerable: !0,
        get: function () {
          return o.PrivateKey;
        }
      }),
        Object.defineProperty(t, 'PublicKey', {
          enumerable: !0,
          get: function () {
            return o.PublicKey;
          }
        }),
        (t.utils = {
          aesEncrypt: i.aesEncrypt,
          aesDecrypt: i.aesDecrypt,
          symEncrypt: i.symEncrypt,
          symDecrypt: i.symDecrypt,
          decodeHex: i.decodeHex,
          getValidSecret: i.getValidSecret,
          remove0x: i.remove0x
        }));
    })(Ta));
  const S5 = Cn('KeyExchange:Layer'),
    x5 = Cn('SocketService:Layer'),
    C5 = Cn('Ecies:Layer'),
    T5 = Cn('RemoteCommunication:Layer');
  ((S5.color = '##95c44e'),
    (x5.color = '#f638d7'),
    (C5.color = '#465b9c'),
    (T5.color = '#47a2be'));
  const te = {
    KeyExchange: S5,
    SocketService: x5,
    Ecies: C5,
    RemoteCommunication: T5
  };
  let Yc,
    Ed = [],
    i0 = [];
  const ss = (t, e) =>
    ue(void 0, void 0, void 0, function* () {
      ((Yc = e),
        i0.push(t),
        (function (n) {
          return ue(this, void 0, void 0, function* () {
            if (!Yc || !n) return;
            (function () {
              const o = i0;
              ((i0 = Ed), (Ed = o));
            })();
            const r = Yc.endsWith('/') ? `${Yc}evt` : `${Yc}/evt`,
              i = Object.assign({}, n);
            if ((delete i.params, n.params))
              for (const [o, a] of Object.entries(n.params)) i[o] = a;
            const s = JSON.stringify(i);
            te.RemoteCommunication(
              `[sendBufferedEvents] Sending ${Ed.length} analytics events to ${r}`
            );
            try {
              const o = yield av(r, {
                  method: 'POST',
                  headers: {
                    Accept: 'application/json',
                    'Content-Type': 'application/json'
                  },
                  body: s
                }),
                a = yield o.text();
              (te.RemoteCommunication(`[sendBufferedEvents] Response: ${a}`),
                (Ed.length = 0));
            } catch {}
          });
        })(t).catch(() => {}));
    });
  class s0 {
    constructor(e) {
      ((this.enabled = !0),
        e != null && e.debug && Cn.enable('Ecies:Layer'),
        (this.ecies =
          e != null && e.privateKey
            ? Ta.PrivateKey.fromHex(e.privateKey)
            : new Ta.PrivateKey()),
        te.Ecies(
          '[ECIES constructor()] initialized secret: ',
          this.ecies.toHex()
        ),
        te.Ecies(
          '[ECIES constructor()] initialized public: ',
          this.ecies.publicKey.toHex()
        ),
        te.Ecies('[ECIES constructor()] init with', this));
    }
    generateECIES() {
      this.ecies = new Ta.PrivateKey();
    }
    getPublicKey() {
      return this.ecies.publicKey.toHex();
    }
    encrypt(e, n) {
      let r = e;
      if (this.enabled)
        try {
          te.Ecies('[ECIES: encrypt()] using otherPublicKey', n);
          const i = de.from(e),
            s = Ta.encrypt(n, i);
          r = de.from(s).toString('base64');
        } catch (i) {
          throw (
            te.Ecies('[ECIES: encrypt()] error encrypt:', i),
            te.Ecies('[ECIES: encrypt()] private: ', this.ecies.toHex()),
            te.Ecies('[ECIES: encrypt()] data: ', e),
            te.Ecies('[ECIES: encrypt()] otherkey: ', n),
            i
          );
        }
      return r;
    }
    decrypt(e) {
      let n = e;
      if (this.enabled)
        try {
          te.Ecies('[ECIES: decrypt()] using privateKey', this.ecies.toHex());
          const r = de.from(e.toString(), 'base64');
          n = Ta.decrypt(this.ecies.toHex(), r).toString();
        } catch (r) {
          throw (
            te.Ecies('[ECIES: decrypt()] error decrypt', r),
            te.Ecies('[ECIES: decrypt()] private: ', this.ecies.toHex()),
            te.Ecies('[ECIES: decrypt()] encryptedData: ', e),
            r
          );
        }
      return n;
    }
    getKeyInfo() {
      return {
        private: this.ecies.toHex(),
        public: this.ecies.publicKey.toHex()
      };
    }
    toString() {
      te.Ecies('[ECIES: toString()]', this.getKeyInfo());
    }
  }
  var io = {version: '0.33.0'};
  const Sc = 'https://metamask-sdk.api.cx.metamask.io/',
    Tj = ['websocket'],
    xc = 6048e5,
    Ij = 3e3,
    on = {
      METAMASK_CONNECTSIGN: 'metamask_connectSign',
      METAMASK_CONNECTWITH: 'metamask_connectWith',
      METAMASK_OPEN: 'metamask_open',
      METAMASK_BATCH: 'metamask_batch',
      PERSONAL_SIGN: 'personal_sign',
      WALLET_REQUESTPERMISSIONS: 'wallet_requestPermissions',
      WALLET_REVOKEPERMISSIONS: 'wallet_revokePermissions',
      WALLET_WATCHASSET: 'wallet_watchAsset',
      ETH_REQUESTACCOUNTS: 'eth_requestAccounts',
      ETH_SENDTRANSACTION: 'eth_sendTransaction',
      ETH_SIGNTYPEDDATA: 'eth_signTypedData',
      ETH_SIGNTYPEDDATA_V3: 'eth_signTypedData_v3',
      ETH_SIGNTYPEDDATA_V4: 'eth_signTypedData_v4',
      ETH_SIGNTRANSACTION: 'eth_signTransaction',
      ETH_SIGN: 'eth_sign',
      PERSONAL_EC_RECOVER: 'personal_ecRecover'
    },
    kj = [
      on.METAMASK_CONNECTSIGN,
      on.METAMASK_CONNECTWITH,
      on.METAMASK_OPEN,
      on.METAMASK_BATCH,
      on.PERSONAL_SIGN,
      on.WALLET_REQUESTPERMISSIONS,
      on.WALLET_REVOKEPERMISSIONS,
      on.WALLET_WATCHASSET,
      on.ETH_SENDTRANSACTION,
      on.ETH_SIGNTYPEDDATA,
      on.ETH_SIGNTYPEDDATA_V3,
      on.ETH_SIGNTYPEDDATA_V4,
      on.ETH_SIGNTRANSACTION,
      on.ETH_SIGN,
      on.PERSONAL_EC_RECOVER
    ];
  function Uu(t) {
    return kj.includes(t);
  }
  function I5(t) {
    const {context: e} = t;
    (te.RemoteCommunication(`[RemoteCommunication: clean()] context=${e}`),
      (t.channelConfig = void 0),
      (t.ready = !1),
      (t.originatorConnectStarted = !1));
  }
  var Xt, me, Mh, at, St, Mt, wa;
  (((wa = Xt || (Xt = {})).DISCONNECTED = 'disconnected'),
    (wa.WAITING = 'waiting'),
    (wa.TIMEOUT = 'timeout'),
    (wa.LINKED = 'linked'),
    (wa.PAUSED = 'paused'),
    (wa.TERMINATED = 'terminated'),
    (function (t) {
      ((t.KEY_INFO = 'key_info'),
        (t.SERVICE_STATUS = 'service_status'),
        (t.PROVIDER_UPDATE = 'provider_update'),
        (t.RPC_UPDATE = 'rpc_update'),
        (t.KEYS_EXCHANGED = 'keys_exchanged'),
        (t.JOIN_CHANNEL = 'join_channel'),
        (t.PUBLIC_KEY = 'public_key'),
        (t.CHANNEL_CREATED = 'channel_created'),
        (t.CLIENTS_CONNECTED = 'clients_connected'),
        (t.CLIENTS_DISCONNECTED = 'clients_disconnected'),
        (t.CLIENTS_WAITING = 'clients_waiting'),
        (t.CLIENTS_READY = 'clients_ready'),
        (t.REJECTED = 'rejected'),
        (t.WALLET_INIT = 'wallet_init'),
        (t.CHANNEL_PERSISTENCE = 'channel_persistence'),
        (t.CONFIG = 'config'),
        (t.MESSAGE_ACK = 'ack'),
        (t.SOCKET_DISCONNECTED = 'socket_disconnected'),
        (t.SOCKET_RECONNECT = 'socket_reconnect'),
        (t.OTP = 'otp'),
        (t.SDK_RPC_CALL = 'sdk_rpc_call'),
        (t.AUTHORIZED = 'authorized'),
        (t.CONNECTION_STATUS = 'connection_status'),
        (t.MESSAGE = 'message'),
        (t.TERMINATE = 'terminate'));
    })(me || (me = {})),
    ((Mh || (Mh = {})).KEY_EXCHANGE = 'key_exchange'),
    (function (t) {
      ((t.KEY_HANDSHAKE_START = 'key_handshake_start'),
        (t.KEY_HANDSHAKE_CHECK = 'key_handshake_check'),
        (t.KEY_HANDSHAKE_SYN = 'key_handshake_SYN'),
        (t.KEY_HANDSHAKE_SYNACK = 'key_handshake_SYNACK'),
        (t.KEY_HANDSHAKE_ACK = 'key_handshake_ACK'),
        (t.KEY_HANDSHAKE_WALLET = 'key_handshake_wallet'),
        (t.KEY_HANDSHAKE_NONE = 'none'));
    })(at || (at = {})));
  class Rj extends Fp.EventEmitter2 {
    constructor({
      communicationLayer: e,
      otherPublicKey: n,
      context: r,
      ecies: i,
      logging: s
    }) {
      (super(),
        (this.keysExchanged = !1),
        (this.step = at.KEY_HANDSHAKE_NONE),
        (this.debug = !1),
        (this.context = r),
        (this.communicationLayer = e),
        i != null &&
          i.privateKey &&
          n &&
          (te.KeyExchange(
            `[KeyExchange: constructor()] otherPubKey=${n} set keysExchanged to true!`,
            i
          ),
          (this.keysExchanged = !0)),
        (this.myECIES = new s0(
          Object.assign(Object.assign({}, i), {
            debug: s == null ? void 0 : s.eciesLayer
          })
        )),
        (this.communicationLayer.state.eciesInstance = this.myECIES),
        (this.myPublicKey = this.myECIES.getPublicKey()),
        (this.debug = (s == null ? void 0 : s.keyExchangeLayer) === !0),
        n && this.setOtherPublicKey(n),
        this.communicationLayer.on(
          Mh.KEY_EXCHANGE,
          this.onKeyExchangeMessage.bind(this)
        ));
    }
    onKeyExchangeMessage(e) {
      const {relayPersistence: n} = this.communicationLayer.remote.state;
      if (
        (te.KeyExchange(
          `[KeyExchange: onKeyExchangeMessage()] context=${this.context} keysExchanged=${this.keysExchanged} relayPersistence=${n}`,
          e
        ),
        n)
      )
        return void te.KeyExchange(
          '[KeyExchange: onKeyExchangeMessage()] Ignoring key exchange message because relay persistence is activated'
        );
      const {message: r} = e;
      (this.keysExchanged &&
        te.KeyExchange(
          `[KeyExchange: onKeyExchangeMessage()] context=${this.context} received handshake while already exchanged. step=${this.step} otherPubKey=${this.otherPublicKey}`
        ),
        this.emit(me.KEY_INFO, r.type),
        r.type === at.KEY_HANDSHAKE_SYN
          ? (this.checkStep([at.KEY_HANDSHAKE_NONE, at.KEY_HANDSHAKE_ACK]),
            te.KeyExchange(
              '[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_SYN',
              r
            ),
            r.pubkey && this.setOtherPublicKey(r.pubkey),
            this.communicationLayer
              .sendMessage({
                type: at.KEY_HANDSHAKE_SYNACK,
                pubkey: this.myPublicKey
              })
              .catch((i) => {
                te.KeyExchange(
                  '[KeyExchange: onKeyExchangeMessage()] Error sending KEY_HANDSHAKE_SYNACK',
                  i
                );
              }),
            this.setStep(at.KEY_HANDSHAKE_ACK))
          : r.type === at.KEY_HANDSHAKE_SYNACK
            ? (this.checkStep([
                at.KEY_HANDSHAKE_SYNACK,
                at.KEY_HANDSHAKE_ACK,
                at.KEY_HANDSHAKE_NONE
              ]),
              te.KeyExchange(
                '[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_SYNACK'
              ),
              r.pubkey && this.setOtherPublicKey(r.pubkey),
              this.communicationLayer
                .sendMessage({type: at.KEY_HANDSHAKE_ACK})
                .catch((i) => {
                  te.KeyExchange(
                    '[KeyExchange: onKeyExchangeMessage()] Error sending KEY_HANDSHAKE_ACK',
                    i
                  );
                }),
              (this.keysExchanged = !0),
              this.setStep(at.KEY_HANDSHAKE_ACK),
              this.emit(me.KEYS_EXCHANGED))
            : r.type === at.KEY_HANDSHAKE_ACK &&
              (te.KeyExchange(
                '[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_ACK set keysExchanged to true!'
              ),
              this.checkStep([at.KEY_HANDSHAKE_ACK, at.KEY_HANDSHAKE_NONE]),
              (this.keysExchanged = !0),
              this.setStep(at.KEY_HANDSHAKE_ACK),
              this.emit(me.KEYS_EXCHANGED)));
    }
    resetKeys(e) {
      (this.clean(), (this.myECIES = new s0(e)));
    }
    clean() {
      (te.KeyExchange(
        `[KeyExchange: clean()] context=${this.context} reset handshake state`
      ),
        this.setStep(at.KEY_HANDSHAKE_NONE),
        this.emit(me.KEY_INFO, this.step),
        (this.keysExchanged = !1));
    }
    start({isOriginator: e, force: n}) {
      const {relayPersistence: r, protocolVersion: i} =
          this.communicationLayer.remote.state,
        s = i >= 2;
      r
        ? te.KeyExchange(
            '[KeyExchange: start()] Ignoring key exchange message because relay persistence is activated'
          )
        : (te.KeyExchange(
            `[KeyExchange: start()] context=${this.context} protocolVersion=${i} isOriginator=${e} step=${this.step} force=${n} relayPersistence=${r} keysExchanged=${this.keysExchanged}`
          ),
          e
            ? !(
                this.keysExchanged ||
                (this.step !== at.KEY_HANDSHAKE_NONE &&
                  this.step !== at.KEY_HANDSHAKE_SYNACK)
              ) || n
              ? (te.KeyExchange(
                  `[KeyExchange: start()] context=${this.context} -- start key exchange (force=${n}) -- step=${this.step}`,
                  this.step
                ),
                this.clean(),
                this.setStep(at.KEY_HANDSHAKE_SYNACK),
                this.communicationLayer
                  .sendMessage({
                    type: at.KEY_HANDSHAKE_SYN,
                    pubkey: this.myPublicKey,
                    v: 2
                  })
                  .catch((o) => {
                    te.KeyExchange(
                      '[KeyExchange: start()] Error sending KEY_HANDSHAKE_SYN',
                      o
                    );
                  }))
              : te.KeyExchange(
                  `[KeyExchange: start()] context=${this.context} -- key exchange already ${this.keysExchanged ? 'done' : 'in progress'} -- aborted.`,
                  this.step
                )
            : this.keysExchanged && n !== !0
              ? te.KeyExchange(
                  "[KeyExchange: start()] don't send KEY_HANDSHAKE_START -- exchange already done."
                )
              : s
                ? this.communicationLayer
                    .sendMessage({
                      type: at.KEY_HANDSHAKE_SYNACK,
                      pubkey: this.myPublicKey,
                      v: 2
                    })
                    .catch((o) => {
                      te.KeyExchange(
                        '[KeyExchange: start()] Error sending KEY_HANDSHAKE_SYNACK',
                        o
                      );
                    })
                : (this.communicationLayer
                    .sendMessage({type: at.KEY_HANDSHAKE_START})
                    .catch((o) => {
                      te.KeyExchange(
                        '[KeyExchange: start()] Error sending KEY_HANDSHAKE_START',
                        o
                      );
                    }),
                  this.clean()));
    }
    setStep(e) {
      ((this.step = e), this.emit(me.KEY_INFO, e));
    }
    checkStep(e) {
      e.length > 0 && e.indexOf(this.step.toString());
    }
    setRelayPersistence({localKey: e, otherKey: n}) {
      ((this.otherPublicKey = n),
        (this.myECIES = new s0({privateKey: e, debug: this.debug})),
        (this.keysExchanged = !0));
    }
    setKeysExchanged(e) {
      this.keysExchanged = e;
    }
    areKeysExchanged() {
      return this.keysExchanged;
    }
    getMyPublicKey() {
      return this.myPublicKey;
    }
    getOtherPublicKey() {
      return this.otherPublicKey;
    }
    setOtherPublicKey(e) {
      (te.KeyExchange('[KeyExchange: setOtherPubKey()]', e),
        (this.otherPublicKey = e));
    }
    encryptMessage(e) {
      if (!this.otherPublicKey)
        throw new Error(
          'encryptMessage: Keys not exchanged - missing otherPubKey'
        );
      return this.myECIES.encrypt(e, this.otherPublicKey);
    }
    decryptMessage(e) {
      if (!this.otherPublicKey)
        throw new Error(
          'decryptMessage: Keys not exchanged - missing otherPubKey'
        );
      return this.myECIES.decrypt(e);
    }
    getKeyInfo() {
      return {
        ecies: Object.assign(Object.assign({}, this.myECIES.getKeyInfo()), {
          otherPubKey: this.otherPublicKey
        }),
        step: this.step,
        keysExchanged: this.areKeysExchanged()
      };
    }
    toString() {
      const e = {
        keyInfo: this.getKeyInfo(),
        keysExchanged: this.keysExchanged,
        step: this.step
      };
      return JSON.stringify(e);
    }
  }
  ((function (t) {
    ((t.TERMINATE = 'terminate'),
      (t.ANSWER = 'answer'),
      (t.OFFER = 'offer'),
      (t.CANDIDATE = 'candidate'),
      (t.JSONRPC = 'jsonrpc'),
      (t.WALLET_INFO = 'wallet_info'),
      (t.WALLET_INIT = 'wallet_init'),
      (t.ORIGINATOR_INFO = 'originator_info'),
      (t.PAUSE = 'pause'),
      (t.OTP = 'otp'),
      (t.AUTHORIZED = 'authorized'),
      (t.PING = 'ping'),
      (t.READY = 'ready'));
  })(St || (St = {})),
    (function (t) {
      ((t.REQUEST = 'sdk_connect_request_started'),
        (t.REQUEST_MOBILE = 'sdk_connect_request_started_mobile'),
        (t.RECONNECT = 'sdk_reconnect_request_started'),
        (t.CONNECTED = 'sdk_connection_established'),
        (t.CONNECTED_MOBILE = 'sdk_connection_established_mobile'),
        (t.AUTHORIZED = 'sdk_connection_authorized'),
        (t.REJECTED = 'sdk_connection_rejected'),
        (t.TERMINATED = 'sdk_connection_terminated'),
        (t.DISCONNECTED = 'sdk_disconnected'),
        (t.SDK_USE_EXTENSION = 'sdk_use_extension'),
        (t.SDK_RPC_REQUEST = 'sdk_rpc_request'),
        (t.SDK_RPC_REQUEST_RECEIVED = 'sdk_rpc_request_received'),
        (t.SDK_RPC_REQUEST_DONE = 'sdk_rpc_request_done'),
        (t.SDK_EXTENSION_UTILIZED = 'sdk_extension_utilized'),
        (t.SDK_USE_INAPP_BROWSER = 'sdk_use_inapp_browser'));
    })(Mt || (Mt = {})));
  const sf = (t, e, n) =>
      ue(void 0, void 0, void 0, function* () {
        var r, i, s, o, a, c;
        const {remote: l, state: u} = t,
          {channelId: d, isOriginator: f} = u;
        if (e === 'error_terminated')
          return (
            te.SocketService(
              `handleJoinChannelResults: Channel ${d} terminated`
            ),
            void t.emit(me.TERMINATE)
          );
        if (!n)
          return void te.SocketService(
            `handleJoinChannelResults: No result for channel ${d}`
          );
        const {persistence: h, walletKey: g, rejected: m} = n;
        if (
          (te.SocketService(
            `handleJoinChannelResults: Channel ${d} persistence=${h} walletKey=${g} rejected=${m}`
          ),
          m)
        )
          return (
            te.SocketService(`handleJoinChannelResults: Channel ${d} rejected`),
            yield t.remote.disconnect({terminate: !0}),
            t.remote.emit(me.REJECTED, {channelId: d}),
            void t.remote.emitServiceStatusEvent()
          );
        if (
          g &&
          !(
            !((r = l.state.channelConfig) === null || r === void 0) &&
            r.otherKey
          )
        ) {
          (t.getKeyExchange().setOtherPublicKey(g),
            (i = t.state.keyExchange) === null ||
              i === void 0 ||
              i.setKeysExchanged(!0),
            (l.state.ready = !0),
            (l.state.authorized = !0),
            l.emit(me.AUTHORIZED));
          const {communicationLayer: y, storageManager: p} = l.state,
            b = Object.assign(Object.assign({}, l.state.channelConfig), {
              channelId:
                (s = l.state.channelId) !== null && s !== void 0 ? s : '',
              validUntil: Date.now() + xc,
              localKey: y == null ? void 0 : y.getKeyInfo().ecies.private,
              otherKey: g
            });
          (t.sendMessage({type: at.KEY_HANDSHAKE_ACK}).catch((v) => {}),
            (o = t.state.socket) === null ||
              o === void 0 ||
              o.emit(St.PING, {
                id: d,
                clientType: f ? 'dapp' : 'wallet',
                context: 'on_channel_reconnect',
                message: ''
              }),
            yield p == null ? void 0 : p.persistChannelConfig(b),
            l.emitServiceStatusEvent(),
            l.setConnectionStatus(Xt.LINKED));
        }
        h &&
          (t.emit(me.CHANNEL_PERSISTENCE),
          (a = t.state.keyExchange) === null ||
            a === void 0 ||
            a.setKeysExchanged(!0),
          (l.state.ready = !0),
          (l.state.authorized = !0),
          l.emit(me.AUTHORIZED),
          ss(
            Object.assign(
              Object.assign(
                {id: d ?? '', event: f ? Mt.CONNECTED : Mt.CONNECTED_MOBILE},
                t.remote.state.originatorInfo
              ),
              {
                sdkVersion: t.remote.state.sdkVersion,
                commLayer: t.state.communicationLayerPreference,
                commLayerVersion: io.version,
                walletVersion:
                  (c = t.remote.state.walletInfo) === null || c === void 0
                    ? void 0
                    : c.version
              }
            ),
            u.communicationServerUrl
          ).catch((y) => {}));
      }),
    Xa = (t) =>
      new Promise((e) => {
        setTimeout(e, t);
      }),
    K_ = (t, e, ...n) =>
      ue(void 0, [t, e, ...n], void 0, function* (r, i, s = 200) {
        let o;
        const a = Date.now();
        let c = !1;
        for (; !c; ) {
          if (
            ((c = Date.now() - a > 3e5), (o = i[r]), o.elapsedTime !== void 0)
          )
            return o;
          yield Xa(s);
        }
        throw new Error(`RPC ${r} timed out`);
      }),
    Zg = (t) =>
      ue(void 0, void 0, void 0, function* () {
        const {state: e} = t,
          {
            socket: n,
            channelId: r,
            context: i,
            isOriginator: s,
            isReconnecting: o
          } = e;
        if (o)
          return (
            te.SocketService(
              '[SocketService: reconnectSocket()] Reconnection already in progress, skipping',
              t
            ),
            !1
          );
        if (!n)
          return (
            te.SocketService(
              '[SocketService: reconnectSocket()] socket is not defined',
              t
            ),
            !1
          );
        if (!r) return !1;
        const {connected: a} = n;
        ((e.isReconnecting = !0),
          (e.reconnectionAttempts = 0),
          te.SocketService(
            `[SocketService: reconnectSocket()] connected=${a} trying to reconnect after socketio disconnection`,
            t
          ));
        try {
          for (; 3 > e.reconnectionAttempts; ) {
            if (
              (te.SocketService(
                `[SocketService: reconnectSocket()] Attempt ${e.reconnectionAttempts + 1} of 3`,
                t
              ),
              yield Xa(200),
              n.connected)
            )
              return (
                te.SocketService(
                  'Socket already connected --- ping to retrieve messages'
                ),
                n.emit(St.PING, {
                  id: r,
                  clientType: s ? 'dapp' : 'wallet',
                  context: 'on_channel_config',
                  message: ''
                }),
                !0
              );
            ((e.resumed = !0), n.connect(), t.emit(me.SOCKET_RECONNECT));
            try {
              if (
                (yield new Promise((c, l) => {
                  n.emit(
                    me.JOIN_CHANNEL,
                    {
                      channelId: r,
                      context: `${i}connect_again`,
                      clientType: s ? 'dapp' : 'wallet'
                    },
                    (u, d) =>
                      ue(void 0, void 0, void 0, function* () {
                        try {
                          (yield sf(t, u, d), c());
                        } catch (f) {
                          l(f);
                        }
                      })
                  );
                }),
                yield Xa(100),
                n.connected)
              )
                return (
                  te.SocketService(
                    `Reconnection successful on attempt ${e.reconnectionAttempts + 1}`
                  ),
                  !0
                );
            } catch (c) {
              te.SocketService(
                `Error during reconnection attempt ${e.reconnectionAttempts + 1}:`,
                c
              );
            }
            ((e.reconnectionAttempts += 1),
              3 > e.reconnectionAttempts && (yield Xa(200)));
          }
          return (te.SocketService('Failed to reconnect after 3 attempts'), !1);
        } finally {
          ((e.isReconnecting = !1), (e.reconnectionAttempts = 0));
        }
      });
  function k5(t, e) {
    return ue(this, void 0, void 0, function* () {
      var n;
      const r =
          (n = t.state.keyExchange) === null || n === void 0
            ? void 0
            : n.encryptMessage(JSON.stringify(e)),
        i = {
          id: t.state.channelId,
          context: t.state.context,
          clientType: t.state.isOriginator ? 'dapp' : 'wallet',
          message: r,
          plaintext: t.state.hasPlaintext ? JSON.stringify(e) : void 0
        };
      return (
        te.SocketService(
          `[SocketService: encryptAndSendMessage()] context=${t.state.context}`,
          i
        ),
        e.type === St.TERMINATE && (t.state.manualDisconnect = !0),
        new Promise((s, o) => {
          var a;
          (a = t.state.socket) === null ||
            a === void 0 ||
            a.emit(me.MESSAGE, i, (c, l) => {
              var u;
              (c &&
                (te.SocketService(
                  `[SocketService: encryptAndSendMessage()] error=${c}`
                ),
                o(c)),
                te.SocketService('[encryptAndSendMessage] response', l),
                s(
                  (u = l == null ? void 0 : l.success) !== null &&
                    u !== void 0 &&
                    u
                ));
            });
        })
      );
    });
  }
  var $a;
  (function (t) {
    ((t.RPC_CHECK = 'rpcCheck'), (t.SKIPPED_RPC = 'skippedRpc'));
  })($a || ($a = {}));
  const R5 = [
      'eth_sendTransaction',
      'eth_signTypedData',
      'eth_signTransaction',
      'personal_sign',
      'wallet_requestPermissions',
      'wallet_switchEthereumChain',
      'eth_signTypedData_v3',
      'eth_signTypedData_v4',
      'metamask_connectSign',
      'metamask_connectWith',
      'metamask_batch'
    ].map((t) => t.toLowerCase()),
    Pj = [
      {
        event: me.CLIENTS_CONNECTED,
        handler: function (t, e) {
          return (n) =>
            ue(this, void 0, void 0, function* () {
              var r, i, s, o, a, c, l, u, d, f, h;
              const g =
                (i =
                  (r = t.remote.state.channelConfig) === null || r === void 0
                    ? void 0
                    : r.relayPersistence) !== null &&
                i !== void 0 &&
                i;
              if (
                (te.SocketService(
                  `[SocketService: handleClientsConnected()] context=${t.state.context} on 'clients_connected-${e}' relayPersistence=${g} resumed=${t.state.resumed}  clientsPaused=${t.state.clientsPaused} keysExchanged=${(s = t.state.keyExchange) === null || s === void 0 ? void 0 : s.areKeysExchanged()} isOriginator=${t.state.isOriginator}`
                ),
                t.emit(me.CLIENTS_CONNECTED, {
                  isOriginator: t.state.isOriginator,
                  keysExchanged:
                    (o = t.state.keyExchange) === null || o === void 0
                      ? void 0
                      : o.areKeysExchanged(),
                  context: t.state.context
                }),
                t.state.resumed)
              )
                (t.state.isOriginator ||
                  (te.SocketService(
                    `[SocketService: handleClientsConnected()] context=${t.state.context} 'clients_connected' / keysExchanged=${(a = t.state.keyExchange) === null || a === void 0 ? void 0 : a.areKeysExchanged()} -- backward compatibility`
                  ),
                  (c = t.state.keyExchange) === null ||
                    c === void 0 ||
                    c.start({
                      isOriginator:
                        (l = t.state.isOriginator) !== null && l !== void 0 && l
                    })),
                  (t.state.resumed = !1));
              else if (t.state.clientsPaused)
                te.SocketService(
                  "[SocketService: handleClientsConnected()] 'clients_connected' skip sending originatorInfo on pause"
                );
              else if (!t.state.isOriginator) {
                const m = !g;
                (te.SocketService(
                  `[SocketService: handleClientsConnected()] context=${t.state.context} on 'clients_connected' / keysExchanged=${(u = t.state.keyExchange) === null || u === void 0 ? void 0 : u.areKeysExchanged()} -- force=${m} -- backward compatibility`
                ),
                  te.SocketService(
                    `[SocketService: handleClientsConnected()] context=${t.state.context} on 'clients_connected' / keysExchanged=${(d = t.state.keyExchange) === null || d === void 0 ? void 0 : d.areKeysExchanged()} -- force=${m} -- backward compatibility`
                  ),
                  (f = t.state.keyExchange) === null ||
                    f === void 0 ||
                    f.start({
                      isOriginator:
                        (h = t.state.isOriginator) !== null &&
                        h !== void 0 &&
                        h,
                      force: m
                    }));
              }
              ((t.state.clientsConnected = !0), (t.state.clientsPaused = !1));
            });
        }
      },
      {
        event: me.CHANNEL_CREATED,
        handler: function (t, e) {
          return (n) => {
            (te.SocketService(
              `[SocketService: handleChannelCreated()] context=${t.state.context} on 'channel_created-${e}'`,
              n
            ),
              t.emit(me.CHANNEL_CREATED, n));
          };
        }
      },
      {
        event: me.CLIENTS_DISCONNECTED,
        handler: function (t, e) {
          return () => {
            var n;
            ((t.state.clientsConnected = !1),
              te.SocketService(
                `[SocketService: handlesClientsDisconnected()] context=${t.state.context} on 'clients_disconnected-${e}'`
              ),
              t.remote.state.relayPersistence
                ? te.SocketService(
                    `[SocketService: handlesClientsDisconnected()] context=${t.state.context} on 'clients_disconnected-${e}' - relayPersistence enabled, skipping key exchange cleanup.`
                  )
                : (t.state.isOriginator &&
                    !t.state.clientsPaused &&
                    ((n = t.state.keyExchange) === null ||
                      n === void 0 ||
                      n.clean()),
                  t.emit(me.CLIENTS_DISCONNECTED, e)));
          };
        }
      },
      {
        event: me.CONFIG,
        handler: function (t, e) {
          return (n) =>
            ue(this, void 0, void 0, function* () {
              var r, i, s;
              te.SocketService(
                `[SocketService: handleChannelConfig()] update relayPersistence on 'config-${e}'`,
                n
              );
              const {persistence: o, walletKey: a} = n;
              t.state.isOriginator && t.remote.state.channelConfig
                ? (n.walletKey &&
                    !t.remote.state.channelConfig.otherKey &&
                    (te.SocketService(`Setting wallet key ${a}`),
                    (t.remote.state.channelConfig.otherKey = a),
                    t.getKeyExchange().setOtherPublicKey(n.walletKey),
                    (r = t.state.keyExchange) === null ||
                      r === void 0 ||
                      r.setKeysExchanged(!0),
                    yield t.remote.sendMessage({type: at.KEY_HANDSHAKE_ACK}),
                    yield t.remote.sendMessage({type: St.PING}),
                    yield (i = t.remote.state.storageManager) === null ||
                    i === void 0
                      ? void 0
                      : i.persistChannelConfig(t.remote.state.channelConfig)),
                  o !== !0 ||
                    t.remote.state.channelConfig.relayPersistence ||
                    (te.SocketService(`Setting relay persistence ${o}`),
                    (t.remote.state.channelConfig.relayPersistence = o),
                    (t.remote.state.relayPersistence = !0),
                    t.remote.emit(me.CHANNEL_PERSISTENCE),
                    (t.remote.state.authorized = !0),
                    (t.remote.state.ready = !0),
                    t.remote.emit(me.AUTHORIZED),
                    yield (s = t.remote.state.storageManager) === null ||
                    s === void 0
                      ? void 0
                      : s.persistChannelConfig(t.remote.state.channelConfig)))
                : t.state.isOriginator ||
                  (n.persistence &&
                    ((t.remote.state.relayPersistence = !0),
                    t.remote.emit(me.CHANNEL_PERSISTENCE)));
            });
        }
      },
      {
        event: me.MESSAGE,
        handler: function (t, e) {
          return (n) => {
            var r, i, s, o, a, c, l, u, d, f, h, g, m, y, p, b, v, x;
            const {ackId: C, message: $, error: G} = n,
              L =
                (r = t.remote.state.relayPersistence) !== null &&
                r !== void 0 &&
                r;
            if (
              (te.SocketService(
                `[SocketService handleMessage()]  relayPersistence=${L}  context=${t.state.context} on 'message' ${e} keysExchanged=${(i = t.state.keyExchange) === null || i === void 0 ? void 0 : i.areKeysExchanged()}`,
                n
              ),
              G)
            )
              throw (
                te.SocketService(`
      [SocketService handleMessage()] context=${t.state.context}::on 'message' error=${G}`),
                new Error(G)
              );
            const F = typeof $ == 'string';
            if (!F && ($ == null ? void 0 : $.type) === at.KEY_HANDSHAKE_START)
              return L
                ? void 0
                : (te.SocketService(
                    `[SocketService handleMessage()] context=${t.state.context}::on 'message' received HANDSHAKE_START isOriginator=${t.state.isOriginator}`,
                    $
                  ),
                  void (
                    (s = t.state.keyExchange) === null ||
                    s === void 0 ||
                    s.start({
                      isOriginator:
                        (o = t.state.isOriginator) !== null &&
                        o !== void 0 &&
                        o,
                      force: !0
                    })
                  ));
            if (
              !F &&
              !((a = $ == null ? void 0 : $.type) === null || a === void 0) &&
              a.startsWith('key_handshake')
            )
              return L
                ? void 0
                : (te.SocketService(
                    `[SocketService handleMessage()] context=${t.state.context}::on 'message' emit KEY_EXCHANGE`,
                    $
                  ),
                  void t.emit(Mh.KEY_EXCHANGE, {
                    message: $,
                    context: t.state.context
                  }));
            if (
              F &&
              !(
                !((c = t.state.keyExchange) === null || c === void 0) &&
                c.areKeysExchanged()
              )
            ) {
              let K = !1;
              try {
                (te.SocketService(
                  `[SocketService handleMessage()] context=${t.state.context}::on 'message' trying to decrypt message`
                ),
                  (l = t.state.keyExchange) === null ||
                    l === void 0 ||
                    l.decryptMessage($),
                  (K = !0));
              } catch (B) {
                te.SocketService(
                  `[SocketService handleMessage()] context=${t.state.context}::on 'message' error`,
                  B
                );
              }
              if (!K)
                return (
                  t.state.isOriginator
                    ? (d = t.state.keyExchange) === null ||
                      d === void 0 ||
                      d.start({
                        isOriginator:
                          (f = t.state.isOriginator) !== null &&
                          f !== void 0 &&
                          f
                      })
                    : t
                        .sendMessage({type: at.KEY_HANDSHAKE_START})
                        .catch((B) => {}),
                  void te.SocketService(
                    `Message ignored because invalid key exchange status. step=${(h = t.state.keyExchange) === null || h === void 0 ? void 0 : h.getKeyInfo().step}`,
                    (g = t.state.keyExchange) === null || g === void 0
                      ? void 0
                      : g.getKeyInfo(),
                    $
                  )
                );
              (te.SocketService(
                'Invalid key exchange status detected --- updating it.'
              ),
                (u = t.state.keyExchange) === null ||
                  u === void 0 ||
                  u.setKeysExchanged(!0));
            } else if (!F && $ != null && $.type)
              return void t.emit(me.MESSAGE, $);
            if (!F) return void t.emit(me.MESSAGE, $);
            const k =
                (m = t.state.keyExchange) === null || m === void 0
                  ? void 0
                  : m.decryptMessage($),
              V = JSON.parse(k ?? '{}');
            if (
              (C &&
                (C == null ? void 0 : C.length) > 0 &&
                (te.SocketService(
                  `[SocketService handleMessage()] context=${t.state.context}::on 'message' ackid=${C} channelId=${e}`
                ),
                (y = t.state.socket) === null ||
                  y === void 0 ||
                  y.emit(me.MESSAGE_ACK, {
                    ackId: C,
                    channelId: e,
                    clientType: t.state.isOriginator ? 'dapp' : 'wallet'
                  })),
              (t.state.clientsPaused =
                (V == null ? void 0 : V.type) === St.PAUSE),
              t.state.isOriginator && V.data)
            ) {
              const K = V.data,
                B = t.state.rpcMethodTracker[K.id];
              if (B) {
                const D = Date.now() - B.timestamp;
                (te.SocketService(
                  `[SocketService handleMessage()] context=${t.state.context}::on 'message' received answer for id=${K.id} method=${B.method} responseTime=${D}`,
                  V
                ),
                  t.remote.state.analytics &&
                    R5.includes(B.method.toLowerCase()) &&
                    ss(
                      Object.assign(
                        Object.assign(
                          {
                            id:
                              (p = t.remote.state.channelId) !== null &&
                              p !== void 0
                                ? p
                                : '',
                            event: Mt.SDK_RPC_REQUEST_DONE,
                            sdkVersion: t.remote.state.sdkVersion,
                            commLayerVersion: io.version
                          },
                          t.remote.state.originatorInfo
                        ),
                        {
                          walletVersion:
                            (b = t.remote.state.walletInfo) === null ||
                            b === void 0
                              ? void 0
                              : b.version,
                          params: {method: B.method, from: 'mobile'}
                        }
                      ),
                      t.remote.state.communicationServerUrl
                    ).catch((P) => {}),
                  Uu(B.method) &&
                    kt.analytics.track(
                      K.error
                        ? K.error.code === 4001
                          ? 'sdk_action_rejected'
                          : 'sdk_action_failed'
                        : 'sdk_action_succeeded',
                      {action: B.method}
                    ));
                const E = Object.assign(Object.assign({}, B), {
                  result: K.result,
                  error: K.error
                    ? {
                        code:
                          (v = K.error) === null || v === void 0
                            ? void 0
                            : v.code,
                        message:
                          (x = K.error) === null || x === void 0
                            ? void 0
                            : x.message
                      }
                    : void 0,
                  elapsedTime: D
                });
                ((t.state.rpcMethodTracker[K.id] = E),
                  t.emit(me.RPC_UPDATE, E));
              }
            }
            t.emit(me.MESSAGE, {message: V});
          };
        }
      },
      {
        event: me.REJECTED,
        handler: function (t, e) {
          return (n) =>
            ue(this, void 0, void 0, function* () {
              var r;
              t.state.isOriginator && !t.remote.state.ready
                ? (te.SocketService(
                    `[SocketService: handleChannelRejected()] context=${t.state.context} channelId=${e} isOriginator=${t.state.isOriginator} ready=${t.remote.state.ready}`,
                    t.remote.state.originatorInfo
                  ),
                  ss(
                    Object.assign(
                      Object.assign(
                        {id: e, event: Mt.REJECTED},
                        t.remote.state.originatorInfo
                      ),
                      {
                        sdkVersion: t.remote.state.sdkVersion,
                        commLayer: t.state.communicationLayerPreference,
                        commLayerVersion: io.version,
                        walletVersion:
                          (r = t.remote.state.walletInfo) === null ||
                          r === void 0
                            ? void 0
                            : r.version
                      }
                    ),
                    t.remote.state.communicationServerUrl
                  ).catch((i) => {}),
                  kt.analytics.track('sdk_connection_rejected', {
                    transport_type: 'websocket'
                  }),
                  yield t.remote.disconnect({terminate: !0}),
                  t.remote.emit(me.REJECTED, {channelId: e}),
                  t.remote.setConnectionStatus(Xt.DISCONNECTED))
                : te.SocketService(
                    `[SocketService: handleChannelRejected()] SKIP -- channelId=${e} isOriginator=${t.state.isOriginator} ready=${t.remote.state.ready}`
                  );
            });
        }
      },
      {
        event: 'clients_waiting_to_join',
        handler: function (t, e) {
          return (n) => {
            (te.SocketService(
              `[SocketService: handleClientsWaitingToJoin()] context=${t.state.context} on 'clients_waiting_to_join-${e}'`,
              n
            ),
              t.emit(me.CLIENTS_WAITING, n));
          };
        }
      }
    ],
    Mj = [
      {
        event: me.KEY_INFO,
        handler: function (t) {
          return (e) => {
            (te.SocketService(
              "[SocketService: handleKeyInfo()] on 'KEY_INFO'",
              e
            ),
              t.emit(me.KEY_INFO, e));
          };
        }
      },
      {
        event: me.KEYS_EXCHANGED,
        handler: function (t) {
          return () => {
            var e, n, r;
            te.SocketService(
              `[SocketService: handleKeysExchanged()] on 'keys_exchanged' keyschanged=${(e = t.state.keyExchange) === null || e === void 0 ? void 0 : e.areKeysExchanged()}`
            );
            const {channelConfig: i} = t.remote.state;
            if (i) {
              const o = t.getKeyExchange().getKeyInfo().ecies;
              ((i.localKey = o.private),
                (i.otherKey = o.otherPubKey),
                (t.remote.state.channelConfig = i),
                (n = t.remote.state.storageManager) === null ||
                  n === void 0 ||
                  n.persistChannelConfig(i).catch((a) => {}));
            }
            t.emit(me.KEYS_EXCHANGED, {
              keysExchanged:
                (r = t.state.keyExchange) === null || r === void 0
                  ? void 0
                  : r.areKeysExchanged(),
              isOriginator: t.state.isOriginator
            });
            const s = {keyInfo: t.getKeyInfo()};
            t.emit(me.SERVICE_STATUS, s);
          };
        }
      }
    ];
  function q_(t, e) {
    te.SocketService(
      `[SocketService: setupChannelListener()] context=${t.state.context} setting socket listeners for channel ${e}...`
    );
    const {socket: n} = t.state,
      {keyExchange: r} = t.state;
    (n &&
      t.state.isOriginator &&
      (t.state.debug &&
        (n == null ||
          n.io.on('error', (i) => {
            te.SocketService(
              `[SocketService: setupChannelListener()] context=${t.state.context} socket event=error`,
              i
            );
          }),
        n == null ||
          n.io.on('reconnect', (i) => {
            (te.SocketService(
              `[SocketService: setupChannelListener()] context=${t.state.context} socket event=reconnect`,
              i
            ),
              Zg(t).catch((s) => {}));
          }),
        n == null ||
          n.io.on('reconnect_error', (i) => {
            te.SocketService(
              `[SocketService: setupChannelListener()] context=${t.state.context} socket event=reconnect_error`,
              i
            );
          }),
        n == null ||
          n.io.on('reconnect_failed', () => {
            te.SocketService(
              `[SocketService: setupChannelListener()] context=${t.state.context} socket event=reconnect_failed`
            );
          })),
      n == null ||
        n.on(
          'disconnect',
          (i) => (
            te.SocketService(
              `[SocketService: setupChannelListener()] on 'disconnect' -- MetaMaskSDK socket disconnected '${i}' begin recovery...`
            ),
            (function (s) {
              return (o) => {
                (te.SocketService(
                  `[SocketService: handleDisconnect()] on 'disconnect' manualDisconnect=${s.state.manualDisconnect}`,
                  o
                ),
                  s.state.manualDisconnect ||
                    (s.emit(me.SOCKET_DISCONNECTED), Zg(s).catch((a) => {})));
              };
            })(t)(i)
          )
        )),
      Pj.forEach(({event: i, handler: s}) => {
        n == null || n.on(`${i}-${e}`, s(t, e));
      }),
      Mj.forEach(({event: i, handler: s}) => {
        r == null || r.on(i, s(t));
      }),
      (t.state.setupChannelListeners = !0));
  }
  class Oj extends Fp.EventEmitter2 {
    constructor(e) {
      (super(),
        (this.state = {
          clientsConnected: !1,
          clientsPaused: !1,
          manualDisconnect: !1,
          lastRpcId: void 0,
          rpcMethodTracker: {},
          hasPlaintext: !1,
          communicationServerUrl: '',
          focusListenerAdded: !1,
          removeFocusListener: void 0,
          isReconnecting: !1,
          reconnectionAttempts: 0
        }),
        (this.options = e));
      const {
        reconnect: n,
        communicationLayerPreference: r,
        communicationServerUrl: i,
        context: s,
        remote: o,
        logging: a
      } = e;
      ((this.state.resumed = n),
        (this.state.context = s),
        (this.state.isOriginator = o.state.isOriginator),
        (this.state.communicationLayerPreference = r),
        (this.state.debug = (a == null ? void 0 : a.serviceLayer) === !0),
        (this.remote = o),
        (a == null ? void 0 : a.serviceLayer) === !0 &&
          Cn.enable('SocketService:Layer'),
        (this.state.communicationServerUrl = i),
        (this.state.hasPlaintext =
          this.state.communicationServerUrl !== Sc &&
          (a == null ? void 0 : a.plaintext) === !0),
        te.SocketService(
          `[SocketService: constructor()] Socket IO url: ${this.state.communicationServerUrl}`
        ),
        this.initSocket());
    }
    initSocket() {
      var e;
      const {otherPublicKey: n, ecies: r, logging: i} = this.options,
        s = {autoConnect: !1, transports: Tj, withCredentials: !0},
        o = this.state.communicationServerUrl;
      (te.SocketService(`[SocketService: initSocket()] Socket IO url: ${o}`),
        (this.state.socket = ef(o, s)),
        (function (c) {
          if (
            typeof window < 'u' &&
            typeof document < 'u' &&
            (te.SocketService(
              `[SocketService: setupSocketFocusListener()] hasFocus=${document.hasFocus()}`,
              c
            ),
            !c.state.focusListenerAdded)
          ) {
            const l = () => {
              (te.SocketService('Document has focus --- reconnecting socket'),
                Zg(c).catch((u) => {}));
            };
            (window.addEventListener('focus', l),
              (c.state.focusListenerAdded = !0),
              (c.state.removeFocusListener = () => {
                (window.removeEventListener('focus', l),
                  (c.state.focusListenerAdded = !1));
              }));
          }
        })(this));
      const a = {
        communicationLayer: this,
        otherPublicKey: n,
        sendPublicKey: !1,
        context: (e = this.state.context) !== null && e !== void 0 ? e : '',
        ecies: r,
        logging: i
      };
      this.state.keyExchange = new Rj(a);
    }
    resetKeys() {
      return (
        te.SocketService('[SocketService: resetKeys()] Resetting keys.'),
        void (
          (e = this.state.keyExchange) === null ||
          e === void 0 ||
          e.resetKeys()
        )
      );
      var e;
    }
    createChannel() {
      return ue(this, void 0, void 0, function* () {
        return (function (e) {
          return ue(this, void 0, void 0, function* () {
            var n, r, i;
            if (
              (te.SocketService(
                `[SocketService: createChannel()] context=${e.state.context}`
              ),
              e.state.socket || e.initSocket(),
              (n = e.state.socket) === null || n === void 0
                ? void 0
                : n.connected)
            )
              throw new Error('socket already connected');
            ((r = e.state.socket) === null || r === void 0 || r.connect(),
              (e.state.manualDisconnect = !1),
              (e.state.isOriginator = !0));
            const s = Ls();
            ((e.state.channelId = s),
              q_(e, s),
              yield new Promise((a, c) => {
                var l;
                (l = e.state.socket) === null ||
                  l === void 0 ||
                  l.emit(
                    me.JOIN_CHANNEL,
                    {
                      channelId: s,
                      context: `${e.state.context}createChannel`,
                      clientType: 'dapp'
                    },
                    (u, d) =>
                      ue(this, void 0, void 0, function* () {
                        try {
                          (yield sf(e, u, d), a());
                        } catch (f) {
                          c(f);
                        }
                      })
                  );
              }));
            const o =
              (i = e.state.keyExchange) === null || i === void 0
                ? void 0
                : i.getKeyInfo();
            return {
              channelId: s,
              pubKey: (o == null ? void 0 : o.ecies.public) || '',
              privKey: (o == null ? void 0 : o.ecies.private) || ''
            };
          });
        })(this);
      });
    }
    connectToChannel({channelId: e, withKeyExchange: n = !1, authorized: r}) {
      return (function (i) {
        return ue(
          this,
          arguments,
          void 0,
          function* ({options: s, instance: o}) {
            const {channelId: a, authorized: c, withKeyExchange: l} = s,
              {state: u, remote: d} = o,
              {isOriginator: f = !1, socket: h, keyExchange: g} = u,
              {channelConfig: m} = d.state;
            if (h != null && h.connected)
              throw new Error('socket already connected');
            if (f && m != null && m.relayPersistence) {
              const {localKey: y, otherKey: p} = m;
              y &&
                p &&
                (g == null ||
                  g.setRelayPersistence({localKey: y, otherKey: p}));
            }
            return (
              Object.assign(u, {
                manualDisconnect: !1,
                withKeyExchange: l,
                isOriginator: f,
                channelId: a
              }),
              h == null || h.connect(),
              q_(o, a),
              !f &&
                c &&
                (g == null || g.setKeysExchanged(!0),
                Object.assign(d.state, {ready: !0, authorized: !0})),
              new Promise((y) => {
                var p;
                const b =
                  (p = g == null ? void 0 : g.getKeyInfo()) === null ||
                  p === void 0
                    ? void 0
                    : p.ecies.public;
                h == null ||
                  h.emit(
                    me.JOIN_CHANNEL,
                    {
                      channelId: a,
                      context: `${u.context}_connectToChannel`,
                      clientType: f ? 'dapp' : 'wallet',
                      publicKey: c && !f ? b : void 0
                    },
                    (v, x) =>
                      ue(this, void 0, void 0, function* () {
                        (yield sf(o, v, x), y());
                      })
                  );
              })
            );
          }
        );
      })({
        options: {channelId: e, withKeyExchange: n, authorized: r},
        instance: this
      });
    }
    getKeyInfo() {
      return this.state.keyExchange.getKeyInfo();
    }
    keyCheck() {
      var e, n;
      (n = (e = this).state.socket) === null ||
        n === void 0 ||
        n.emit(me.MESSAGE, {
          id: e.state.channelId,
          context: e.state.context,
          message: {
            type: at.KEY_HANDSHAKE_CHECK,
            pubkey: e.getKeyInfo().ecies.otherPubKey
          }
        });
    }
    getKeyExchange() {
      return this.state.keyExchange;
    }
    sendMessage(e) {
      return ue(this, void 0, void 0, function* () {
        return (function (n, r) {
          return ue(this, void 0, void 0, function* () {
            var i, s, o;
            if (!n.state.channelId)
              throw (
                te.SocketService(
                  'handleSendMessage: no channelId - Create a channel first'
                ),
                new Error('Create a channel first')
              );
            if (
              (te.SocketService(
                `[SocketService: handleSendMessage()] context=${n.state.context} areKeysExchanged=${(i = n.state.keyExchange) === null || i === void 0 ? void 0 : i.areKeysExchanged()}`,
                r
              ),
              (s = r == null ? void 0 : r.type) === null || s === void 0
                ? void 0
                : s.startsWith('key_handshake'))
            )
              return (
                (function (c, l) {
                  var u;
                  (te.SocketService(
                    `[SocketService: handleKeyHandshake()] context=${c.state.context}`,
                    l
                  ),
                    (u = c.state.socket) === null ||
                      u === void 0 ||
                      u.emit(me.MESSAGE, {
                        id: c.state.channelId,
                        context: c.state.context,
                        clientType: c.state.isOriginator ? 'dapp' : 'wallet',
                        message: l
                      }));
                })(n, r),
                !0
              );
            ((function (c, l) {
              var u;
              if (
                !(
                  !((u = c.state.keyExchange) === null || u === void 0) &&
                  u.areKeysExchanged()
                ) &&
                !c.remote.state.relayPersistence
              )
                throw (
                  te.SocketService(
                    `[SocketService: validateKeyExchange()] context=${c.state.context} ERROR keys not exchanged`,
                    l
                  ),
                  new Error('Keys not exchanged BBB')
                );
            })(n, r),
              (function (c, l) {
                var u;
                const d =
                    (u = l == null ? void 0 : l.method) !== null && u !== void 0
                      ? u
                      : '',
                  f = l == null ? void 0 : l.id;
                c.state.isOriginator &&
                  f &&
                  ((c.state.rpcMethodTracker[f] = {
                    id: f,
                    timestamp: Date.now(),
                    method: d
                  }),
                  c.emit(me.RPC_UPDATE, c.state.rpcMethodTracker[f]));
              })(n, r));
            const a = yield k5(n, r);
            return (
              n.remote.state.analytics &&
                n.remote.state.isOriginator &&
                r.method &&
                R5.includes(r.method.toLowerCase()) &&
                ss(
                  {
                    id:
                      (o = n.remote.state.channelId) !== null && o !== void 0
                        ? o
                        : '',
                    event: Mt.SDK_RPC_REQUEST,
                    params: {method: r.method, from: 'mobile'}
                  },
                  n.remote.state.communicationServerUrl
                ).catch((c) => {}),
              n.remote.state.isOriginator &&
                r.method &&
                Uu(r.method) &&
                kt.analytics.track('sdk_action_requested', {action: r.method}),
              (function (c, l) {
                return ue(this, void 0, void 0, function* () {
                  var u;
                  const d = l == null ? void 0 : l.id,
                    f =
                      (u = l == null ? void 0 : l.method) !== null &&
                      u !== void 0
                        ? u
                        : '';
                  if (c.state.isOriginator && d)
                    try {
                      const h = K_(d, c.state.rpcMethodTracker, 200).then(
                          (y) => ({type: $a.RPC_CHECK, result: y})
                        ),
                        g = ue(this, void 0, void 0, function* () {
                          const y = yield ((b) =>
                              ue(
                                void 0,
                                [b],
                                void 0,
                                function* ({rpcId: v, instance: x}) {
                                  for (
                                    ;
                                    x.state.lastRpcId === v ||
                                    x.state.lastRpcId === void 0;

                                  )
                                    yield Xa(200);
                                  return x.state.lastRpcId;
                                }
                              ))({instance: c, rpcId: d}),
                            p = yield K_(y, c.state.rpcMethodTracker, 200);
                          return {type: $a.SKIPPED_RPC, result: p};
                        }),
                        m = yield Promise.race([h, g]);
                      if (m.type === $a.RPC_CHECK) {
                        const y = m.result;
                        te.SocketService(
                          `[SocketService:handleRpcReplies()] id=${l.id} ${f} ( ${y.elapsedTime} ms)`,
                          y.result
                        );
                      } else {
                        if (m.type !== $a.SKIPPED_RPC)
                          throw new Error(
                            `Error handling RPC replies for ${d}`
                          );
                        {
                          const y = Object.assign(
                            Object.assign({}, c.state.rpcMethodTracker[d]),
                            {error: new Error('SDK_CONNECTION_ISSUE')}
                          );
                          c.emit(me.RPC_UPDATE, y);
                          const p = {
                            data: Object.assign(Object.assign({}, y), {
                              jsonrpc: '2.0'
                            }),
                            name: 'metamask-provider'
                          };
                          c.emit(me.MESSAGE, {message: p});
                        }
                      }
                    } catch (h) {
                      throw h;
                    }
                });
              })(n, r).catch((c) => {}),
              a
            );
          });
        })(this, e);
      });
    }
    ping() {
      return (function (e) {
        return ue(this, void 0, void 0, function* () {
          var n, r;
          (te.SocketService(
            `[SocketService: ping()] context=${e.state.context} originator=${e.state.isOriginator} keysExchanged=${(n = e.state.keyExchange) === null || n === void 0 ? void 0 : n.areKeysExchanged()}`
          ),
            (r = e.state.socket) === null ||
              r === void 0 ||
              r.emit(St.PING, {
                id: e.state.channelId,
                context: 'ping',
                clientType: e.remote.state.isOriginator ? 'dapp' : 'wallet',
                message: ''
              }));
        });
      })(this);
    }
    pause() {
      return (function (e) {
        return ue(this, void 0, void 0, function* () {
          var n, r;
          (te.SocketService(
            `[SocketService: pause()] context=${e.state.context}`
          ),
            (e.state.manualDisconnect = !0),
            !((n = e.state.keyExchange) === null || n === void 0) &&
              n.areKeysExchanged() &&
              (yield e.sendMessage({type: St.PAUSE})),
            (r = e.state.socket) === null || r === void 0 || r.disconnect());
        });
      })(this);
    }
    isConnected() {
      var e;
      return (e = this.state.socket) === null || e === void 0
        ? void 0
        : e.connected;
    }
    resume() {
      return (function (e) {
        return ue(this, void 0, void 0, function* () {
          const {state: n, remote: r} = e,
            {
              socket: i,
              channelId: s,
              context: o,
              keyExchange: a,
              isOriginator: c
            } = n,
            {isOriginator: l} = r.state;
          if (
            (te.SocketService(
              `[SocketService: resume()] channelId=${s} context=${o} connected=${i == null ? void 0 : i.connected} manualDisconnect=${n.manualDisconnect} resumed=${n.resumed} keysExchanged=${a == null ? void 0 : a.areKeysExchanged()}`
            ),
            !s)
          )
            throw (
              te.SocketService(
                '[SocketService: resume()] channelId is not defined'
              ),
              new Error('ChannelId is not defined')
            );
          (i != null && i.connected
            ? (te.SocketService('[SocketService: resume()] already connected.'),
              i.emit(St.PING, {
                id: s,
                clientType: l ? 'dapp' : 'wallet',
                context: 'on_channel_config',
                message: ''
              }),
              r.hasRelayPersistence() ||
                (a != null && a.areKeysExchanged()) ||
                (c
                  ? yield e.sendMessage({type: St.READY})
                  : a == null || a.start({isOriginator: !1})))
            : (i == null || i.connect(),
              te.SocketService(
                `[SocketService: resume()] after connecting socket --> connected=${i == null ? void 0 : i.connected}`
              ),
              i == null ||
                i.emit(
                  me.JOIN_CHANNEL,
                  {
                    channelId: s,
                    context: `${o}_resume`,
                    clientType: l ? 'dapp' : 'wallet'
                  },
                  (u, d) =>
                    ue(this, void 0, void 0, function* () {
                      try {
                        yield sf(e, u, d);
                      } catch {}
                    })
                )),
            (n.manualDisconnect = !1),
            (n.resumed = !0));
        });
      })(this);
    }
    getRPCMethodTracker() {
      return this.state.rpcMethodTracker;
    }
    disconnect(e) {
      return (function (n, r) {
        var i, s, o, a, c;
        (te.SocketService(
          `[SocketService: disconnect()] context=${n.state.context}`,
          r
        ),
          r != null &&
            r.terminate &&
            ((s = (i = n.state).removeFocusListener) === null ||
              s === void 0 ||
              s.call(i),
            (n.state.channelId = r.channelId),
            (o = n.state.socket) === null ||
              o === void 0 ||
              o.removeAllListeners(),
            (a = n.state.keyExchange) === null || a === void 0 || a.clean(),
            (n.remote.state.ready = !1),
            (n.state.socket = void 0),
            (n.state.rpcMethodTracker = {})),
          (n.state.manualDisconnect = !0),
          (c = n.state.socket) === null || c === void 0 || c.disconnect());
      })(this, e);
    }
  }
  var ta, fn, V_;
  function Nj(t) {
    return () =>
      ue(this, void 0, void 0, function* () {
        var e, n, r;
        const {state: i} = t;
        if (i.authorized) return;
        yield ue(this, void 0, void 0, function* () {
          for (; !i.walletInfo; ) yield Xa(500);
        });
        const s = '7.3'.localeCompare(
          ((e = i.walletInfo) === null || e === void 0 ? void 0 : e.version) ||
            ''
        );
        if (
          (te.RemoteCommunication(
            `[RemoteCommunication: handleAuthorizedEvent()] HACK 'authorized' version=${(n = i.walletInfo) === null || n === void 0 ? void 0 : n.version} compareValue=${s}`
          ),
          s !== 1)
        )
          return;
        const o =
          i.platformType === fn.MobileWeb ||
          i.platformType === fn.ReactNative ||
          i.platformType === fn.MetaMaskMobileWebview;
        (te.RemoteCommunication(
          `[RemoteCommunication: handleAuthorizedEvent()] HACK 'authorized' platform=${i.platformType} secure=${o} channel=${i.channelId} walletVersion=${(r = i.walletInfo) === null || r === void 0 ? void 0 : r.version}`
        ),
          o && ((i.authorized = !0), t.emit(me.AUTHORIZED)));
      });
  }
  function Lj(t) {
    return (e) => {
      const {state: n} = t;
      (te.RemoteCommunication(
        `[RemoteCommunication: handleChannelCreatedEvent()] context=${n.context} on 'channel_created' channelId=${e}`
      ),
        t.emit(me.CHANNEL_CREATED, e));
    };
  }
  function Bj(t, e) {
    return () => {
      var n, r, i, s;
      const {state: o} = t;
      (te.RemoteCommunication(
        `[RemoteCommunication: handleClientsConnectedEvent()] on 'clients_connected' channel=${o.channelId} keysExchanged=${(r = (n = o.communicationLayer) === null || n === void 0 ? void 0 : n.getKeyInfo()) === null || r === void 0 ? void 0 : r.keysExchanged}`
      ),
        o.analytics &&
          ss(
            Object.assign(
              Object.assign(
                {
                  id: (i = o.channelId) !== null && i !== void 0 ? i : '',
                  event: o.reconnection
                    ? Mt.RECONNECT
                    : o.isOriginator
                      ? Mt.REQUEST
                      : Mt.REQUEST_MOBILE
                },
                o.originatorInfo
              ),
              {
                commLayer: e,
                sdkVersion: o.sdkVersion,
                walletVersion:
                  (s = o.walletInfo) === null || s === void 0
                    ? void 0
                    : s.version,
                commLayerVersion: io.version
              }
            ),
            o.communicationServerUrl
          ).catch((a) => {}),
        o.isOriginator &&
          !o.reconnection &&
          kt.analytics.track('sdk_connection_established', {
            transport_type: 'websocket'
          }),
        (o.clientsConnected = !0),
        (o.originatorInfoSent = !1),
        t.emit(me.CLIENTS_CONNECTED));
    };
  }
  function Dj(t) {
    return (e) => {
      const {state: n} = t;
      (te.RemoteCommunication(
        `[RemoteCommunication: handleClientsDisconnectedEvent()] context=${n.context} on 'clients_disconnected' channelId=${e}`
      ),
        n.relayPersistence ||
          ((n.clientsConnected = !1), (n.ready = !1), (n.authorized = !1)),
        t.emit(me.CLIENTS_DISCONNECTED, n.channelId),
        t.setConnectionStatus(Xt.DISCONNECTED));
    };
  }
  function Fj(t) {
    return (e) => {
      var n;
      const {state: r} = t;
      if (
        (te.RemoteCommunication(
          `[RemoteCommunication: handleClientsWaitingEvent()] context=${r.context} on 'clients_waiting' numberUsers=${e} ready=${r.ready} autoStarted=${r.originatorConnectStarted}`
        ),
        t.setConnectionStatus(Xt.WAITING),
        t.emit(me.CLIENTS_WAITING, e),
        r.originatorConnectStarted)
      ) {
        te.RemoteCommunication(
          `[RemoteCommunication: handleClientsWaitingEvent()] on 'clients_waiting' watch autoStarted=${r.originatorConnectStarted} timeout`,
          r.autoConnectOptions
        );
        const i =
            ((n = r.autoConnectOptions) === null || n === void 0
              ? void 0
              : n.timeout) || 3e3,
          s = setTimeout(() => {
            (te.RemoteCommunication(
              `[RemoteCommunication: handleClientsWaitingEvent()] setTimeout(${i}) terminate channelConfig`,
              r.autoConnectOptions
            ),
              (r.originatorConnectStarted = !1),
              r.ready || t.setConnectionStatus(Xt.TIMEOUT),
              clearTimeout(s));
          }, i);
      }
    };
  }
  function $j(t, e) {
    return (n) => {
      var r, i, s, o, a, c, l, u;
      const {state: d} = t;
      if (
        (te.RemoteCommunication(
          `[RemoteCommunication: handleKeysExchangedEvent()] context=${d.context} on commLayer.'keys_exchanged' channel=${d.channelId}`,
          n
        ),
        (i =
          (r = d.communicationLayer) === null || r === void 0
            ? void 0
            : r.getKeyInfo()) === null || i === void 0
          ? void 0
          : i.keysExchanged)
      ) {
        const f = Object.assign(Object.assign({}, d.channelConfig), {
          channelId: (s = d.channelId) !== null && s !== void 0 ? s : '',
          validUntil:
            ((o = d.channelConfig) === null || o === void 0
              ? void 0
              : o.validUntil) || xc,
          localKey: d.communicationLayer.getKeyInfo().ecies.private,
          otherKey: d.communicationLayer.getKeyInfo().ecies.otherPubKey
        });
        ((a = d.storageManager) === null ||
          a === void 0 ||
          a.persistChannelConfig(f).catch((h) => {}),
          t.setConnectionStatus(Xt.LINKED));
      }
      ((function (f, h) {
        var g, m, y, p, b, v, x, C;
        const {state: $} = f;
        te.RemoteCommunication(
          `[RemoteCommunication: setLastActiveDate()] channel=${$.channelId}`,
          h
        );
        const G = Object.assign(Object.assign({}, $.channelConfig), {
          channelId: (g = $.channelId) !== null && g !== void 0 ? g : '',
          validUntil:
            (y =
              (m = $.channelConfig) === null || m === void 0
                ? void 0
                : m.validUntil) !== null && y !== void 0
              ? y
              : 0,
          relayPersistence: $.relayPersistence,
          localKey:
            (b =
              (p = $.communicationLayer) === null || p === void 0
                ? void 0
                : p.state.keyExchange) === null || b === void 0
              ? void 0
              : b.getKeyInfo().ecies.private,
          otherKey:
            (x =
              (v = $.communicationLayer) === null || v === void 0
                ? void 0
                : v.state.keyExchange) === null || x === void 0
              ? void 0
              : x.getKeyInfo().ecies.otherPubKey,
          lastActive: h.getTime()
        });
        (C = $.storageManager) === null ||
          C === void 0 ||
          C.persistChannelConfig(G);
      })(t, new Date()),
        d.analytics &&
          d.channelId &&
          ss(
            Object.assign(
              Object.assign(
                {
                  id: d.channelId,
                  event: n.isOriginator ? Mt.CONNECTED : Mt.CONNECTED_MOBILE
                },
                d.originatorInfo
              ),
              {
                sdkVersion: d.sdkVersion,
                commLayer: e,
                commLayerVersion: io.version,
                walletVersion:
                  (c = d.walletInfo) === null || c === void 0
                    ? void 0
                    : c.version
              }
            ),
            d.communicationServerUrl
          ).catch((f) => {}),
        (d.isOriginator = n.isOriginator),
        n.isOriginator ||
          ((l = d.communicationLayer) === null ||
            l === void 0 ||
            l.sendMessage({type: St.READY}),
          (d.ready = !0),
          (d.paused = !1)),
        n.isOriginator &&
          !d.originatorInfoSent &&
          ((u = d.communicationLayer) === null ||
            u === void 0 ||
            u.sendMessage({
              type: St.ORIGINATOR_INFO,
              originatorInfo: d.originatorInfo,
              originator: d.originatorInfo
            }),
          (d.originatorInfoSent = !0)));
    };
  }
  function Hj(t) {
    return (e) => {
      let n = e;
      (e.message && (n = n.message),
        (function (r, i) {
          const {state: s} = i;
          if (
            (te.RemoteCommunication(
              `[RemoteCommunication: onCommunicationLayerMessage()] context=${s.context} on 'message' typeof=${typeof r}`,
              r
            ),
            (i.state.ready = !0),
            s.isOriginator || r.type !== St.ORIGINATOR_INFO)
          )
            if (s.isOriginator && r.type === St.WALLET_INFO)
              (function (o, a) {
                const {state: c} = o;
                ((c.walletInfo = a.walletInfo), (c.paused = !1));
              })(i, r);
            else {
              if (s.isOriginator && r.type === St.WALLET_INIT)
                (function (o, a) {
                  return ue(this, void 0, void 0, function* () {
                    var c, l, u;
                    const {state: d} = o;
                    if (d.isOriginator) {
                      const f = a.data || {};
                      if (
                        typeof f == 'object' &&
                        'accounts' in f &&
                        'chainId' in f &&
                        'walletKey' in f
                      )
                        try {
                          const {channelConfig: h} = o.state;
                          if (
                            (te.RemoteCommunication(
                              'WALLET_INIT: channelConfig',
                              JSON.stringify(h, null, 2)
                            ),
                            h)
                          ) {
                            const g = f.accounts,
                              m = f.chainId,
                              y = f.walletKey;
                            let p,
                              b = !1;
                            ('deeplinkProtocol' in f &&
                              ((b = !!f.deeplinkProtocol),
                              (o.state.deeplinkProtocolAvailable = b)),
                              'walletVersion' in f && (p = f.walletVersion),
                              yield (c = o.state.storageManager) === null ||
                              c === void 0
                                ? void 0
                                : c.persistChannelConfig(
                                    Object.assign(Object.assign({}, h), {
                                      otherKey: y,
                                      walletVersion: p,
                                      deeplinkProtocolAvailable: b,
                                      relayPersistence: !0
                                    })
                                  ),
                              yield (l = o.state.storageManager) === null ||
                              l === void 0
                                ? void 0
                                : l.persistAccounts(g),
                              yield (u = o.state.storageManager) === null ||
                              u === void 0
                                ? void 0
                                : u.persistChainId(m));
                          }
                          o.emit(me.WALLET_INIT, {
                            accounts: f.accounts,
                            chainId: f.chainId
                          });
                        } catch {}
                    }
                  });
                })(i, r).catch((o) => {
                  te.RemoteCommunication(
                    `[RemoteCommunication: onCommunicationLayerMessage()] error=${o}`
                  );
                });
              else if (r.type === St.TERMINATE)
                (function (o) {
                  return ue(this, void 0, void 0, function* () {
                    const {state: a} = o;
                    a.isOriginator &&
                      (yield P5({
                        options: {terminate: !0, sendMessage: !1},
                        instance: o
                      }),
                      o.emit(me.TERMINATE));
                  });
                })(i).catch((o) => {
                  te.RemoteCommunication(
                    `[RemoteCommunication: onCommunicationLayerMessage()] error=${o}`
                  );
                });
              else if (r.type === St.PAUSE)
                (function (o) {
                  const {state: a} = o;
                  ((a.paused = !0), o.setConnectionStatus(Xt.PAUSED));
                })(i);
              else if (r.type === St.READY && s.isOriginator)
                (function (o) {
                  const {state: a} = o;
                  o.setConnectionStatus(Xt.LINKED);
                  const c = a.paused;
                  ((a.paused = !1),
                    o.emit(me.CLIENTS_READY, {
                      isOriginator: a.isOriginator,
                      walletInfo: a.walletInfo
                    }),
                    c && ((a.authorized = !0), o.emit(me.AUTHORIZED)));
                })(i);
              else {
                if (r.type === St.OTP && s.isOriginator)
                  return void (function (o, a) {
                    var c;
                    const {state: l} = o;
                    (o.emit(me.OTP, a.otpAnswer),
                      '6.6'.localeCompare(
                        ((c = l.walletInfo) === null || c === void 0
                          ? void 0
                          : c.version) || ''
                      ) === 1 &&
                        o.emit(me.SDK_RPC_CALL, {
                          method: on.ETH_REQUESTACCOUNTS,
                          params: []
                        }));
                  })(i, r);
                r.type === St.AUTHORIZED &&
                  s.isOriginator &&
                  (function (o) {
                    const {state: a} = o;
                    ((a.authorized = !0), o.emit(me.AUTHORIZED));
                  })(i);
              }
              i.emit(me.MESSAGE, r);
            }
          else
            (function (o, a) {
              var c;
              const {state: l} = o;
              ((c = l.communicationLayer) === null ||
                c === void 0 ||
                c.sendMessage({type: St.WALLET_INFO, walletInfo: l.walletInfo}),
                (l.originatorInfo = a.originatorInfo || a.originator),
                o.emit(me.CLIENTS_READY, {
                  isOriginator: l.isOriginator,
                  originatorInfo: l.originatorInfo
                }),
                (l.paused = !1));
            })(i, r);
        })(n, t));
    };
  }
  function jj(t) {
    return () => {
      const {state: e} = t;
      (te.RemoteCommunication(
        "[RemoteCommunication: handleSocketReconnectEvent()] on 'socket_reconnect' -- reset key exchange status / set ready to false"
      ),
        (e.ready = !1),
        (e.authorized = !1),
        I5(e),
        t.emitServiceStatusEvent({context: 'socket_reconnect'}));
    };
  }
  function Uj(t) {
    return () => {
      const {state: e} = t;
      (te.RemoteCommunication(
        "[RemoteCommunication: handleSocketDisconnectedEvent()] on 'socket_Disconnected' set ready to false"
      ),
        (e.ready = !1));
    };
  }
  function Kj(t) {
    return () =>
      ue(this, void 0, void 0, function* () {
        var e, n, r, i, s, o, a;
        const {state: c} = t;
        (te.RemoteCommunication(
          `[RemoteCommunication: handleFullPersistenceEvent()] context=${c.context}`
        ),
          (t.state.ready = !0),
          (t.state.clientsConnected = !0),
          (t.state.authorized = !0),
          (t.state.relayPersistence = !0),
          (e = t.state.communicationLayer) === null ||
            e === void 0 ||
            e.getKeyExchange().setKeysExchanged(!0),
          t.emit(me.KEYS_EXCHANGED, {keysExchanged: !0, isOriginator: !0}),
          t.emit(me.AUTHORIZED),
          t.emit(me.CLIENTS_READY),
          t.emit(me.CHANNEL_PERSISTENCE));
        try {
          ((c.channelConfig = Object.assign(
            Object.assign({}, c.channelConfig),
            {
              localKey:
                (n = c.communicationLayer) === null || n === void 0
                  ? void 0
                  : n.getKeyExchange().getKeyInfo().ecies.private,
              otherKey:
                (r = c.communicationLayer) === null || r === void 0
                  ? void 0
                  : r.getKeyExchange().getOtherPublicKey(),
              channelId: (i = c.channelId) !== null && i !== void 0 ? i : '',
              validUntil:
                (o =
                  (s = c.channelConfig) === null || s === void 0
                    ? void 0
                    : s.validUntil) !== null && o !== void 0
                  ? o
                  : xc,
              relayPersistence: !0
            }
          )),
            yield (a = c.storageManager) === null || a === void 0
              ? void 0
              : a.persistChannelConfig(c.channelConfig));
        } catch {}
      });
  }
  function G_({
    communicationLayerPreference: t,
    otherPublicKey: e,
    reconnect: n,
    ecies: r,
    communicationServerUrl: i = Sc,
    instance: s
  }) {
    var o, a, c, l, u, d, f, h, g, m, y;
    const {state: p} = s;
    if (
      (te.RemoteCommunication(
        '[initCommunicationLayer()] ',
        JSON.stringify(p, null, 2)
      ),
      t !== ta.SOCKET)
    )
      throw new Error('Invalid communication protocol');
    p.communicationLayer = new Oj({
      communicationLayerPreference: t,
      otherPublicKey: e,
      reconnect: n,
      transports: p.transports,
      communicationServerUrl: i,
      context: p.context,
      ecies: r,
      logging: p.logging,
      remote: s
    });
    let b = (typeof document < 'u' && document.URL) || '',
      v = (typeof document < 'u' && document.title) || '';
    (!((o = p.dappMetadata) === null || o === void 0) &&
      o.url &&
      (b = p.dappMetadata.url),
      !((a = p.dappMetadata) === null || a === void 0) &&
        a.name &&
        (v = p.dappMetadata.name));
    const x =
        (d =
          (l =
            (c = p.dappMetadata) === null || c === void 0 ? void 0 : c.name) !==
            null && l !== void 0
            ? l
            : (u = p.dappMetadata) === null || u === void 0
              ? void 0
              : u.url) !== null && d !== void 0
          ? d
          : 'N/A',
      C =
        typeof window < 'u' &&
        window.location !== void 0 &&
        (f = window.location.hostname) !== null &&
        f !== void 0
          ? f
          : x,
      $ = {
        url: b,
        title: v,
        source:
          (h = p.dappMetadata) === null || h === void 0 ? void 0 : h.source,
        dappId: C,
        anonId: p.anonId,
        icon:
          ((g = p.dappMetadata) === null || g === void 0
            ? void 0
            : g.iconUrl) ||
          ((m = p.dappMetadata) === null || m === void 0
            ? void 0
            : m.base64Icon),
        platform: p.platformType,
        apiVersion: io.version,
        connector:
          (y = p.dappMetadata) === null || y === void 0 ? void 0 : y.connector
      };
    p.originatorInfo = $;
    const G = {
      [me.AUTHORIZED]: Nj(s),
      [me.MESSAGE]: Hj(s),
      [me.CHANNEL_PERSISTENCE]: Kj(s),
      [me.CLIENTS_CONNECTED]: Bj(s, t),
      [me.KEYS_EXCHANGED]: $j(s, t),
      [me.SOCKET_DISCONNECTED]: Uj(s),
      [me.SOCKET_RECONNECT]: jj(s),
      [me.CLIENTS_DISCONNECTED]: Dj(s),
      [me.KEY_INFO]: () => {},
      [me.CHANNEL_CREATED]: Lj(s),
      [me.CLIENTS_WAITING]: Fj(s),
      [me.RPC_UPDATE]: (L) => {
        s.emit(me.RPC_UPDATE, L);
      }
    };
    for (const [L, F] of Object.entries(G))
      try {
        p.communicationLayer.on(L, F);
      } catch {}
  }
  function P5(t) {
    return ue(this, arguments, void 0, function* ({options: e, instance: n}) {
      const {state: r} = n;
      return (
        te.RemoteCommunication(
          `[RemoteCommunication: disconnect()] channel=${r.channelId}`,
          e
        ),
        new Promise((i, s) => {
          var o, a, c, l, u, d;
          e != null && e.terminate
            ? (n.state.ready &&
                ss(
                  {
                    id:
                      (o = n.state.channelId) !== null && o !== void 0 ? o : '',
                    event: Mt.TERMINATED
                  },
                  n.state.communicationServerUrl
                ).catch((f) => {}),
              (r.ready = !1),
              (r.paused = !1),
              (a = r.storageManager) === null ||
                a === void 0 ||
                a.terminate(
                  (c = r.channelId) !== null && c !== void 0 ? c : ''
                ),
              (n.state.terminated = !0),
              e.sendMessage
                ? !((l = r.communicationLayer) === null || l === void 0) &&
                  l.getKeyInfo().keysExchanged &&
                  n.state.communicationLayer &&
                  k5(n.state.communicationLayer, {type: St.TERMINATE})
                    .then(() => {
                      i(!0);
                    })
                    .catch((f) => {
                      s(f);
                    })
                : i(!0),
              (r.authorized = !1),
              (r.relayPersistence = !1),
              (r.channelId = Ls()),
              (e.channelId = r.channelId),
              (r.channelConfig = void 0),
              (r.originatorConnectStarted = !1),
              (u = r.communicationLayer) === null ||
                u === void 0 ||
                u.disconnect(e),
              n.setConnectionStatus(Xt.TERMINATED))
            : ((d = r.communicationLayer) === null ||
                d === void 0 ||
                d.disconnect(e),
              n.setConnectionStatus(Xt.DISCONNECTED),
              i(!0));
        })
      );
    });
  }
  (((ta || (ta = {})).SOCKET = 'socket'),
    (function (t) {
      ((t.NonBrowser = 'nodejs'),
        (t.MetaMaskMobileWebview = 'in-app-browser'),
        (t.DesktopWeb = 'web-desktop'),
        (t.MobileWeb = 'web-mobile'),
        (t.ReactNative = 'react-native'));
    })(fn || (fn = {})));
  class qj extends Fp.EventEmitter2 {
    constructor(e) {
      (super(),
        (this.state = {
          ready: !1,
          anonId: '',
          authorized: !1,
          isOriginator: !1,
          terminated: !1,
          protocolVersion: 1,
          paused: !1,
          deeplinkProtocolAvailable: !1,
          platformType: 'metamask-mobile',
          analytics: !1,
          reconnection: !1,
          originatorInfoSent: !1,
          communicationServerUrl: Sc,
          context: '',
          persist: !1,
          clientsConnected: !1,
          sessionDuration: xc,
          originatorConnectStarted: !1,
          debug: !1,
          _connectionStatus: Xt.DISCONNECTED
        }),
        (this._options = e));
      const {
        anonId: n,
        platformType: r,
        communicationLayerPreference: i,
        otherPublicKey: s,
        reconnect: o,
        walletInfo: a,
        dappMetadata: c,
        protocolVersion: l,
        transports: u,
        context: d,
        relayPersistence: f,
        ecies: h,
        analytics: g = !1,
        storage: m,
        sdkVersion: y,
        communicationServerUrl: p = Sc,
        logging: b,
        autoConnect: v = {timeout: Ij}
      } = e;
      ((this.state.anonId = n),
        (this.state.otherPublicKey = s),
        (this.state.dappMetadata = c),
        (this.state.walletInfo = a),
        (this.state.transports = u),
        (this.state.platformType = r),
        (this.state.analytics = g),
        (this.state.protocolVersion = l ?? 1),
        (this.state.isOriginator = !s),
        (this.state.relayPersistence = f),
        (this.state.communicationServerUrl = p),
        (this.state.context = d),
        (this.state.terminated = !1),
        (this.state.sdkVersion = y),
        this.setMaxListeners(50),
        this.setConnectionStatus(Xt.DISCONNECTED),
        m != null && m.duration && (this.state.sessionDuration = xc),
        (this.state.storageOptions = m),
        (this.state.autoConnectOptions = v),
        (this.state.debug = (b == null ? void 0 : b.remoteLayer) === !0),
        (b == null ? void 0 : b.remoteLayer) === !0 &&
          Cn.enable('RemoteCommunication:Layer'),
        (b == null ? void 0 : b.serviceLayer) === !0 &&
          Cn.enable('SocketService:Layer'),
        (b == null ? void 0 : b.eciesLayer) === !0 && Cn.enable('ECIES:Layer'),
        (b == null ? void 0 : b.keyExchangeLayer) === !0 &&
          Cn.enable('KeyExchange:Layer'),
        (this.state.logging = b),
        m != null &&
          m.storageManager &&
          (this.state.storageManager = m.storageManager),
        te.RemoteCommunication(
          `[RemoteCommunication: constructor()] protocolVersion=${l} relayPersistence=${f} isOriginator=${this.state.isOriginator} communicationLayerPreference=${i} otherPublicKey=${s} reconnect=${o}`
        ),
        this.state.isOriginator ||
          G_({
            communicationLayerPreference: i,
            otherPublicKey: s,
            reconnect: o,
            ecies: h,
            communicationServerUrl: p,
            instance: this
          }),
        this.emitServiceStatusEvent({context: 'constructor'}));
    }
    initFromDappStorage() {
      return ue(this, void 0, void 0, function* () {
        var e;
        if (this.state.storageManager) {
          const n = yield this.state.storageManager.getPersistedChannelConfig(
            {}
          );
          n &&
            ((this.state.channelConfig = n),
            (this.state.channelId = n.channelId),
            (this.state.deeplinkProtocolAvailable =
              (e = n.deeplinkProtocolAvailable) !== null && e !== void 0 && e),
            n.relayPersistence &&
              ((this.state.authorized = !0),
              (this.state.ready = !0),
              this.setConnectionStatus(Xt.LINKED),
              yield this.connectToChannel({channelId: n.channelId})));
        }
        G_({
          communicationLayerPreference: ta.SOCKET,
          otherPublicKey: this.state.otherPublicKey,
          reconnect: this._options.reconnect,
          ecies: this._options.ecies,
          communicationServerUrl: this.state.communicationServerUrl,
          instance: this
        });
      });
    }
    originatorSessionConnect() {
      return ue(this, void 0, void 0, function* () {
        return yield (function (e) {
          return ue(this, void 0, void 0, function* () {
            var n;
            const {state: r} = e;
            if (!r.storageManager)
              return void te.RemoteCommunication(
                '[RemoteCommunication: originatorSessionConnect()] no storage manager defined - skip'
              );
            const i = yield r.storageManager.getPersistedChannelConfig({});
            if (
              (te.RemoteCommunication(
                `[RemoteCommunication: originatorSessionConnect()] autoStarted=${r.originatorConnectStarted} channelConfig`,
                i
              ),
              (n = r.communicationLayer) === null || n === void 0
                ? void 0
                : n.isConnected())
            )
              return (
                te.RemoteCommunication(
                  '[RemoteCommunication: originatorSessionConnect()] socket already connected - skip'
                ),
                i
              );
            if (i) {
              if (i.validUntil > Date.now())
                return (
                  (r.channelConfig = i),
                  (r.originatorConnectStarted = !0),
                  (r.channelId = i == null ? void 0 : i.channelId),
                  (r.reconnection = !0),
                  i
                );
              te.RemoteCommunication(
                '[RemoteCommunication: autoConnect()] Session has expired'
              );
            }
            r.originatorConnectStarted = !1;
          });
        })(this);
      });
    }
    generateChannelIdConnect() {
      return ue(this, void 0, void 0, function* () {
        return (function (e) {
          return ue(this, void 0, void 0, function* () {
            var n, r, i, s, o, a;
            if (!e.communicationLayer)
              throw new Error('communication layer not initialized');
            if (e.ready) throw new Error('Channel already connected');
            if (
              e.channelId &&
              !((n = e.communicationLayer) === null || n === void 0) &&
              n.isConnected()
            )
              return (
                (e.channelConfig = Object.assign(
                  Object.assign({}, e.channelConfig),
                  {
                    channelId: e.channelId,
                    validUntil: Date.now() + e.sessionDuration
                  }
                )),
                (r = e.storageManager) === null ||
                  r === void 0 ||
                  r.persistChannelConfig(e.channelConfig),
                {
                  channelId: e.channelId,
                  privKey:
                    (s =
                      (i = e.communicationLayer) === null || i === void 0
                        ? void 0
                        : i.getKeyInfo()) === null || s === void 0
                      ? void 0
                      : s.ecies.private,
                  pubKey:
                    (a =
                      (o = e.communicationLayer) === null || o === void 0
                        ? void 0
                        : o.getKeyInfo()) === null || a === void 0
                      ? void 0
                      : a.ecies.public
                }
              );
            te.RemoteCommunication(
              '[RemoteCommunication: generateChannelId()]'
            );
            const c = yield e.communicationLayer.createChannel();
            te.RemoteCommunication(
              '[RemoteCommunication: generateChannelId()] channel created',
              c
            );
            const l = Object.assign(Object.assign({}, e.channelConfig), {
              channelId: c.channelId,
              localKey: c.privKey,
              validUntil: Date.now() + e.sessionDuration
            });
            return (
              (e.channelId = c.channelId),
              (e.channelConfig = l),
              {channelId: e.channelId, pubKey: c.pubKey, privKey: c.privKey}
            );
          });
        })(this.state);
      });
    }
    clean() {
      return I5(this.state);
    }
    connectToChannel({channelId: e, withKeyExchange: n, authorized: r}) {
      return (function (i) {
        return ue(
          this,
          arguments,
          void 0,
          function* ({
            channelId: s,
            withKeyExchange: o,
            authorized: a,
            state: c
          }) {
            var l, u, d;
            if (!Pg(s))
              throw (
                te.RemoteCommunication(
                  `[RemoteCommunication: connectToChannel()] context=${c.context} invalid channel channelId=${s}`
                ),
                new Error(`Invalid channel ${s}`)
              );
            if (
              (te.RemoteCommunication(
                `[RemoteCommunication: connectToChannel()] context=${c.context} channelId=${s} withKeyExchange=${o}`
              ),
              (l = c.communicationLayer) === null || l === void 0
                ? void 0
                : l.isConnected())
            )
              return void te.RemoteCommunication(
                `[RemoteCommunication: connectToChannel()] context=${c.context} already connected - interrupt connection.`
              );
            ((c.channelId = s),
              yield (u = c.communicationLayer) === null || u === void 0
                ? void 0
                : u.connectToChannel({
                    channelId: s,
                    authorized: a,
                    withKeyExchange: o
                  }));
            const f = Object.assign(Object.assign({}, c.channelConfig), {
              channelId: s,
              validUntil: Date.now() + c.sessionDuration
            });
            ((c.channelConfig = f),
              (d = c.storageManager) === null ||
                d === void 0 ||
                d.persistChannelConfig(f));
          }
        );
      })({channelId: e, authorized: r, withKeyExchange: n, state: this.state});
    }
    sendMessage(e) {
      return ue(this, void 0, void 0, function* () {
        const n = this.state.isOriginator && e.method && Uu(e.method);
        n && kt.analytics.track('sdk_action_requested', {action: e.method});
        try {
          return yield (function (r, i) {
            return ue(this, void 0, void 0, function* () {
              var s, o;
              const {state: a} = r;
              (te.RemoteCommunication(
                `[RemoteCommunication: sendMessage()] context=${a.context} paused=${a.paused} ready=${a.ready} relayPersistence=${a.relayPersistence} authorized=${a.authorized} socket=${(s = a.communicationLayer) === null || s === void 0 ? void 0 : s.isConnected()} clientsConnected=${a.clientsConnected} status=${a._connectionStatus}`,
                i
              ),
                a.relayPersistence ||
                  (a.ready &&
                    !((o = a.communicationLayer) === null || o === void 0) &&
                    o.isConnected() &&
                    a.clientsConnected) ||
                  (te.RemoteCommunication(
                    `[RemoteCommunication: sendMessage()] context=${a.context}  SKIP message waiting for MM mobile readiness.`
                  ),
                  yield new Promise((c) => {
                    r.once(me.CLIENTS_READY, c);
                  }),
                  te.RemoteCommunication(
                    `[RemoteCommunication: sendMessage()] context=${a.context}  AFTER SKIP / READY -- sending pending message`
                  )));
              try {
                return yield (function (l, u) {
                  return ue(this, void 0, void 0, function* () {
                    return new Promise((d) => {
                      var f;
                      const {state: h} = l;
                      (te.RemoteCommunication(
                        `[RemoteCommunication: handleAuthorization()] context=${h.context} ready=${h.ready} authorized=${h.authorized} method=${u.method}`
                      ),
                        !h.isOriginator || h.authorized || h.relayPersistence
                          ? (f = h.communicationLayer) === null ||
                            f === void 0 ||
                            f
                              .sendMessage(u)
                              .then((g) => {
                                d(g);
                              })
                              .catch((g) => {
                                d(!1);
                              })
                          : l.once(me.AUTHORIZED, () => {
                              var g;
                              (te.RemoteCommunication(
                                `[RemoteCommunication: handleAuthorization()] context=${h.context}  AFTER SKIP / AUTHORIZED -- sending pending message`
                              ),
                                (g = h.communicationLayer) === null ||
                                  g === void 0 ||
                                  g
                                    .sendMessage(u)
                                    .then((m) => {
                                      d(m);
                                    })
                                    .catch((m) => {
                                      d(!1);
                                    }));
                            }));
                    });
                  });
                })(r, i);
              } catch (c) {
                throw c;
              }
            });
          })(this, e);
        } catch (r) {
          throw (
            n && kt.analytics.track('sdk_action_failed', {action: e.method}),
            r
          );
        }
      });
    }
    testStorage() {
      return ue(this, void 0, void 0, function* () {
        return (function (e) {
          return ue(this, void 0, void 0, function* () {
            var n;
            const r = yield (n = e.storageManager) === null || n === void 0
              ? void 0
              : n.getPersistedChannelConfig();
            te.RemoteCommunication(
              '[RemoteCommunication: testStorage()] res',
              r
            );
          });
        })(this.state);
      });
    }
    hasDeeplinkProtocol() {
      return this.state.deeplinkProtocolAvailable;
    }
    getChannelConfig() {
      return this.state.channelConfig;
    }
    isReady() {
      return this.state.ready;
    }
    isConnected() {
      var e;
      return (e = this.state.communicationLayer) === null || e === void 0
        ? void 0
        : e.isConnected();
    }
    isAuthorized() {
      return this.state.authorized;
    }
    isPaused() {
      return this.state.paused;
    }
    getCommunicationLayer() {
      return this.state.communicationLayer;
    }
    ping() {
      return ue(this, void 0, void 0, function* () {
        var e;
        (te.RemoteCommunication(
          `[RemoteCommunication: ping()] channel=${this.state.channelId}`
        ),
          yield (e = this.state.communicationLayer) === null || e === void 0
            ? void 0
            : e.ping());
      });
    }
    testLogger() {
      (te.RemoteCommunication(`testLogger() channel=${this.state.channelId}`),
        te.SocketService(`testLogger() channel=${this.state.channelId}`),
        te.Ecies(`testLogger() channel=${this.state.channelId}`),
        te.KeyExchange(`testLogger() channel=${this.state.channelId}`));
    }
    keyCheck() {
      var e;
      (te.RemoteCommunication(
        `[RemoteCommunication: keyCheck()] channel=${this.state.channelId}`
      ),
        (e = this.state.communicationLayer) === null ||
          e === void 0 ||
          e.keyCheck());
    }
    setConnectionStatus(e) {
      this.state._connectionStatus !== e &&
        ((this.state._connectionStatus = e),
        this.emit(me.CONNECTION_STATUS, e),
        this.emitServiceStatusEvent({context: 'setConnectionStatus'}));
    }
    emitServiceStatusEvent(e = {}) {
      this.emit(me.SERVICE_STATUS, this.getServiceStatus());
    }
    getConnectionStatus() {
      return this.state._connectionStatus;
    }
    getServiceStatus() {
      return {
        originatorInfo: this.state.originatorInfo,
        keyInfo: this.getKeyInfo(),
        connectionStatus: this.state._connectionStatus,
        channelConfig: this.state.channelConfig,
        channelId: this.state.channelId
      };
    }
    getKeyInfo() {
      var e;
      return (e = this.state.communicationLayer) === null || e === void 0
        ? void 0
        : e.getKeyInfo();
    }
    resetKeys() {
      var e;
      (e = this.state.communicationLayer) === null ||
        e === void 0 ||
        e.resetKeys();
    }
    setOtherPublicKey(e) {
      var n;
      const r =
        (n = this.state.communicationLayer) === null || n === void 0
          ? void 0
          : n.getKeyExchange();
      if (!r) throw new Error('KeyExchange is not initialized.');
      r.getOtherPublicKey() !== e && r.setOtherPublicKey(e);
    }
    pause() {
      return ue(this, void 0, void 0, function* () {
        var e;
        (te.RemoteCommunication(
          `[RemoteCommunication: pause()] channel=${this.state.channelId}`
        ),
          yield (e = this.state.communicationLayer) === null || e === void 0
            ? void 0
            : e.pause(),
          this.setConnectionStatus(Xt.PAUSED));
      });
    }
    getVersion() {
      return io.version;
    }
    hasRelayPersistence() {
      var e;
      return (e = this.state.relayPersistence) !== null && e !== void 0 && e;
    }
    resume() {
      return ue(this, void 0, void 0, function* () {
        return (function (e) {
          return ue(this, void 0, void 0, function* () {
            var n;
            const {state: r} = e;
            (te.RemoteCommunication(
              `[RemoteCommunication: resume()] channel=${r.channelId}`
            ),
              yield (n = r.communicationLayer) === null || n === void 0
                ? void 0
                : n.resume(),
              e.setConnectionStatus(Xt.LINKED));
          });
        })(this);
      });
    }
    encrypt(e) {
      var n, r, i;
      const s =
          (n = this.state.communicationLayer) === null || n === void 0
            ? void 0
            : n.getKeyExchange(),
        o = s == null ? void 0 : s.getOtherPublicKey();
      if (!o) throw new Error('KeyExchange not completed');
      return (i =
        (r = this.state.communicationLayer) === null || r === void 0
          ? void 0
          : r.state.eciesInstance) === null || i === void 0
        ? void 0
        : i.encrypt(e, o);
    }
    decrypt(e) {
      var n, r, i;
      if (
        !(
          !((n = this.state.communicationLayer) === null || n === void 0) &&
          n.state.eciesInstance
        )
      )
        throw new Error('ECIES instance is not initialized');
      return (i =
        (r = this.state.communicationLayer) === null || r === void 0
          ? void 0
          : r.state.eciesInstance) === null || i === void 0
        ? void 0
        : i.decrypt(e);
    }
    getChannelId() {
      return this.state.channelId;
    }
    getRPCMethodTracker() {
      var e;
      return (e = this.state.communicationLayer) === null || e === void 0
        ? void 0
        : e.getRPCMethodTracker();
    }
    reject({channelId: e}) {
      return (function (n) {
        return ue(
          this,
          arguments,
          void 0,
          function* ({channelId: r, state: i}) {
            var s, o, a;
            if (!Pg(r))
              throw (
                te.RemoteCommunication(
                  `[RemoteCommunication: connectToChannel()] context=${i.context} invalid channel channelId=${r}`
                ),
                new Error(`Invalid channel ${r}`)
              );
            if (i.isOriginator)
              return void te.RemoteCommunication(
                `[RemoteCommunication: reject()] context=${i.context} isOriginator=${i.isOriginator} channelId=${r}`
              );
            const {socket: c} =
              (o =
                (s = i.communicationLayer) === null || s === void 0
                  ? void 0
                  : s.state) !== null && o !== void 0
                ? o
                : {};
            ((c != null && c.connected) ||
              (te.RemoteCommunication(
                `[RemoteCommunication: reject()] context=${i.context} socket already connected`
              ),
              c == null || c.connect()),
              ss(
                Object.assign(
                  Object.assign({id: r, event: Mt.REJECTED}, i.originatorInfo),
                  {
                    sdkVersion: i.sdkVersion,
                    commLayerVersion: io.version,
                    walletVersion:
                      (a = i.walletInfo) === null || a === void 0
                        ? void 0
                        : a.version
                  }
                ),
                i.communicationServerUrl
              ).catch((l) => {}),
              yield new Promise((l, u) => {
                c == null ||
                  c.emit(me.REJECTED, {channelId: r}, (d, f) => {
                    (te.RemoteCommunication(
                      `[RemoteCommunication: reject()] context=${i.context} socket=${c == null ? void 0 : c.id}`,
                      {error: d, response: f}
                    ),
                      d ? u(d) : l(f));
                  });
              }));
          }
        );
      })({channelId: e, state: this.state});
    }
    disconnect(e) {
      return ue(this, void 0, void 0, function* () {
        return P5({options: e, instance: this});
      });
    }
  }
  (function (t) {
    ((t.RENEW = 'renew'), (t.LINK = 'link'));
  })(V_ || (V_ = {}));
  var Vj = 'ERC721',
    Gj = 'ERC1155',
    Tt = {
      errors: {
        disconnected: () =>
          'MetaMask: Disconnected from chain. Attempting to connect.',
        permanentlyDisconnected: () =>
          'MetaMask: Disconnected from MetaMask background. Page reload required.',
        sendSiteMetadata: () =>
          'MetaMask: Failed to send site metadata. This is an internal error, please report this bug.',
        unsupportedSync: (t) =>
          `MetaMask: The MetaMask Ethereum provider does not support synchronous methods like ${t} without a callback parameter.`,
        invalidDuplexStream: () =>
          'Must provide a Node.js-style duplex stream.',
        invalidNetworkParams: () =>
          'MetaMask: Received invalid network parameters. Please report this bug.',
        invalidRequestArgs: () =>
          'Expected a single, non-array, object argument.',
        invalidRequestMethod: () => "'args.method' must be a non-empty string.",
        invalidRequestParams: () =>
          "'args.params' must be an object or array if provided.",
        invalidLoggerObject: () =>
          "'args.logger' must be an object if provided.",
        invalidLoggerMethod: (t) =>
          `'args.logger' must include required method '${t}'.`
      },
      info: {connected: (t) => `MetaMask: Connected to chain with ID "${t}".`},
      warnings: {
        chainIdDeprecation: `MetaMask: 'ethereum.chainId' is deprecated and may be removed in the future. Please use the 'eth_chainId' RPC method instead.
For more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23`,
        networkVersionDeprecation: `MetaMask: 'ethereum.networkVersion' is deprecated and may be removed in the future. Please use the 'net_version' RPC method instead.
For more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23`,
        selectedAddressDeprecation: `MetaMask: 'ethereum.selectedAddress' is deprecated and may be removed in the future. Please use the 'eth_accounts' RPC method instead.
For more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23`,
        enableDeprecation: `MetaMask: 'ethereum.enable()' is deprecated and may be removed in the future. Please use the 'eth_requestAccounts' RPC method instead.
For more information, see: https://eips.ethereum.org/EIPS/eip-1102`,
        sendDeprecation: `MetaMask: 'ethereum.send(...)' is deprecated and may be removed in the future. Please use 'ethereum.sendAsync(...)' or 'ethereum.request(...)' instead.
For more information, see: https://eips.ethereum.org/EIPS/eip-1193`,
        events: {
          close: `MetaMask: The event 'close' is deprecated and may be removed in the future. Please use 'disconnect' instead.
For more information, see: https://eips.ethereum.org/EIPS/eip-1193#disconnect`,
          data: `MetaMask: The event 'data' is deprecated and will be removed in the future. Use 'message' instead.
For more information, see: https://eips.ethereum.org/EIPS/eip-1193#message`,
          networkChanged: `MetaMask: The event 'networkChanged' is deprecated and may be removed in the future. Use 'chainChanged' instead.
For more information, see: https://eips.ethereum.org/EIPS/eip-1193#chainchanged`,
          notification: `MetaMask: The event 'notification' is deprecated and may be removed in the future. Use 'message' instead.
For more information, see: https://eips.ethereum.org/EIPS/eip-1193#message`
        },
        rpc: {
          ethDecryptDeprecation: `MetaMask: The RPC method 'eth_decrypt' is deprecated and may be removed in the future.
For more information, see: https://medium.com/metamask/metamask-api-method-deprecation-2b0564a84686`,
          ethGetEncryptionPublicKeyDeprecation: `MetaMask: The RPC method 'eth_getEncryptionPublicKey' is deprecated and may be removed in the future.
For more information, see: https://medium.com/metamask/metamask-api-method-deprecation-2b0564a84686`,
          walletWatchAssetNFTExperimental: `MetaMask: The RPC method 'wallet_watchAsset' is experimental for ERC721/ERC1155 assets and may change in the future.
For more information, see: https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-1.md and https://github.com/MetaMask/metamask-improvement-proposals/blob/main/PROCESS-GUIDE.md#proposal-lifecycle`
        },
        experimentalMethods:
          "MetaMask: 'ethereum._metamask' exposes non-standard, experimental methods. They may be removed or changed without warning."
      }
    };
  function zj(t) {
    const e = {
      ethDecryptDeprecation: !1,
      ethGetEncryptionPublicKeyDeprecation: !1,
      walletWatchAssetNFTExperimental: !1
    };
    return (n, r, i) => {
      var s;
      (e.ethDecryptDeprecation || n.method !== 'eth_decrypt'
        ? e.ethGetEncryptionPublicKeyDeprecation ||
          n.method !== 'eth_getEncryptionPublicKey'
          ? !e.walletWatchAssetNFTExperimental &&
            n.method === 'wallet_watchAsset' &&
            [Vj, Gj].includes(
              ((s = n.params) == null ? void 0 : s.type) || ''
            ) &&
            (t.warn(Tt.warnings.rpc.walletWatchAssetNFTExperimental),
            (e.walletWatchAssetNFTExperimental = !0))
          : (t.warn(Tt.warnings.rpc.ethGetEncryptionPublicKeyDeprecation),
            (e.ethGetEncryptionPublicKeyDeprecation = !0))
        : (t.warn(Tt.warnings.rpc.ethDecryptDeprecation),
          (e.ethDecryptDeprecation = !0)),
        i());
    };
  }
  var M5 = 4294967295,
    z_ = Math.floor(Math.random() * M5);
  function Wj() {
    return (t, e, n, r) => {
      const i = t.id,
        s = (z_ = (z_ + 1) % M5);
      ((t.id = s),
        (e.id = s),
        n((o) => {
          ((t.id = i), (e.id = i), o());
        }));
    };
  }
  var r1 = (t, e, n) => {
      if (!e.has(t)) throw TypeError('Cannot ' + n);
    },
    Ds = (t, e, n) => (
      r1(t, e, 'read from private field'),
      n ? n.call(t) : e.get(t)
    ),
    kr = (t, e, n) => {
      if (e.has(t))
        throw TypeError('Cannot add the same private member more than once');
      e instanceof WeakSet ? e.add(t) : e.set(t, n);
    },
    Ad = (t, e, n, r) => (r1(t, e, 'write to private field'), e.set(t, n), n),
    wn = (t, e, n) => (r1(t, e, 'access private method'), n),
    Ps = {
      invalidInput: -32e3,
      resourceNotFound: -32001,
      resourceUnavailable: -32002,
      transactionRejected: -32003,
      methodNotSupported: -32004,
      limitExceeded: -32005,
      parse: -32700,
      invalidRequest: -32600,
      methodNotFound: -32601,
      invalidParams: -32602,
      internal: -32603
    },
    W_ = {
      '-32700': {
        standard: 'JSON RPC 2.0',
        message:
          'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.'
      },
      '-32600': {
        standard: 'JSON RPC 2.0',
        message: 'The JSON sent is not a valid Request object.'
      },
      '-32601': {
        standard: 'JSON RPC 2.0',
        message: 'The method does not exist / is not available.'
      },
      '-32602': {
        standard: 'JSON RPC 2.0',
        message: 'Invalid method parameter(s).'
      },
      '-32603': {standard: 'JSON RPC 2.0', message: 'Internal JSON-RPC error.'},
      '-32000': {standard: 'EIP-1474', message: 'Invalid input.'},
      '-32001': {standard: 'EIP-1474', message: 'Resource not found.'},
      '-32002': {standard: 'EIP-1474', message: 'Resource unavailable.'},
      '-32003': {standard: 'EIP-1474', message: 'Transaction rejected.'},
      '-32004': {standard: 'EIP-1474', message: 'Method not supported.'},
      '-32005': {standard: 'EIP-1474', message: 'Request limit exceeded.'},
      4001: {standard: 'EIP-1193', message: 'User rejected the request.'},
      4100: {
        standard: 'EIP-1193',
        message:
          'The requested account and/or method has not been authorized by the user.'
      },
      4200: {
        standard: 'EIP-1193',
        message:
          'The requested method is not supported by this Ethereum provider.'
      },
      4900: {
        standard: 'EIP-1193',
        message: 'The provider is disconnected from all chains.'
      },
      4901: {
        standard: 'EIP-1193',
        message: 'The provider is disconnected from the specified chain.'
      }
    };
  function Z_(t) {
    return !!t && typeof t == 'object' && !Array.isArray(t);
  }
  var Oh = (t, e) => Object.hasOwnProperty.call(t, e);
  class Zj extends TypeError {
    constructor(e, n) {
      let r;
      const {message: i, explanation: s, ...o} = e,
        {path: a} = e,
        c = a.length === 0 ? i : `At path: ${a.join('.')} -- ${i}`;
      (super(s ?? c),
        s != null && (this.cause = c),
        Object.assign(this, o),
        (this.name = this.constructor.name),
        (this.failures = () => r ?? (r = [e, ...n()])));
    }
  }
  function Qi(t) {
    return typeof t == 'object' && t != null;
  }
  function wi(t) {
    return typeof t == 'symbol'
      ? t.toString()
      : typeof t == 'string'
        ? JSON.stringify(t)
        : `${t}`;
  }
  function Yj(t, e, n, r) {
    if (t === !0) return;
    t === !1 ? (t = {}) : typeof t == 'string' && (t = {message: t});
    const {path: i, branch: s} = e,
      {type: o} = n,
      {
        refinement: a,
        message:
          c = `Expected a value of type \`${o}\`${a ? ` with refinement \`${a}\`` : ''}, but received: \`${wi(r)}\``
      } = t;
    return {
      value: r,
      type: o,
      refinement: a,
      key: i[i.length - 1],
      path: i,
      branch: s,
      ...t,
      message: c
    };
  }
  function* Y_(t, e, n, r) {
    (function (i) {
      return Qi(i) && typeof i[Symbol.iterator] == 'function';
    })(t) || (t = [t]);
    for (const i of t) {
      const s = Yj(i, e, n, r);
      s && (yield s);
    }
  }
  function* i1(t, e, n = {}) {
    const {path: r = [], branch: i = [t], coerce: s = !1, mask: o = !1} = n,
      a = {path: r, branch: i};
    if (
      s &&
      ((t = e.coercer(t, a)),
      o && e.type !== 'type' && Qi(e.schema) && Qi(t) && !Array.isArray(t))
    )
      for (const l in t) e.schema[l] === void 0 && delete t[l];
    let c = 'valid';
    for (const l of e.validator(t, a))
      ((l.explanation = n.message), (c = 'not_valid'), yield [l, void 0]);
    for (let [l, u, d] of e.entries(t, a)) {
      const f = i1(u, d, {
        path: l === void 0 ? r : [...r, l],
        branch: l === void 0 ? i : [...i, u],
        coerce: s,
        mask: o,
        message: n.message
      });
      for (const h of f)
        h[0]
          ? ((c = h[0].refinement != null ? 'not_refined' : 'not_valid'),
            yield [h[0], void 0])
          : s &&
            ((u = h[1]),
            l === void 0
              ? (t = u)
              : t instanceof Map
                ? t.set(l, u)
                : t instanceof Set
                  ? t.add(u)
                  : Qi(t) && (u !== void 0 || l in t) && (t[l] = u));
    }
    if (c !== 'not_valid')
      for (const l of e.refiner(t, a))
        ((l.explanation = n.message), (c = 'not_refined'), yield [l, void 0]);
    c === 'valid' && (yield [void 0, t]);
  }
  class jr {
    constructor(e) {
      const {
        type: n,
        schema: r,
        validator: i,
        refiner: s,
        coercer: o = (c) => c,
        entries: a = function* () {}
      } = e;
      ((this.type = n),
        (this.schema = r),
        (this.entries = a),
        (this.coercer = o),
        (this.validator = i ? (c, l) => Y_(i(c, l), l, this, c) : () => []),
        (this.refiner = s ? (c, l) => Y_(s(c, l), l, this, c) : () => []));
    }
    assert(e, n) {
      return O5(e, this, n);
    }
    create(e, n) {
      return N5(e, this, n);
    }
    is(e) {
      return Dc(e, this);
    }
    mask(e, n) {
      return (function (r, i, s) {
        const o = gu(r, i, {coerce: !0, mask: !0, message: s});
        if (o[0]) throw o[0];
        return o[1];
      })(e, this, n);
    }
    validate(e, n = {}) {
      return gu(e, this, n);
    }
  }
  function O5(t, e, n) {
    const r = gu(t, e, {message: n});
    if (r[0]) throw r[0];
  }
  function N5(t, e, n) {
    const r = gu(t, e, {coerce: !0, message: n});
    if (r[0]) throw r[0];
    return r[1];
  }
  function Dc(t, e) {
    return !gu(t, e)[0];
  }
  function gu(t, e, n = {}) {
    const r = i1(t, e, n),
      i = (function (s) {
        const {done: o, value: a} = s.next();
        return o ? void 0 : a;
      })(r);
    return i[0]
      ? [
          new Zj(i[0], function* () {
            for (const o of r) o[0] && (yield o[0]);
          }),
          void 0
        ]
      : [void 0, i[1]];
  }
  function so(t, e) {
    return new jr({type: t, schema: null, validator: e});
  }
  function Q_(t) {
    let e;
    return new jr({
      type: 'lazy',
      schema: null,
      *entries(n, r) {
        (e ?? (e = t()), yield* e.entries(n, r));
      },
      validator: (n, r) => (e ?? (e = t()), e.validator(n, r)),
      coercer: (n, r) => (e ?? (e = t()), e.coercer(n, r)),
      refiner: (n, r) => (e ?? (e = t()), e.refiner(n, r))
    });
  }
  function L5(t) {
    return new jr({
      type: 'array',
      schema: t,
      *entries(e) {
        if (t && Array.isArray(e))
          for (const [n, r] of e.entries()) yield [n, r, t];
      },
      coercer: (e) => (Array.isArray(e) ? e.slice() : e),
      validator: (e) =>
        Array.isArray(e) || `Expected an array value, but received: ${wi(e)}`
    });
  }
  function B5(t) {
    const e = wi(t),
      n = typeof t;
    return new jr({
      type: 'literal',
      schema: n === 'string' || n === 'number' || n === 'boolean' ? t : null,
      validator: (r) =>
        r === t || `Expected the literal \`${e}\`, but received: ${wi(r)}`
    });
  }
  function D5() {
    return so(
      'number',
      (t) =>
        (typeof t == 'number' && !isNaN(t)) ||
        `Expected a number, but received: ${wi(t)}`
    );
  }
  function F5(t) {
    const e = t ? Object.keys(t) : [],
      n = so('never', () => !1);
    return new jr({
      type: 'object',
      schema: t || null,
      *entries(r) {
        if (t && Qi(r)) {
          const i = new Set(Object.keys(r));
          for (const s of e) (i.delete(s), yield [s, r[s], t[s]]);
          for (const s of i) yield [s, r[s], n];
        }
      },
      validator: (r) => Qi(r) || `Expected an object, but received: ${wi(r)}`,
      coercer: (r) => (Qi(r) ? {...r} : r)
    });
  }
  function J_(t) {
    return new jr({
      ...t,
      validator: (e, n) => e === void 0 || t.validator(e, n),
      refiner: (e, n) => e === void 0 || t.refiner(e, n)
    });
  }
  function $5(t, e) {
    return new jr({
      type: 'record',
      schema: null,
      *entries(n) {
        if (Qi(n))
          for (const r in n) {
            const i = n[r];
            (yield [r, r, t], yield [r, i, e]);
          }
      },
      validator: (n) => Qi(n) || `Expected an object, but received: ${wi(n)}`
    });
  }
  function oo() {
    return so(
      'string',
      (t) => typeof t == 'string' || `Expected a string, but received: ${wi(t)}`
    );
  }
  function qp(t) {
    const e = t.map((n) => n.type).join(' | ');
    return new jr({
      type: 'union',
      schema: null,
      coercer(n) {
        for (const r of t) {
          const [i, s] = r.validate(n, {coerce: !0});
          if (!i) return s;
        }
        return n;
      },
      validator(n, r) {
        const i = [];
        for (const s of t) {
          const [...o] = i1(n, s, r),
            [a] = o;
          if (!a[0]) return [];
          for (const [c] of o) c && i.push(c);
        }
        return [
          `Expected the value to satisfy a union of \`${e}\`, but received: ${wi(n)}`,
          ...i
        ];
      }
    });
  }
  function Qj(t) {
    return (function (e) {
      return (function (n) {
        return typeof n == 'object' && n !== null && 'message' in n;
      })(e) && typeof e.message == 'string'
        ? e.message
        : e == null
          ? ''
          : String(e);
    })(t).replace(/\.$/u, '');
  }
  function Jj(t, e) {
    var r, i;
    return (
      (n = t),
      typeof ((i =
        (r = n == null ? void 0 : n.prototype) == null
          ? void 0
          : r.constructor) == null
        ? void 0
        : i.name) == 'string'
        ? new t({message: e})
        : t({message: e})
    );
    var n;
  }
  var Xj = class extends Error {
    constructor(t) {
      (super(t.message), (this.code = 'ERR_ASSERTION'));
    }
  };
  function H5() {
    throw new Error('setTimeout has not been defined');
  }
  function j5() {
    throw new Error('clearTimeout has not been defined');
  }
  var Es = H5,
    As = j5;
  function U5(t) {
    if (Es === setTimeout) return setTimeout(t, 0);
    if ((Es === H5 || !Es) && setTimeout)
      return ((Es = setTimeout), setTimeout(t, 0));
    try {
      return Es(t, 0);
    } catch {
      try {
        return Es.call(null, t, 0);
      } catch {
        return Es.call(this, t, 0);
      }
    }
  }
  (typeof kn.setTimeout == 'function' && (Es = setTimeout),
    typeof kn.clearTimeout == 'function' && (As = clearTimeout));
  var Mo,
    Zi = [],
    ec = !1,
    of = -1;
  function eU() {
    ec &&
      Mo &&
      ((ec = !1),
      Mo.length ? (Zi = Mo.concat(Zi)) : (of = -1),
      Zi.length && K5());
  }
  function K5() {
    if (!ec) {
      var t = U5(eU);
      ec = !0;
      for (var e = Zi.length; e; ) {
        for (Mo = Zi, Zi = []; ++of < e; ) Mo && Mo[of].run();
        ((of = -1), (e = Zi.length));
      }
      ((Mo = null),
        (ec = !1),
        (function (n) {
          if (As === clearTimeout) return clearTimeout(n);
          if ((As === j5 || !As) && clearTimeout)
            return ((As = clearTimeout), clearTimeout(n));
          try {
            return As(n);
          } catch {
            try {
              return As.call(null, n);
            } catch {
              return As.call(this, n);
            }
          }
        })(t));
    }
  }
  function q5(t, e) {
    ((this.fun = t), (this.array = e));
  }
  q5.prototype.run = function () {
    this.fun.apply(null, this.array);
  };
  function aa() {}
  var tU = aa,
    nU = aa,
    rU = aa,
    iU = aa,
    sU = aa,
    oU = aa,
    aU = aa,
    Ia = kn.performance || {},
    cU =
      Ia.now ||
      Ia.mozNow ||
      Ia.msNow ||
      Ia.oNow ||
      Ia.webkitNow ||
      function () {
        return new Date().getTime();
      },
    lU = new Date(),
    tt = {
      nextTick: function (t) {
        var e = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
        (Zi.push(new q5(t, e)), Zi.length !== 1 || ec || U5(K5));
      },
      title: 'browser',
      browser: !0,
      env: {},
      argv: [],
      version: '',
      versions: {},
      on: tU,
      addListener: nU,
      once: rU,
      off: iU,
      removeListener: sU,
      removeAllListeners: oU,
      emit: aU,
      binding: function (t) {
        throw new Error('process.binding is not supported');
      },
      cwd: function () {
        return '/';
      },
      chdir: function (t) {
        throw new Error('process.chdir is not supported');
      },
      umask: function () {
        return 0;
      },
      hrtime: function (t) {
        var e = 0.001 * cU.call(Ia),
          n = Math.floor(e),
          r = Math.floor((e % 1) * 1e9);
        return (
          t && ((n -= t[0]), (r -= t[1]) < 0 && (n--, (r += 1e9))),
          [n, r]
        );
      },
      platform: 'browser',
      release: {},
      config: {},
      uptime: function () {
        return (new Date() - lU) / 1e3;
      }
    },
    yu = (t) => F5(t);
  function X_({path: t, branch: e}) {
    const n = t[t.length - 1];
    return Oh(e[e.length - 2], n);
  }
  function Nh(t) {
    return new jr({
      ...t,
      type: `optional ${t.type}`,
      validator: (e, n) => !X_(n) || t.validator(e, n),
      refiner: (e, n) => !X_(n) || t.refiner(e, n)
    });
  }
  var Sd,
    e2,
    t2,
    Lh = qp([
      B5(null),
      so('boolean', (t) => typeof t == 'boolean'),
      so('finite number', (t) => Dc(t, D5()) && Number.isFinite(t)),
      oo(),
      L5(Q_(() => Lh)),
      $5(
        oo(),
        Q_(() => Lh)
      )
    ]),
    vu =
      ((Sd = Lh),
      (e2 = so('any', () => !0)),
      (t2 = (t) => (
        (function (e, n, r = 'Assertion failed', i = Xj) {
          try {
            O5(e, n);
          } catch (s) {
            throw Jj(i, `${r}: ${Qj(s)}.`);
          }
        })(t, Lh),
        JSON.parse(
          JSON.stringify(t, (e, n) => {
            if (e !== '__proto__' && e !== 'constructor') return n;
          })
        )
      )),
      new jr({
        ...Sd,
        coercer: (t, e) =>
          Dc(t, e2) ? Sd.coercer(t2(t, e), e) : Sd.coercer(t, e)
      }));
  function Yg(t) {
    try {
      return (
        (function (e) {
          N5(e, vu);
        })(t),
        !0
      );
    } catch {
      return !1;
    }
  }
  var Sl = B5('2.0'),
    af = (function (t) {
      return new jr({
        ...t,
        validator: (e, n) => e === null || t.validator(e, n),
        refiner: (e, n) => e === null || t.refiner(e, n)
      });
    })(qp([D5(), oo()])),
    Qg = yu({
      code: so(
        'integer',
        (t) =>
          (typeof t == 'number' && !isNaN(t) && Number.isInteger(t)) ||
          `Expected an integer, but received: ${wi(t)}`
      ),
      message: oo(),
      data: Nh(vu),
      stack: Nh(oo())
    }),
    V5 = qp([$5(oo(), vu), L5(vu)]),
    uU = yu({id: af, jsonrpc: Sl, method: oo(), params: Nh(V5)}),
    dU = yu({jsonrpc: Sl, method: oo(), params: Nh(V5)});
  function n2(t) {
    return Dc(t, uU);
  }
  function r2(t) {
    return Dc(t, Qg);
  }
  (F5({
    id: af,
    jsonrpc: Sl,
    result: J_(so('unknown', () => !0)),
    error: J_(Qg)
  }),
    qp([
      yu({id: af, jsonrpc: Sl, result: vu}),
      yu({id: af, jsonrpc: Sl, error: Qg})
    ]));
  var i2 = Ps.internal,
    fU = 'Unspecified error message. This is a bug, please report it.',
    hU = {code: i2, message: G5(i2)},
    pU = 'Unspecified server error.';
  function G5(t, e = fU) {
    if (
      (function (n) {
        return Number.isInteger(n);
      })(t)
    ) {
      const n = t.toString();
      if (Oh(W_, n)) return W_[n].message;
      if (
        (function (r) {
          return r >= -32099 && r <= -32e3;
        })(t)
      )
        return pU;
    }
    return e;
  }
  function s2(t, {fallbackError: e = hU, shouldIncludeStack: n = !0} = {}) {
    if (!r2(e))
      throw new Error(
        'Must provide fallback error with integer number code and string message.'
      );
    const r = (function (i, s) {
      if (
        i &&
        typeof i == 'object' &&
        'serialize' in i &&
        typeof i.serialize == 'function'
      )
        return i.serialize();
      if (r2(i)) return i;
      const o = z5(i);
      return {...s, data: {cause: o}};
    })(t, e);
    return (n || delete r.stack, r);
  }
  function z5(t) {
    return Array.isArray(t)
      ? t.map((e) => (Yg(e) ? e : Z_(e) ? o2(e) : null))
      : Z_(t)
        ? o2(t)
        : Yg(t)
          ? t
          : null;
  }
  function o2(t) {
    return Object.getOwnPropertyNames(t).reduce((e, n) => {
      const r = t[n];
      return (Yg(r) && (e[n] = r), e);
    }, {});
  }
  var W5 = il;
  ((il.default = il), (il.stable = a2), (il.stableStringify = a2));
  var Bh = '[...]',
    Z5 = '[Circular]',
    na = [],
    Oo = [];
  function Y5() {
    return {
      depthLimit: Number.MAX_SAFE_INTEGER,
      edgesLimit: Number.MAX_SAFE_INTEGER
    };
  }
  function il(t, e, n, r) {
    var i;
    (r === void 0 && (r = Y5()), Jg(t, '', 0, [], void 0, 0, r));
    try {
      i =
        Oo.length === 0 ? JSON.stringify(t, e, n) : JSON.stringify(t, Q5(e), n);
    } catch {
      return JSON.stringify(
        '[unable to serialize, circular reference is too complex to analyze]'
      );
    } finally {
      for (; na.length !== 0; ) {
        var s = na.pop();
        s.length === 4
          ? Object.defineProperty(s[0], s[1], s[3])
          : (s[0][s[1]] = s[2]);
      }
    }
    return i;
  }
  function tc(t, e, n, r) {
    var i = Object.getOwnPropertyDescriptor(r, n);
    i.get !== void 0
      ? i.configurable
        ? (Object.defineProperty(r, n, {value: t}), na.push([r, n, e, i]))
        : Oo.push([e, n, t])
      : ((r[n] = t), na.push([r, n, e]));
  }
  function Jg(t, e, n, r, i, s, o) {
    var a;
    if (((s += 1), typeof t == 'object' && t !== null)) {
      for (a = 0; a < r.length; a++)
        if (r[a] === t) return void tc(Z5, t, e, i);
      if (
        (o.depthLimit !== void 0 && s > o.depthLimit) ||
        (o.edgesLimit !== void 0 && n + 1 > o.edgesLimit)
      )
        return void tc(Bh, t, e, i);
      if ((r.push(t), Array.isArray(t)))
        for (a = 0; a < t.length; a++) Jg(t[a], a, a, r, t, s, o);
      else {
        var c = Object.keys(t);
        for (a = 0; a < c.length; a++) {
          var l = c[a];
          Jg(t[l], l, a, r, t, s, o);
        }
      }
      r.pop();
    }
  }
  function mU(t, e) {
    return t < e ? -1 : t > e ? 1 : 0;
  }
  function a2(t, e, n, r) {
    r === void 0 && (r = Y5());
    var i,
      s = Xg(t, '', 0, [], void 0, 0, r) || t;
    try {
      i =
        Oo.length === 0 ? JSON.stringify(s, e, n) : JSON.stringify(s, Q5(e), n);
    } catch {
      return JSON.stringify(
        '[unable to serialize, circular reference is too complex to analyze]'
      );
    } finally {
      for (; na.length !== 0; ) {
        var o = na.pop();
        o.length === 4
          ? Object.defineProperty(o[0], o[1], o[3])
          : (o[0][o[1]] = o[2]);
      }
    }
    return i;
  }
  function Xg(t, e, n, r, i, s, o) {
    var a;
    if (((s += 1), typeof t == 'object' && t !== null)) {
      for (a = 0; a < r.length; a++)
        if (r[a] === t) return void tc(Z5, t, e, i);
      try {
        if (typeof t.toJSON == 'function') return;
      } catch {
        return;
      }
      if (
        (o.depthLimit !== void 0 && s > o.depthLimit) ||
        (o.edgesLimit !== void 0 && n + 1 > o.edgesLimit)
      )
        return void tc(Bh, t, e, i);
      if ((r.push(t), Array.isArray(t)))
        for (a = 0; a < t.length; a++) Xg(t[a], a, a, r, t, s, o);
      else {
        var c = {},
          l = Object.keys(t).sort(mU);
        for (a = 0; a < l.length; a++) {
          var u = l[a];
          (Xg(t[u], u, a, r, t, s, o), (c[u] = t[u]));
        }
        if (i === void 0) return c;
        (na.push([i, e, t]), (i[e] = c));
      }
      r.pop();
    }
  }
  function Q5(t) {
    return (
      (t =
        t !== void 0
          ? t
          : function (e, n) {
              return n;
            }),
      function (e, n) {
        if (Oo.length > 0)
          for (var r = 0; r < Oo.length; r++) {
            var i = Oo[r];
            if (i[1] === e && i[0] === n) {
              ((n = i[2]), Oo.splice(r, 1));
              break;
            }
          }
        return t.call(this, e, n);
      }
    );
  }
  var gU = Up(W5),
    $i = class extends Error {
      constructor(t, e, n) {
        if (!Number.isInteger(t)) throw new Error('"code" must be an integer.');
        if (!e || typeof e != 'string')
          throw new Error('"message" must be a non-empty string.');
        (super(e), (this.code = t), n !== void 0 && (this.data = n));
      }
      serialize() {
        const t = {code: this.code, message: this.message};
        return (
          this.data !== void 0 &&
            ((t.data = this.data),
            (function (e) {
              if (typeof e != 'object' || e === null) return !1;
              try {
                let n = e;
                for (; Object.getPrototypeOf(n) !== null; )
                  n = Object.getPrototypeOf(n);
                return Object.getPrototypeOf(e) === n;
              } catch {
                return !1;
              }
            })(this.data) && (t.data.cause = z5(this.data.cause))),
          this.stack && (t.stack = this.stack),
          t
        );
      }
      toString() {
        return gU(this.serialize(), yU, 2);
      }
    };
  function yU(t, e) {
    if (e !== '[Circular]') return e;
  }
  var xl = (t) => vU(Ps.invalidRequest, t);
  function vU(t, e) {
    const [n, r] = (function (i) {
      if (i) {
        if (typeof i == 'string') return [i];
        if (typeof i == 'object' && !Array.isArray(i)) {
          const {message: s, data: o} = i;
          if (s && typeof s != 'string')
            throw new Error('Must specify string message.');
          return [s ?? void 0, o];
        }
      }
      return [];
    })(e);
    return new $i(t, n ?? G5(t), r);
  }
  var J5 = {};
  function Ss() {}
  function ot() {
    ot.init.call(this);
  }
  function X5(t) {
    return t._maxListeners === void 0
      ? ot.defaultMaxListeners
      : t._maxListeners;
  }
  function c2(t, e, n, r) {
    var i, s, o;
    if (typeof n != 'function')
      throw new TypeError('"listener" argument must be a function');
    if (
      ((s = t._events)
        ? (s.newListener &&
            (t.emit('newListener', e, n.listener ? n.listener : n),
            (s = t._events)),
          (o = s[e]))
        : ((s = t._events = new Ss()), (t._eventsCount = 0)),
      o)
    ) {
      if (
        (typeof o == 'function'
          ? (o = s[e] = r ? [n, o] : [o, n])
          : r
            ? o.unshift(n)
            : o.push(n),
        !o.warned && (i = X5(t)) && i > 0 && o.length > i)
      ) {
        o.warned = !0;
        var a = new Error(
          'Possible EventEmitter memory leak detected. ' +
            o.length +
            ' ' +
            e +
            ' listeners added. Use emitter.setMaxListeners() to increase limit'
        );
        ((a.name = 'MaxListenersExceededWarning'),
          (a.emitter = t),
          (a.type = e),
          (a.count = o.length),
          (function (c) {
            typeof console.warn == 'function'
              ? console.warn(c)
              : console.log(c);
          })(a));
      }
    } else ((o = s[e] = n), ++t._eventsCount);
    return t;
  }
  function l2(t, e, n) {
    var r = !1;
    function i() {
      (t.removeListener(e, i), r || ((r = !0), n.apply(t, arguments)));
    }
    return ((i.listener = n), i);
  }
  function u2(t) {
    var e = this._events;
    if (e) {
      var n = e[t];
      if (typeof n == 'function') return 1;
      if (n) return n.length;
    }
    return 0;
  }
  function Qc(t, e) {
    for (var n = new Array(e); e--; ) n[e] = t[e];
    return n;
  }
  ((Ss.prototype = Object.create(null)),
    (ot.EventEmitter = ot),
    (ot.usingDomains = !1),
    (ot.prototype.domain = void 0),
    (ot.prototype._events = void 0),
    (ot.prototype._maxListeners = void 0),
    (ot.defaultMaxListeners = 10),
    (ot.init = function () {
      ((this.domain = null),
        ot.usingDomains && (void 0).active,
        (this._events &&
          this._events !== Object.getPrototypeOf(this)._events) ||
          ((this._events = new Ss()), (this._eventsCount = 0)),
        (this._maxListeners = this._maxListeners || void 0));
    }),
    (ot.prototype.setMaxListeners = function (t) {
      if (typeof t != 'number' || t < 0 || isNaN(t))
        throw new TypeError('"n" argument must be a positive number');
      return ((this._maxListeners = t), this);
    }),
    (ot.prototype.getMaxListeners = function () {
      return X5(this);
    }),
    (ot.prototype.emit = function (t) {
      var e,
        n,
        r,
        i,
        s,
        o,
        a,
        c = t === 'error';
      if ((o = this._events)) c = c && o.error == null;
      else if (!c) return !1;
      if (((a = this.domain), c)) {
        if (((e = arguments[1]), !a)) {
          if (e instanceof Error) throw e;
          var l = new Error('Uncaught, unspecified "error" event. (' + e + ')');
          throw ((l.context = e), l);
        }
        return (
          e || (e = new Error('Uncaught, unspecified "error" event')),
          (e.domainEmitter = this),
          (e.domain = a),
          (e.domainThrown = !1),
          a.emit('error', e),
          !1
        );
      }
      if (!(n = o[t])) return !1;
      var u = typeof n == 'function';
      switch ((r = arguments.length)) {
        case 1:
          (function (d, f, h) {
            if (f) d.call(h);
            else
              for (var g = d.length, m = Qc(d, g), y = 0; y < g; ++y)
                m[y].call(h);
          })(n, u, this);
          break;
        case 2:
          (function (d, f, h, g) {
            if (f) d.call(h, g);
            else
              for (var m = d.length, y = Qc(d, m), p = 0; p < m; ++p)
                y[p].call(h, g);
          })(n, u, this, arguments[1]);
          break;
        case 3:
          (function (d, f, h, g, m) {
            if (f) d.call(h, g, m);
            else
              for (var y = d.length, p = Qc(d, y), b = 0; b < y; ++b)
                p[b].call(h, g, m);
          })(n, u, this, arguments[1], arguments[2]);
          break;
        case 4:
          (function (d, f, h, g, m, y) {
            if (f) d.call(h, g, m, y);
            else
              for (var p = d.length, b = Qc(d, p), v = 0; v < p; ++v)
                b[v].call(h, g, m, y);
          })(n, u, this, arguments[1], arguments[2], arguments[3]);
          break;
        default:
          for (i = new Array(r - 1), s = 1; s < r; s++) i[s - 1] = arguments[s];
          (function (d, f, h, g) {
            if (f) d.apply(h, g);
            else
              for (var m = d.length, y = Qc(d, m), p = 0; p < m; ++p)
                y[p].apply(h, g);
          })(n, u, this, i);
      }
      return !0;
    }),
    (ot.prototype.addListener = function (t, e) {
      return c2(this, t, e, !1);
    }),
    (ot.prototype.on = ot.prototype.addListener),
    (ot.prototype.prependListener = function (t, e) {
      return c2(this, t, e, !0);
    }),
    (ot.prototype.once = function (t, e) {
      if (typeof e != 'function')
        throw new TypeError('"listener" argument must be a function');
      return (this.on(t, l2(this, t, e)), this);
    }),
    (ot.prototype.prependOnceListener = function (t, e) {
      if (typeof e != 'function')
        throw new TypeError('"listener" argument must be a function');
      return (this.prependListener(t, l2(this, t, e)), this);
    }),
    (ot.prototype.removeListener = function (t, e) {
      var n, r, i, s, o;
      if (typeof e != 'function')
        throw new TypeError('"listener" argument must be a function');
      if (!(r = this._events)) return this;
      if (!(n = r[t])) return this;
      if (n === e || (n.listener && n.listener === e))
        --this._eventsCount == 0
          ? (this._events = new Ss())
          : (delete r[t],
            r.removeListener &&
              this.emit('removeListener', t, n.listener || e));
      else if (typeof n != 'function') {
        for (i = -1, s = n.length; s-- > 0; )
          if (n[s] === e || (n[s].listener && n[s].listener === e)) {
            ((o = n[s].listener), (i = s));
            break;
          }
        if (i < 0) return this;
        if (n.length === 1) {
          if (((n[0] = void 0), --this._eventsCount == 0))
            return ((this._events = new Ss()), this);
          delete r[t];
        } else
          (function (a, c) {
            for (var l = c, u = l + 1, d = a.length; u < d; l += 1, u += 1)
              a[l] = a[u];
            a.pop();
          })(n, i);
        r.removeListener && this.emit('removeListener', t, o || e);
      }
      return this;
    }),
    (ot.prototype.off = function (t, e) {
      return this.removeListener(t, e);
    }),
    (ot.prototype.removeAllListeners = function (t) {
      var e, n;
      if (!(n = this._events)) return this;
      if (!n.removeListener)
        return (
          arguments.length === 0
            ? ((this._events = new Ss()), (this._eventsCount = 0))
            : n[t] &&
              (--this._eventsCount == 0
                ? (this._events = new Ss())
                : delete n[t]),
          this
        );
      if (arguments.length === 0) {
        for (var r, i = Object.keys(n), s = 0; s < i.length; ++s)
          (r = i[s]) !== 'removeListener' && this.removeAllListeners(r);
        return (
          this.removeAllListeners('removeListener'),
          (this._events = new Ss()),
          (this._eventsCount = 0),
          this
        );
      }
      if (typeof (e = n[t]) == 'function') this.removeListener(t, e);
      else if (e)
        do this.removeListener(t, e[e.length - 1]);
        while (e[0]);
      return this;
    }),
    (ot.prototype.listeners = function (t) {
      var e,
        n,
        r = this._events;
      return (
        (n =
          r && (e = r[t])
            ? typeof e == 'function'
              ? [e.listener || e]
              : (function (i) {
                  for (var s = new Array(i.length), o = 0; o < s.length; ++o)
                    s[o] = i[o].listener || i[o];
                  return s;
                })(e)
            : []),
        n
      );
    }),
    (ot.listenerCount = function (t, e) {
      return typeof t.listenerCount == 'function'
        ? t.listenerCount(e)
        : u2.call(t, e);
    }),
    (ot.prototype.listenerCount = u2),
    (ot.prototype.eventNames = function () {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    }));
  var s1 = Hu(Object.freeze({__proto__: null, EventEmitter: ot, default: ot}));
  Object.defineProperty(J5, '__esModule', {value: !0});
  const bU = s1;
  function d2(t, e, n) {
    try {
      Reflect.apply(t, e, n);
    } catch (r) {
      setTimeout(() => {
        throw r;
      });
    }
  }
  let wU = class extends bU.EventEmitter {
    emit(t, ...e) {
      let n = t === 'error';
      const r = this._events;
      if (r !== void 0) n = n && r.error === void 0;
      else if (!n) return !1;
      if (n) {
        let s;
        if ((e.length > 0 && ([s] = e), s instanceof Error)) throw s;
        const o = new Error('Unhandled error.' + (s ? ` (${s.message})` : ''));
        throw ((o.context = s), o);
      }
      const i = r[t];
      if (i === void 0) return !1;
      if (typeof i == 'function') d2(i, this, e);
      else {
        const s = i.length,
          o = (function (a) {
            const c = a.length,
              l = new Array(c);
            for (let u = 0; u < c; u += 1) l[u] = a[u];
            return l;
          })(i);
        for (let a = 0; a < s; a += 1) d2(o[a], this, e);
      }
      return !0;
    }
  };
  var Dh,
    Ms,
    Ha,
    sl,
    cf,
    lf,
    ey,
    uf,
    ty,
    o0,
    f2,
    df,
    ny,
    a0,
    h2,
    Cl,
    Fh,
    c0,
    p2,
    eT = (J5.default = wU),
    Cr = class ff extends eT {
      constructor({notificationHandler: e} = {}) {
        (super(),
          kr(this, sl),
          kr(this, lf),
          kr(this, uf),
          kr(this, Dh, !1),
          kr(this, Ms, void 0),
          kr(this, Ha, void 0),
          Ad(this, Ms, []),
          Ad(this, Ha, e));
      }
      destroy() {
        (Ds(this, Ms).forEach((e) => {
          'destroy' in e && typeof e.destroy == 'function' && e.destroy();
        }),
          Ad(this, Ms, []),
          Ad(this, Dh, !0));
      }
      push(e) {
        (wn(this, sl, cf).call(this), Ds(this, Ms).push(e));
      }
      handle(e, n) {
        if ((wn(this, sl, cf).call(this), n && typeof n != 'function'))
          throw new Error('"callback" must be a function if provided.');
        return Array.isArray(e)
          ? n
            ? wn(this, lf, ey).call(this, e, n)
            : wn(this, lf, ey).call(this, e)
          : n
            ? wn(this, uf, ty).call(this, e, n)
            : this._promiseHandle(e);
      }
      asMiddleware() {
        return (
          wn(this, sl, cf).call(this),
          async (e, n, r, i) => {
            var s, o;
            try {
              const [a, c, l] = await wn((s = ff), df, ny).call(
                s,
                e,
                n,
                Ds(this, Ms)
              );
              return c
                ? (await wn((o = ff), Cl, Fh).call(o, l), i(a))
                : r(async (u) => {
                    var d;
                    try {
                      await wn((d = ff), Cl, Fh).call(d, l);
                    } catch (f) {
                      return u(f);
                    }
                    return u();
                  });
            } catch (a) {
              return i(a);
            }
          }
        );
      }
      async _promiseHandle(e) {
        return new Promise((n, r) => {
          wn(this, uf, ty)
            .call(this, e, (i, s) => {
              i && s === void 0 ? r(i) : n(s);
            })
            .catch(r);
        });
      }
    };
  ((Dh = new WeakMap()),
    (Ms = new WeakMap()),
    (Ha = new WeakMap()),
    (sl = new WeakSet()),
    (cf = function () {
      if (Ds(this, Dh))
        throw new Error('This engine is destroyed and can no longer be used.');
    }),
    (lf = new WeakSet()),
    (ey = async function (t, e) {
      try {
        if (t.length === 0) {
          const r = [
            {
              id: null,
              jsonrpc: '2.0',
              error: new $i(
                Ps.invalidRequest,
                'Request batch must contain plain objects. Received an empty array'
              )
            }
          ];
          return e ? e(null, r) : r;
        }
        const n = (
          await Promise.all(t.map(this._promiseHandle.bind(this)))
        ).filter((r) => r !== void 0);
        return e ? e(null, n) : n;
      } catch (n) {
        if (e) return e(n);
        throw n;
      }
    }),
    (uf = new WeakSet()),
    (ty = async function (t, e) {
      var n;
      if (!t || Array.isArray(t) || typeof t != 'object') {
        const o = new $i(
          Ps.invalidRequest,
          'Requests must be plain objects. Received: ' + typeof t,
          {request: t}
        );
        return e(o, {id: null, jsonrpc: '2.0', error: o});
      }
      if (typeof t.method != 'string') {
        const o = new $i(
          Ps.invalidRequest,
          'Must specify a string method. Received: ' + typeof t.method,
          {request: t}
        );
        return Ds(this, Ha) && !n2(t)
          ? e(null)
          : e(o, {id: t.id ?? null, jsonrpc: '2.0', error: o});
      }
      if (Ds(this, Ha) && Dc(t, dU) && !n2(t)) {
        try {
          await Ds(this, Ha).call(this, t);
        } catch (o) {
          return e(o);
        }
        return e(null);
      }
      let r = null;
      const i = {...t},
        s = {id: i.id, jsonrpc: i.jsonrpc};
      try {
        await wn((n = Cr), o0, f2).call(n, i, s, Ds(this, Ms));
      } catch (o) {
        r = o;
      }
      return (r && (delete s.result, s.error || (s.error = s2(r))), e(r, s));
    }),
    (o0 = new WeakSet()),
    (f2 = async function (t, e, n) {
      var r, i, s;
      const [o, a, c] = await wn((r = Cr), df, ny).call(r, t, e, n);
      if (
        (wn((i = Cr), c0, p2).call(i, t, e, a),
        await wn((s = Cr), Cl, Fh).call(s, c),
        o)
      )
        throw o;
    }),
    (df = new WeakSet()),
    (ny = async function (t, e, n) {
      var r;
      const i = [];
      let s = null,
        o = !1;
      for (const a of n)
        if ((([s, o] = await wn((r = Cr), a0, h2).call(r, t, e, a, i)), o))
          break;
      return [s, o, i.reverse()];
    }),
    (a0 = new WeakSet()),
    (h2 = async function (t, e, n, r) {
      return new Promise((i) => {
        const s = (a) => {
            const c = a || e.error;
            (c && (e.error = s2(c)), i([c, !0]));
          },
          o = (a) => {
            e.error
              ? s(e.error)
              : (a &&
                  (typeof a != 'function' &&
                    s(
                      new $i(
                        Ps.internal,
                        `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof a}" for request:
${l0(t)}`,
                        {request: t}
                      )
                    ),
                  r.push(a)),
                i([null, !1]));
          };
        try {
          n(t, e, o, s);
        } catch (a) {
          s(a);
        }
      });
    }),
    (Cl = new WeakSet()),
    (Fh = async function (t) {
      for (const e of t)
        await new Promise((n, r) => {
          e((i) => (i ? r(i) : n()));
        });
    }),
    (c0 = new WeakSet()),
    (p2 = function (t, e, n) {
      if (!Oh(e, 'result') && !Oh(e, 'error'))
        throw new $i(
          Ps.internal,
          `JsonRpcEngine: Response has no error or result for request:
${l0(t)}`,
          {request: t}
        );
      if (!n)
        throw new $i(
          Ps.internal,
          `JsonRpcEngine: Nothing ended request:
${l0(t)}`,
          {request: t}
        );
    }),
    kr(Cr, o0),
    kr(Cr, df),
    kr(Cr, a0),
    kr(Cr, Cl),
    kr(Cr, c0));
  var _U = Cr;
  function l0(t) {
    return JSON.stringify(t, null, 2);
  }
  var tT = Object.freeze(['eth_subscription']),
    EU = (t = console) => [Wj(), AU(t), zj(t)];
  function AU(t) {
    return (e, n, r) => {
      ((typeof e.method == 'string' && e.method) ||
        (n.error = xl({
          message: "The request 'method' must be a non-empty string.",
          data: e
        })),
        r((i) => {
          const {error: s} = n;
          return (s && t.error(`MetaMask - RPC Error: ${s.message}`, s), i());
        }));
    };
  }
  var hf =
      (t, e, n = !0) =>
      (r, i) => {
        r || i.error
          ? e(r || i.error)
          : !n || Array.isArray(i)
            ? t(i)
            : t(i.result);
      },
    nT = (t) => !!t && typeof t == 'string' && t.startsWith('0x'),
    rT = () => {};
  async function m2(t, e) {
    try {
      const n = await (async function () {
        return {name: SU(window), icon: await xU(window)};
      })();
      t.handle(
        {
          jsonrpc: '2.0',
          id: 1,
          method: 'metamask_sendDomainMetadata',
          params: n
        },
        rT
      );
    } catch (n) {
      e.error({message: Tt.errors.sendSiteMetadata(), originalError: n});
    }
  }
  function SU(t) {
    const {document: e} = t,
      n = e.querySelector('head > meta[property="og:site_name"]');
    if (n) return n.content;
    const r = e.querySelector('head > meta[name="title"]');
    return r
      ? r.content
      : e.title && e.title.length > 0
        ? e.title
        : window.location.hostname;
  }
  async function xU(t) {
    const {document: e} = t,
      n = e.querySelectorAll('head > link[rel~="icon"]');
    for (const r of Array.from(n)) if (r && (await CU(r.href))) return r.href;
    return null;
  }
  async function CU(t) {
    return new Promise((e, n) => {
      try {
        const r = document.createElement('img');
        ((r.onload = () => e(!0)), (r.onerror = () => e(!1)), (r.src = t));
      } catch (r) {
        n(r);
      }
    });
  }
  var iT = (t, e, n) => {
      if (!e.has(t)) throw TypeError('Cannot ' + n);
    },
    ri = (t, e, n) => (
      iT(t, e, 'read from private field'),
      n ? n.call(t) : e.get(t)
    ),
    ry = (t, e, n) => {
      if (e.has(t))
        throw TypeError('Cannot add the same private member more than once');
      e instanceof WeakSet ? e.add(t) : e.set(t, n);
    },
    Hi = (t, e, n, r) => (iT(t, e, 'write to private field'), e.set(t, n), n);
  function g2(t, e, n) {
    try {
      Reflect.apply(t, e, n);
    } catch (r) {
      setTimeout(() => {
        throw r;
      });
    }
  }
  class TU extends ot {
    emit(e, ...n) {
      let r = e === 'error';
      const i = this._events;
      if (i !== void 0) r = r && i.error === void 0;
      else if (!r) return !1;
      if (r) {
        let o;
        if ((n.length > 0 && ([o] = n), o instanceof Error)) throw o;
        const a = new Error('Unhandled error.' + (o ? ` (${o.message})` : ''));
        throw ((a.context = o), a);
      }
      const s = i[e];
      if (s === void 0) return !1;
      if (typeof s == 'function') g2(s, this, n);
      else {
        const o = s.length,
          a = (function (c) {
            const l = c.length,
              u = new Array(l);
            for (let d = 0; d < l; d += 1) u[d] = c[d];
            return u;
          })(s);
        for (let c = 0; c < o; c += 1) g2(a[c], this, n);
      }
      return !0;
    }
  }
  var xs,
    _o,
    IU = function t(e, n) {
      if (e === n) return !0;
      if (e && n && typeof e == 'object' && typeof n == 'object') {
        if (e.constructor !== n.constructor) return !1;
        var r, i, s;
        if (Array.isArray(e)) {
          if ((r = e.length) != n.length) return !1;
          for (i = r; i-- != 0; ) if (!t(e[i], n[i])) return !1;
          return !0;
        }
        if (e.constructor === RegExp)
          return e.source === n.source && e.flags === n.flags;
        if (e.valueOf !== Object.prototype.valueOf)
          return e.valueOf() === n.valueOf();
        if (e.toString !== Object.prototype.toString)
          return e.toString() === n.toString();
        if ((r = (s = Object.keys(e)).length) !== Object.keys(n).length)
          return !1;
        for (i = r; i-- != 0; )
          if (!Object.prototype.hasOwnProperty.call(n, s[i])) return !1;
        for (i = r; i-- != 0; ) {
          var o = s[i];
          if (!t(e[o], n[o])) return !1;
        }
        return !0;
      }
      return e != e && n != n;
    },
    kU = Up(IU),
    sT = class oT extends TU {
      constructor({
        logger: e = console,
        maxEventListeners: n = 100,
        rpcMiddleware: r = []
      } = {}) {
        (super(),
          ry(this, xs, void 0),
          ry(this, _o, void 0),
          (this._log = e),
          this.setMaxListeners(n),
          (this._state = {...oT._defaultState}),
          Hi(this, _o, null),
          Hi(this, xs, null),
          (this._handleAccountsChanged =
            this._handleAccountsChanged.bind(this)),
          (this._handleConnect = this._handleConnect.bind(this)),
          (this._handleChainChanged = this._handleChainChanged.bind(this)),
          (this._handleDisconnect = this._handleDisconnect.bind(this)),
          (this._handleUnlockStateChanged =
            this._handleUnlockStateChanged.bind(this)),
          (this._rpcRequest = this._rpcRequest.bind(this)),
          (this.request = this.request.bind(this)));
        const i = new _U();
        (r.forEach((s) => i.push(s)), (this._rpcEngine = i));
      }
      get chainId() {
        return ri(this, xs);
      }
      get selectedAddress() {
        return ri(this, _o);
      }
      isConnected() {
        return this._state.isConnected;
      }
      async request(e) {
        if (!e || typeof e != 'object' || Array.isArray(e))
          throw xl({message: Tt.errors.invalidRequestArgs(), data: e});
        const {method: n, params: r} = e;
        if (typeof n != 'string' || n.length === 0)
          throw xl({message: Tt.errors.invalidRequestMethod(), data: e});
        if (
          r !== void 0 &&
          !Array.isArray(r) &&
          (typeof r != 'object' || r === null)
        )
          throw xl({message: Tt.errors.invalidRequestParams(), data: e});
        const i = r == null ? {method: n} : {method: n, params: r};
        return new Promise((s, o) => {
          this._rpcRequest(i, hf(s, o));
        });
      }
      _initializeState(e) {
        if (this._state.initialized)
          throw new Error('Provider already initialized.');
        if (e) {
          const {accounts: n, chainId: r, isUnlocked: i, networkVersion: s} = e;
          (this._handleConnect(r),
            this._handleChainChanged({chainId: r, networkVersion: s}),
            this._handleUnlockStateChanged({accounts: n, isUnlocked: i}),
            this._handleAccountsChanged(n));
        }
        ((this._state.initialized = !0), this.emit('_initialized'));
      }
      _rpcRequest(e, n) {
        let r = n;
        return (
          Array.isArray(e) ||
            (e.jsonrpc || (e.jsonrpc = '2.0'),
            (e.method !== 'eth_accounts' &&
              e.method !== 'eth_requestAccounts') ||
              (r = (i, s) => {
                (this._handleAccountsChanged(
                  s.result ?? [],
                  e.method === 'eth_accounts'
                ),
                  n(i, s));
              })),
          this._rpcEngine.handle(e, r)
        );
      }
      _handleConnect(e) {
        this._state.isConnected ||
          ((this._state.isConnected = !0),
          this.emit('connect', {chainId: e}),
          this._log.debug(Tt.info.connected(e)));
      }
      _handleDisconnect(e, n) {
        if (
          this._state.isConnected ||
          (!this._state.isPermanentlyDisconnected && !e)
        ) {
          let r;
          ((this._state.isConnected = !1),
            e
              ? ((r = new $i(1013, n ?? Tt.errors.disconnected())),
                this._log.debug(r))
              : ((r = new $i(1011, n ?? Tt.errors.permanentlyDisconnected())),
                this._log.error(r),
                Hi(this, xs, null),
                (this._state.accounts = null),
                Hi(this, _o, null),
                (this._state.isUnlocked = !1),
                (this._state.isPermanentlyDisconnected = !0)),
            this.emit('disconnect', r));
        }
      }
      _handleChainChanged({chainId: e} = {}) {
        nT(e)
          ? (this._handleConnect(e),
            e !== ri(this, xs) &&
              (Hi(this, xs, e),
              this._state.initialized &&
                this.emit('chainChanged', ri(this, xs))))
          : this._log.error(Tt.errors.invalidNetworkParams(), {chainId: e});
      }
      _handleAccountsChanged(e, n = !1) {
        let r = e;
        Array.isArray(e) ||
          (this._log.error(
            'MetaMask: Received invalid accounts parameter. Please report this bug.',
            e
          ),
          (r = []));
        for (const i of e)
          if (typeof i != 'string') {
            (this._log.error(
              'MetaMask: Received non-string account. Please report this bug.',
              e
            ),
              (r = []));
            break;
          }
        if (
          !kU(this._state.accounts, r) &&
          (n &&
            this._state.accounts !== null &&
            this._log.error(
              "MetaMask: 'eth_accounts' unexpectedly updated accounts. Please report this bug.",
              r
            ),
          (this._state.accounts = r),
          ri(this, _o) !== r[0] && Hi(this, _o, r[0] || null),
          this._state.initialized)
        ) {
          const i = [...r];
          this.emit('accountsChanged', i);
        }
      }
      _handleUnlockStateChanged({accounts: e, isUnlocked: n} = {}) {
        typeof n == 'boolean'
          ? n !== this._state.isUnlocked &&
            ((this._state.isUnlocked = n), this._handleAccountsChanged(e ?? []))
          : this._log.error(
              'MetaMask: Received invalid isUnlocked parameter. Please report this bug.'
            );
      }
    };
  ((xs = new WeakMap()),
    (_o = new WeakMap()),
    (sT._defaultState = {
      accounts: null,
      isConnected: !1,
      isUnlocked: !1,
      initialized: !1,
      isPermanentlyDisconnected: !1
    }));
  var y2,
    v2,
    RU = sT,
    iy = {exports: {}};
  function aT() {
    return v2 ? y2 : ((v2 = 1), (y2 = s1.EventEmitter));
  }
  var o1,
    a1 = Hu(VH);
  o1 =
    typeof Object.create == 'function'
      ? function (t, e) {
          ((t.super_ = e),
            (t.prototype = Object.create(e.prototype, {
              constructor: {
                value: t,
                enumerable: !1,
                writable: !0,
                configurable: !0
              }
            })));
        }
      : function (t, e) {
          t.super_ = e;
          var n = function () {};
          ((n.prototype = e.prototype),
            (t.prototype = new n()),
            (t.prototype.constructor = t));
        };
  var cT =
      Object.getOwnPropertyDescriptors ||
      function (t) {
        for (var e = Object.keys(t), n = {}, r = 0; r < e.length; r++)
          n[e[r]] = Object.getOwnPropertyDescriptor(t, e[r]);
        return n;
      },
    PU = /%[sdj%]/g;
  function Vp(t) {
    if (!bu(t)) {
      for (var e = [], n = 0; n < arguments.length; n++)
        e.push(fi(arguments[n]));
      return e.join(' ');
    }
    n = 1;
    for (
      var r = arguments,
        i = r.length,
        s = String(t).replace(PU, function (a) {
          if (a === '%%') return '%';
          if (n >= i) return a;
          switch (a) {
            case '%s':
              return String(r[n++]);
            case '%d':
              return Number(r[n++]);
            case '%j':
              try {
                return JSON.stringify(r[n++]);
              } catch {
                return '[Circular]';
              }
            default:
              return a;
          }
        }),
        o = r[n];
      n < i;
      o = r[++n]
    )
      Ku(o) || !ca(o) ? (s += ' ' + o) : (s += ' ' + fi(o));
    return s;
  }
  function c1(t, e) {
    if (oi(kn.process))
      return function () {
        return c1(t, e).apply(this, arguments);
      };
    if (tt.noDeprecation === !0) return t;
    var n = !1;
    return function () {
      if (!n) {
        if (tt.throwDeprecation) throw new Error(e);
        (tt.traceDeprecation ? console.trace(e) : console.error(e), (n = !0));
      }
      return t.apply(this, arguments);
    };
  }
  var u0,
    xd = {};
  function lT(t) {
    return (
      oi(u0) && (u0 = tt.env.NODE_DEBUG || ''),
      (t = t.toUpperCase()),
      !xd[t] &&
        (new RegExp('\\b' + t + '\\b', 'i').test(u0)
          ? (xd[t] = function () {
              var e = Vp.apply(null, arguments);
              console.error('%s %d: %s', t, 0, e);
            })
          : (xd[t] = function () {})),
      xd[t]
    );
  }
  function fi(t, e) {
    var n = {seen: [], stylize: OU};
    return (
      arguments.length >= 3 && (n.depth = arguments[2]),
      arguments.length >= 4 && (n.colors = arguments[3]),
      Gp(e) ? (n.showHidden = e) : e && f1(n, e),
      oi(n.showHidden) && (n.showHidden = !1),
      oi(n.depth) && (n.depth = 2),
      oi(n.colors) && (n.colors = !1),
      oi(n.customInspect) && (n.customInspect = !0),
      n.colors && (n.stylize = MU),
      $h(n, t, n.depth)
    );
  }
  function MU(t, e) {
    var n = fi.styles[e];
    return n
      ? '\x1B[' + fi.colors[n][0] + 'm' + t + '\x1B[' + fi.colors[n][1] + 'm'
      : t;
  }
  function OU(t, e) {
    return t;
  }
  function $h(t, e, n) {
    if (
      t.customInspect &&
      e &&
      kl(e.inspect) &&
      e.inspect !== fi &&
      (!e.constructor || e.constructor.prototype !== e)
    ) {
      var r = e.inspect(n, t);
      return (bu(r) || (r = $h(t, r, n)), r);
    }
    var i = (function (f, h) {
      if (oi(h)) return f.stylize('undefined', 'undefined');
      if (bu(h)) {
        var g =
          "'" +
          JSON.stringify(h)
            .replace(/^"|"$/g, '')
            .replace(/'/g, "\\'")
            .replace(/\\"/g, '"') +
          "'";
        return f.stylize(g, 'string');
      }
      if (u1(h)) return f.stylize('' + h, 'number');
      if (Gp(h)) return f.stylize('' + h, 'boolean');
      if (Ku(h)) return f.stylize('null', 'null');
    })(t, e);
    if (i) return i;
    var s = Object.keys(e),
      o = (function (f) {
        var h = {};
        return (
          f.forEach(function (g, m) {
            h[g] = !0;
          }),
          h
        );
      })(s);
    if (
      (t.showHidden && (s = Object.getOwnPropertyNames(e)),
      Il(e) && (s.indexOf('message') >= 0 || s.indexOf('description') >= 0))
    )
      return d0(e);
    if (s.length === 0) {
      if (kl(e)) {
        var a = e.name ? ': ' + e.name : '';
        return t.stylize('[Function' + a + ']', 'special');
      }
      if (Tl(e)) return t.stylize(RegExp.prototype.toString.call(e), 'regexp');
      if (Hh(e)) return t.stylize(Date.prototype.toString.call(e), 'date');
      if (Il(e)) return d0(e);
    }
    var c,
      l = '',
      u = !1,
      d = ['{', '}'];
    return (
      l1(e) && ((u = !0), (d = ['[', ']'])),
      kl(e) && (l = ' [Function' + (e.name ? ': ' + e.name : '') + ']'),
      Tl(e) && (l = ' ' + RegExp.prototype.toString.call(e)),
      Hh(e) && (l = ' ' + Date.prototype.toUTCString.call(e)),
      Il(e) && (l = ' ' + d0(e)),
      s.length !== 0 || (u && e.length != 0)
        ? n < 0
          ? Tl(e)
            ? t.stylize(RegExp.prototype.toString.call(e), 'regexp')
            : t.stylize('[Object]', 'special')
          : (t.seen.push(e),
            (c = u
              ? (function (f, h, g, m, y) {
                  for (var p = [], b = 0, v = h.length; b < v; ++b)
                    mT(h, String(b))
                      ? p.push(f0(f, h, g, m, String(b), !0))
                      : p.push('');
                  return (
                    y.forEach(function (x) {
                      x.match(/^\d+$/) || p.push(f0(f, h, g, m, x, !0));
                    }),
                    p
                  );
                })(t, e, n, o, s)
              : s.map(function (f) {
                  return f0(t, e, n, o, f, u);
                })),
            t.seen.pop(),
            (function (f, h, g) {
              var m = f.reduce(function (y, p) {
                return (
                  p.indexOf(`
`),
                  y + p.replace(/\u001b\[\d\d?m/g, '').length + 1
                );
              }, 0);
              return m > 60
                ? g[0] +
                    (h === ''
                      ? ''
                      : h +
                        `
 `) +
                    ' ' +
                    f.join(`,
  `) +
                    ' ' +
                    g[1]
                : g[0] + h + ' ' + f.join(', ') + ' ' + g[1];
            })(c, l, d))
        : d[0] + l + d[1]
    );
  }
  function d0(t) {
    return '[' + Error.prototype.toString.call(t) + ']';
  }
  function f0(t, e, n, r, i, s) {
    var o, a, c;
    if (
      ((c = Object.getOwnPropertyDescriptor(e, i) || {value: e[i]}).get
        ? (a = c.set
            ? t.stylize('[Getter/Setter]', 'special')
            : t.stylize('[Getter]', 'special'))
        : c.set && (a = t.stylize('[Setter]', 'special')),
      mT(r, i) || (o = '[' + i + ']'),
      a ||
        (t.seen.indexOf(c.value) < 0
          ? (a = Ku(n) ? $h(t, c.value, null) : $h(t, c.value, n - 1)).indexOf(`
`) > -1 &&
            (a = s
              ? a
                  .split(
                    `
`
                  )
                  .map(function (l) {
                    return '  ' + l;
                  })
                  .join(
                    `
`
                  )
                  .substr(2)
              : `
` +
                a
                  .split(
                    `
`
                  )
                  .map(function (l) {
                    return '   ' + l;
                  }).join(`
`))
          : (a = t.stylize('[Circular]', 'special'))),
      oi(o))
    ) {
      if (s && i.match(/^\d+$/)) return a;
      (o = JSON.stringify('' + i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)
        ? ((o = o.substr(1, o.length - 2)), (o = t.stylize(o, 'name')))
        : ((o = o
            .replace(/'/g, "\\'")
            .replace(/\\"/g, '"')
            .replace(/(^"|"$)/g, "'")),
          (o = t.stylize(o, 'string')));
    }
    return o + ': ' + a;
  }
  function l1(t) {
    return Array.isArray(t);
  }
  function Gp(t) {
    return typeof t == 'boolean';
  }
  function Ku(t) {
    return t === null;
  }
  function uT(t) {
    return t == null;
  }
  function u1(t) {
    return typeof t == 'number';
  }
  function bu(t) {
    return typeof t == 'string';
  }
  function dT(t) {
    return typeof t == 'symbol';
  }
  function oi(t) {
    return t === void 0;
  }
  function Tl(t) {
    return ca(t) && d1(t) === '[object RegExp]';
  }
  function ca(t) {
    return typeof t == 'object' && t !== null;
  }
  function Hh(t) {
    return ca(t) && d1(t) === '[object Date]';
  }
  function Il(t) {
    return ca(t) && (d1(t) === '[object Error]' || t instanceof Error);
  }
  function kl(t) {
    return typeof t == 'function';
  }
  function fT(t) {
    return (
      t === null ||
      typeof t == 'boolean' ||
      typeof t == 'number' ||
      typeof t == 'string' ||
      typeof t == 'symbol' ||
      t === void 0
    );
  }
  function hT(t) {
    return de.isBuffer(t);
  }
  function d1(t) {
    return Object.prototype.toString.call(t);
  }
  function h0(t) {
    return t < 10 ? '0' + t.toString(10) : t.toString(10);
  }
  ((fi.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }),
    (fi.styles = {
      special: 'cyan',
      number: 'yellow',
      boolean: 'yellow',
      undefined: 'grey',
      null: 'bold',
      string: 'green',
      date: 'magenta',
      regexp: 'red'
    }));
  var NU = [
    'Jan',
    'Feb',
    'Mar',
    'Apr',
    'May',
    'Jun',
    'Jul',
    'Aug',
    'Sep',
    'Oct',
    'Nov',
    'Dec'
  ];
  function pT() {
    var t, e;
    console.log(
      '%s - %s',
      ((t = new Date()),
      (e = [h0(t.getHours()), h0(t.getMinutes()), h0(t.getSeconds())].join(
        ':'
      )),
      [t.getDate(), NU[t.getMonth()], e].join(' ')),
      Vp.apply(null, arguments)
    );
  }
  function f1(t, e) {
    if (!e || !ca(e)) return t;
    for (var n = Object.keys(e), r = n.length; r--; ) t[n[r]] = e[n[r]];
    return t;
  }
  function mT(t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }
  var Eo = typeof Symbol < 'u' ? Symbol('util.promisify.custom') : void 0;
  function h1(t) {
    if (typeof t != 'function')
      throw new TypeError('The "original" argument must be of type Function');
    if (Eo && t[Eo]) {
      var e;
      if (typeof (e = t[Eo]) != 'function')
        throw new TypeError(
          'The "util.promisify.custom" argument must be of type Function'
        );
      return (
        Object.defineProperty(e, Eo, {
          value: e,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }),
        e
      );
    }
    function e() {
      for (
        var n,
          r,
          i = new Promise(function (a, c) {
            ((n = a), (r = c));
          }),
          s = [],
          o = 0;
        o < arguments.length;
        o++
      )
        s.push(arguments[o]);
      s.push(function (a, c) {
        a ? r(a) : n(c);
      });
      try {
        t.apply(this, s);
      } catch (a) {
        r(a);
      }
      return i;
    }
    return (
      Object.setPrototypeOf(e, Object.getPrototypeOf(t)),
      Eo &&
        Object.defineProperty(e, Eo, {
          value: e,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }),
      Object.defineProperties(e, cT(t))
    );
  }
  function LU(t, e) {
    if (!t) {
      var n = new Error('Promise was rejected with a falsy value');
      ((n.reason = t), (t = n));
    }
    return e(t);
  }
  function gT(t) {
    if (typeof t != 'function')
      throw new TypeError('The "original" argument must be of type Function');
    function e() {
      for (var n = [], r = 0; r < arguments.length; r++) n.push(arguments[r]);
      var i = n.pop();
      if (typeof i != 'function')
        throw new TypeError('The last argument must be of type Function');
      var s = this,
        o = function () {
          return i.apply(s, arguments);
        };
      t.apply(this, n).then(
        function (a) {
          tt.nextTick(o.bind(null, null, a));
        },
        function (a) {
          tt.nextTick(LU.bind(null, a, o));
        }
      );
    }
    return (
      Object.setPrototypeOf(e, Object.getPrototypeOf(t)),
      Object.defineProperties(e, cT(t)),
      e
    );
  }
  h1.custom = Eo;
  var p0,
    b2,
    m0,
    w2,
    BU = {
      inherits: o1,
      _extend: f1,
      log: pT,
      isBuffer: hT,
      isPrimitive: fT,
      isFunction: kl,
      isError: Il,
      isDate: Hh,
      isObject: ca,
      isRegExp: Tl,
      isUndefined: oi,
      isSymbol: dT,
      isString: bu,
      isNumber: u1,
      isNullOrUndefined: uT,
      isNull: Ku,
      isBoolean: Gp,
      isArray: l1,
      inspect: fi,
      deprecate: c1,
      format: Vp,
      debuglog: lT,
      promisify: h1,
      callbackify: gT
    },
    yT = Hu(
      Object.freeze({
        __proto__: null,
        _extend: f1,
        callbackify: gT,
        debuglog: lT,
        default: BU,
        deprecate: c1,
        format: Vp,
        inherits: o1,
        inspect: fi,
        isArray: l1,
        isBoolean: Gp,
        isBuffer: hT,
        isDate: Hh,
        isError: Il,
        isFunction: kl,
        isNull: Ku,
        isNullOrUndefined: uT,
        isNumber: u1,
        isObject: ca,
        isPrimitive: fT,
        isRegExp: Tl,
        isString: bu,
        isSymbol: dT,
        isUndefined: oi,
        log: pT,
        promisify: h1
      })
    );
  function DU() {
    if (b2) return p0;
    function t(c, l) {
      var u = Object.keys(c);
      if (Object.getOwnPropertySymbols) {
        var d = Object.getOwnPropertySymbols(c);
        (l &&
          (d = d.filter(function (f) {
            return Object.getOwnPropertyDescriptor(c, f).enumerable;
          })),
          u.push.apply(u, d));
      }
      return u;
    }
    function e(c) {
      for (var l = 1; l < arguments.length; l++) {
        var u = arguments[l] != null ? arguments[l] : {};
        l % 2
          ? t(Object(u), !0).forEach(function (d) {
              n(c, d, u[d]);
            })
          : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(c, Object.getOwnPropertyDescriptors(u))
            : t(Object(u)).forEach(function (d) {
                Object.defineProperty(
                  c,
                  d,
                  Object.getOwnPropertyDescriptor(u, d)
                );
              });
      }
      return c;
    }
    function n(c, l, u) {
      return (
        (l = i(l)) in c
          ? Object.defineProperty(c, l, {
              value: u,
              enumerable: !0,
              configurable: !0,
              writable: !0
            })
          : (c[l] = u),
        c
      );
    }
    function r(c, l, u) {
      return (
        l &&
          (function (d, f) {
            for (var h = 0; h < f.length; h++) {
              var g = f[h];
              ((g.enumerable = g.enumerable || !1),
                (g.configurable = !0),
                'value' in g && (g.writable = !0),
                Object.defineProperty(d, i(g.key), g));
            }
          })(c.prototype, l),
        Object.defineProperty(c, 'prototype', {writable: !1}),
        c
      );
    }
    function i(c) {
      var l = (function (u, d) {
        if (typeof u != 'object' || u === null) return u;
        var f = u[Symbol.toPrimitive];
        if (f !== void 0) {
          var h = f.call(u, d);
          if (typeof h != 'object') return h;
          throw new TypeError('@@toPrimitive must return a primitive value.');
        }
        return String(u);
      })(c, 'string');
      return typeof l == 'symbol' ? l : String(l);
    }
    b2 = 1;
    var s = a1.Buffer,
      o = yT.inspect,
      a = (o && o.custom) || 'inspect';
    return (
      (p0 = (function () {
        function c() {
          ((function (l, u) {
            if (!(l instanceof u))
              throw new TypeError('Cannot call a class as a function');
          })(this, c),
            (this.head = null),
            (this.tail = null),
            (this.length = 0));
        }
        return (
          r(c, [
            {
              key: 'push',
              value: function (l) {
                var u = {data: l, next: null};
                (this.length > 0 ? (this.tail.next = u) : (this.head = u),
                  (this.tail = u),
                  ++this.length);
              }
            },
            {
              key: 'unshift',
              value: function (l) {
                var u = {data: l, next: this.head};
                (this.length === 0 && (this.tail = u),
                  (this.head = u),
                  ++this.length);
              }
            },
            {
              key: 'shift',
              value: function () {
                if (this.length !== 0) {
                  var l = this.head.data;
                  return (
                    this.length === 1
                      ? (this.head = this.tail = null)
                      : (this.head = this.head.next),
                    --this.length,
                    l
                  );
                }
              }
            },
            {
              key: 'clear',
              value: function () {
                ((this.head = this.tail = null), (this.length = 0));
              }
            },
            {
              key: 'join',
              value: function (l) {
                if (this.length === 0) return '';
                for (var u = this.head, d = '' + u.data; (u = u.next); )
                  d += l + u.data;
                return d;
              }
            },
            {
              key: 'concat',
              value: function (l) {
                if (this.length === 0) return s.alloc(0);
                for (
                  var u, d, f, h = s.allocUnsafe(l >>> 0), g = this.head, m = 0;
                  g;

                )
                  ((u = g.data),
                    (d = h),
                    (f = m),
                    s.prototype.copy.call(u, d, f),
                    (m += g.data.length),
                    (g = g.next));
                return h;
              }
            },
            {
              key: 'consume',
              value: function (l, u) {
                var d;
                return (
                  l < this.head.data.length
                    ? ((d = this.head.data.slice(0, l)),
                      (this.head.data = this.head.data.slice(l)))
                    : (d =
                        l === this.head.data.length
                          ? this.shift()
                          : u
                            ? this._getString(l)
                            : this._getBuffer(l)),
                  d
                );
              }
            },
            {
              key: 'first',
              value: function () {
                return this.head.data;
              }
            },
            {
              key: '_getString',
              value: function (l) {
                var u = this.head,
                  d = 1,
                  f = u.data;
                for (l -= f.length; (u = u.next); ) {
                  var h = u.data,
                    g = l > h.length ? h.length : l;
                  if (
                    (g === h.length ? (f += h) : (f += h.slice(0, l)),
                    (l -= g) === 0)
                  ) {
                    g === h.length
                      ? (++d,
                        u.next
                          ? (this.head = u.next)
                          : (this.head = this.tail = null))
                      : ((this.head = u), (u.data = h.slice(g)));
                    break;
                  }
                  ++d;
                }
                return ((this.length -= d), f);
              }
            },
            {
              key: '_getBuffer',
              value: function (l) {
                var u = s.allocUnsafe(l),
                  d = this.head,
                  f = 1;
                for (d.data.copy(u), l -= d.data.length; (d = d.next); ) {
                  var h = d.data,
                    g = l > h.length ? h.length : l;
                  if ((h.copy(u, u.length - l, 0, g), (l -= g) === 0)) {
                    g === h.length
                      ? (++f,
                        d.next
                          ? (this.head = d.next)
                          : (this.head = this.tail = null))
                      : ((this.head = d), (d.data = h.slice(g)));
                    break;
                  }
                  ++f;
                }
                return ((this.length -= f), u);
              }
            },
            {
              key: a,
              value: function (l, u) {
                return o(this, e(e({}, u), {}, {depth: 0, customInspect: !1}));
              }
            }
          ]),
          c
        );
      })()),
      p0
    );
  }
  function vT() {
    if (w2) return m0;
    function t(r, i) {
      (n(r, i), e(r));
    }
    function e(r) {
      (r._writableState && !r._writableState.emitClose) ||
        (r._readableState && !r._readableState.emitClose) ||
        r.emit('close');
    }
    function n(r, i) {
      r.emit('error', i);
    }
    return (
      (w2 = 1),
      (m0 = {
        destroy: function (r, i) {
          var s = this,
            o = this._readableState && this._readableState.destroyed,
            a = this._writableState && this._writableState.destroyed;
          return o || a
            ? (i
                ? i(r)
                : r &&
                  (this._writableState
                    ? this._writableState.errorEmitted ||
                      ((this._writableState.errorEmitted = !0),
                      tt.nextTick(n, this, r))
                    : tt.nextTick(n, this, r)),
              this)
            : (this._readableState && (this._readableState.destroyed = !0),
              this._writableState && (this._writableState.destroyed = !0),
              this._destroy(r || null, function (c) {
                !i && c
                  ? s._writableState
                    ? s._writableState.errorEmitted
                      ? tt.nextTick(e, s)
                      : ((s._writableState.errorEmitted = !0),
                        tt.nextTick(t, s, c))
                    : tt.nextTick(t, s, c)
                  : i
                    ? (tt.nextTick(e, s), i(c))
                    : tt.nextTick(e, s);
              }),
              this);
        },
        undestroy: function () {
          (this._readableState &&
            ((this._readableState.destroyed = !1),
            (this._readableState.reading = !1),
            (this._readableState.ended = !1),
            (this._readableState.endEmitted = !1)),
            this._writableState &&
              ((this._writableState.destroyed = !1),
              (this._writableState.ended = !1),
              (this._writableState.ending = !1),
              (this._writableState.finalCalled = !1),
              (this._writableState.prefinished = !1),
              (this._writableState.finished = !1),
              (this._writableState.errorEmitted = !1)));
        },
        errorOrDestroy: function (r, i) {
          var s = r._readableState,
            o = r._writableState;
          (s && s.autoDestroy) || (o && o.autoDestroy)
            ? r.destroy(i)
            : r.emit('error', i);
        }
      }),
      m0
    );
  }
  var la = {},
    _2,
    E2,
    bT = {};
  function lr(t, e, n) {
    n || (n = Error);
    var r = (function (i) {
      var s, o;
      function a(c, l, u) {
        return (
          i.call(
            this,
            (function (d, f, h) {
              return typeof e == 'string' ? e : e(d, f, h);
            })(c, l, u)
          ) || this
        );
      }
      return (
        (o = i),
        ((s = a).prototype = Object.create(o.prototype)),
        (s.prototype.constructor = s),
        (s.__proto__ = o),
        a
      );
    })(n);
    ((r.prototype.name = n.name), (r.prototype.code = t), (bT[t] = r));
  }
  function A2(t, e) {
    if (Array.isArray(t)) {
      var n = t.length;
      return (
        (t = t.map(function (r) {
          return String(r);
        })),
        n > 2
          ? 'one of '
              .concat(e, ' ')
              .concat(t.slice(0, n - 1).join(', '), ', or ') + t[n - 1]
          : n === 2
            ? 'one of '.concat(e, ' ').concat(t[0], ' or ').concat(t[1])
            : 'of '.concat(e, ' ').concat(t[0])
      );
    }
    return 'of '.concat(e, ' ').concat(String(t));
  }
  function wT() {
    if (E2) return _2;
    E2 = 1;
    var t = la.codes.ERR_INVALID_OPT_VALUE;
    return (_2 = {
      getHighWaterMark: function (e, n, r, i) {
        var s = (function (o, a, c) {
          return o.highWaterMark != null ? o.highWaterMark : a ? o[c] : null;
        })(n, i, r);
        if (s != null) {
          if (!isFinite(s) || Math.floor(s) !== s || s < 0)
            throw new t(i ? r : 'highWaterMark', s);
          return Math.floor(s);
        }
        return e.objectMode ? 16 : 16384;
      }
    });
  }
  (lr(
    'ERR_INVALID_OPT_VALUE',
    function (t, e) {
      return 'The value "' + e + '" is invalid for option "' + t + '"';
    },
    TypeError
  ),
    lr(
      'ERR_INVALID_ARG_TYPE',
      function (t, e, n) {
        var r, i, s;
        if (
          (typeof e == 'string' && ((i = 'not '), e.substr(0, i.length) === i)
            ? ((r = 'must not be'), (e = e.replace(/^not /, '')))
            : (r = 'must be'),
          (function (a, c, l) {
            return (
              (l === void 0 || l > a.length) && (l = a.length),
              a.substring(l - c.length, l) === c
            );
          })(t, ' argument'))
        )
          s = 'The '.concat(t, ' ').concat(r, ' ').concat(A2(e, 'type'));
        else {
          var o = (function (a, c, l) {
            return (
              typeof l != 'number' && (l = 0),
              !(l + c.length > a.length) && a.indexOf(c, l) !== -1
            );
          })(t, '.')
            ? 'property'
            : 'argument';
          s = 'The "'
            .concat(t, '" ')
            .concat(o, ' ')
            .concat(r, ' ')
            .concat(A2(e, 'type'));
        }
        return (s += '. Received type '.concat(typeof n));
      },
      TypeError
    ),
    lr('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF'),
    lr('ERR_METHOD_NOT_IMPLEMENTED', function (t) {
      return 'The ' + t + ' method is not implemented';
    }),
    lr('ERR_STREAM_PREMATURE_CLOSE', 'Premature close'),
    lr('ERR_STREAM_DESTROYED', function (t) {
      return 'Cannot call ' + t + ' after a stream was destroyed';
    }),
    lr('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times'),
    lr('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable'),
    lr('ERR_STREAM_WRITE_AFTER_END', 'write after end'),
    lr(
      'ERR_STREAM_NULL_VALUES',
      'May not write null values to stream',
      TypeError
    ),
    lr(
      'ERR_UNKNOWN_ENCODING',
      function (t) {
        return 'Unknown encoding: ' + t;
      },
      TypeError
    ),
    lr(
      'ERR_STREAM_UNSHIFT_AFTER_END_EVENT',
      'stream.unshift() after end event'
    ),
    (la.codes = bT));
  var g0,
    S2,
    y0,
    x2,
    v0,
    C2,
    FU =
      typeof Object.create == 'function'
        ? function (t, e) {
            ((t.super_ = e),
              (t.prototype = Object.create(e.prototype, {
                constructor: {
                  value: t,
                  enumerable: !1,
                  writable: !0,
                  configurable: !0
                }
              })));
          }
        : function (t, e) {
            t.super_ = e;
            var n = function () {};
            ((n.prototype = e.prototype),
              (t.prototype = new n()),
              (t.prototype.constructor = t));
          },
    qu = Hu(Object.freeze({__proto__: null, default: FU}));
  function $U() {
    if (S2) return g0;
    function t(e) {
      try {
        if (!_r.localStorage) return !1;
      } catch {
        return !1;
      }
      var n = _r.localStorage[e];
      return n != null && String(n).toLowerCase() === 'true';
    }
    return (
      (S2 = 1),
      (g0 = function (e, n) {
        if (t('noDeprecation')) return e;
        var r = !1;
        return function () {
          if (!r) {
            if (t('throwDeprecation')) throw new Error(n);
            (t('traceDeprecation') ? console.trace(n) : console.warn(n),
              (r = !0));
          }
          return e.apply(this, arguments);
        };
      }),
      g0
    );
  }
  function _T() {
    if (x2) return y0;
    function t(K) {
      var B = this;
      ((this.next = null),
        (this.entry = null),
        (this.finish = function () {
          (function (D, E, P) {
            var U = D.entry;
            for (D.entry = null; U; ) {
              var w = U.callback;
              (E.pendingcb--, w(P), (U = U.next));
            }
            E.corkedRequestsFree.next = D;
          })(B, K);
        }));
    }
    var e;
    ((x2 = 1), (y0 = C), (C.WritableState = x));
    var n = {deprecate: $U()},
      r = aT(),
      i = a1.Buffer,
      s =
        (_r !== void 0
          ? _r
          : typeof window < 'u'
            ? window
            : typeof self < 'u'
              ? self
              : {}
        ).Uint8Array || function () {},
      o,
      a = vT(),
      c = wT().getHighWaterMark,
      l = la.codes,
      u = l.ERR_INVALID_ARG_TYPE,
      d = l.ERR_METHOD_NOT_IMPLEMENTED,
      f = l.ERR_MULTIPLE_CALLBACK,
      h = l.ERR_STREAM_CANNOT_PIPE,
      g = l.ERR_STREAM_DESTROYED,
      m = l.ERR_STREAM_NULL_VALUES,
      y = l.ERR_STREAM_WRITE_AFTER_END,
      p = l.ERR_UNKNOWN_ENCODING,
      b = a.errorOrDestroy;
    function v() {}
    function x(K, B, D) {
      ((e = e || Cc()),
        (K = K || {}),
        typeof D != 'boolean' && (D = B instanceof e),
        (this.objectMode = !!K.objectMode),
        D && (this.objectMode = this.objectMode || !!K.writableObjectMode),
        (this.highWaterMark = c(this, K, 'writableHighWaterMark', D)),
        (this.finalCalled = !1),
        (this.needDrain = !1),
        (this.ending = !1),
        (this.ended = !1),
        (this.finished = !1),
        (this.destroyed = !1));
      var E = K.decodeStrings === !1;
      ((this.decodeStrings = !E),
        (this.defaultEncoding = K.defaultEncoding || 'utf8'),
        (this.length = 0),
        (this.writing = !1),
        (this.corked = 0),
        (this.sync = !0),
        (this.bufferProcessing = !1),
        (this.onwrite = function (P) {
          (function (U, w) {
            var A = U._writableState,
              T = A.sync,
              R = A.writecb;
            if (typeof R != 'function') throw new f();
            if (
              ((function (S) {
                ((S.writing = !1),
                  (S.writecb = null),
                  (S.length -= S.writelen),
                  (S.writelen = 0));
              })(A),
              w)
            )
              (function (S, I, O, H, M) {
                (--I.pendingcb,
                  O
                    ? (tt.nextTick(M, H),
                      tt.nextTick(V, S, I),
                      (S._writableState.errorEmitted = !0),
                      b(S, H))
                    : (M(H),
                      (S._writableState.errorEmitted = !0),
                      b(S, H),
                      V(S, I)));
              })(U, A, T, w, R);
            else {
              var _ = F(A) || U.destroyed;
              (_ ||
                A.corked ||
                A.bufferProcessing ||
                !A.bufferedRequest ||
                L(U, A),
                T ? tt.nextTick(G, U, A, _, R) : G(U, A, _, R));
            }
          })(B, P);
        }),
        (this.writecb = null),
        (this.writelen = 0),
        (this.bufferedRequest = null),
        (this.lastBufferedRequest = null),
        (this.pendingcb = 0),
        (this.prefinished = !1),
        (this.errorEmitted = !1),
        (this.emitClose = K.emitClose !== !1),
        (this.autoDestroy = !!K.autoDestroy),
        (this.bufferedRequestCount = 0),
        (this.corkedRequestsFree = new t(this)));
    }
    function C(K) {
      var B = this instanceof (e = e || Cc());
      if (!B && !o.call(C, this)) return new C(K);
      ((this._writableState = new x(K, this, B)),
        (this.writable = !0),
        K &&
          (typeof K.write == 'function' && (this._write = K.write),
          typeof K.writev == 'function' && (this._writev = K.writev),
          typeof K.destroy == 'function' && (this._destroy = K.destroy),
          typeof K.final == 'function' && (this._final = K.final)),
        r.call(this));
    }
    function $(K, B, D, E, P, U, w) {
      ((B.writelen = E),
        (B.writecb = w),
        (B.writing = !0),
        (B.sync = !0),
        B.destroyed
          ? B.onwrite(new g('write'))
          : D
            ? K._writev(P, B.onwrite)
            : K._write(P, U, B.onwrite),
        (B.sync = !1));
    }
    function G(K, B, D, E) {
      (D ||
        (function (P, U) {
          U.length === 0 &&
            U.needDrain &&
            ((U.needDrain = !1), P.emit('drain'));
        })(K, B),
        B.pendingcb--,
        E(),
        V(K, B));
    }
    function L(K, B) {
      B.bufferProcessing = !0;
      var D = B.bufferedRequest;
      if (K._writev && D && D.next) {
        var E = B.bufferedRequestCount,
          P = new Array(E),
          U = B.corkedRequestsFree;
        U.entry = D;
        for (var w = 0, A = !0; D; )
          ((P[w] = D), D.isBuf || (A = !1), (D = D.next), (w += 1));
        ((P.allBuffers = A),
          $(K, B, !0, B.length, P, '', U.finish),
          B.pendingcb++,
          (B.lastBufferedRequest = null),
          U.next
            ? ((B.corkedRequestsFree = U.next), (U.next = null))
            : (B.corkedRequestsFree = new t(B)),
          (B.bufferedRequestCount = 0));
      } else {
        for (; D; ) {
          var T = D.chunk,
            R = D.encoding,
            _ = D.callback;
          if (
            ($(K, B, !1, B.objectMode ? 1 : T.length, T, R, _),
            (D = D.next),
            B.bufferedRequestCount--,
            B.writing)
          )
            break;
        }
        D === null && (B.lastBufferedRequest = null);
      }
      ((B.bufferedRequest = D), (B.bufferProcessing = !1));
    }
    function F(K) {
      return (
        K.ending &&
        K.length === 0 &&
        K.bufferedRequest === null &&
        !K.finished &&
        !K.writing
      );
    }
    function k(K, B) {
      K._final(function (D) {
        (B.pendingcb--,
          D && b(K, D),
          (B.prefinished = !0),
          K.emit('prefinish'),
          V(K, B));
      });
    }
    function V(K, B) {
      var D = F(B);
      if (
        D &&
        ((function (P, U) {
          U.prefinished ||
            U.finalCalled ||
            (typeof P._final != 'function' || U.destroyed
              ? ((U.prefinished = !0), P.emit('prefinish'))
              : (U.pendingcb++, (U.finalCalled = !0), tt.nextTick(k, P, U)));
        })(K, B),
        B.pendingcb === 0 &&
          ((B.finished = !0), K.emit('finish'), B.autoDestroy))
      ) {
        var E = K._readableState;
        (!E || (E.autoDestroy && E.endEmitted)) && K.destroy();
      }
      return D;
    }
    return (
      qu(C, r),
      (x.prototype.getBuffer = function () {
        for (var K = this.bufferedRequest, B = []; K; )
          (B.push(K), (K = K.next));
        return B;
      }),
      (function () {
        try {
          Object.defineProperty(x.prototype, 'buffer', {
            get: n.deprecate(
              function () {
                return this.getBuffer();
              },
              '_writableState.buffer is deprecated. Use _writableState.getBuffer instead.',
              'DEP0003'
            )
          });
        } catch {}
      })(),
      typeof Symbol == 'function' &&
      Symbol.hasInstance &&
      typeof Function.prototype[Symbol.hasInstance] == 'function'
        ? ((o = Function.prototype[Symbol.hasInstance]),
          Object.defineProperty(C, Symbol.hasInstance, {
            value: function (K) {
              return (
                !!o.call(this, K) ||
                (this === C && K && K._writableState instanceof x)
              );
            }
          }))
        : (o = function (K) {
            return K instanceof this;
          }),
      (C.prototype.pipe = function () {
        b(this, new h());
      }),
      (C.prototype.write = function (K, B, D) {
        var E,
          P = this._writableState,
          U = !1,
          w = !P.objectMode && ((E = K), i.isBuffer(E) || E instanceof s);
        return (
          w &&
            !i.isBuffer(K) &&
            (K = (function (A) {
              return i.from(A);
            })(K)),
          typeof B == 'function' && ((D = B), (B = null)),
          w ? (B = 'buffer') : B || (B = P.defaultEncoding),
          typeof D != 'function' && (D = v),
          P.ending
            ? (function (A, T) {
                var R = new y();
                (b(A, R), tt.nextTick(T, R));
              })(this, D)
            : (w ||
                (function (A, T, R, _) {
                  var S;
                  return (
                    R === null
                      ? (S = new m())
                      : typeof R == 'string' ||
                        T.objectMode ||
                        (S = new u('chunk', ['string', 'Buffer'], R)),
                    !S || (b(A, S), tt.nextTick(_, S), !1)
                  );
                })(this, P, K, D)) &&
              (P.pendingcb++,
              (U = (function (A, T, R, _, S, I) {
                if (!R) {
                  var O = (function (z, Z, X) {
                    return (
                      z.objectMode ||
                        z.decodeStrings === !1 ||
                        typeof Z != 'string' ||
                        (Z = i.from(Z, X)),
                      Z
                    );
                  })(T, _, S);
                  _ !== O && ((R = !0), (S = 'buffer'), (_ = O));
                }
                var H = T.objectMode ? 1 : _.length;
                T.length += H;
                var M = T.length < T.highWaterMark;
                if ((M || (T.needDrain = !0), T.writing || T.corked)) {
                  var q = T.lastBufferedRequest;
                  ((T.lastBufferedRequest = {
                    chunk: _,
                    encoding: S,
                    isBuf: R,
                    callback: I,
                    next: null
                  }),
                    q
                      ? (q.next = T.lastBufferedRequest)
                      : (T.bufferedRequest = T.lastBufferedRequest),
                    (T.bufferedRequestCount += 1));
                } else $(A, T, !1, H, _, S, I);
                return M;
              })(this, P, w, K, B, D))),
          U
        );
      }),
      (C.prototype.cork = function () {
        this._writableState.corked++;
      }),
      (C.prototype.uncork = function () {
        var K = this._writableState;
        K.corked &&
          (K.corked--,
          K.writing ||
            K.corked ||
            K.bufferProcessing ||
            !K.bufferedRequest ||
            L(this, K));
      }),
      (C.prototype.setDefaultEncoding = function (K) {
        if (
          (typeof K == 'string' && (K = K.toLowerCase()),
          !(
            [
              'hex',
              'utf8',
              'utf-8',
              'ascii',
              'binary',
              'base64',
              'ucs2',
              'ucs-2',
              'utf16le',
              'utf-16le',
              'raw'
            ].indexOf((K + '').toLowerCase()) > -1
          ))
        )
          throw new p(K);
        return ((this._writableState.defaultEncoding = K), this);
      }),
      Object.defineProperty(C.prototype, 'writableBuffer', {
        enumerable: !1,
        get: function () {
          return this._writableState && this._writableState.getBuffer();
        }
      }),
      Object.defineProperty(C.prototype, 'writableHighWaterMark', {
        enumerable: !1,
        get: function () {
          return this._writableState.highWaterMark;
        }
      }),
      (C.prototype._write = function (K, B, D) {
        D(new d('_write()'));
      }),
      (C.prototype._writev = null),
      (C.prototype.end = function (K, B, D) {
        var E = this._writableState;
        return (
          typeof K == 'function'
            ? ((D = K), (K = null), (B = null))
            : typeof B == 'function' && ((D = B), (B = null)),
          K != null && this.write(K, B),
          E.corked && ((E.corked = 1), this.uncork()),
          E.ending ||
            (function (P, U, w) {
              ((U.ending = !0),
                V(P, U),
                w && (U.finished ? tt.nextTick(w) : P.once('finish', w)),
                (U.ended = !0),
                (P.writable = !1));
            })(this, E, D),
          this
        );
      }),
      Object.defineProperty(C.prototype, 'writableLength', {
        enumerable: !1,
        get: function () {
          return this._writableState.length;
        }
      }),
      Object.defineProperty(C.prototype, 'destroyed', {
        enumerable: !1,
        get: function () {
          return (
            this._writableState !== void 0 && this._writableState.destroyed
          );
        },
        set: function (K) {
          this._writableState && (this._writableState.destroyed = K);
        }
      }),
      (C.prototype.destroy = a.destroy),
      (C.prototype._undestroy = a.undestroy),
      (C.prototype._destroy = function (K, B) {
        B(K);
      }),
      y0
    );
  }
  function Cc() {
    if (C2) return v0;
    C2 = 1;
    var t =
      Object.keys ||
      function (l) {
        var u = [];
        for (var d in l) u.push(d);
        return u;
      };
    v0 = o;
    var e = ET(),
      n = _T();
    qu(o, e);
    for (var r = t(n.prototype), i = 0; i < r.length; i++) {
      var s = r[i];
      o.prototype[s] || (o.prototype[s] = n.prototype[s]);
    }
    function o(l) {
      if (!(this instanceof o)) return new o(l);
      (e.call(this, l),
        n.call(this, l),
        (this.allowHalfOpen = !0),
        l &&
          (l.readable === !1 && (this.readable = !1),
          l.writable === !1 && (this.writable = !1),
          l.allowHalfOpen === !1 &&
            ((this.allowHalfOpen = !1), this.once('end', a))));
    }
    function a() {
      this._writableState.ended || tt.nextTick(c, this);
    }
    function c(l) {
      l.end();
    }
    return (
      Object.defineProperty(o.prototype, 'writableHighWaterMark', {
        enumerable: !1,
        get: function () {
          return this._writableState.highWaterMark;
        }
      }),
      Object.defineProperty(o.prototype, 'writableBuffer', {
        enumerable: !1,
        get: function () {
          return this._writableState && this._writableState.getBuffer();
        }
      }),
      Object.defineProperty(o.prototype, 'writableLength', {
        enumerable: !1,
        get: function () {
          return this._writableState.length;
        }
      }),
      Object.defineProperty(o.prototype, 'destroyed', {
        enumerable: !1,
        get: function () {
          return (
            this._readableState !== void 0 &&
            this._writableState !== void 0 &&
            this._readableState.destroyed &&
            this._writableState.destroyed
          );
        },
        set: function (l) {
          this._readableState !== void 0 &&
            this._writableState !== void 0 &&
            ((this._readableState.destroyed = l),
            (this._writableState.destroyed = l));
        }
      }),
      v0
    );
  }
  var HU =
    de.isEncoding ||
    function (t) {
      switch (t && t.toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
        case 'raw':
          return !0;
        default:
          return !1;
      }
    };
  function pf(t) {
    switch (
      ((this.encoding = (t || 'utf8').toLowerCase().replace(/[-_]/, '')),
      (function (e) {
        if (e && !HU(e)) throw new Error('Unknown encoding: ' + e);
      })(t),
      this.encoding)
    ) {
      case 'utf8':
        this.surrogateSize = 3;
        break;
      case 'ucs2':
      case 'utf16le':
        ((this.surrogateSize = 2), (this.detectIncompleteChar = UU));
        break;
      case 'base64':
        ((this.surrogateSize = 3), (this.detectIncompleteChar = KU));
        break;
      default:
        return void (this.write = jU);
    }
    ((this.charBuffer = new de(6)),
      (this.charReceived = 0),
      (this.charLength = 0));
  }
  function jU(t) {
    return t.toString(this.encoding);
  }
  function UU(t) {
    ((this.charReceived = t.length % 2),
      (this.charLength = this.charReceived ? 2 : 0));
  }
  function KU(t) {
    ((this.charReceived = t.length % 3),
      (this.charLength = this.charReceived ? 3 : 0));
  }
  ((pf.prototype.write = function (t) {
    for (var e = ''; this.charLength; ) {
      var n =
        t.length >= this.charLength - this.charReceived
          ? this.charLength - this.charReceived
          : t.length;
      if (
        (t.copy(this.charBuffer, this.charReceived, 0, n),
        (this.charReceived += n),
        this.charReceived < this.charLength)
      )
        return '';
      if (
        ((t = t.slice(n, t.length)),
        !(
          (i = (e = this.charBuffer
            .slice(0, this.charLength)
            .toString(this.encoding)).charCodeAt(e.length - 1)) >= 55296 &&
          i <= 56319
        ))
      ) {
        if (((this.charReceived = this.charLength = 0), t.length === 0))
          return e;
        break;
      }
      ((this.charLength += this.surrogateSize), (e = ''));
    }
    this.detectIncompleteChar(t);
    var r = t.length;
    this.charLength &&
      (t.copy(this.charBuffer, 0, t.length - this.charReceived, r),
      (r -= this.charReceived));
    var i;
    if (
      ((r = (e += t.toString(this.encoding, 0, r)).length - 1),
      (i = e.charCodeAt(r)) >= 55296 && i <= 56319)
    ) {
      var s = this.surrogateSize;
      return (
        (this.charLength += s),
        (this.charReceived += s),
        this.charBuffer.copy(this.charBuffer, s, 0, s),
        t.copy(this.charBuffer, 0, 0, s),
        e.substring(0, r)
      );
    }
    return e;
  }),
    (pf.prototype.detectIncompleteChar = function (t) {
      for (var e = t.length >= 3 ? 3 : t.length; e > 0; e--) {
        var n = t[t.length - e];
        if (e == 1 && n >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (e <= 2 && n >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (e <= 3 && n >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = e;
    }),
    (pf.prototype.end = function (t) {
      var e = '';
      if ((t && t.length && (e = this.write(t)), this.charReceived)) {
        var n = this.charReceived,
          r = this.charBuffer,
          i = this.encoding;
        e += r.slice(0, n).toString(i);
      }
      return e;
    }));
  var T2 = Hu(Object.freeze({__proto__: null, StringDecoder: pf})),
    I2 = la.codes.ERR_STREAM_PREMATURE_CLOSE;
  function qU() {}
  var b0,
    k2,
    R2,
    P2,
    w0,
    M2,
    p1 = function t(e, n, r) {
      if (typeof n == 'function') return t(e, null, n);
      (n || (n = {}),
        (r = (function (g) {
          var m = !1;
          return function () {
            if (!m) {
              m = !0;
              for (
                var y = arguments.length, p = new Array(y), b = 0;
                b < y;
                b++
              )
                p[b] = arguments[b];
              g.apply(this, p);
            }
          };
        })(r || qU)));
      var i = n.readable || (n.readable !== !1 && e.readable),
        s = n.writable || (n.writable !== !1 && e.writable),
        o = function () {
          e.writable || c();
        },
        a = e._writableState && e._writableState.finished,
        c = function () {
          ((s = !1), (a = !0), i || r.call(e));
        },
        l = e._readableState && e._readableState.endEmitted,
        u = function () {
          ((i = !1), (l = !0), s || r.call(e));
        },
        d = function (g) {
          r.call(e, g);
        },
        f = function () {
          var g;
          return i && !l
            ? ((e._readableState && e._readableState.ended) || (g = new I2()),
              r.call(e, g))
            : s && !a
              ? ((e._writableState && e._writableState.ended) || (g = new I2()),
                r.call(e, g))
              : void 0;
        },
        h = function () {
          e.req.on('finish', c);
        };
      return (
        (function (g) {
          return g.setHeader && typeof g.abort == 'function';
        })(e)
          ? (e.on('complete', c),
            e.on('abort', f),
            e.req ? h() : e.on('request', h))
          : s && !e._writableState && (e.on('end', o), e.on('close', o)),
        e.on('end', u),
        e.on('finish', c),
        n.error !== !1 && e.on('error', d),
        e.on('close', f),
        function () {
          (e.removeListener('complete', c),
            e.removeListener('abort', f),
            e.removeListener('request', h),
            e.req && e.req.removeListener('finish', c),
            e.removeListener('end', o),
            e.removeListener('close', o),
            e.removeListener('finish', c),
            e.removeListener('end', u),
            e.removeListener('error', d),
            e.removeListener('close', f));
        }
      );
    };
  function VU() {
    if (k2) return b0;
    var t;
    function e(m, y, p) {
      return (
        (y = (function (b) {
          var v = (function (x, C) {
            if (typeof x != 'object' || x === null) return x;
            var $ = x[Symbol.toPrimitive];
            if ($ !== void 0) {
              var G = $.call(x, C);
              if (typeof G != 'object') return G;
              throw new TypeError(
                '@@toPrimitive must return a primitive value.'
              );
            }
            return (C === 'string' ? String : Number)(x);
          })(b, 'string');
          return typeof v == 'symbol' ? v : String(v);
        })(y)) in m
          ? Object.defineProperty(m, y, {
              value: p,
              enumerable: !0,
              configurable: !0,
              writable: !0
            })
          : (m[y] = p),
        m
      );
    }
    k2 = 1;
    var n = p1,
      r = Symbol('lastResolve'),
      i = Symbol('lastReject'),
      s = Symbol('error'),
      o = Symbol('ended'),
      a = Symbol('lastPromise'),
      c = Symbol('handlePromise'),
      l = Symbol('stream');
    function u(m, y) {
      return {value: m, done: y};
    }
    function d(m) {
      var y = m[r];
      if (y !== null) {
        var p = m[l].read();
        p !== null &&
          ((m[a] = null), (m[r] = null), (m[i] = null), y(u(p, !1)));
      }
    }
    function f(m) {
      tt.nextTick(d, m);
    }
    var h = Object.getPrototypeOf(function () {}),
      g = Object.setPrototypeOf(
        (e(
          (t = {
            get stream() {
              return this[l];
            },
            next: function () {
              var m = this,
                y = this[s];
              if (y !== null) return Promise.reject(y);
              if (this[o]) return Promise.resolve(u(void 0, !0));
              if (this[l].destroyed)
                return new Promise(function (x, C) {
                  tt.nextTick(function () {
                    m[s] ? C(m[s]) : x(u(void 0, !0));
                  });
                });
              var p,
                b = this[a];
              if (b)
                p = new Promise(
                  (function (x, C) {
                    return function ($, G) {
                      x.then(function () {
                        C[o] ? $(u(void 0, !0)) : C[c]($, G);
                      }, G);
                    };
                  })(b, this)
                );
              else {
                var v = this[l].read();
                if (v !== null) return Promise.resolve(u(v, !1));
                p = new Promise(this[c]);
              }
              return ((this[a] = p), p);
            }
          }),
          Symbol.asyncIterator,
          function () {
            return this;
          }
        ),
        e(t, 'return', function () {
          var m = this;
          return new Promise(function (y, p) {
            m[l].destroy(null, function (b) {
              b ? p(b) : y(u(void 0, !0));
            });
          });
        }),
        t),
        h
      );
    return (
      (b0 = function (m) {
        var y,
          p = Object.create(
            g,
            (e((y = {}), l, {value: m, writable: !0}),
            e(y, r, {value: null, writable: !0}),
            e(y, i, {value: null, writable: !0}),
            e(y, s, {value: null, writable: !0}),
            e(y, o, {value: m._readableState.endEmitted, writable: !0}),
            e(y, c, {
              value: function (b, v) {
                var x = p[l].read();
                x
                  ? ((p[a] = null), (p[r] = null), (p[i] = null), b(u(x, !1)))
                  : ((p[r] = b), (p[i] = v));
              },
              writable: !0
            }),
            y)
          );
        return (
          (p[a] = null),
          n(m, function (b) {
            if (b && b.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
              var v = p[i];
              return (
                v !== null &&
                  ((p[a] = null), (p[r] = null), (p[i] = null), v(b)),
                void (p[s] = b)
              );
            }
            var x = p[r];
            (x !== null &&
              ((p[a] = null), (p[r] = null), (p[i] = null), x(u(void 0, !0))),
              (p[o] = !0));
          }),
          m.on('readable', f.bind(null, p)),
          p
        );
      }),
      b0
    );
  }
  function ET() {
    if (M2) return w0;
    var t;
    ((M2 = 1), (w0 = C), (C.ReadableState = x), s1.EventEmitter);
    var e = function (_, S) {
        return _.listeners(S).length;
      },
      n = aT(),
      r = a1.Buffer,
      i =
        (_r !== void 0
          ? _r
          : typeof window < 'u'
            ? window
            : typeof self < 'u'
              ? self
              : {}
        ).Uint8Array || function () {},
      s,
      o = yT;
    s = o && o.debuglog ? o.debuglog('stream') : function () {};
    var a,
      c,
      l,
      u = DU(),
      d = vT(),
      f = wT().getHighWaterMark,
      h = la.codes,
      g = h.ERR_INVALID_ARG_TYPE,
      m = h.ERR_STREAM_PUSH_AFTER_EOF,
      y = h.ERR_METHOD_NOT_IMPLEMENTED,
      p = h.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    qu(C, n);
    var b = d.errorOrDestroy,
      v = ['error', 'close', 'destroy', 'pause', 'resume'];
    function x(_, S, I) {
      ((t = t || Cc()),
        (_ = _ || {}),
        typeof I != 'boolean' && (I = S instanceof t),
        (this.objectMode = !!_.objectMode),
        I && (this.objectMode = this.objectMode || !!_.readableObjectMode),
        (this.highWaterMark = f(this, _, 'readableHighWaterMark', I)),
        (this.buffer = new u()),
        (this.length = 0),
        (this.pipes = null),
        (this.pipesCount = 0),
        (this.flowing = null),
        (this.ended = !1),
        (this.endEmitted = !1),
        (this.reading = !1),
        (this.sync = !0),
        (this.needReadable = !1),
        (this.emittedReadable = !1),
        (this.readableListening = !1),
        (this.resumeScheduled = !1),
        (this.paused = !0),
        (this.emitClose = _.emitClose !== !1),
        (this.autoDestroy = !!_.autoDestroy),
        (this.destroyed = !1),
        (this.defaultEncoding = _.defaultEncoding || 'utf8'),
        (this.awaitDrain = 0),
        (this.readingMore = !1),
        (this.decoder = null),
        (this.encoding = null),
        _.encoding &&
          (a || (a = T2.StringDecoder),
          (this.decoder = new a(_.encoding)),
          (this.encoding = _.encoding)));
    }
    function C(_) {
      if (((t = t || Cc()), !(this instanceof C))) return new C(_);
      var S = this instanceof t;
      ((this._readableState = new x(_, this, S)),
        (this.readable = !0),
        _ &&
          (typeof _.read == 'function' && (this._read = _.read),
          typeof _.destroy == 'function' && (this._destroy = _.destroy)),
        n.call(this));
    }
    function $(_, S, I, O, H) {
      s('readableAddChunk', S);
      var M,
        q = _._readableState;
      if (S === null)
        ((q.reading = !1),
          (function (z, Z) {
            if ((s('onEofChunk'), !Z.ended)) {
              if (Z.decoder) {
                var X = Z.decoder.end();
                X &&
                  X.length &&
                  (Z.buffer.push(X), (Z.length += Z.objectMode ? 1 : X.length));
              }
              ((Z.ended = !0),
                Z.sync
                  ? k(z)
                  : ((Z.needReadable = !1),
                    Z.emittedReadable || ((Z.emittedReadable = !0), V(z))));
            }
          })(_, q));
      else if (
        (H ||
          (M = (function (z, Z) {
            var X;
            ((N = Z),
              r.isBuffer(N) ||
                N instanceof i ||
                typeof Z == 'string' ||
                Z === void 0 ||
                z.objectMode ||
                (X = new g('chunk', ['string', 'Buffer', 'Uint8Array'], Z)));
            var N;
            return X;
          })(q, S)),
        M)
      )
        b(_, M);
      else if (q.objectMode || (S && S.length > 0))
        if (
          (typeof S == 'string' ||
            q.objectMode ||
            Object.getPrototypeOf(S) === r.prototype ||
            (S = (function (z) {
              return r.from(z);
            })(S)),
          O)
        )
          q.endEmitted ? b(_, new p()) : G(_, q, S, !0);
        else if (q.ended) b(_, new m());
        else {
          if (q.destroyed) return !1;
          ((q.reading = !1),
            q.decoder && !I
              ? ((S = q.decoder.write(S)),
                q.objectMode || S.length !== 0 ? G(_, q, S, !1) : K(_, q))
              : G(_, q, S, !1));
        }
      else O || ((q.reading = !1), K(_, q));
      return !q.ended && (q.length < q.highWaterMark || q.length === 0);
    }
    function G(_, S, I, O) {
      (S.flowing && S.length === 0 && !S.sync
        ? ((S.awaitDrain = 0), _.emit('data', I))
        : ((S.length += S.objectMode ? 1 : I.length),
          O ? S.buffer.unshift(I) : S.buffer.push(I),
          S.needReadable && k(_)),
        K(_, S));
    }
    (Object.defineProperty(C.prototype, 'destroyed', {
      enumerable: !1,
      get: function () {
        return this._readableState !== void 0 && this._readableState.destroyed;
      },
      set: function (_) {
        this._readableState && (this._readableState.destroyed = _);
      }
    }),
      (C.prototype.destroy = d.destroy),
      (C.prototype._undestroy = d.undestroy),
      (C.prototype._destroy = function (_, S) {
        S(_);
      }),
      (C.prototype.push = function (_, S) {
        var I,
          O = this._readableState;
        return (
          O.objectMode
            ? (I = !0)
            : typeof _ == 'string' &&
              ((S = S || O.defaultEncoding) !== O.encoding &&
                ((_ = r.from(_, S)), (S = '')),
              (I = !0)),
          $(this, _, S, !1, I)
        );
      }),
      (C.prototype.unshift = function (_) {
        return $(this, _, null, !0, !1);
      }),
      (C.prototype.isPaused = function () {
        return this._readableState.flowing === !1;
      }),
      (C.prototype.setEncoding = function (_) {
        a || (a = T2.StringDecoder);
        var S = new a(_);
        ((this._readableState.decoder = S),
          (this._readableState.encoding =
            this._readableState.decoder.encoding));
        for (var I = this._readableState.buffer.head, O = ''; I !== null; )
          ((O += S.write(I.data)), (I = I.next));
        return (
          this._readableState.buffer.clear(),
          O !== '' && this._readableState.buffer.push(O),
          (this._readableState.length = O.length),
          this
        );
      }));
    var L = 1073741824;
    function F(_, S) {
      return _ <= 0 || (S.length === 0 && S.ended)
        ? 0
        : S.objectMode
          ? 1
          : _ != _
            ? S.flowing && S.length
              ? S.buffer.head.data.length
              : S.length
            : (_ > S.highWaterMark &&
                (S.highWaterMark = (function (I) {
                  return (
                    I >= L
                      ? (I = L)
                      : (I--,
                        (I |= I >>> 1),
                        (I |= I >>> 2),
                        (I |= I >>> 4),
                        (I |= I >>> 8),
                        (I |= I >>> 16),
                        I++),
                    I
                  );
                })(_)),
              _ <= S.length
                ? _
                : S.ended
                  ? S.length
                  : ((S.needReadable = !0), 0));
    }
    function k(_) {
      var S = _._readableState;
      (s('emitReadable', S.needReadable, S.emittedReadable),
        (S.needReadable = !1),
        S.emittedReadable ||
          (s('emitReadable', S.flowing),
          (S.emittedReadable = !0),
          tt.nextTick(V, _)));
    }
    function V(_) {
      var S = _._readableState;
      (s('emitReadable_', S.destroyed, S.length, S.ended),
        S.destroyed ||
          (!S.length && !S.ended) ||
          (_.emit('readable'), (S.emittedReadable = !1)),
        (S.needReadable =
          !S.flowing && !S.ended && S.length <= S.highWaterMark),
        U(_));
    }
    function K(_, S) {
      S.readingMore || ((S.readingMore = !0), tt.nextTick(B, _, S));
    }
    function B(_, S) {
      for (
        ;
        !S.reading &&
        !S.ended &&
        (S.length < S.highWaterMark || (S.flowing && S.length === 0));

      ) {
        var I = S.length;
        if ((s('maybeReadMore read 0'), _.read(0), I === S.length)) break;
      }
      S.readingMore = !1;
    }
    function D(_) {
      var S = _._readableState;
      ((S.readableListening = _.listenerCount('readable') > 0),
        S.resumeScheduled && !S.paused
          ? (S.flowing = !0)
          : _.listenerCount('data') > 0 && _.resume());
    }
    function E(_) {
      (s('readable nexttick read 0'), _.read(0));
    }
    function P(_, S) {
      (s('resume', S.reading),
        S.reading || _.read(0),
        (S.resumeScheduled = !1),
        _.emit('resume'),
        U(_),
        S.flowing && !S.reading && _.read(0));
    }
    function U(_) {
      var S = _._readableState;
      for (s('flow', S.flowing); S.flowing && _.read() !== null; );
    }
    function w(_, S) {
      return S.length === 0
        ? null
        : (S.objectMode
            ? (I = S.buffer.shift())
            : !_ || _ >= S.length
              ? ((I = S.decoder
                  ? S.buffer.join('')
                  : S.buffer.length === 1
                    ? S.buffer.first()
                    : S.buffer.concat(S.length)),
                S.buffer.clear())
              : (I = S.buffer.consume(_, S.decoder)),
          I);
      var I;
    }
    function A(_) {
      var S = _._readableState;
      (s('endReadable', S.endEmitted),
        S.endEmitted || ((S.ended = !0), tt.nextTick(T, S, _)));
    }
    function T(_, S) {
      if (
        (s('endReadableNT', _.endEmitted, _.length),
        !_.endEmitted &&
          _.length === 0 &&
          ((_.endEmitted = !0),
          (S.readable = !1),
          S.emit('end'),
          _.autoDestroy))
      ) {
        var I = S._writableState;
        (!I || (I.autoDestroy && I.finished)) && S.destroy();
      }
    }
    function R(_, S) {
      for (var I = 0, O = _.length; I < O; I++) if (_[I] === S) return I;
      return -1;
    }
    return (
      (C.prototype.read = function (_) {
        (s('read', _), (_ = parseInt(_, 10)));
        var S = this._readableState,
          I = _;
        if (
          (_ !== 0 && (S.emittedReadable = !1),
          _ === 0 &&
            S.needReadable &&
            ((S.highWaterMark !== 0
              ? S.length >= S.highWaterMark
              : S.length > 0) ||
              S.ended))
        )
          return (
            s('read: emitReadable', S.length, S.ended),
            S.length === 0 && S.ended ? A(this) : k(this),
            null
          );
        if ((_ = F(_, S)) === 0 && S.ended)
          return (S.length === 0 && A(this), null);
        var O,
          H = S.needReadable;
        return (
          s('need readable', H),
          (S.length === 0 || S.length - _ < S.highWaterMark) &&
            s('length less than watermark', (H = !0)),
          S.ended || S.reading
            ? s('reading or ended', (H = !1))
            : H &&
              (s('do read'),
              (S.reading = !0),
              (S.sync = !0),
              S.length === 0 && (S.needReadable = !0),
              this._read(S.highWaterMark),
              (S.sync = !1),
              S.reading || (_ = F(I, S))),
          (O = _ > 0 ? w(_, S) : null) === null
            ? ((S.needReadable = S.length <= S.highWaterMark), (_ = 0))
            : ((S.length -= _), (S.awaitDrain = 0)),
          S.length === 0 &&
            (S.ended || (S.needReadable = !0), I !== _ && S.ended && A(this)),
          O !== null && this.emit('data', O),
          O
        );
      }),
      (C.prototype._read = function (_) {
        b(this, new y('_read()'));
      }),
      (C.prototype.pipe = function (_, S) {
        var I = this,
          O = this._readableState;
        switch (O.pipesCount) {
          case 0:
            O.pipes = _;
            break;
          case 1:
            O.pipes = [O.pipes, _];
            break;
          default:
            O.pipes.push(_);
        }
        ((O.pipesCount += 1), s('pipe count=%d opts=%j', O.pipesCount, S));
        var H =
          (!S || S.end !== !1) && _ !== tt.stdout && _ !== tt.stderr ? q : J;
        function M(Q, Y) {
          (s('onunpipe'),
            Q === I &&
              Y &&
              Y.hasUnpiped === !1 &&
              ((Y.hasUnpiped = !0),
              s('cleanup'),
              _.removeListener('close', j),
              _.removeListener('finish', W),
              _.removeListener('drain', z),
              _.removeListener('error', N),
              _.removeListener('unpipe', M),
              I.removeListener('end', q),
              I.removeListener('end', J),
              I.removeListener('data', X),
              (Z = !0),
              !O.awaitDrain ||
                (_._writableState && !_._writableState.needDrain) ||
                z()));
        }
        function q() {
          (s('onend'), _.end());
        }
        (O.endEmitted ? tt.nextTick(H) : I.once('end', H), _.on('unpipe', M));
        var z = (function (Q) {
          return function () {
            var Y = Q._readableState;
            (s('pipeOnDrain', Y.awaitDrain),
              Y.awaitDrain && Y.awaitDrain--,
              Y.awaitDrain === 0 && e(Q, 'data') && ((Y.flowing = !0), U(Q)));
          };
        })(I);
        _.on('drain', z);
        var Z = !1;
        function X(Q) {
          s('ondata');
          var Y = _.write(Q);
          (s('dest.write', Y),
            Y === !1 &&
              (((O.pipesCount === 1 && O.pipes === _) ||
                (O.pipesCount > 1 && R(O.pipes, _) !== -1)) &&
                !Z &&
                (s('false write response, pause', O.awaitDrain),
                O.awaitDrain++),
              I.pause()));
        }
        function N(Q) {
          (s('onerror', Q),
            J(),
            _.removeListener('error', N),
            e(_, 'error') === 0 && b(_, Q));
        }
        function j() {
          (_.removeListener('finish', W), J());
        }
        function W() {
          (s('onfinish'), _.removeListener('close', j), J());
        }
        function J() {
          (s('unpipe'), I.unpipe(_));
        }
        return (
          I.on('data', X),
          (function (Q, Y, se) {
            if (typeof Q.prependListener == 'function')
              return Q.prependListener(Y, se);
            Q._events && Q._events[Y]
              ? Array.isArray(Q._events[Y])
                ? Q._events[Y].unshift(se)
                : (Q._events[Y] = [se, Q._events[Y]])
              : Q.on(Y, se);
          })(_, 'error', N),
          _.once('close', j),
          _.once('finish', W),
          _.emit('pipe', I),
          O.flowing || (s('pipe resume'), I.resume()),
          _
        );
      }),
      (C.prototype.unpipe = function (_) {
        var S = this._readableState,
          I = {hasUnpiped: !1};
        if (S.pipesCount === 0) return this;
        if (S.pipesCount === 1)
          return (
            (_ && _ !== S.pipes) ||
              (_ || (_ = S.pipes),
              (S.pipes = null),
              (S.pipesCount = 0),
              (S.flowing = !1),
              _ && _.emit('unpipe', this, I)),
            this
          );
        if (!_) {
          var O = S.pipes,
            H = S.pipesCount;
          ((S.pipes = null), (S.pipesCount = 0), (S.flowing = !1));
          for (var M = 0; M < H; M++)
            O[M].emit('unpipe', this, {hasUnpiped: !1});
          return this;
        }
        var q = R(S.pipes, _);
        return (
          q === -1 ||
            (S.pipes.splice(q, 1),
            (S.pipesCount -= 1),
            S.pipesCount === 1 && (S.pipes = S.pipes[0]),
            _.emit('unpipe', this, I)),
          this
        );
      }),
      (C.prototype.on = function (_, S) {
        var I = n.prototype.on.call(this, _, S),
          O = this._readableState;
        return (
          _ === 'data'
            ? ((O.readableListening = this.listenerCount('readable') > 0),
              O.flowing !== !1 && this.resume())
            : _ === 'readable' &&
              (O.endEmitted ||
                O.readableListening ||
                ((O.readableListening = O.needReadable = !0),
                (O.flowing = !1),
                (O.emittedReadable = !1),
                s('on readable', O.length, O.reading),
                O.length ? k(this) : O.reading || tt.nextTick(E, this))),
          I
        );
      }),
      (C.prototype.addListener = C.prototype.on),
      (C.prototype.removeListener = function (_, S) {
        var I = n.prototype.removeListener.call(this, _, S);
        return (_ === 'readable' && tt.nextTick(D, this), I);
      }),
      (C.prototype.removeAllListeners = function (_) {
        var S = n.prototype.removeAllListeners.apply(this, arguments);
        return ((_ !== 'readable' && _ !== void 0) || tt.nextTick(D, this), S);
      }),
      (C.prototype.resume = function () {
        var _ = this._readableState;
        return (
          _.flowing ||
            (s('resume'),
            (_.flowing = !_.readableListening),
            (function (S, I) {
              I.resumeScheduled ||
                ((I.resumeScheduled = !0), tt.nextTick(P, S, I));
            })(this, _)),
          (_.paused = !1),
          this
        );
      }),
      (C.prototype.pause = function () {
        return (
          s('call pause flowing=%j', this._readableState.flowing),
          this._readableState.flowing !== !1 &&
            (s('pause'),
            (this._readableState.flowing = !1),
            this.emit('pause')),
          (this._readableState.paused = !0),
          this
        );
      }),
      (C.prototype.wrap = function (_) {
        var S = this,
          I = this._readableState,
          O = !1;
        for (var H in (_.on('end', function () {
          if ((s('wrapped end'), I.decoder && !I.ended)) {
            var q = I.decoder.end();
            q && q.length && S.push(q);
          }
          S.push(null);
        }),
        _.on('data', function (q) {
          (s('wrapped data'),
            I.decoder && (q = I.decoder.write(q)),
            (I.objectMode && q == null) ||
              ((I.objectMode || (q && q.length)) &&
                (S.push(q) || ((O = !0), _.pause()))));
        }),
        _))
          this[H] === void 0 &&
            typeof _[H] == 'function' &&
            (this[H] = (function (q) {
              return function () {
                return _[q].apply(_, arguments);
              };
            })(H));
        for (var M = 0; M < v.length; M++)
          _.on(v[M], this.emit.bind(this, v[M]));
        return (
          (this._read = function (q) {
            (s('wrapped _read', q), O && ((O = !1), _.resume()));
          }),
          this
        );
      }),
      typeof Symbol == 'function' &&
        (C.prototype[Symbol.asyncIterator] = function () {
          return (c === void 0 && (c = VU()), c(this));
        }),
      Object.defineProperty(C.prototype, 'readableHighWaterMark', {
        enumerable: !1,
        get: function () {
          return this._readableState.highWaterMark;
        }
      }),
      Object.defineProperty(C.prototype, 'readableBuffer', {
        enumerable: !1,
        get: function () {
          return this._readableState && this._readableState.buffer;
        }
      }),
      Object.defineProperty(C.prototype, 'readableFlowing', {
        enumerable: !1,
        get: function () {
          return this._readableState.flowing;
        },
        set: function (_) {
          this._readableState && (this._readableState.flowing = _);
        }
      }),
      (C._fromList = w),
      Object.defineProperty(C.prototype, 'readableLength', {
        enumerable: !1,
        get: function () {
          return this._readableState.length;
        }
      }),
      typeof Symbol == 'function' &&
        (C.from = function (_, S) {
          return (
            l === void 0 &&
              (l = P2
                ? R2
                : ((P2 = 1),
                  (R2 = function () {
                    throw new Error(
                      'Readable.from is not available in the browser'
                    );
                  }))),
            l(C, _, S)
          );
        }),
      w0
    );
  }
  var AT = ji,
    zp = la.codes,
    GU = zp.ERR_METHOD_NOT_IMPLEMENTED,
    zU = zp.ERR_MULTIPLE_CALLBACK,
    WU = zp.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ZU = zp.ERR_TRANSFORM_WITH_LENGTH_0,
    mf = Cc();
  function YU(t, e) {
    var n = this._transformState;
    n.transforming = !1;
    var r = n.writecb;
    if (r === null) return this.emit('error', new zU());
    ((n.writechunk = null),
      (n.writecb = null),
      e != null && this.push(e),
      r(t));
    var i = this._readableState;
    ((i.reading = !1),
      (i.needReadable || i.length < i.highWaterMark) &&
        this._read(i.highWaterMark));
  }
  function ji(t) {
    if (!(this instanceof ji)) return new ji(t);
    (mf.call(this, t),
      (this._transformState = {
        afterTransform: YU.bind(this),
        needTransform: !1,
        transforming: !1,
        writecb: null,
        writechunk: null,
        writeencoding: null
      }),
      (this._readableState.needReadable = !0),
      (this._readableState.sync = !1),
      t &&
        (typeof t.transform == 'function' && (this._transform = t.transform),
        typeof t.flush == 'function' && (this._flush = t.flush)),
      this.on('prefinish', QU));
  }
  function QU() {
    var t = this;
    typeof this._flush != 'function' || this._readableState.destroyed
      ? O2(this, null, null)
      : this._flush(function (e, n) {
          O2(t, e, n);
        });
  }
  function O2(t, e, n) {
    if (e) return t.emit('error', e);
    if ((n != null && t.push(n), t._writableState.length)) throw new ZU();
    if (t._transformState.transforming) throw new WU();
    return t.push(null);
  }
  (qu(ji, mf),
    (ji.prototype.push = function (t, e) {
      return (
        (this._transformState.needTransform = !1),
        mf.prototype.push.call(this, t, e)
      );
    }),
    (ji.prototype._transform = function (t, e, n) {
      n(new GU('_transform()'));
    }),
    (ji.prototype._write = function (t, e, n) {
      var r = this._transformState;
      if (
        ((r.writecb = n),
        (r.writechunk = t),
        (r.writeencoding = e),
        !r.transforming)
      ) {
        var i = this._readableState;
        (r.needTransform || i.needReadable || i.length < i.highWaterMark) &&
          this._read(i.highWaterMark);
      }
    }),
    (ji.prototype._read = function (t) {
      var e = this._transformState;
      e.writechunk === null || e.transforming
        ? (e.needTransform = !0)
        : ((e.transforming = !0),
          this._transform(e.writechunk, e.writeencoding, e.afterTransform));
    }),
    (ji.prototype._destroy = function (t, e) {
      mf.prototype._destroy.call(this, t, function (n) {
        e(n);
      });
    }));
  var _0,
    JU = wu,
    ST = AT;
  function wu(t) {
    if (!(this instanceof wu)) return new wu(t);
    ST.call(this, t);
  }
  (qu(wu, ST),
    (wu.prototype._transform = function (t, e, n) {
      n(null, t);
    }));
  var xT = la.codes,
    XU = xT.ERR_MISSING_ARGS,
    eK = xT.ERR_STREAM_DESTROYED;
  function N2(t) {
    if (t) throw t;
  }
  function L2(t) {
    t();
  }
  function tK(t, e) {
    return t.pipe(e);
  }
  var nK = function () {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
      e[n] = arguments[n];
    var r,
      i = (function (o) {
        return o.length
          ? typeof o[o.length - 1] != 'function'
            ? N2
            : o.pop()
          : N2;
      })(e);
    if ((Array.isArray(e[0]) && (e = e[0]), e.length < 2))
      throw new XU('streams');
    var s = e.map(function (o, a) {
      var c = a < e.length - 1;
      return (function (l, u, d, f) {
        f = (function (m) {
          var y = !1;
          return function () {
            y || ((y = !0), m.apply(void 0, arguments));
          };
        })(f);
        var h = !1;
        (l.on('close', function () {
          h = !0;
        }),
          _0 === void 0 && (_0 = p1),
          _0(l, {readable: u, writable: d}, function (m) {
            if (m) return f(m);
            ((h = !0), f());
          }));
        var g = !1;
        return function (m) {
          if (!h && !g)
            return (
              (g = !0),
              (function (y) {
                return y.setHeader && typeof y.abort == 'function';
              })(l)
                ? l.abort()
                : typeof l.destroy == 'function'
                  ? l.destroy()
                  : void f(m || new eK('pipe'))
            );
        };
      })(o, c, a > 0, function (l) {
        (r || (r = l), l && s.forEach(L2), c || (s.forEach(L2), i(r)));
      });
    });
    return e.reduce(tK);
  };
  (function (t, e) {
    (((e = iy.exports = ET()).Stream = e),
      (e.Readable = e),
      (e.Writable = _T()),
      (e.Duplex = Cc()),
      (e.Transform = AT),
      (e.PassThrough = JU),
      (e.finished = p1),
      (e.pipeline = nK));
  })(0, iy.exports);
  var Tc = iy.exports;
  function rK(t = {}) {
    const e = {},
      n = new Tc.Duplex({
        objectMode: !0,
        read: () => {},
        write: function (s, o, a) {
          let c = null;
          try {
            s.id
              ? (function (l) {
                  const {id: u} = l;
                  if (u === null) return;
                  const d = e[u];
                  if (!d)
                    return void console.warn(
                      `StreamMiddleware - Unknown response id "${u}"`
                    );
                  (delete e[u], Object.assign(d.res, l), setTimeout(d.end));
                })(s)
              : (function (l) {
                  (t != null &&
                    t.retryOnMessage &&
                    l.method === t.retryOnMessage &&
                    Object.values(e).forEach(({req: u, retryCount: d = 0}) => {
                      if (!u.id) return;
                      if (d >= 3)
                        throw new Error(
                          `StreamMiddleware - Retry limit exceeded for request id "${u.id}"`
                        );
                      const f = e[u.id];
                      (f && (f.retryCount = d + 1), i(u));
                    }),
                    r.emit('notification', l));
                })(s);
          } catch (l) {
            c = l;
          }
          a(c);
        }
      }),
      r = new eT();
    return {
      events: r,
      middleware: (s, o, a, c) => {
        ((e[s.id] = {req: s, res: o, next: a, end: c}), i(s));
      },
      stream: n
    };
    function i(s) {
      n.push(s);
    }
  }
  var jh = {},
    sy = {exports: {}},
    iK = function t(e, n) {
      if (e && n) return t(e)(n);
      if (typeof e != 'function') throw new TypeError('need wrapper function');
      return (
        Object.keys(e).forEach(function (i) {
          r[i] = e[i];
        }),
        r
      );
      function r() {
        for (var i = new Array(arguments.length), s = 0; s < i.length; s++)
          i[s] = arguments[s];
        var o = e.apply(this, i),
          a = i[i.length - 1];
        return (
          typeof o == 'function' &&
            o !== a &&
            Object.keys(a).forEach(function (c) {
              o[c] = a[c];
            }),
          o
        );
      }
    },
    B2 = iK;
  function Cd(t) {
    var e = function () {
      return e.called
        ? e.value
        : ((e.called = !0), (e.value = t.apply(this, arguments)));
    };
    return ((e.called = !1), e);
  }
  function D2(t) {
    var e = function () {
        if (e.called) throw new Error(e.onceError);
        return ((e.called = !0), (e.value = t.apply(this, arguments)));
      },
      n = t.name || 'Function wrapped with `once`';
    return (
      (e.onceError = n + " shouldn't be called more than once"),
      (e.called = !1),
      e
    );
  }
  ((sy.exports = B2(Cd)),
    (sy.exports.strict = B2(D2)),
    (Cd.proto = Cd(function () {
      (Object.defineProperty(Function.prototype, 'once', {
        value: function () {
          return Cd(this);
        },
        configurable: !0
      }),
        Object.defineProperty(Function.prototype, 'onceStrict', {
          value: function () {
            return D2(this);
          },
          configurable: !0
        }));
    })));
  var sK = sy.exports,
    Uh = {};
  (Object.defineProperty(Uh, '__esModule', {value: !0}),
    (Uh.Substream = void 0));
  const oK = Tc;
  class aK extends oK.Duplex {
    constructor({parent: e, name: n}) {
      (super({objectMode: !0}), (this._parent = e), (this._name = n));
    }
    _read() {}
    _write(e, n, r) {
      (this._parent.push({name: this._name, data: e}), r());
    }
  }
  Uh.Substream = aK;
  var cK =
    (_r && _r.__importDefault) ||
    function (t) {
      return t && t.__esModule ? t : {default: t};
    };
  (Object.defineProperty(jh, '__esModule', {value: !0}),
    (jh.ObjectMultiplex = void 0));
  const E0 = Tc,
    lK = cK(sK),
    uK = Uh,
    F2 = Symbol('IGNORE_SUBSTREAM');
  let dK = class extends E0.Duplex {
    constructor(t = {}) {
      (super(Object.assign(Object.assign({}, t), {objectMode: !0})),
        (this._substreams = {}));
    }
    createStream(t) {
      if (this.destroyed)
        throw new Error(
          `ObjectMultiplex - parent stream for name "${t}" already destroyed`
        );
      if (this._readableState.ended || this._writableState.ended)
        throw new Error(
          `ObjectMultiplex - parent stream for name "${t}" already ended`
        );
      if (!t) throw new Error('ObjectMultiplex - name must not be empty');
      if (this._substreams[t])
        throw new Error(
          `ObjectMultiplex - Substream for name "${t}" already exists`
        );
      const e = new uK.Substream({parent: this, name: t});
      return (
        (this._substreams[t] = e),
        (function (n, r) {
          const i = (0, lK.default)(r);
          ((0, E0.finished)(n, {readable: !1}, i),
            (0, E0.finished)(n, {writable: !1}, i));
        })(this, (n) => e.destroy(n || void 0)),
        e
      );
    }
    ignoreStream(t) {
      if (!t) throw new Error('ObjectMultiplex - name must not be empty');
      if (this._substreams[t])
        throw new Error(
          `ObjectMultiplex - Substream for name "${t}" already exists`
        );
      this._substreams[t] = F2;
    }
    _read() {}
    _write(t, e, n) {
      const {name: r, data: i} = t;
      if (!r)
        return (
          console.warn(`ObjectMultiplex - malformed chunk without name "${t}"`),
          n()
        );
      const s = this._substreams[r];
      return s
        ? (s !== F2 && s.push(i), n())
        : (console.warn(`ObjectMultiplex - orphaned data for stream "${r}"`),
          n());
    }
  };
  jh.ObjectMultiplex = dK;
  var fK = Up(jh.ObjectMultiplex);
  const Vr = (t) =>
    t !== null && typeof t == 'object' && typeof t.pipe == 'function';
  ((Vr.writable = (t) =>
    Vr(t) &&
    t.writable !== !1 &&
    typeof t._write == 'function' &&
    typeof t._writableState == 'object'),
    (Vr.readable = (t) =>
      Vr(t) &&
      t.readable !== !1 &&
      typeof t._read == 'function' &&
      typeof t._readableState == 'object'),
    (Vr.duplex = (t) => Vr.writable(t) && Vr.readable(t)),
    (Vr.transform = (t) => Vr.duplex(t) && typeof t._transform == 'function'));
  var Gr,
    hK = Vr,
    pK = class extends RU {
      constructor(
        t,
        {
          jsonRpcStreamName: e,
          logger: n = console,
          maxEventListeners: r = 100,
          rpcMiddleware: i = []
        }
      ) {
        if (
          (super({logger: n, maxEventListeners: r, rpcMiddleware: i}),
          !hK.duplex(t))
        )
          throw new Error(Tt.errors.invalidDuplexStream());
        this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);
        const s = new fK();
        (Tc.pipeline(
          t,
          s,
          t,
          this._handleStreamDisconnect.bind(this, 'MetaMask')
        ),
          (this._jsonRpcConnection = rK({
            retryOnMessage: 'METAMASK_EXTENSION_CONNECT_CAN_RETRY'
          })),
          Tc.pipeline(
            this._jsonRpcConnection.stream,
            s.createStream(e),
            this._jsonRpcConnection.stream,
            this._handleStreamDisconnect.bind(this, 'MetaMask RpcProvider')
          ),
          this._rpcEngine.push(this._jsonRpcConnection.middleware),
          this._jsonRpcConnection.events.on('notification', (o) => {
            const {method: a, params: c} = o;
            a === 'metamask_accountsChanged'
              ? this._handleAccountsChanged(c)
              : a === 'metamask_unlockStateChanged'
                ? this._handleUnlockStateChanged(c)
                : a === 'metamask_chainChanged'
                  ? this._handleChainChanged(c)
                  : tT.includes(a)
                    ? this.emit('message', {type: a, data: c})
                    : a === 'METAMASK_STREAM_FAILURE' &&
                      t.destroy(new Error(Tt.errors.permanentlyDisconnected()));
          }));
      }
      async _initializeStateAsync() {
        let t;
        try {
          t = await this.request({method: 'metamask_getProviderState'});
        } catch (e) {
          this._log.error(
            'MetaMask: Failed to get initial state. Please report this bug.',
            e
          );
        }
        this._initializeState(t);
      }
      _handleStreamDisconnect(t, e) {
        let n = `MetaMask: Lost connection to "${t}".`;
        (e != null &&
          e.stack &&
          (n += `
${e.stack}`),
          this._log.warn(n),
          this.listenerCount('error') > 0 && this.emit('error', n),
          this._handleDisconnect(!1, e ? e.message : void 0));
      }
      _handleChainChanged({chainId: t, networkVersion: e} = {}) {
        nT(t) && ((n) => !!n && typeof n == 'string')(e)
          ? e === 'loading'
            ? this._handleDisconnect(!0)
            : super._handleChainChanged({chainId: t})
          : this._log.error(Tt.errors.invalidNetworkParams(), {
              chainId: t,
              networkVersion: e
            });
      }
    },
    mK = class extends pK {
      constructor(
        t,
        {
          jsonRpcStreamName: e = 'metamask-provider',
          logger: n = console,
          maxEventListeners: r = 100,
          shouldSendMetadata: i
        } = {}
      ) {
        if (
          (super(t, {
            jsonRpcStreamName: e,
            logger: n,
            maxEventListeners: r,
            rpcMiddleware: EU(n)
          }),
          (this._sentWarnings = {
            chainId: !1,
            networkVersion: !1,
            selectedAddress: !1,
            enable: !1,
            experimentalMethods: !1,
            send: !1,
            events: {close: !1, data: !1, networkChanged: !1, notification: !1}
          }),
          ry(this, Gr, void 0),
          this._initializeStateAsync(),
          Hi(this, Gr, null),
          (this.isMetaMask = !0),
          (this._sendSync = this._sendSync.bind(this)),
          (this.enable = this.enable.bind(this)),
          (this.send = this.send.bind(this)),
          (this.sendAsync = this.sendAsync.bind(this)),
          (this._warnOfDeprecation = this._warnOfDeprecation.bind(this)),
          (this._metamask = this._getExperimentalApi()),
          this._jsonRpcConnection.events.on('notification', (s) => {
            const {method: o} = s;
            tT.includes(o) &&
              (this.emit('data', s),
              this.emit('notification', s.params.result));
          }),
          i)
        )
          if (document.readyState === 'complete')
            m2(this._rpcEngine, this._log);
          else {
            const s = () => {
              (m2(this._rpcEngine, this._log),
                window.removeEventListener('DOMContentLoaded', s));
            };
            window.addEventListener('DOMContentLoaded', s);
          }
      }
      get chainId() {
        return (
          this._sentWarnings.chainId ||
            (this._log.warn(Tt.warnings.chainIdDeprecation),
            (this._sentWarnings.chainId = !0)),
          super.chainId
        );
      }
      get networkVersion() {
        return (
          this._sentWarnings.networkVersion ||
            (this._log.warn(Tt.warnings.networkVersionDeprecation),
            (this._sentWarnings.networkVersion = !0)),
          ri(this, Gr)
        );
      }
      get selectedAddress() {
        return (
          this._sentWarnings.selectedAddress ||
            (this._log.warn(Tt.warnings.selectedAddressDeprecation),
            (this._sentWarnings.selectedAddress = !0)),
          super.selectedAddress
        );
      }
      sendAsync(t, e) {
        this._rpcRequest(t, e);
      }
      addListener(t, e) {
        return (this._warnOfDeprecation(t), super.addListener(t, e));
      }
      on(t, e) {
        return (this._warnOfDeprecation(t), super.on(t, e));
      }
      once(t, e) {
        return (this._warnOfDeprecation(t), super.once(t, e));
      }
      prependListener(t, e) {
        return (this._warnOfDeprecation(t), super.prependListener(t, e));
      }
      prependOnceListener(t, e) {
        return (this._warnOfDeprecation(t), super.prependOnceListener(t, e));
      }
      _handleDisconnect(t, e) {
        (super._handleDisconnect(t, e),
          ri(this, Gr) && !t && Hi(this, Gr, null));
      }
      _warnOfDeprecation(t) {
        var e;
        ((e = this._sentWarnings) == null ? void 0 : e.events[t]) === !1 &&
          (this._log.warn(Tt.warnings.events[t]),
          (this._sentWarnings.events[t] = !0));
      }
      async enable() {
        return (
          this._sentWarnings.enable ||
            (this._log.warn(Tt.warnings.enableDeprecation),
            (this._sentWarnings.enable = !0)),
          new Promise((t, e) => {
            try {
              this._rpcRequest(
                {method: 'eth_requestAccounts', params: []},
                hf(t, e)
              );
            } catch (n) {
              e(n);
            }
          })
        );
      }
      send(t, e) {
        return (
          this._sentWarnings.send ||
            (this._log.warn(Tt.warnings.sendDeprecation),
            (this._sentWarnings.send = !0)),
          typeof t != 'string' || (e && !Array.isArray(e))
            ? t && typeof t == 'object' && typeof e == 'function'
              ? this._rpcRequest(t, e)
              : this._sendSync(t)
            : new Promise((n, r) => {
                try {
                  this._rpcRequest({method: t, params: e}, hf(n, r, !1));
                } catch (i) {
                  r(i);
                }
              })
        );
      }
      _sendSync(t) {
        let e;
        switch (t.method) {
          case 'eth_accounts':
            e = this.selectedAddress ? [this.selectedAddress] : [];
            break;
          case 'eth_coinbase':
            e = this.selectedAddress ?? null;
            break;
          case 'eth_uninstallFilter':
            (this._rpcRequest(t, rT), (e = !0));
            break;
          case 'net_version':
            e = ri(this, Gr) ?? null;
            break;
          default:
            throw new Error(Tt.errors.unsupportedSync(t.method));
        }
        return {id: t.id, jsonrpc: t.jsonrpc, result: e};
      }
      _getExperimentalApi() {
        return new Proxy(
          {
            isUnlocked: async () => (
              this._state.initialized ||
                (await new Promise((t) => {
                  this.on('_initialized', () => t());
                })),
              this._state.isUnlocked
            ),
            requestBatch: async (t) => {
              if (!Array.isArray(t))
                throw xl({
                  message:
                    'Batch requests must be made with an array of request objects.',
                  data: t
                });
              return new Promise((e, n) => {
                this._rpcRequest(t, hf(e, n));
              });
            }
          },
          {
            get: (t, e, ...n) => (
              this._sentWarnings.experimentalMethods ||
                (this._log.warn(Tt.warnings.experimentalMethods),
                (this._sentWarnings.experimentalMethods = !0)),
              Reflect.get(t, e, ...n)
            )
          }
        );
      }
      _handleChainChanged({chainId: t, networkVersion: e} = {}) {
        (super._handleChainChanged({chainId: t, networkVersion: e}),
          this._state.isConnected &&
            e !== ri(this, Gr) &&
            (Hi(this, Gr, e),
            this._state.initialized &&
              this.emit('networkChanged', ri(this, Gr))));
      }
    };
  Gr = new WeakMap();
  const re = Cn('MM_SDK');
  let $2;
  re.color = '#FFAC1C';
  var CT = {},
    Ws = {};
  (Object.defineProperty(Ws, '__esModule', {value: !0}),
    (Ws.EthereumProviderError = Ws.EthereumRpcError = void 0));
  const gK = W5;
  class TT extends Error {
    constructor(e, n, r) {
      if (!Number.isInteger(e)) throw new Error('"code" must be an integer.');
      if (!n || typeof n != 'string')
        throw new Error('"message" must be a nonempty string.');
      (super(n), (this.code = e), r !== void 0 && (this.data = r));
    }
    serialize() {
      const e = {code: this.code, message: this.message};
      return (
        this.data !== void 0 && (e.data = this.data),
        this.stack && (e.stack = this.stack),
        e
      );
    }
    toString() {
      return gK.default(this.serialize(), yK, 2);
    }
  }
  Ws.EthereumRpcError = TT;
  function yK(t, e) {
    if (e !== '[Circular]') return e;
  }
  Ws.EthereumProviderError = class extends TT {
    constructor(t, e, n) {
      if (
        !(function (r) {
          return Number.isInteger(r) && r >= 1e3 && r <= 4999;
        })(t)
      )
        throw new Error(
          '"code" must be an integer such that: 1000 <= code <= 4999'
        );
      super(t, e, n);
    }
  };
  var m1 = {},
    Os = {};
  (Object.defineProperty(Os, '__esModule', {value: !0}),
    (Os.errorValues = Os.errorCodes = void 0),
    (Os.errorCodes = {
      rpc: {
        invalidInput: -32e3,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603
      },
      provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901
      }
    }),
    (Os.errorValues = {
      '-32700': {
        standard: 'JSON RPC 2.0',
        message:
          'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.'
      },
      '-32600': {
        standard: 'JSON RPC 2.0',
        message: 'The JSON sent is not a valid Request object.'
      },
      '-32601': {
        standard: 'JSON RPC 2.0',
        message: 'The method does not exist / is not available.'
      },
      '-32602': {
        standard: 'JSON RPC 2.0',
        message: 'Invalid method parameter(s).'
      },
      '-32603': {standard: 'JSON RPC 2.0', message: 'Internal JSON-RPC error.'},
      '-32000': {standard: 'EIP-1474', message: 'Invalid input.'},
      '-32001': {standard: 'EIP-1474', message: 'Resource not found.'},
      '-32002': {standard: 'EIP-1474', message: 'Resource unavailable.'},
      '-32003': {standard: 'EIP-1474', message: 'Transaction rejected.'},
      '-32004': {standard: 'EIP-1474', message: 'Method not supported.'},
      '-32005': {standard: 'EIP-1474', message: 'Request limit exceeded.'},
      4001: {standard: 'EIP-1193', message: 'User rejected the request.'},
      4100: {
        standard: 'EIP-1193',
        message:
          'The requested account and/or method has not been authorized by the user.'
      },
      4200: {
        standard: 'EIP-1193',
        message:
          'The requested method is not supported by this Ethereum provider.'
      },
      4900: {
        standard: 'EIP-1193',
        message: 'The provider is disconnected from all chains.'
      },
      4901: {
        standard: 'EIP-1193',
        message: 'The provider is disconnected from the specified chain.'
      }
    }),
    (function (t) {
      (Object.defineProperty(t, '__esModule', {value: !0}),
        (t.serializeError =
          t.isValidCode =
          t.getMessageFromCode =
          t.JSON_RPC_SERVER_ERROR_MESSAGE =
            void 0));
      const e = Os,
        n = Ws,
        r = e.errorCodes.rpc.internal,
        i = 'Unspecified error message. This is a bug, please report it.',
        s = {code: r, message: o(r)};
      function o(d, f = i) {
        if (Number.isInteger(d)) {
          const h = d.toString();
          if (u(e.errorValues, h)) return e.errorValues[h].message;
          if (c(d)) return t.JSON_RPC_SERVER_ERROR_MESSAGE;
        }
        return f;
      }
      function a(d) {
        if (!Number.isInteger(d)) return !1;
        const f = d.toString();
        return !!e.errorValues[f] || !!c(d);
      }
      function c(d) {
        return d >= -32099 && d <= -32e3;
      }
      function l(d) {
        return d && typeof d == 'object' && !Array.isArray(d)
          ? Object.assign({}, d)
          : d;
      }
      function u(d, f) {
        return Object.prototype.hasOwnProperty.call(d, f);
      }
      ((t.JSON_RPC_SERVER_ERROR_MESSAGE = 'Unspecified server error.'),
        (t.getMessageFromCode = o),
        (t.isValidCode = a),
        (t.serializeError = function (
          d,
          {fallbackError: f = s, shouldIncludeStack: h = !1} = {}
        ) {
          var g, m;
          if (!f || !Number.isInteger(f.code) || typeof f.message != 'string')
            throw new Error(
              'Must provide fallback error with integer number code and string message.'
            );
          if (d instanceof n.EthereumRpcError) return d.serialize();
          const y = {};
          if (
            d &&
            typeof d == 'object' &&
            !Array.isArray(d) &&
            u(d, 'code') &&
            a(d.code)
          ) {
            const b = d;
            ((y.code = b.code),
              b.message && typeof b.message == 'string'
                ? ((y.message = b.message), u(b, 'data') && (y.data = b.data))
                : ((y.message = o(y.code)), (y.data = {originalError: l(d)})));
          } else {
            y.code = f.code;
            const b = (g = d) === null || g === void 0 ? void 0 : g.message;
            ((y.message = b && typeof b == 'string' ? b : f.message),
              (y.data = {originalError: l(d)}));
          }
          const p = (m = d) === null || m === void 0 ? void 0 : m.stack;
          return (h && d && p && typeof p == 'string' && (y.stack = p), y);
        }));
    })(m1));
  var Kh = {};
  (Object.defineProperty(Kh, '__esModule', {value: !0}),
    (Kh.ethErrors = void 0));
  const g1 = Ws,
    IT = m1,
    sn = Os;
  function ur(t, e) {
    const [n, r] = kT(e);
    return new g1.EthereumRpcError(t, n || IT.getMessageFromCode(t), r);
  }
  function Jc(t, e) {
    const [n, r] = kT(e);
    return new g1.EthereumProviderError(t, n || IT.getMessageFromCode(t), r);
  }
  function kT(t) {
    if (t) {
      if (typeof t == 'string') return [t];
      if (typeof t == 'object' && !Array.isArray(t)) {
        const {message: e, data: n} = t;
        if (e && typeof e != 'string')
          throw new Error('Must specify string message.');
        return [e || void 0, n];
      }
    }
    return [];
  }
  ((Kh.ethErrors = {
    rpc: {
      parse: (t) => ur(sn.errorCodes.rpc.parse, t),
      invalidRequest: (t) => ur(sn.errorCodes.rpc.invalidRequest, t),
      invalidParams: (t) => ur(sn.errorCodes.rpc.invalidParams, t),
      methodNotFound: (t) => ur(sn.errorCodes.rpc.methodNotFound, t),
      internal: (t) => ur(sn.errorCodes.rpc.internal, t),
      server: (t) => {
        if (!t || typeof t != 'object' || Array.isArray(t))
          throw new Error(
            'Ethereum RPC Server errors must provide single object argument.'
          );
        const {code: e} = t;
        if (!Number.isInteger(e) || e > -32005 || e < -32099)
          throw new Error(
            '"code" must be an integer such that: -32099 <= code <= -32005'
          );
        return ur(e, t);
      },
      invalidInput: (t) => ur(sn.errorCodes.rpc.invalidInput, t),
      resourceNotFound: (t) => ur(sn.errorCodes.rpc.resourceNotFound, t),
      resourceUnavailable: (t) => ur(sn.errorCodes.rpc.resourceUnavailable, t),
      transactionRejected: (t) => ur(sn.errorCodes.rpc.transactionRejected, t),
      methodNotSupported: (t) => ur(sn.errorCodes.rpc.methodNotSupported, t),
      limitExceeded: (t) => ur(sn.errorCodes.rpc.limitExceeded, t)
    },
    provider: {
      userRejectedRequest: (t) =>
        Jc(sn.errorCodes.provider.userRejectedRequest, t),
      unauthorized: (t) => Jc(sn.errorCodes.provider.unauthorized, t),
      unsupportedMethod: (t) => Jc(sn.errorCodes.provider.unsupportedMethod, t),
      disconnected: (t) => Jc(sn.errorCodes.provider.disconnected, t),
      chainDisconnected: (t) => Jc(sn.errorCodes.provider.chainDisconnected, t),
      custom: (t) => {
        if (!t || typeof t != 'object' || Array.isArray(t))
          throw new Error(
            'Ethereum Provider custom errors must provide single object argument.'
          );
        const {code: e, message: n, data: r} = t;
        if (!n || typeof n != 'string')
          throw new Error('"message" must be a nonempty string');
        return new g1.EthereumProviderError(e, n, r);
      }
    }
  }),
    (function (t) {
      (Object.defineProperty(t, '__esModule', {value: !0}),
        (t.getMessageFromCode =
          t.serializeError =
          t.EthereumProviderError =
          t.EthereumRpcError =
          t.ethErrors =
          t.errorCodes =
            void 0));
      const e = Ws;
      (Object.defineProperty(t, 'EthereumRpcError', {
        enumerable: !0,
        get: function () {
          return e.EthereumRpcError;
        }
      }),
        Object.defineProperty(t, 'EthereumProviderError', {
          enumerable: !0,
          get: function () {
            return e.EthereumProviderError;
          }
        }));
      const n = m1;
      (Object.defineProperty(t, 'serializeError', {
        enumerable: !0,
        get: function () {
          return n.serializeError;
        }
      }),
        Object.defineProperty(t, 'getMessageFromCode', {
          enumerable: !0,
          get: function () {
            return n.getMessageFromCode;
          }
        }));
      const r = Kh;
      Object.defineProperty(t, 'ethErrors', {
        enumerable: !0,
        get: function () {
          return r.ethErrors;
        }
      });
      const i = Os;
      Object.defineProperty(t, 'errorCodes', {
        enumerable: !0,
        get: function () {
          return i.errorCodes;
        }
      });
    })(CT));
  var RT = {exports: {}};
  RT.exports = (function (t) {
    var e = {};
    function n(r) {
      if (e[r]) return e[r].exports;
      var i = (e[r] = {i: r, l: !1, exports: {}});
      return (t[r].call(i.exports, i, i.exports, n), (i.l = !0), i.exports);
    }
    return (
      (n.m = t),
      (n.c = e),
      (n.d = function (r, i, s) {
        n.o(r, i) || Object.defineProperty(r, i, {enumerable: !0, get: s});
      }),
      (n.r = function (r) {
        (typeof Symbol < 'u' &&
          Symbol.toStringTag &&
          Object.defineProperty(r, Symbol.toStringTag, {value: 'Module'}),
          Object.defineProperty(r, '__esModule', {value: !0}));
      }),
      (n.t = function (r, i) {
        if (
          (1 & i && (r = n(r)),
          8 & i || (4 & i && typeof r == 'object' && r && r.__esModule))
        )
          return r;
        var s = Object.create(null);
        if (
          (n.r(s),
          Object.defineProperty(s, 'default', {enumerable: !0, value: r}),
          2 & i && typeof r != 'string')
        )
          for (var o in r)
            n.d(
              s,
              o,
              function (a) {
                return r[a];
              }.bind(null, o)
            );
        return s;
      }),
      (n.n = function (r) {
        var i =
          r && r.__esModule
            ? function () {
                return r.default;
              }
            : function () {
                return r;
              };
        return (n.d(i, 'a', i), i);
      }),
      (n.o = function (r, i) {
        return Object.prototype.hasOwnProperty.call(r, i);
      }),
      (n.p = ''),
      n((n.s = 90))
    );
  })({
    17: function (t, e, n) {
      ((e.__esModule = !0), (e.default = void 0));
      var r = n(18),
        i = (function () {
          function s() {}
          return (
            (s.getFirstMatch = function (o, a) {
              var c = a.match(o);
              return (c && c.length > 0 && c[1]) || '';
            }),
            (s.getSecondMatch = function (o, a) {
              var c = a.match(o);
              return (c && c.length > 1 && c[2]) || '';
            }),
            (s.matchAndReturnConst = function (o, a, c) {
              if (o.test(a)) return c;
            }),
            (s.getWindowsVersionName = function (o) {
              switch (o) {
                case 'NT':
                  return 'NT';
                case 'XP':
                case 'NT 5.1':
                  return 'XP';
                case 'NT 5.0':
                  return '2000';
                case 'NT 5.2':
                  return '2003';
                case 'NT 6.0':
                  return 'Vista';
                case 'NT 6.1':
                  return '7';
                case 'NT 6.2':
                  return '8';
                case 'NT 6.3':
                  return '8.1';
                case 'NT 10.0':
                  return '10';
                default:
                  return;
              }
            }),
            (s.getMacOSVersionName = function (o) {
              var a = o
                .split('.')
                .splice(0, 2)
                .map(function (c) {
                  return parseInt(c, 10) || 0;
                });
              if ((a.push(0), a[0] === 10))
                switch (a[1]) {
                  case 5:
                    return 'Leopard';
                  case 6:
                    return 'Snow Leopard';
                  case 7:
                    return 'Lion';
                  case 8:
                    return 'Mountain Lion';
                  case 9:
                    return 'Mavericks';
                  case 10:
                    return 'Yosemite';
                  case 11:
                    return 'El Capitan';
                  case 12:
                    return 'Sierra';
                  case 13:
                    return 'High Sierra';
                  case 14:
                    return 'Mojave';
                  case 15:
                    return 'Catalina';
                  default:
                    return;
                }
            }),
            (s.getAndroidVersionName = function (o) {
              var a = o
                .split('.')
                .splice(0, 2)
                .map(function (c) {
                  return parseInt(c, 10) || 0;
                });
              if ((a.push(0), !(a[0] === 1 && a[1] < 5)))
                return a[0] === 1 && a[1] < 6
                  ? 'Cupcake'
                  : a[0] === 1 && a[1] >= 6
                    ? 'Donut'
                    : a[0] === 2 && a[1] < 2
                      ? 'Eclair'
                      : a[0] === 2 && a[1] === 2
                        ? 'Froyo'
                        : a[0] === 2 && a[1] > 2
                          ? 'Gingerbread'
                          : a[0] === 3
                            ? 'Honeycomb'
                            : a[0] === 4 && a[1] < 1
                              ? 'Ice Cream Sandwich'
                              : a[0] === 4 && a[1] < 4
                                ? 'Jelly Bean'
                                : a[0] === 4 && a[1] >= 4
                                  ? 'KitKat'
                                  : a[0] === 5
                                    ? 'Lollipop'
                                    : a[0] === 6
                                      ? 'Marshmallow'
                                      : a[0] === 7
                                        ? 'Nougat'
                                        : a[0] === 8
                                          ? 'Oreo'
                                          : a[0] === 9
                                            ? 'Pie'
                                            : void 0;
            }),
            (s.getVersionPrecision = function (o) {
              return o.split('.').length;
            }),
            (s.compareVersions = function (o, a, c) {
              c === void 0 && (c = !1);
              var l = s.getVersionPrecision(o),
                u = s.getVersionPrecision(a),
                d = Math.max(l, u),
                f = 0,
                h = s.map([o, a], function (g) {
                  var m = d - s.getVersionPrecision(g),
                    y = g + new Array(m + 1).join('.0');
                  return s
                    .map(y.split('.'), function (p) {
                      return new Array(20 - p.length).join('0') + p;
                    })
                    .reverse();
                });
              for (c && (f = d - Math.min(l, u)), d -= 1; d >= f; ) {
                if (h[0][d] > h[1][d]) return 1;
                if (h[0][d] === h[1][d]) {
                  if (d === f) return 0;
                  d -= 1;
                } else if (h[0][d] < h[1][d]) return -1;
              }
            }),
            (s.map = function (o, a) {
              var c,
                l = [];
              if (Array.prototype.map) return Array.prototype.map.call(o, a);
              for (c = 0; c < o.length; c += 1) l.push(a(o[c]));
              return l;
            }),
            (s.find = function (o, a) {
              var c, l;
              if (Array.prototype.find) return Array.prototype.find.call(o, a);
              for (c = 0, l = o.length; c < l; c += 1) {
                var u = o[c];
                if (a(u, c)) return u;
              }
            }),
            (s.assign = function (o) {
              for (
                var a,
                  c,
                  l = o,
                  u = arguments.length,
                  d = new Array(u > 1 ? u - 1 : 0),
                  f = 1;
                f < u;
                f++
              )
                d[f - 1] = arguments[f];
              if (Object.assign)
                return Object.assign.apply(Object, [o].concat(d));
              var h = function () {
                var g = d[a];
                typeof g == 'object' &&
                  g !== null &&
                  Object.keys(g).forEach(function (m) {
                    l[m] = g[m];
                  });
              };
              for (a = 0, c = d.length; a < c; a += 1) h();
              return o;
            }),
            (s.getBrowserAlias = function (o) {
              return r.BROWSER_ALIASES_MAP[o];
            }),
            (s.getBrowserTypeByAlias = function (o) {
              return r.BROWSER_MAP[o] || '';
            }),
            s
          );
        })();
      ((e.default = i), (t.exports = e.default));
    },
    18: function (t, e, n) {
      ((e.__esModule = !0),
        (e.ENGINE_MAP =
          e.OS_MAP =
          e.PLATFORMS_MAP =
          e.BROWSER_MAP =
          e.BROWSER_ALIASES_MAP =
            void 0),
        (e.BROWSER_ALIASES_MAP = {
          'Amazon Silk': 'amazon_silk',
          'Android Browser': 'android',
          Bada: 'bada',
          BlackBerry: 'blackberry',
          Chrome: 'chrome',
          Chromium: 'chromium',
          Electron: 'electron',
          Epiphany: 'epiphany',
          Firefox: 'firefox',
          Focus: 'focus',
          Generic: 'generic',
          'Google Search': 'google_search',
          Googlebot: 'googlebot',
          'Internet Explorer': 'ie',
          'K-Meleon': 'k_meleon',
          Maxthon: 'maxthon',
          'Microsoft Edge': 'edge',
          'MZ Browser': 'mz',
          'NAVER Whale Browser': 'naver',
          Opera: 'opera',
          'Opera Coast': 'opera_coast',
          PhantomJS: 'phantomjs',
          Puffin: 'puffin',
          QupZilla: 'qupzilla',
          QQ: 'qq',
          QQLite: 'qqlite',
          Safari: 'safari',
          Sailfish: 'sailfish',
          'Samsung Internet for Android': 'samsung_internet',
          SeaMonkey: 'seamonkey',
          Sleipnir: 'sleipnir',
          Swing: 'swing',
          Tizen: 'tizen',
          'UC Browser': 'uc',
          Vivaldi: 'vivaldi',
          'WebOS Browser': 'webos',
          WeChat: 'wechat',
          'Yandex Browser': 'yandex',
          Roku: 'roku'
        }),
        (e.BROWSER_MAP = {
          amazon_silk: 'Amazon Silk',
          android: 'Android Browser',
          bada: 'Bada',
          blackberry: 'BlackBerry',
          chrome: 'Chrome',
          chromium: 'Chromium',
          electron: 'Electron',
          epiphany: 'Epiphany',
          firefox: 'Firefox',
          focus: 'Focus',
          generic: 'Generic',
          googlebot: 'Googlebot',
          google_search: 'Google Search',
          ie: 'Internet Explorer',
          k_meleon: 'K-Meleon',
          maxthon: 'Maxthon',
          edge: 'Microsoft Edge',
          mz: 'MZ Browser',
          naver: 'NAVER Whale Browser',
          opera: 'Opera',
          opera_coast: 'Opera Coast',
          phantomjs: 'PhantomJS',
          puffin: 'Puffin',
          qupzilla: 'QupZilla',
          qq: 'QQ Browser',
          qqlite: 'QQ Browser Lite',
          safari: 'Safari',
          sailfish: 'Sailfish',
          samsung_internet: 'Samsung Internet for Android',
          seamonkey: 'SeaMonkey',
          sleipnir: 'Sleipnir',
          swing: 'Swing',
          tizen: 'Tizen',
          uc: 'UC Browser',
          vivaldi: 'Vivaldi',
          webos: 'WebOS Browser',
          wechat: 'WeChat',
          yandex: 'Yandex Browser'
        }),
        (e.PLATFORMS_MAP = {
          tablet: 'tablet',
          mobile: 'mobile',
          desktop: 'desktop',
          tv: 'tv'
        }),
        (e.OS_MAP = {
          WindowsPhone: 'Windows Phone',
          Windows: 'Windows',
          MacOS: 'macOS',
          iOS: 'iOS',
          Android: 'Android',
          WebOS: 'WebOS',
          BlackBerry: 'BlackBerry',
          Bada: 'Bada',
          Tizen: 'Tizen',
          Linux: 'Linux',
          ChromeOS: 'Chrome OS',
          PlayStation4: 'PlayStation 4',
          Roku: 'Roku'
        }),
        (e.ENGINE_MAP = {
          EdgeHTML: 'EdgeHTML',
          Blink: 'Blink',
          Trident: 'Trident',
          Presto: 'Presto',
          Gecko: 'Gecko',
          WebKit: 'WebKit'
        }));
    },
    90: function (t, e, n) {
      ((e.__esModule = !0), (e.default = void 0));
      var r,
        i = (r = n(91)) && r.__esModule ? r : {default: r},
        s = n(18);
      function o(c, l) {
        for (var u = 0; u < l.length; u++) {
          var d = l[u];
          ((d.enumerable = d.enumerable || !1),
            (d.configurable = !0),
            'value' in d && (d.writable = !0),
            Object.defineProperty(c, d.key, d));
        }
      }
      var a = (function () {
        function c() {}
        var l, u, d;
        return (
          (c.getParser = function (f, h) {
            if ((h === void 0 && (h = !1), typeof f != 'string'))
              throw new Error('UserAgent should be a string');
            return new i.default(f, h);
          }),
          (c.parse = function (f) {
            return new i.default(f).getResult();
          }),
          (l = c),
          (d = [
            {
              key: 'BROWSER_MAP',
              get: function () {
                return s.BROWSER_MAP;
              }
            },
            {
              key: 'ENGINE_MAP',
              get: function () {
                return s.ENGINE_MAP;
              }
            },
            {
              key: 'OS_MAP',
              get: function () {
                return s.OS_MAP;
              }
            },
            {
              key: 'PLATFORMS_MAP',
              get: function () {
                return s.PLATFORMS_MAP;
              }
            }
          ]),
          (u = null) && o(l.prototype, u),
          d && o(l, d),
          c
        );
      })();
      ((e.default = a), (t.exports = e.default));
    },
    91: function (t, e, n) {
      ((e.__esModule = !0), (e.default = void 0));
      var r = c(n(92)),
        i = c(n(93)),
        s = c(n(94)),
        o = c(n(95)),
        a = c(n(17));
      function c(u) {
        return u && u.__esModule ? u : {default: u};
      }
      var l = (function () {
        function u(f, h) {
          if ((h === void 0 && (h = !1), f == null || f === ''))
            throw new Error("UserAgent parameter can't be empty");
          ((this._ua = f), (this.parsedResult = {}), h !== !0 && this.parse());
        }
        var d = u.prototype;
        return (
          (d.getUA = function () {
            return this._ua;
          }),
          (d.test = function (f) {
            return f.test(this._ua);
          }),
          (d.parseBrowser = function () {
            var f = this;
            this.parsedResult.browser = {};
            var h = a.default.find(r.default, function (g) {
              if (typeof g.test == 'function') return g.test(f);
              if (g.test instanceof Array)
                return g.test.some(function (m) {
                  return f.test(m);
                });
              throw new Error("Browser's test function is not valid");
            });
            return (
              h && (this.parsedResult.browser = h.describe(this.getUA())),
              this.parsedResult.browser
            );
          }),
          (d.getBrowser = function () {
            return this.parsedResult.browser
              ? this.parsedResult.browser
              : this.parseBrowser();
          }),
          (d.getBrowserName = function (f) {
            return f
              ? String(this.getBrowser().name).toLowerCase() || ''
              : this.getBrowser().name || '';
          }),
          (d.getBrowserVersion = function () {
            return this.getBrowser().version;
          }),
          (d.getOS = function () {
            return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
          }),
          (d.parseOS = function () {
            var f = this;
            this.parsedResult.os = {};
            var h = a.default.find(i.default, function (g) {
              if (typeof g.test == 'function') return g.test(f);
              if (g.test instanceof Array)
                return g.test.some(function (m) {
                  return f.test(m);
                });
              throw new Error("Browser's test function is not valid");
            });
            return (
              h && (this.parsedResult.os = h.describe(this.getUA())),
              this.parsedResult.os
            );
          }),
          (d.getOSName = function (f) {
            var h = this.getOS().name;
            return f ? String(h).toLowerCase() || '' : h || '';
          }),
          (d.getOSVersion = function () {
            return this.getOS().version;
          }),
          (d.getPlatform = function () {
            return this.parsedResult.platform
              ? this.parsedResult.platform
              : this.parsePlatform();
          }),
          (d.getPlatformType = function (f) {
            f === void 0 && (f = !1);
            var h = this.getPlatform().type;
            return f ? String(h).toLowerCase() || '' : h || '';
          }),
          (d.parsePlatform = function () {
            var f = this;
            this.parsedResult.platform = {};
            var h = a.default.find(s.default, function (g) {
              if (typeof g.test == 'function') return g.test(f);
              if (g.test instanceof Array)
                return g.test.some(function (m) {
                  return f.test(m);
                });
              throw new Error("Browser's test function is not valid");
            });
            return (
              h && (this.parsedResult.platform = h.describe(this.getUA())),
              this.parsedResult.platform
            );
          }),
          (d.getEngine = function () {
            return this.parsedResult.engine
              ? this.parsedResult.engine
              : this.parseEngine();
          }),
          (d.getEngineName = function (f) {
            return f
              ? String(this.getEngine().name).toLowerCase() || ''
              : this.getEngine().name || '';
          }),
          (d.parseEngine = function () {
            var f = this;
            this.parsedResult.engine = {};
            var h = a.default.find(o.default, function (g) {
              if (typeof g.test == 'function') return g.test(f);
              if (g.test instanceof Array)
                return g.test.some(function (m) {
                  return f.test(m);
                });
              throw new Error("Browser's test function is not valid");
            });
            return (
              h && (this.parsedResult.engine = h.describe(this.getUA())),
              this.parsedResult.engine
            );
          }),
          (d.parse = function () {
            return (
              this.parseBrowser(),
              this.parseOS(),
              this.parsePlatform(),
              this.parseEngine(),
              this
            );
          }),
          (d.getResult = function () {
            return a.default.assign({}, this.parsedResult);
          }),
          (d.satisfies = function (f) {
            var h = this,
              g = {},
              m = 0,
              y = {},
              p = 0;
            if (
              (Object.keys(f).forEach(function (F) {
                var k = f[F];
                typeof k == 'string'
                  ? ((y[F] = k), (p += 1))
                  : typeof k == 'object' && ((g[F] = k), (m += 1));
              }),
              m > 0)
            ) {
              var b = Object.keys(g),
                v = a.default.find(b, function (F) {
                  return h.isOS(F);
                });
              if (v) {
                var x = this.satisfies(g[v]);
                if (x !== void 0) return x;
              }
              var C = a.default.find(b, function (F) {
                return h.isPlatform(F);
              });
              if (C) {
                var $ = this.satisfies(g[C]);
                if ($ !== void 0) return $;
              }
            }
            if (p > 0) {
              var G = Object.keys(y),
                L = a.default.find(G, function (F) {
                  return h.isBrowser(F, !0);
                });
              if (L !== void 0) return this.compareVersion(y[L]);
            }
          }),
          (d.isBrowser = function (f, h) {
            h === void 0 && (h = !1);
            var g = this.getBrowserName().toLowerCase(),
              m = f.toLowerCase(),
              y = a.default.getBrowserTypeByAlias(m);
            return (h && y && (m = y.toLowerCase()), m === g);
          }),
          (d.compareVersion = function (f) {
            var h = [0],
              g = f,
              m = !1,
              y = this.getBrowserVersion();
            if (typeof y == 'string')
              return (
                f[0] === '>' || f[0] === '<'
                  ? ((g = f.substr(1)),
                    f[1] === '=' ? ((m = !0), (g = f.substr(2))) : (h = []),
                    f[0] === '>' ? h.push(1) : h.push(-1))
                  : f[0] === '='
                    ? (g = f.substr(1))
                    : f[0] === '~' && ((m = !0), (g = f.substr(1))),
                h.indexOf(a.default.compareVersions(y, g, m)) > -1
              );
          }),
          (d.isOS = function (f) {
            return this.getOSName(!0) === String(f).toLowerCase();
          }),
          (d.isPlatform = function (f) {
            return this.getPlatformType(!0) === String(f).toLowerCase();
          }),
          (d.isEngine = function (f) {
            return this.getEngineName(!0) === String(f).toLowerCase();
          }),
          (d.is = function (f, h) {
            return (
              h === void 0 && (h = !1),
              this.isBrowser(f, h) || this.isOS(f) || this.isPlatform(f)
            );
          }),
          (d.some = function (f) {
            var h = this;
            return (
              f === void 0 && (f = []),
              f.some(function (g) {
                return h.is(g);
              })
            );
          }),
          u
        );
      })();
      ((e.default = l), (t.exports = e.default));
    },
    92: function (t, e, n) {
      ((e.__esModule = !0), (e.default = void 0));
      var r,
        i = (r = n(17)) && r.__esModule ? r : {default: r},
        s = /version\/(\d+(\.?_?\d+)+)/i,
        o = [
          {
            test: [/googlebot/i],
            describe: function (a) {
              var c = {name: 'Googlebot'},
                l =
                  i.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, a) ||
                  i.default.getFirstMatch(s, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/opera/i],
            describe: function (a) {
              var c = {name: 'Opera'},
                l =
                  i.default.getFirstMatch(s, a) ||
                  i.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/opr\/|opios/i],
            describe: function (a) {
              var c = {name: 'Opera'},
                l =
                  i.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, a) ||
                  i.default.getFirstMatch(s, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/SamsungBrowser/i],
            describe: function (a) {
              var c = {name: 'Samsung Internet for Android'},
                l =
                  i.default.getFirstMatch(s, a) ||
                  i.default.getFirstMatch(
                    /(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i,
                    a
                  );
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/Whale/i],
            describe: function (a) {
              var c = {name: 'NAVER Whale Browser'},
                l =
                  i.default.getFirstMatch(s, a) ||
                  i.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/MZBrowser/i],
            describe: function (a) {
              var c = {name: 'MZ Browser'},
                l =
                  i.default.getFirstMatch(
                    /(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i,
                    a
                  ) || i.default.getFirstMatch(s, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/focus/i],
            describe: function (a) {
              var c = {name: 'Focus'},
                l =
                  i.default.getFirstMatch(
                    /(?:focus)[\s/](\d+(?:\.\d+)+)/i,
                    a
                  ) || i.default.getFirstMatch(s, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/swing/i],
            describe: function (a) {
              var c = {name: 'Swing'},
                l =
                  i.default.getFirstMatch(
                    /(?:swing)[\s/](\d+(?:\.\d+)+)/i,
                    a
                  ) || i.default.getFirstMatch(s, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/coast/i],
            describe: function (a) {
              var c = {name: 'Opera Coast'},
                l =
                  i.default.getFirstMatch(s, a) ||
                  i.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/opt\/\d+(?:.?_?\d+)+/i],
            describe: function (a) {
              var c = {name: 'Opera Touch'},
                l =
                  i.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, a) ||
                  i.default.getFirstMatch(s, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/yabrowser/i],
            describe: function (a) {
              var c = {name: 'Yandex Browser'},
                l =
                  i.default.getFirstMatch(
                    /(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i,
                    a
                  ) || i.default.getFirstMatch(s, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/ucbrowser/i],
            describe: function (a) {
              var c = {name: 'UC Browser'},
                l =
                  i.default.getFirstMatch(s, a) ||
                  i.default.getFirstMatch(
                    /(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i,
                    a
                  );
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/Maxthon|mxios/i],
            describe: function (a) {
              var c = {name: 'Maxthon'},
                l =
                  i.default.getFirstMatch(s, a) ||
                  i.default.getFirstMatch(
                    /(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i,
                    a
                  );
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/epiphany/i],
            describe: function (a) {
              var c = {name: 'Epiphany'},
                l =
                  i.default.getFirstMatch(s, a) ||
                  i.default.getFirstMatch(
                    /(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i,
                    a
                  );
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/puffin/i],
            describe: function (a) {
              var c = {name: 'Puffin'},
                l =
                  i.default.getFirstMatch(s, a) ||
                  i.default.getFirstMatch(
                    /(?:puffin)[\s/](\d+(\.?_?\d+)+)/i,
                    a
                  );
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/sleipnir/i],
            describe: function (a) {
              var c = {name: 'Sleipnir'},
                l =
                  i.default.getFirstMatch(s, a) ||
                  i.default.getFirstMatch(
                    /(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i,
                    a
                  );
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/k-meleon/i],
            describe: function (a) {
              var c = {name: 'K-Meleon'},
                l =
                  i.default.getFirstMatch(s, a) ||
                  i.default.getFirstMatch(
                    /(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i,
                    a
                  );
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/micromessenger/i],
            describe: function (a) {
              var c = {name: 'WeChat'},
                l =
                  i.default.getFirstMatch(
                    /(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i,
                    a
                  ) || i.default.getFirstMatch(s, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/qqbrowser/i],
            describe: function (a) {
              var c = {
                  name: /qqbrowserlite/i.test(a)
                    ? 'QQ Browser Lite'
                    : 'QQ Browser'
                },
                l =
                  i.default.getFirstMatch(
                    /(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i,
                    a
                  ) || i.default.getFirstMatch(s, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/msie|trident/i],
            describe: function (a) {
              var c = {name: 'Internet Explorer'},
                l = i.default.getFirstMatch(
                  /(?:msie |rv:)(\d+(\.?_?\d+)+)/i,
                  a
                );
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/\sedg\//i],
            describe: function (a) {
              var c = {name: 'Microsoft Edge'},
                l = i.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/edg([ea]|ios)/i],
            describe: function (a) {
              var c = {name: 'Microsoft Edge'},
                l = i.default.getSecondMatch(
                  /edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i,
                  a
                );
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/vivaldi/i],
            describe: function (a) {
              var c = {name: 'Vivaldi'},
                l = i.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/seamonkey/i],
            describe: function (a) {
              var c = {name: 'SeaMonkey'},
                l = i.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/sailfish/i],
            describe: function (a) {
              var c = {name: 'Sailfish'},
                l = i.default.getFirstMatch(
                  /sailfish\s?browser\/(\d+(\.\d+)?)/i,
                  a
                );
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/silk/i],
            describe: function (a) {
              var c = {name: 'Amazon Silk'},
                l = i.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/phantom/i],
            describe: function (a) {
              var c = {name: 'PhantomJS'},
                l = i.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/slimerjs/i],
            describe: function (a) {
              var c = {name: 'SlimerJS'},
                l = i.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
            describe: function (a) {
              var c = {name: 'BlackBerry'},
                l =
                  i.default.getFirstMatch(s, a) ||
                  i.default.getFirstMatch(
                    /blackberry[\d]+\/(\d+(\.?_?\d+)+)/i,
                    a
                  );
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/(web|hpw)[o0]s/i],
            describe: function (a) {
              var c = {name: 'WebOS Browser'},
                l =
                  i.default.getFirstMatch(s, a) ||
                  i.default.getFirstMatch(
                    /w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i,
                    a
                  );
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/bada/i],
            describe: function (a) {
              var c = {name: 'Bada'},
                l = i.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/tizen/i],
            describe: function (a) {
              var c = {name: 'Tizen'},
                l =
                  i.default.getFirstMatch(
                    /(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i,
                    a
                  ) || i.default.getFirstMatch(s, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/qupzilla/i],
            describe: function (a) {
              var c = {name: 'QupZilla'},
                l =
                  i.default.getFirstMatch(
                    /(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i,
                    a
                  ) || i.default.getFirstMatch(s, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/firefox|iceweasel|fxios/i],
            describe: function (a) {
              var c = {name: 'Firefox'},
                l = i.default.getFirstMatch(
                  /(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i,
                  a
                );
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/electron/i],
            describe: function (a) {
              var c = {name: 'Electron'},
                l = i.default.getFirstMatch(
                  /(?:electron)\/(\d+(\.?_?\d+)+)/i,
                  a
                );
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/MiuiBrowser/i],
            describe: function (a) {
              var c = {name: 'Miui'},
                l = i.default.getFirstMatch(
                  /(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i,
                  a
                );
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/chromium/i],
            describe: function (a) {
              var c = {name: 'Chromium'},
                l =
                  i.default.getFirstMatch(
                    /(?:chromium)[\s/](\d+(\.?_?\d+)+)/i,
                    a
                  ) || i.default.getFirstMatch(s, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/chrome|crios|crmo/i],
            describe: function (a) {
              var c = {name: 'Chrome'},
                l = i.default.getFirstMatch(
                  /(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i,
                  a
                );
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/GSA/i],
            describe: function (a) {
              var c = {name: 'Google Search'},
                l = i.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: function (a) {
              var c = !a.test(/like android/i),
                l = a.test(/android/i);
              return c && l;
            },
            describe: function (a) {
              var c = {name: 'Android Browser'},
                l = i.default.getFirstMatch(s, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/playstation 4/i],
            describe: function (a) {
              var c = {name: 'PlayStation 4'},
                l = i.default.getFirstMatch(s, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/safari|applewebkit/i],
            describe: function (a) {
              var c = {name: 'Safari'},
                l = i.default.getFirstMatch(s, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/.*/i],
            describe: function (a) {
              var c =
                a.search('\\(') !== -1
                  ? /^(.*)\/(.*)[ \t]\((.*)/
                  : /^(.*)\/(.*) /;
              return {
                name: i.default.getFirstMatch(c, a),
                version: i.default.getSecondMatch(c, a)
              };
            }
          }
        ];
      ((e.default = o), (t.exports = e.default));
    },
    93: function (t, e, n) {
      ((e.__esModule = !0), (e.default = void 0));
      var r,
        i = (r = n(17)) && r.__esModule ? r : {default: r},
        s = n(18),
        o = [
          {
            test: [/Roku\/DVP/],
            describe: function (a) {
              var c = i.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, a);
              return {name: s.OS_MAP.Roku, version: c};
            }
          },
          {
            test: [/windows phone/i],
            describe: function (a) {
              var c = i.default.getFirstMatch(
                /windows phone (?:os)?\s?(\d+(\.\d+)*)/i,
                a
              );
              return {name: s.OS_MAP.WindowsPhone, version: c};
            }
          },
          {
            test: [/windows /i],
            describe: function (a) {
              var c = i.default.getFirstMatch(
                  /Windows ((NT|XP)( \d\d?.\d)?)/i,
                  a
                ),
                l = i.default.getWindowsVersionName(c);
              return {name: s.OS_MAP.Windows, version: c, versionName: l};
            }
          },
          {
            test: [/Macintosh(.*?) FxiOS(.*?)\//],
            describe: function (a) {
              var c = {name: s.OS_MAP.iOS},
                l = i.default.getSecondMatch(/(Version\/)(\d[\d.]+)/, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/macintosh/i],
            describe: function (a) {
              var c = i.default
                  .getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, a)
                  .replace(/[_\s]/g, '.'),
                l = i.default.getMacOSVersionName(c),
                u = {name: s.OS_MAP.MacOS, version: c};
              return (l && (u.versionName = l), u);
            }
          },
          {
            test: [/(ipod|iphone|ipad)/i],
            describe: function (a) {
              var c = i.default
                .getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, a)
                .replace(/[_\s]/g, '.');
              return {name: s.OS_MAP.iOS, version: c};
            }
          },
          {
            test: function (a) {
              var c = !a.test(/like android/i),
                l = a.test(/android/i);
              return c && l;
            },
            describe: function (a) {
              var c = i.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, a),
                l = i.default.getAndroidVersionName(c),
                u = {name: s.OS_MAP.Android, version: c};
              return (l && (u.versionName = l), u);
            }
          },
          {
            test: [/(web|hpw)[o0]s/i],
            describe: function (a) {
              var c = i.default.getFirstMatch(
                  /(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i,
                  a
                ),
                l = {name: s.OS_MAP.WebOS};
              return (c && c.length && (l.version = c), l);
            }
          },
          {
            test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
            describe: function (a) {
              var c =
                i.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, a) ||
                i.default.getFirstMatch(
                  /blackberry\d+\/(\d+([_\s]\d+)*)/i,
                  a
                ) ||
                i.default.getFirstMatch(/\bbb(\d+)/i, a);
              return {name: s.OS_MAP.BlackBerry, version: c};
            }
          },
          {
            test: [/bada/i],
            describe: function (a) {
              var c = i.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, a);
              return {name: s.OS_MAP.Bada, version: c};
            }
          },
          {
            test: [/tizen/i],
            describe: function (a) {
              var c = i.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, a);
              return {name: s.OS_MAP.Tizen, version: c};
            }
          },
          {
            test: [/linux/i],
            describe: function () {
              return {name: s.OS_MAP.Linux};
            }
          },
          {
            test: [/CrOS/],
            describe: function () {
              return {name: s.OS_MAP.ChromeOS};
            }
          },
          {
            test: [/PlayStation 4/],
            describe: function (a) {
              var c = i.default.getFirstMatch(
                /PlayStation 4[/\s](\d+(\.\d+)*)/i,
                a
              );
              return {name: s.OS_MAP.PlayStation4, version: c};
            }
          }
        ];
      ((e.default = o), (t.exports = e.default));
    },
    94: function (t, e, n) {
      ((e.__esModule = !0), (e.default = void 0));
      var r,
        i = (r = n(17)) && r.__esModule ? r : {default: r},
        s = n(18),
        o = [
          {
            test: [/googlebot/i],
            describe: function () {
              return {type: 'bot', vendor: 'Google'};
            }
          },
          {
            test: [/huawei/i],
            describe: function (a) {
              var c = i.default.getFirstMatch(/(can-l01)/i, a) && 'Nova',
                l = {type: s.PLATFORMS_MAP.mobile, vendor: 'Huawei'};
              return (c && (l.model = c), l);
            }
          },
          {
            test: [/nexus\s*(?:7|8|9|10).*/i],
            describe: function () {
              return {type: s.PLATFORMS_MAP.tablet, vendor: 'Nexus'};
            }
          },
          {
            test: [/ipad/i],
            describe: function () {
              return {
                type: s.PLATFORMS_MAP.tablet,
                vendor: 'Apple',
                model: 'iPad'
              };
            }
          },
          {
            test: [/Macintosh(.*?) FxiOS(.*?)\//],
            describe: function () {
              return {
                type: s.PLATFORMS_MAP.tablet,
                vendor: 'Apple',
                model: 'iPad'
              };
            }
          },
          {
            test: [/kftt build/i],
            describe: function () {
              return {
                type: s.PLATFORMS_MAP.tablet,
                vendor: 'Amazon',
                model: 'Kindle Fire HD 7'
              };
            }
          },
          {
            test: [/silk/i],
            describe: function () {
              return {type: s.PLATFORMS_MAP.tablet, vendor: 'Amazon'};
            }
          },
          {
            test: [/tablet(?! pc)/i],
            describe: function () {
              return {type: s.PLATFORMS_MAP.tablet};
            }
          },
          {
            test: function (a) {
              var c = a.test(/ipod|iphone/i),
                l = a.test(/like (ipod|iphone)/i);
              return c && !l;
            },
            describe: function (a) {
              var c = i.default.getFirstMatch(/(ipod|iphone)/i, a);
              return {type: s.PLATFORMS_MAP.mobile, vendor: 'Apple', model: c};
            }
          },
          {
            test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
            describe: function () {
              return {type: s.PLATFORMS_MAP.mobile, vendor: 'Nexus'};
            }
          },
          {
            test: [/[^-]mobi/i],
            describe: function () {
              return {type: s.PLATFORMS_MAP.mobile};
            }
          },
          {
            test: function (a) {
              return a.getBrowserName(!0) === 'blackberry';
            },
            describe: function () {
              return {type: s.PLATFORMS_MAP.mobile, vendor: 'BlackBerry'};
            }
          },
          {
            test: function (a) {
              return a.getBrowserName(!0) === 'bada';
            },
            describe: function () {
              return {type: s.PLATFORMS_MAP.mobile};
            }
          },
          {
            test: function (a) {
              return a.getBrowserName() === 'windows phone';
            },
            describe: function () {
              return {type: s.PLATFORMS_MAP.mobile, vendor: 'Microsoft'};
            }
          },
          {
            test: function (a) {
              var c = Number(String(a.getOSVersion()).split('.')[0]);
              return a.getOSName(!0) === 'android' && c >= 3;
            },
            describe: function () {
              return {type: s.PLATFORMS_MAP.tablet};
            }
          },
          {
            test: function (a) {
              return a.getOSName(!0) === 'android';
            },
            describe: function () {
              return {type: s.PLATFORMS_MAP.mobile};
            }
          },
          {
            test: function (a) {
              return a.getOSName(!0) === 'macos';
            },
            describe: function () {
              return {type: s.PLATFORMS_MAP.desktop, vendor: 'Apple'};
            }
          },
          {
            test: function (a) {
              return a.getOSName(!0) === 'windows';
            },
            describe: function () {
              return {type: s.PLATFORMS_MAP.desktop};
            }
          },
          {
            test: function (a) {
              return a.getOSName(!0) === 'linux';
            },
            describe: function () {
              return {type: s.PLATFORMS_MAP.desktop};
            }
          },
          {
            test: function (a) {
              return a.getOSName(!0) === 'playstation 4';
            },
            describe: function () {
              return {type: s.PLATFORMS_MAP.tv};
            }
          },
          {
            test: function (a) {
              return a.getOSName(!0) === 'roku';
            },
            describe: function () {
              return {type: s.PLATFORMS_MAP.tv};
            }
          }
        ];
      ((e.default = o), (t.exports = e.default));
    },
    95: function (t, e, n) {
      ((e.__esModule = !0), (e.default = void 0));
      var r,
        i = (r = n(17)) && r.__esModule ? r : {default: r},
        s = n(18),
        o = [
          {
            test: function (a) {
              return a.getBrowserName(!0) === 'microsoft edge';
            },
            describe: function (a) {
              if (/\sedg\//i.test(a)) return {name: s.ENGINE_MAP.Blink};
              var c = i.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, a);
              return {name: s.ENGINE_MAP.EdgeHTML, version: c};
            }
          },
          {
            test: [/trident/i],
            describe: function (a) {
              var c = {name: s.ENGINE_MAP.Trident},
                l = i.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: function (a) {
              return a.test(/presto/i);
            },
            describe: function (a) {
              var c = {name: s.ENGINE_MAP.Presto},
                l = i.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: function (a) {
              var c = a.test(/gecko/i),
                l = a.test(/like gecko/i);
              return c && !l;
            },
            describe: function (a) {
              var c = {name: s.ENGINE_MAP.Gecko},
                l = i.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, a);
              return (l && (c.version = l), c);
            }
          },
          {
            test: [/(apple)?webkit\/537\.36/i],
            describe: function () {
              return {name: s.ENGINE_MAP.Blink};
            }
          },
          {
            test: [/(apple)?webkit/i],
            describe: function (a) {
              var c = {name: s.ENGINE_MAP.WebKit},
                l = i.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, a);
              return (l && (c.version = l), c);
            }
          }
        ];
      ((e.default = o), (t.exports = e.default));
    }
  });
  var PT = Up(RT.exports);
  const Kn = {
    Initialized: 'initialized',
    DisplayURI: 'display_uri',
    ProviderUpdate: 'provider_update',
    ConnectWithResponse: 'connectWithResponse',
    ConnectionStatus: 'connection_status',
    ServiceStatus: 'service_status'
  };
  class Br {
    constructor({
      shouldSetOnWindow: e,
      connectionStream: n,
      shouldSendMetadata: r = !1,
      shouldShimWeb3: i,
      sdkInstance: s
    }) {
      const o = new vK({
          connectionStream: n,
          shouldSendMetadata: r,
          shouldSetOnWindow: e,
          shouldShimWeb3: i,
          autoRequestAccounts: !1
        }),
        a = new Proxy(o, {deleteProperty: () => !0});
      if (
        ((this.provider = a), (this.sdkInstance = s), e && typeof window < 'u')
      )
        try {
          ((c = o),
            (window.ethereum = c),
            window.dispatchEvent(new Event('ethereum#initialized')));
        } catch (l) {
          re(
            '[Ethereum] Unable to set global provider - window.ethereum may be read-only',
            l
          );
        }
      var c;
      if (i && typeof window < 'u')
        try {
          (function (l, u = console) {
            let d = !1,
              f = !1;
            if (!window.web3) {
              const h = '__isMetaMaskShim__';
              let g = {currentProvider: l};
              (Object.defineProperty(g, h, {
                value: !0,
                enumerable: !0,
                configurable: !1,
                writable: !1
              }),
                (g = new Proxy(g, {
                  get: (m, y, ...p) => (
                    y !== 'currentProvider' || d
                      ? y === 'currentProvider' ||
                        y === h ||
                        f ||
                        ((f = !0),
                        u.error(
                          'MetaMask no longer injects web3. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3'
                        ),
                        l
                          .request({method: 'metamask_logWeb3ShimUsage'})
                          .catch((b) => {
                            u.debug(
                              'MetaMask: Failed to log web3 shim usage.',
                              b
                            );
                          }))
                      : ((d = !0),
                        u.warn(
                          'You are accessing the MetaMask window.web3.currentProvider shim. This property is deprecated; use window.ethereum instead. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3'
                        )),
                    Reflect.get(m, y, ...p)
                  ),
                  set: (...m) => (
                    u.warn(
                      'You are accessing the MetaMask window.web3 shim. This object is deprecated; use window.ethereum instead. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3'
                    ),
                    Reflect.set(...m)
                  )
                })),
                Object.defineProperty(window, 'web3', {
                  value: g,
                  enumerable: !1,
                  configurable: !0,
                  writable: !0
                }));
            }
          })(this.provider);
        } catch (l) {
          re(
            '[Ethereum] Unable to shim web3 - window.web3 may be read-only',
            l
          );
        }
      (this.provider.on('display_uri', (l) => {
        this.sdkInstance.emit(Kn.DisplayURI, l);
      }),
        this.provider.on('_initialized', () => {
          const l = {
            chainId: this.provider.getChainId(),
            isConnected: this.provider.isConnected(),
            isMetaMask: this.provider.isMetaMask,
            selectedAddress: this.provider.getSelectedAddress(),
            networkVersion: this.provider.getNetworkVersion()
          };
          (this.sdkInstance.emit(Kn.Initialized, l),
            re('[Ethereum: constructor()] provider initialized', l));
        }));
    }
    static init(e) {
      var n;
      return (
        re('[Ethereum: init()] Initializing Ethereum service'),
        (this.instance = new Br(e)),
        (n = this.instance) === null || n === void 0 ? void 0 : n.provider
      );
    }
    static destroy() {}
    static getInstance() {
      var e;
      if (!(!((e = this.instance) === null || e === void 0) && e.provider))
        throw new Error(
          'Ethereum instance not intiialized - call Ethereum.factory first.'
        );
      return this.instance;
    }
    static getProvider() {
      var e;
      if (!(!((e = this.instance) === null || e === void 0) && e.provider))
        throw new Error(
          'Ethereum instance not intiialized - call Ethereum.factory first.'
        );
      return this.instance.provider;
    }
  }
  class _u {
    constructor({useDeepLink: e, preferredOpenLink: n, debug: r = !1}) {
      ((this.state = {
        platformType: void 0,
        useDeeplink: !1,
        preferredOpenLink: void 0,
        debug: !1
      }),
        (this.state.platformType = this.getPlatformType()),
        (this.state.useDeeplink = e),
        (this.state.preferredOpenLink = n),
        (this.state.debug = r));
    }
    openDeeplink(e, n, r) {
      return (function (i, s, o, a) {
        const {state: c} = i;
        (re(`[PlatfformManager: openDeeplink()] universalLink --> ${s}`),
          re(`[PlatfformManager: openDeeplink()] deepLink --> ${o}`));
        try {
          if (c.preferredOpenLink)
            return void c.preferredOpenLink(c.useDeeplink ? o : s, a);
          if (
            (re(
              `[PlatfformManager: openDeeplink()] open link now useDeepLink=${c.useDeeplink} link=${c.useDeeplink ? o : s}`
            ),
            c.useDeeplink)
          )
            typeof window < 'u' && (window.location.href = o);
          else if (typeof document < 'u') {
            const l = document.createElement('a');
            ((l.href = s),
              (l.target = '_self'),
              (l.rel = 'noreferrer noopener'),
              l.click());
          }
        } catch (l) {
          console.log("[PlatfformManager: openDeeplink()] can't open link", l);
        }
      })(this, e, n, r);
    }
    isReactNative() {
      var e;
      return (
        this.isNotBrowser() &&
        typeof window < 'u' &&
        (window == null ? void 0 : window.navigator) &&
        ((e = window.navigator) === null || e === void 0
          ? void 0
          : e.product) === 'ReactNative'
      );
    }
    isMetaMaskInstalled() {
      return (function () {
        const e =
          Br.getProvider() || (window == null ? void 0 : window.ethereum);
        return (
          re(
            `[PlatfformManager: isMetaMaskInstalled()] isMetaMask=${e == null ? void 0 : e.isMetaMask} isConnected=${e == null ? void 0 : e.isConnected()}`
          ),
          (e == null ? void 0 : e.isMetaMask) &&
            (e == null ? void 0 : e.isConnected())
        );
      })();
    }
    isDesktopWeb() {
      return this.isBrowser() && !this.isMobileWeb();
    }
    isMobile() {
      var e, n;
      const r = PT.parse(window.navigator.userAgent);
      return (
        ((e = r == null ? void 0 : r.platform) === null || e === void 0
          ? void 0
          : e.type) === 'mobile' ||
        ((n = r == null ? void 0 : r.platform) === null || n === void 0
          ? void 0
          : n.type) === 'tablet'
      );
    }
    isSecure() {
      return this.isReactNative() || this.isMobileWeb();
    }
    isMetaMaskMobileWebView() {
      return (
        typeof window < 'u' &&
        !!window.ReactNativeWebView &&
        !!navigator.userAgent.endsWith('MetaMaskMobile')
      );
    }
    isMobileWeb() {
      return this.state.platformType === fn.MobileWeb;
    }
    static isNotBrowser() {
      var e;
      return (
        typeof window > 'u' ||
        !(window != null && window.navigator) ||
        (kn !== void 0 &&
          ((e = kn == null ? void 0 : kn.navigator) === null || e === void 0
            ? void 0
            : e.product) === 'ReactNative') ||
        (navigator == null ? void 0 : navigator.product) === 'ReactNative'
      );
    }
    isNotBrowser() {
      return _u.isNotBrowser();
    }
    static isBrowser() {
      return !this.isNotBrowser();
    }
    isBrowser() {
      return _u.isBrowser();
    }
    isNodeJS() {
      return this.isNotBrowser() && !this.isReactNative();
    }
    isUseDeepLink() {
      return this.state.useDeeplink;
    }
    getPlatformType() {
      return (function (e) {
        const {state: n} = e;
        return n.platformType
          ? n.platformType
          : e.isReactNative()
            ? fn.ReactNative
            : e.isNotBrowser()
              ? fn.NonBrowser
              : e.isMetaMaskMobileWebView()
                ? fn.MetaMaskMobileWebview
                : e.isMobile()
                  ? fn.MobileWeb
                  : fn.DesktopWeb;
      })(this);
    }
  }
  const MT = (t) =>
    ue(void 0, void 0, void 0, function* () {
      if (_u.isBrowser()) {
        const {StorageManagerWeb: n} = yield Promise.resolve().then(
          function () {
            return zK;
          }
        );
        return new n(t);
      }
      const e = {
        persistChannelConfig: () => ue(void 0, void 0, void 0, function* () {}),
        getPersistedChannelConfig: () =>
          ue(void 0, void 0, void 0, function* () {}),
        persistAccounts: () => ue(void 0, void 0, void 0, function* () {}),
        getCachedAccounts: () =>
          ue(void 0, void 0, void 0, function* () {
            return [];
          }),
        persistChainId: () => ue(void 0, void 0, void 0, function* () {}),
        getCachedChainId: () => ue(void 0, void 0, void 0, function* () {}),
        terminate: () => ue(void 0, void 0, void 0, function* () {})
      };
      return Promise.resolve(e);
    });
  class vK extends mK {
    constructor({
      connectionStream: e,
      shouldSendMetadata: n,
      autoRequestAccounts: r = !1
    }) {
      (super(e, {
        logger: console,
        maxEventListeners: 100,
        shouldSendMetadata: n
      }),
        (this.state = {
          accounts: null,
          autoRequestAccounts: !1,
          providerStateRequested: !1,
          chainId: '',
          networkVersion: ''
        }),
        re(`[SDKProvider: constructor()] autoRequestAccounts=${r}`),
        (this.state.autoRequestAccounts = r));
    }
    forceInitializeState() {
      return ue(this, void 0, void 0, function* () {
        return (
          re(
            `[SDKProvider: forceInitializeState()] autoRequestAccounts=${this.state.autoRequestAccounts}`
          ),
          this._initializeStateAsync()
        );
      });
    }
    _setConnected() {
      (re('[SDKProvider: _setConnected()] Setting connected state'),
        (this._state.isConnected = !0));
    }
    getState() {
      return this._state;
    }
    getSDKProviderState() {
      return this.state;
    }
    getSelectedAddress() {
      var e;
      const {accounts: n} = this._state;
      return n && n.length !== 0
        ? ((e = n[0]) === null || e === void 0 ? void 0 : e.toLowerCase()) || ''
        : (re('[SDKProvider: getSelectedAddress] No accounts found'), null);
    }
    getChainId() {
      return this.state.chainId;
    }
    getNetworkVersion() {
      return this.state.networkVersion;
    }
    setSDKProviderState(e) {
      this.state = Object.assign(Object.assign({}, this.state), e);
    }
    handleAccountsChanged(e, n) {
      return this._handleAccountsChanged(e, n);
    }
    handleDisconnect({terminate: e = !1}) {
      (function ({terminate: n = !1, instance: r}) {
        const {state: i} = r;
        (re(
          `[SDKProvider: handleDisconnect()] cleaning up provider state terminate=${n}`,
          r
        ),
          n &&
            ((r._state.accounts = null),
            (r._state.isUnlocked = !1),
            (r._state.isPermanentlyDisconnected = !0),
            (r._state.initialized = !1)),
          r._handleAccountsChanged([]),
          (r._state.isConnected = !1),
          r.emit('disconnect', CT.ethErrors.provider.disconnected()),
          (i.providerStateRequested = !1));
      })({terminate: e, instance: this});
    }
    _initializeStateAsync() {
      return ue(this, void 0, void 0, function* () {
        return (function (e) {
          var n, r;
          return ue(this, void 0, void 0, function* () {
            e.state === void 0 &&
              (e.state = {
                accounts: null,
                autoRequestAccounts: !1,
                providerStateRequested: !1,
                chainId: ''
              });
            const {state: i} = e;
            let s;
            if (i.providerStateRequested)
              re(
                '[SDKProvider: initializeStateAsync()] initialization already in progress'
              );
            else {
              let o;
              i.providerStateRequested = !0;
              let a = null,
                c = !1,
                l = !1;
              const u = yield MT({enabled: !0});
              if (u) {
                const d = yield u.getPersistedChannelConfig({});
                ((c =
                  (n = d == null ? void 0 : d.relayPersistence) !== null &&
                  n !== void 0 &&
                  n),
                  (o = yield u.getCachedChainId()));
                const f = yield u.getCachedAccounts();
                f.length > 0 && (a = f[0]);
              }
              if (
                (re(
                  `[SDKProvider: initializeStateAsync()] relayPersistence=${c}`,
                  {
                    relayPersistence: c,
                    cachedChainId: o,
                    cachedSelectedAddress: a
                  }
                ),
                c)
              )
                if (o && a)
                  ((s = {accounts: [a], chainId: o, isUnlocked: !1}), (l = !0));
                else
                  try {
                    s = yield e.request({method: 'metamask_getProviderState'});
                  } catch (d) {
                    return (
                      e._log.error(
                        'MetaMask: Failed to get initial state. Please report this bug.',
                        d
                      ),
                      void (i.providerStateRequested = !1)
                    );
                  }
              if (
                ((r = s == null ? void 0 : s.accounts) === null || r === void 0
                  ? void 0
                  : r.length) === 0
              )
                if (e.getSelectedAddress())
                  s.accounts = [e.getSelectedAddress()];
                else {
                  re(
                    '[SDKProvider: initializeStateAsync()] Fetch accounts remotely.'
                  );
                  const d = yield e.request({
                    method: 'eth_requestAccounts',
                    params: []
                  });
                  s.accounts = d;
                }
              (e._initializeState(s),
                (i.providerStateRequested = !1),
                l &&
                  ((e._state.isConnected = !0),
                  e.emit('connect', {
                    chainId: s == null ? void 0 : s.chainId
                  })));
            }
          });
        })(this);
      });
    }
    _initializeState(e) {
      return (
        re('[SDKProvider: _initializeState()]', e),
        (function (n, r, i) {
          return (
            re(
              '[SDKProvider: initializeState()] set state._initialized to false'
            ),
            (n._state.initialized = !1),
            r(i)
          );
        })(this, super._initializeState.bind(this), e)
      );
    }
    _handleChainChanged({chainId: e, networkVersion: n} = {}) {
      ((this.state.chainId = e),
        (this.state.networkVersion = n),
        (function ({
          instance: r,
          chainId: i,
          networkVersion: s,
          superHandleChainChanged: o
        }) {
          re(
            `[SDKProvider: handleChainChanged()] chainId=${i} networkVersion=${s}`
          );
          let a = s;
          (s ||
            (re(
              '[SDKProvider: handleChainChanged()] forced network version to prevent provider error'
            ),
            (a = '1')),
            i !== $2 &&
              (kt.analytics.track('sdk_used_chain', {
                caip_chain_id: `eip155:${parseInt(i ?? '0x1', 16)}`
              }),
              ($2 = i)),
            (r._state.isConnected = !0),
            r.emit('connect', {chainId: i}),
            o({chainId: i, networkVersion: a}));
        })({
          instance: this,
          chainId: e,
          networkVersion: n,
          superHandleChainChanged: super._handleChainChanged.bind(this)
        }));
    }
  }
  var Eu,
    ua = {
      name: '@metamask/sdk',
      version: '0.33.0',
      description: '',
      homepage: 'https://github.com/MetaMask/metamask-sdk#readme',
      bugs: {url: 'https://github.com/MetaMask/metamask-sdk/issues'},
      repository: {
        type: 'git',
        url: 'https://github.com/MetaMask/metamask-sdk',
        directory: 'packages/sdk'
      },
      main: 'dist/node/cjs/metamask-sdk.js',
      module: 'dist/browser/es/metamask-sdk.js',
      browser: 'dist/browser/es/metamask-sdk.js',
      unpkg: 'dist/browser/umd/metamask-sdk.js',
      'react-native': 'dist/react-native/es/metamask-sdk.js',
      types: 'dist/types/src/index.d.ts',
      sideEffects: !1,
      files: ['/dist'],
      scripts: {
        'build:types':
          'tsc --project tsconfig.build.json --emitDeclarationOnly --outDir dist/types',
        build: 'yarn build:types && rollup -c --bundleConfigAsCjs',
        'build:clean': 'yarn clean && yarn build',
        'build:post-tsc': "echo 'N/A'",
        'build:pre-tsc': "echo 'N/A'",
        typecheck: 'tsc --noEmit',
        clean: 'rimraf ./dist',
        size: 'node bundle-size && size-limit',
        lint: 'yarn lint:eslint && yarn lint:misc --check',
        'lint:changelog': '../../scripts/validate-changelog.sh @metamask/sdk',
        'lint:eslint': 'eslint . --cache --ext js,ts',
        'lint:fix': 'yarn lint:eslint --fix && yarn lint:misc --write',
        'lint:misc':
          "prettier '**/*.json' '**/*.md' '!CHANGELOG.md' --ignore-path ../../.gitignore",
        prepack: '../../scripts/prepack.sh',
        'publish:preview': 'yarn npm publish --tag preview',
        reset: 'yarn clean && rimraf ./node_modules/',
        test: 'jest --testPathIgnorePatterns "/e2e/"',
        'test:coverage': 'jest --coverage --testPathIgnorePatterns "/e2e/"',
        'test:e2e': 'jest --testPathPattern "/e2e/"',
        'test:ci':
          'jest --coverage --passWithNoTests --setupFilesAfterEnv ./jest-preload.js --testPathIgnorePatterns "/e2e/"',
        'test:dev':
          'jest -c ./jest.config.ts --detectOpenHandles  --testPathIgnorePatterns "/e2e/"',
        watch: 'rollup -c -w',
        dev: 'concurrently "tsc --watch" "rollup -c -w --bundleConfigAsCjs"',
        'build:dev':
          'yarn build:types && NODE_ENV=dev rollup -c --bundleConfigAsCjs'
      },
      dependencies: {
        '@babel/runtime': '^7.26.0',
        '@metamask/onboarding': '^1.0.1',
        '@metamask/providers': '16.1.0',
        '@metamask/sdk-analytics': 'workspace:*',
        '@metamask/sdk-communication-layer': 'workspace:*',
        '@metamask/sdk-install-modal-web': 'workspace:*',
        '@paulmillr/qr': '^0.2.1',
        bowser: '^2.9.0',
        'cross-fetch': '^4.0.0',
        debug: '^4.3.4',
        eciesjs: '^0.4.11',
        'eth-rpc-errors': '^4.0.3',
        eventemitter2: '^6.4.9',
        'obj-multiplex': '^1.0.0',
        pump: '^3.0.0',
        'readable-stream': '^3.6.2',
        'socket.io-client': '^4.5.1',
        tslib: '^2.6.0',
        util: '^0.12.4',
        uuid: '^8.3.2'
      },
      devDependencies: {
        '@jest/globals': '^29.3.1',
        '@lavamoat/allow-scripts': '^2.3.1',
        '@metamask/auto-changelog': '3.1.0',
        '@metamask/eslint-config': '^6.0.0',
        '@metamask/eslint-config-nodejs': '^6.0.0',
        '@metamask/eslint-config-typescript': '^6.0.0',
        '@react-native-async-storage/async-storage': '^1.19.6',
        '@rollup/plugin-alias': '^5.1.1',
        '@rollup/plugin-commonjs': '^25.0.7',
        '@rollup/plugin-json': '^6.0.0',
        '@rollup/plugin-node-resolve': '^15.0.2',
        '@rollup/plugin-replace': '^6.0.1',
        '@rollup/plugin-terser': '^0.4.1',
        '@size-limit/preset-big-lib': '^11.0.2',
        '@types/dom-screen-wake-lock': '^1.0.2',
        '@types/node': '^20.1.3',
        '@types/pump': '^1.1.1',
        '@types/qrcode-terminal': '^0.12.0',
        '@types/uuid': '^10.0.0',
        '@typescript-eslint/eslint-plugin': '^4.26.0',
        '@typescript-eslint/parser': '^4.26.0',
        'browserify-zlib': '^0.2.0',
        buffer: '^6.0.3',
        concurrently: '^9.1.2',
        'crypto-browserify': '^3.12.0',
        eslint: '^7.30.0',
        'eslint-config-prettier': '^8.3.0',
        'eslint-plugin-import': '^2.23.4',
        'eslint-plugin-jest': '^24.4.0',
        'eslint-plugin-jsdoc': '^36.1.0',
        'eslint-plugin-node': '^11.1.0',
        'eslint-plugin-prettier': '^3.4.0',
        'https-browserify': '^1.0.0',
        jest: '^29.3.1',
        'jest-environment-jsdom': '^29.3.1',
        prettier: '^2.3.0',
        process: '^0.11.10',
        rimraf: '^4.4.0',
        rollup: '^4.26.0',
        'rollup-plugin-analyzer': '^4.0.0',
        'rollup-plugin-jscc': '^2.0.0',
        'rollup-plugin-natives': '^0.7.5',
        'rollup-plugin-node-builtins': '^2.1.2',
        'rollup-plugin-polyfill-node': '^0.13.0',
        'rollup-plugin-sizes': '^1.0.6',
        'rollup-plugin-typescript2': '^0.31.2',
        'rollup-plugin-visualizer': '^5.12.0',
        'size-limit': '^11.0.2',
        'stream-browserify': '^3.0.0',
        'stream-http': '^3.2.0',
        'ts-jest': '^29.0.3',
        'ts-node': '^10.9.1',
        typescript: '^4.3.2',
        url: '^0.11.0',
        webpack: '^5.0.0'
      },
      publishConfig: {
        access: 'public',
        registry: 'https://registry.npmjs.org/'
      },
      lavamoat: {
        allowScripts: {
          'eciesjs>secp256k1': !1,
          'socket.io-client>engine.io-client>ws>bufferutil': !1,
          'socket.io-client>engine.io-client>ws>utf-8-validate': !1,
          '@metamask/sdk-communication-layer>bufferutil': !1,
          '@metamask/sdk-communication-layer>eciesjs>secp256k1': !1,
          '@metamask/sdk-communication-layer>utf-8-validate': !1
        }
      }
    };
  (function (t) {
    ((t.INPAGE = 'metamask-inpage'),
      (t.CONTENT_SCRIPT = 'metamask-contentscript'),
      (t.PROVIDER = 'metamask-provider'));
  })(Eu || (Eu = {}));
  const H2 = 'direct',
    Au = 'https://metamask.app.link/connect',
    Su = 'metamask://connect',
    j2 = {NAME: 'MetaMask', RDNS: ['io.metamask', 'io.metamask.flask']},
    bK =
      /(?:^[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}$)|(?:^0{8}-0{4}-0{4}-0{4}-0{12}$)/u,
    xe = {
      METAMASK_GETPROVIDERSTATE: 'metamask_getProviderState',
      METAMASK_CONNECTSIGN: 'metamask_connectSign',
      METAMASK_CONNECTWITH: 'metamask_connectWith',
      METAMASK_OPEN: 'metamask_open',
      METAMASK_BATCH: 'metamask_batch',
      PERSONAL_SIGN: 'personal_sign',
      WALLET_REQUESTPERMISSIONS: 'wallet_requestPermissions',
      WALLET_REVOKEPERMISSIONS: 'wallet_revokePermissions',
      WALLET_GETPERMISSIONS: 'wallet_getPermissions',
      WALLET_WATCHASSET: 'wallet_watchAsset',
      WALLET_ADDETHEREUMCHAIN: 'wallet_addEthereumChain',
      WALLET_SWITCHETHETHEREUMCHAIN: 'wallet_switchEthereumChain',
      ETH_REQUESTACCOUNTS: 'eth_requestAccounts',
      ETH_ACCOUNTS: 'eth_accounts',
      ETH_CHAINID: 'eth_chainId',
      ETH_SENDTRANSACTION: 'eth_sendTransaction',
      ETH_SIGNTYPEDDATA: 'eth_signTypedData',
      ETH_SIGNTYPEDDATA_V3: 'eth_signTypedData_v3',
      ETH_SIGNTYPEDDATA_V4: 'eth_signTypedData_v4',
      ETH_SIGNTRANSACTION: 'eth_signTransaction',
      ETH_SIGN: 'eth_sign',
      PERSONAL_EC_RECOVER: 'personal_ecRecover'
    },
    xu = {
      [xe.ETH_REQUESTACCOUNTS]: !0,
      [xe.ETH_SENDTRANSACTION]: !0,
      [xe.ETH_SIGNTRANSACTION]: !0,
      [xe.ETH_SIGN]: !0,
      [xe.PERSONAL_SIGN]: !0,
      [xe.ETH_ACCOUNTS]: !1,
      [xe.ETH_CHAINID]: !1,
      [xe.PERSONAL_SIGN]: !0,
      [xe.ETH_SIGNTYPEDDATA]: !0,
      [xe.ETH_SIGNTYPEDDATA_V3]: !0,
      [xe.ETH_SIGNTYPEDDATA_V4]: !0,
      [xe.WALLET_REQUESTPERMISSIONS]: !0,
      [xe.WALLET_GETPERMISSIONS]: !0,
      [xe.WALLET_WATCHASSET]: !0,
      [xe.WALLET_ADDETHEREUMCHAIN]: !0,
      [xe.WALLET_SWITCHETHETHEREUMCHAIN]: !0,
      [xe.METAMASK_CONNECTSIGN]: !0,
      [xe.METAMASK_CONNECTWITH]: !0,
      [xe.PERSONAL_EC_RECOVER]: !0,
      [xe.METAMASK_BATCH]: !0,
      [xe.METAMASK_OPEN]: !0
    },
    wK = Object.keys(xu)
      .filter((t) => xu[t] === !0)
      .map((t) => t.toLowerCase()),
    OT = [
      'eth_signTypedData',
      'eth_signTypedData_v3',
      'eth_signTypedData_v4',
      'eth_sign'
    ].map((t) => t.toLowerCase()),
    A0 = '.sdk-comm',
    qh = 'providerType',
    oy = '.MMSDK_cached_address',
    ay = '.MMSDK_cached_chainId',
    qr = {
      CHAIN_CHANGED: 'chainChanged',
      ACCOUNTS_CHANGED: 'accountsChanged',
      DISCONNECT: 'disconnect',
      CONNECT: 'connect',
      CONNECTED: 'connected'
    },
    _K = 1e6;
  var hi;
  (function (t) {
    ((t.TERMINATE = 'terminate'),
      (t.EXTENSION = 'extension'),
      (t.INITIALIZED = 'initialized'));
  })(hi || (hi = {}));
  const EK = typeof window < 'u' && window.localStorage;
  function AK({instance: t, msg: e}) {
    return ue(this, void 0, void 0, function* () {
      if (
        (t._initialized ||
          (re(
            '[MetaMaskSDK: connectAndSign()] provider not ready -- wait for init()'
          ),
          yield t.init()),
        re(
          `[MetaMaskSDK: connectAndSign()] activeProvider=${t.activeProvider}`
        ),
        !t.activeProvider)
      )
        throw new Error('SDK state invalid -- undefined provider');
      const n = /^0x([0-9A-Fa-f]{2})*$/u.test(e)
        ? e
        : (function (r) {
            let i;
            if (de !== void 0) i = de.from(r, 'utf8').toString('hex');
            else if (typeof TextEncoder < 'u') {
              const s = new TextEncoder().encode(r);
              i = Array.from(s)
                .map((o) => o.toString(16).padStart(2, '0'))
                .join('');
            } else {
              if (typeof kn != 'object' || !('Buffer' in kn))
                throw new Error(
                  'Unable to convert string to hex: No available method.'
                );
              i = kn.Buffer.from(r, 'utf8').toString('hex');
            }
            return `0x${i}`;
          })(e);
      return t.activeProvider.request({
        method: xe.METAMASK_CONNECTWITH,
        params: [{method: xe.PERSONAL_SIGN, params: [n]}]
      });
    });
  }
  function U2(t) {
    var e, n;
    return ue(this, void 0, void 0, function* () {
      (re('[MetaMaskSDK: connectWithExtensionProvider()] ', t),
        (t.sdkProvider = t.activeProvider),
        (t.activeProvider = window.extension),
        (window.ethereum = window.extension));
      try {
        const r = yield (e = window.extension) === null || e === void 0
          ? void 0
          : e.request({method: 'eth_requestAccounts'});
        re(`[MetaMaskSDK: connectWithExtensionProvider()] accounts=${r}`);
      } catch (r) {
        return void console.warn(
          "[MetaMaskSDK: connectWithExtensionProvider()] can't request accounts error",
          r
        );
      }
      (localStorage.setItem(qh, 'extension'),
        (t.extensionActive = !0),
        t.emit(Kn.ProviderUpdate, hi.EXTENSION),
        t.options.enableAnalytics &&
          ((n = t.analytics) === null ||
            n === void 0 ||
            n.send({event: Mt.SDK_USE_EXTENSION})));
    });
  }
  function Vh(t) {
    let e;
    if (de !== void 0) e = de.from(t, 'utf8').toString('base64');
    else if (typeof btoa == 'function')
      e = btoa(
        encodeURIComponent(t).replace(/%([0-9A-F]{2})/gu, (n, r) =>
          String.fromCharCode(parseInt(r, 16))
        )
      );
    else {
      if (typeof kn != 'object' || !('Buffer' in kn))
        throw new Error('Unable to base64 encode: No available method.');
      e = kn.Buffer.from(t, 'utf8').toString('base64');
    }
    return e;
  }
  function SK(t, e, n, r) {
    var i, s, o, a, c, l, u, d, f, h, g, m, y, p, b, v, x, C, $, G;
    return ue(this, void 0, void 0, function* () {
      const L =
          (i = t.state.remote) === null || i === void 0 ? void 0 : i.isReady(),
        F =
          (s = t.state.remote) === null || s === void 0
            ? void 0
            : s.isConnected(),
        k =
          (o = t.state.remote) === null || o === void 0 ? void 0 : o.isPaused(),
        V = Br.getProvider(),
        K =
          (a = t.state.remote) === null || a === void 0
            ? void 0
            : a.getChannelId(),
        B =
          (c = t.state.remote) === null || c === void 0
            ? void 0
            : c.isAuthorized(),
        {deeplinkProtocol: D} = t.state,
        {
          method: E,
          data: P,
          triggeredInstaller: U
        } = ((R) => {
          var _, S, I, O;
          let H;
          de.isBuffer(R) ? ((H = R.toJSON()), (H._isBuffer = !0)) : (H = R);
          const M =
            (_ = H == null ? void 0 : H.data) === null || _ === void 0
              ? void 0
              : _.method;
          let q = !1;
          return (
            typeof ((S = H == null ? void 0 : H.data) === null || S === void 0
              ? void 0
              : S.params) == 'object' &&
              ((O =
                (I = H == null ? void 0 : H.data) === null || I === void 0
                  ? void 0
                  : I.params) === null || O === void 0
                ? void 0
                : O.__triggeredInstaller) === !0 &&
              ((q = !0), (H.data.params = H.data.params.wrappedParams)),
            {method: M, data: H, triggeredInstaller: q}
          );
        })(e);
      if (
        (re(
          `[RCPMS: write()] method='${E}' isRemoteReady=${L} channelId=${K} isSocketConnected=${F} isRemotePaused=${k} providerConnected=${V.isConnected()}`,
          e
        ),
        !K)
      )
        return (
          E !== xe.METAMASK_GETPROVIDERSTATE &&
            re(`[RCPMS: write()] ${E} --> channelId is undefined`),
          r(new Error('disconnected'))
        );
      re(
        `[RCPMS: write()] remote.isPaused()=${(l = t.state.remote) === null || l === void 0 ? void 0 : l.isPaused()} authorized=${B} ready=${L} socketConnected=${F}`,
        e
      );
      const w =
          (u = t.state.platformManager) === null || u === void 0
            ? void 0
            : u.isSecure(),
        A =
          (f =
            (d = t.state.platformManager) === null || d === void 0
              ? void 0
              : d.isMobileWeb()) !== null &&
          f !== void 0 &&
          f,
        T =
          (g =
            (h = t.state.remote) === null || h === void 0
              ? void 0
              : h.hasDeeplinkProtocol()) !== null &&
          g !== void 0 &&
          g &&
          A &&
          B;
      try {
        if (!U) {
          const S = JSON.stringify(P == null ? void 0 : P.data);
          if (S.length > _K)
            return r(
              new Error(
                `Message size ${S.length} exceeds maximum allowed size of 1000000 bytes`
              )
            );
          (m = t.state.remote) === null ||
            m === void 0 ||
            m
              .sendMessage(P == null ? void 0 : P.data)
              .then(() => {
                re(`[RCPMS: _write()] ${E} sent successfully`);
              })
              .catch((I) => {
                re('[RCPMS: _write()] error sending message', I);
              });
        }
        if (!w)
          return (
            re(
              `[RCPMS: _write()] unsecure platform for method ${E} -- return callback`
            ),
            r()
          );
        if (U)
          return (
            re(
              '[RCPMS: _write()] prevent deeplink -- installation completed separately.'
            ),
            r()
          );
        const R =
          (b =
            (p =
              (y = t.state.remote) === null || y === void 0
                ? void 0
                : y.getKeyInfo()) === null || p === void 0
              ? void 0
              : p.ecies.public) !== null && b !== void 0
            ? b
            : '';
        let _ = encodeURI(`channelId=${K}&pubkey=${R}&comm=socket&t=d&v=2`);
        if (T) {
          const S = JSON.stringify(P == null ? void 0 : P.data),
            I =
              (v = t.state.remote) === null || v === void 0
                ? void 0
                : v.encrypt(S);
          if (!I)
            return (
              re('[RCPMS: _write()] error encrypting message'),
              r(
                new Error('RemoteCommunicationPostMessageStream - disconnected')
              )
            );
          _ += `&scheme=${D}&rpc=${Vh(I)}`;
        }
        if (
          !(
            !((x = t.state.platformManager) === null || x === void 0) &&
            x.isMetaMaskInstalled()
          )
        )
          return (
            re(
              '[RCPMS: _write()] prevent deeplink until installation is completed.'
            ),
            r()
          );
        xu[E]
          ? (re(
              `[RCPMS: _write()] redirect link for '${E}' socketConnected=${F} connect?${_}`
            ),
            (C = t.state.platformManager) === null ||
              C === void 0 ||
              C.openDeeplink(`${Au}?${_}`, `${Su}?${_}`, '_self'))
          : !(($ = t.state.remote) === null || $ === void 0) && $.isPaused()
            ? (re(
                `[RCPMS: _write()] MM is PAUSED! deeplink with connect! targetMethod=${E}`
              ),
              (G = t.state.platformManager) === null ||
                G === void 0 ||
                G.openDeeplink(
                  `${Au}?redirect=true&${_}`,
                  `${Su}?redirect=true&${_}`,
                  '_self'
                ))
            : re(`[RCPMS: _write()] method ${E} doesn't need redirect.`);
      } catch (R) {
        return (
          re('[RCPMS: _write()] error sending message', R),
          r(new Error('RemoteCommunicationPostMessageStream - disconnected'))
        );
      }
      return r();
    });
  }
  class xK extends Tc.Duplex {
    constructor({name: e, remote: n, deeplinkProtocol: r, platformManager: i}) {
      (super({objectMode: !0}),
        (this.state = {
          _name: null,
          remote: null,
          deeplinkProtocol: !1,
          platformManager: null
        }),
        (this.state._name = e),
        (this.state.remote = n),
        (this.state.deeplinkProtocol = r),
        (this.state.platformManager = i),
        (this._onMessage = this._onMessage.bind(this)),
        this.state.remote.on(me.MESSAGE, this._onMessage));
    }
    _write(e, n, r) {
      return ue(this, void 0, void 0, function* () {
        return SK(this, e, 0, r);
      });
    }
    _read() {}
    _onMessage(e) {
      return (function (n, r) {
        try {
          if (
            (re('[RCPMS: onMessage()] message', r),
            !r ||
              typeof r != 'object' ||
              typeof (r == null ? void 0 : r.data) != 'object')
          )
            return;
          if (!(r != null && r.name))
            return void re(
              '[RCPMS: onMessage()] ignore message without name',
              r
            );
          if ((r == null ? void 0 : r.name) !== Eu.PROVIDER)
            return void re(
              `[RCPMS: onMessage()] ignore message with wrong name message=${r}`
            );
          if (de.isBuffer(r)) {
            const i = de.from(r);
            n.push(i);
          } else n.push(r);
        } catch (i) {
          re(`[RCPMS: onMessage()] ignore message error err=${i}`);
        }
      })(this, e);
    }
    start() {}
  }
  let K2 = 1;
  const NT = (t) =>
      new Promise((e) => {
        setTimeout(() => {
          e(!0);
        }, t);
      }),
    CK = ({
      checkInstallationOnAllCalls: t = !1,
      communicationLayerPreference: e,
      injectProvider: n,
      shouldShimWeb3: r,
      platformManager: i,
      installer: s,
      sdk: o,
      remoteConnection: a,
      debug: c
    }) =>
      ue(void 0, void 0, void 0, function* () {
        var l, u;
        const d = (({name: k, remoteConnection: V}) => {
            if (!V || !(V != null && V.getConnector()))
              throw new Error('Missing remote connection parameter');
            return new xK({
              name: k,
              remote: V == null ? void 0 : V.getConnector(),
              deeplinkProtocol: V == null ? void 0 : V.state.deeplinkProtocol,
              platformManager: V == null ? void 0 : V.getPlatformManager()
            });
          })({name: Eu.INPAGE, target: Eu.CONTENT_SCRIPT, remoteConnection: a}),
          f = i.getPlatformType(),
          h = o.options.dappMetadata,
          g = `Sdk/Javascript SdkVersion/${ua.version} Platform/${f} dApp/${(l = h.url) !== null && l !== void 0 ? l : h.name} dAppTitle/${h.name}`;
        let m = null,
          y = null;
        const p =
          (u = o.options.storage) === null || u === void 0
            ? void 0
            : u.storageManager;
        if (p) {
          try {
            const k = yield p.getCachedAccounts();
            k.length > 0 && (m = k[0]);
          } catch (k) {
            console.error(
              `[initializeMobileProvider] failed to get cached addresses: ${k}`
            );
          }
          try {
            const k = yield p.getCachedChainId();
            k && (y = k);
          } catch (k) {
            console.error(
              `[initializeMobileProvider] failed to parse cached chainId: ${k}`
            );
          }
        }
        re(
          `[initializeMobileProvider] cachedAccountAddress: ${m}, cachedChainId: ${y}`
        );
        const b = !(!n || f === fn.NonBrowser || f === fn.ReactNative),
          v = Br.init({
            shouldSetOnWindow: b,
            connectionStream: d,
            shouldShimWeb3: r,
            sdkInstance: o
          });
        let x = !1;
        const C = (k) => {
            x = k;
          },
          $ = () => x,
          G = (k, V, K, B) =>
            ue(void 0, void 0, void 0, function* () {
              var D, E, P, U, w, A, T, R, _;
              const S = Br.getProvider();
              if (x) {
                (S.emit(
                  'display_uri',
                  (a == null ? void 0 : a.state.qrcodeLink) || ''
                ),
                  a == null || a.showActiveModal());
                let N = $();
                for (; N; ) {
                  const j = $(),
                    W = a == null ? void 0 : a.isAuthorized();
                  ((N = j && !W),
                    re(
                      `[initializeMobileProvider: sendRequest()] waiting for initialization to complete - initializing: ${j} authorized: ${W}`
                    ),
                    yield NT(1e3));
                }
                return (
                  re(
                    '[initializeMobileProvider: sendRequest()] initial method completed -- prevent installation and call provider'
                  ),
                  K(...V)
                );
              }
              const I = i.isMetaMaskInstalled(),
                O = a == null ? void 0 : a.isConnected();
              let H = null,
                M = null,
                q = null;
              if (
                ((H =
                  (D = S.getSelectedAddress()) !== null && D !== void 0
                    ? D
                    : m),
                (q = S.getChainId() || y),
                H &&
                  p &&
                  H !== m &&
                  p.persistAccounts([H]).catch((N) => {
                    console.error(
                      `[initializeMobileProvider] failed to persist account: ${N}`
                    );
                  }),
                q &&
                  ((y = q),
                  p &&
                    p.persistChainId(q).catch((N) => {
                      console.error(
                        `[initializeMobileProvider] failed to persist chainId: ${N}`
                      );
                    })),
                re('[initializeMobileProvider: sendRequest()]', {
                  selectedAddress: H,
                  chainId: q
                }),
                B &&
                  re(
                    `[initializeMobileProvider: sendRequest()] method=${k} ongoing=${x} selectedAddress=${H} isInstalled=${I} checkInstallationOnAllCalls=${t} socketConnected=${O}`
                  ),
                H && k.toLowerCase() === xe.ETH_ACCOUNTS.toLowerCase())
              )
                return [H];
              if (q && k.toLowerCase() === xe.ETH_CHAINID.toLowerCase())
                return q;
              const z = [
                  xe.ETH_REQUESTACCOUNTS,
                  xe.WALLET_REQUESTPERMISSIONS,
                  xe.METAMASK_CONNECTSIGN,
                  xe.METAMASK_CONNECTWITH
                ],
                Z = !xu[k],
                X =
                  (E = o.options.readonlyRPCMap) === null || E === void 0
                    ? void 0
                    : E[q];
              if (X && Z)
                try {
                  const N =
                      (P = V == null ? void 0 : V[0]) === null || P === void 0
                        ? void 0
                        : P.params,
                    j = yield (({
                      rpcEndpoint: W,
                      method: J,
                      sdkInfo: Q,
                      params: Y
                    }) =>
                      ue(void 0, void 0, void 0, function* () {
                        const se = JSON.stringify({
                            jsonrpc: '2.0',
                            method: J,
                            params: Y,
                            id: ((K2 += 1), K2)
                          }),
                          ne = {
                            Accept: 'application/json',
                            'Content-Type': 'application/json'
                          };
                        let oe;
                        W.includes('infura') && (ne['Metamask-Sdk-Info'] = Q);
                        try {
                          oe = yield av(W, {
                            method: 'POST',
                            headers: ne,
                            body: se
                          });
                        } catch (ce) {
                          throw ce instanceof Error
                            ? new Error(
                                `Failed to fetch from RPC: ${ce.message}`
                              )
                            : new Error(`Failed to fetch from RPC: ${ce}`);
                        }
                        if (!oe.ok)
                          throw new Error(
                            `Server responded with a status of ${oe.status}`
                          );
                        return (yield oe.json()).result;
                      }))({
                      rpcEndpoint: X,
                      sdkInfo: g,
                      method: k,
                      params: N || []
                    });
                  return (
                    B && re(`initializeProvider::ReadOnlyRPCResponse ${j}`),
                    j
                  );
                } catch (N) {
                  console.warn(
                    `[initializeMobileProvider: sendRequest()] method=${k} readOnlyRPCRequest failed:`,
                    N
                  );
                }
              if ((!I || (I && !O)) && k !== xe.METAMASK_GETPROVIDERSTATE) {
                const N =
                  ((U = V == null ? void 0 : V[0]) === null || U === void 0
                    ? void 0
                    : U.params) || [];
                if (z.indexOf(k) !== -1 || t) {
                  C(!0);
                  const j = k === xe.METAMASK_CONNECTWITH,
                    W = `${Date.now()}`;
                  try {
                    (yield s.start({
                      wait: !1,
                      connectWith: j ? {method: k, id: W, params: N} : void 0
                    }),
                      yield new Promise((J, Q) => {
                        (a != null &&
                          a.isAuthorized() &&
                          (re(
                            '[initializeMobileProvider: sendRequest()] already authorized'
                          ),
                          J(!0)),
                          a == null ||
                            a.getConnector().once(me.AUTHORIZED, () => {
                              J(!0);
                            }),
                          o.once(me.PROVIDER_UPDATE, (Y) => {
                            (re(
                              `[initializeMobileProvider: sendRequest()] PROVIDER_UPDATE --- remote provider request interupted type=${Y}`
                            ),
                              Y === hi.EXTENSION
                                ? Q(me.PROVIDER_UPDATE)
                                : Q(new Error('Connection Terminated')));
                          }));
                      }));
                  } catch (J) {
                    if (hi.EXTENSION === J) {
                      if (
                        (re(
                          `[initializeMobileProvider: sendRequest()] extension provider detect: re-create ${k} on the active provider`
                        ),
                        k.toLowerCase() ===
                          xe.METAMASK_CONNECTSIGN.toLowerCase())
                      ) {
                        const Q = yield (w = o.getProvider()) === null ||
                        w === void 0
                          ? void 0
                          : w.request({
                              method: xe.ETH_REQUESTACCOUNTS,
                              params: []
                            });
                        if (!Q.length)
                          throw new Error(
                            'SDK state invalid -- undefined accounts'
                          );
                        const Y = yield (A = o.getProvider()) === null ||
                        A === void 0
                          ? void 0
                          : A.request({
                              method: xe.PERSONAL_SIGN,
                              params: [N[0], Q[0]]
                            });
                        return (o.emit(Kn.ConnectWithResponse, Y), Y);
                      }
                      if (
                        k.toLowerCase() ===
                        xe.METAMASK_CONNECTWITH.toLowerCase()
                      ) {
                        const [Q] = N,
                          Y = yield (({method: se, sdk: ne, params: oe}) =>
                            ue(void 0, void 0, void 0, function* () {
                              var ce, fe, le, ve;
                              if (!ne.isExtensionActive())
                                throw new Error(
                                  'SDK state invalid -- extension is not active'
                                );
                              re(
                                '[MetaMaskProvider: extensionConnectWithOverwrite()] Overwriting request method',
                                se,
                                oe
                              );
                              const _e = yield (ce = ne.getProvider()) ===
                                null || ce === void 0
                                ? void 0
                                : ce.request({
                                    method: xe.ETH_REQUESTACCOUNTS,
                                    params: []
                                  });
                              if (!_e.length)
                                throw new Error(
                                  'SDK state invalid -- undefined accounts'
                                );
                              if (
                                (se == null ? void 0 : se.toLowerCase()) ===
                                xe.PERSONAL_SIGN.toLowerCase()
                              ) {
                                const Te = {method: se, params: [oe[0], _e[0]]};
                                return yield (fe = ne.getProvider()) === null ||
                                fe === void 0
                                  ? void 0
                                  : fe.request(Te);
                              }
                              if (
                                (se == null ? void 0 : se.toLowerCase()) ===
                                xe.ETH_SENDTRANSACTION.toLowerCase()
                              ) {
                                const Te = {
                                  method: se,
                                  params: [
                                    Object.assign(Object.assign({}, oe[0]), {
                                      from: _e[0]
                                    })
                                  ]
                                };
                                return yield (le = ne.getProvider()) === null ||
                                le === void 0
                                  ? void 0
                                  : le.request(Te);
                              }
                              return OT.includes(se.toLowerCase())
                                ? (console.warn(
                                    `MetaMaskSDK connectWith method=${se} -- not handled by the extension -- call separately`
                                  ),
                                  _e)
                                : yield (ve = ne.getProvider()) === null ||
                                  ve === void 0
                                    ? void 0
                                    : ve.request({method: se, params: oe});
                            }))({method: Q.method, sdk: o, params: Q.params});
                        return (o.emit(Kn.ConnectWithResponse, Y), Y);
                      }
                      return (
                        re(
                          `[initializeMobileProvider: sendRequest()] sending '${k}' on active provider`,
                          N
                        ),
                        yield (T = o.getProvider()) === null || T === void 0
                          ? void 0
                          : T.request({method: k, params: N})
                      );
                    }
                    throw J === me.REJECTED
                      ? (a == null || a.closeModal(),
                        (R = o.getProvider()) === null ||
                          R === void 0 ||
                          R.handleDisconnect({terminate: !1}),
                        Object.assign(new Error('User rejected connection'), {
                          code: 4001
                        }))
                      : (re(
                          `[initializeMobileProvider: sendRequest()] failed to start installer: ${J}`
                        ),
                        J);
                  } finally {
                    C(!1);
                  }
                  if (k === xe.ETH_REQUESTACCOUNTS)
                    return (
                      (M = yield new Promise((J) => {
                        const Q = setInterval(() => {
                          const {accounts: Y} = S.getState();
                          Y && (clearInterval(Q), J(Y));
                        }, 100);
                      })),
                      re(
                        `[initializeMobileProvider: sendRequest()] selectedAddress: ${H} --- SKIP rpc call`
                      ),
                      M
                    );
                  if (k === xe.METAMASK_CONNECTWITH)
                    try {
                      let J = 0;
                      const Q = 5,
                        Y = ({resolve: ce, reject: fe}) => {
                          J += 1;
                          const le =
                              a == null
                                ? void 0
                                : a.getConnector().getRPCMethodTracker(),
                            ve = le == null ? void 0 : le[W];
                          return (
                            re(`TRACKER: update method ${W}`, ve),
                            ve != null && ve.result
                              ? (re(
                                  '[initializeMobileProvider: sendRequest()] found result',
                                  ve.result
                                ),
                                o.emit(Kn.ConnectWithResponse, ve.result),
                                void ce(ve.result))
                              : ve != null && ve.error
                                ? (re(
                                    '[initializeMobileProvider: sendRequest()] found error',
                                    ve.error
                                  ),
                                  void fe(ve.error))
                                : J >= Q
                                  ? (re(
                                      '[initializeMobileProvider: sendRequest()] max message count reached without result'
                                    ),
                                    void fe(
                                      new Error(
                                        'Max message count reached without result'
                                      )
                                    ))
                                  : void re(
                                      '[initializeMobileProvider: sendRequest()] not found yet, need to wait for next update'
                                    )
                          );
                        };
                      let se, ne;
                      const oe = yield new Promise((ce, fe) => {
                        const le =
                          a == null
                            ? void 0
                            : a.getConnector().getRPCMethodTracker();
                        (re(`TRACKER: method ${W}`, le),
                          le != null && le[W].result
                            ? (re(
                                '[initializeMobileProvider: sendRequest()] found result',
                                le == null ? void 0 : le[W].result
                              ),
                              ce(le == null ? void 0 : le[W].result))
                            : le != null &&
                              le[W].error &&
                              (re(
                                '[initializeMobileProvider: sendRequest()] found error',
                                le == null ? void 0 : le[W].error
                              ),
                              fe(le == null ? void 0 : le[W].error)),
                          (ne = () => Y({resolve: ce, reject: fe})),
                          (se =
                            a == null
                              ? void 0
                              : a.getConnector().on(me.RPC_UPDATE, ne)));
                      });
                      return (
                        ne && (se == null || se.off(me.RPC_UPDATE, ne)),
                        re('TRACKER: result', oe),
                        oe
                      );
                    } catch (J) {
                      throw (
                        re(
                          '[initializeMobileProvider: sendRequest()] error:',
                          J
                        ),
                        J
                      );
                    }
                  return (
                    V[0] &&
                      typeof V[0] == 'object' &&
                      (V[0].params = {
                        __triggeredInstaller: !0,
                        wrappedParams: V[0].params
                      }),
                    K(...V)
                  );
                }
                if (i.isSecure() && xu[k]) return K(...V);
                if (o.isExtensionActive())
                  return (
                    re(
                      `[initializeMobileProvider: sendRequest()] EXTENSION active - redirect request '${k}' to it`,
                      V,
                      N
                    ),
                    yield (_ = o.getProvider()) === null || _ === void 0
                      ? void 0
                      : _.request({method: k, params: N})
                  );
                throw (
                  re(
                    `[initializeMobileProvider: sendRequest()] method=${k} --- skip --- not connected/installed`
                  ),
                  new Error(
                    'MetaMask is not connected/installed, please call eth_requestAccounts to connect first.'
                  )
                );
              }
              try {
                const N = yield K(...V);
                if (
                  (re(
                    `[initializeMobileProvider: sendRequest()] method=${k} rpcResponse`,
                    N
                  ),
                  k === xe.WALLET_REQUESTPERMISSIONS)
                ) {
                  const j = N.reduce((W, J) => {
                    var Q;
                    if (J.parentCapability === 'eth_accounts') {
                      const Y =
                        (Q = J.caveats.find(
                          (se) => se.type === 'restrictReturnedAccounts'
                        )) === null || Q === void 0
                          ? void 0
                          : Q.value;
                      Y && W.push(...Y);
                    }
                    return W;
                  }, []);
                  (re(
                    '[initializeMobileProvider: sendRequest()] accountsToPersist:',
                    j
                  ),
                    j.length > 0 &&
                      (S.handleAccountsChanged(j, !1),
                      p == null || p.persistAccounts(j)));
                }
                return N;
              } catch (N) {
                throw (
                  console.error(
                    '[initializeMobileProvider: sendRequest()] error:',
                    N
                  ),
                  N
                );
              }
            }),
          {request: L} = v;
        v.request = (...k) =>
          ue(void 0, void 0, void 0, function* () {
            return G(k == null ? void 0 : k[0].method, k, L, c);
          });
        const {send: F} = v;
        return (
          (v.send = (...k) =>
            ue(void 0, void 0, void 0, function* () {
              return G(k == null ? void 0 : k[0], k, F, c);
            })),
          re(
            '[initializeMobileProvider: sendRequest()] metamaskStream.start()'
          ),
          d.start(),
          v
        );
      });
  function TK(t) {
    var e, n, r, i;
    return ue(this, void 0, void 0, function* () {
      const {options: s} = t,
        o = {
          communicationLayerPreference:
            (e = s.communicationLayerPreference) !== null && e !== void 0
              ? e
              : ta.SOCKET,
          platformManager: t.platformManager,
          sdk: t,
          checkInstallationOnAllCalls: s.checkInstallationOnAllCalls,
          injectProvider: (n = s.injectProvider) === null || n === void 0 || n,
          shouldShimWeb3: (r = s.shouldShimWeb3) === null || r === void 0 || r,
          extensionOnly: (i = s.extensionOnly) === null || i === void 0 || i,
          installer: t.installer,
          remoteConnection: t.remoteConnection,
          debug: t.debug
        },
        a = yield CK(o);
      ((t.activeProvider = a),
        (function (c) {
          var l, u, d, f;
          ((u =
            (l = c.remoteConnection) === null || l === void 0
              ? void 0
              : l.getConnector()) === null ||
            u === void 0 ||
            u.on(Kn.ConnectionStatus, (h) => {
              c.emit(Kn.ConnectionStatus, h);
            }),
            (f =
              (d = c.remoteConnection) === null || d === void 0
                ? void 0
                : d.getConnector()) === null ||
              f === void 0 ||
              f.on(Kn.ServiceStatus, (h) => {
                c.emit(Kn.ServiceStatus, h);
              }));
        })(t));
    });
  }
  const IK = 'sdk';
  class kK {
    constructor({serverUrl: e, enabled: n, originatorInfo: r}) {
      ((this.serverURL = Sc),
        (this.serverURL = e),
        (this.originatorInfo = r),
        (this.enabled = n == null || n));
    }
    send({event: e, params: n}) {
      if (!this.enabled) return;
      const r = Object.assign(
        Object.assign(
          {id: IK, event: e, sdkVersion: ua.version},
          this.originatorInfo
        ),
        {params: n}
      );
      (re(`[Analytics: send()] event: ${e}`, r),
        ss(r, this.serverURL).catch((i) => {
          re(`[Analytics: send()] error: ${i}`);
        }));
    }
  }
  const RK = () => {
      if (typeof document > 'u') return;
      let t;
      const e = document.getElementsByTagName('link');
      for (let n = 0; n < e.length; n++)
        (e[n].getAttribute('rel') !== 'icon' &&
          e[n].getAttribute('rel') !== 'shortcut icon') ||
          (t = e[n].getAttribute('href'));
      return t;
    },
    PK = 163400;
  function q2(t) {
    var e, n, r;
    const {dappMetadata: i} = t,
      s = (function ({url: u, name: d}) {
        var f;
        const h = u + d,
          g = Vh(h);
        if (!localStorage) return '';
        let m = (f = localStorage.getItem(g)) !== null && f !== void 0 ? f : '';
        if (!m) {
          m = Ls();
          try {
            localStorage.setItem(g, m);
          } catch {
            return '';
          }
        }
        return m;
      })({
        url:
          (e = i == null ? void 0 : i.url) !== null && e !== void 0
            ? e
            : 'no_url',
        name:
          (n = i == null ? void 0 : i.name) !== null && n !== void 0
            ? n
            : 'no_name'
      }),
      o =
        (r = t.platformManager) === null || r === void 0
          ? void 0
          : r.getPlatformType(),
      a = o === fn.DesktopWeb,
      c = o === fn.MetaMaskMobileWebview;
    let l = 'N/A';
    return (a ? (l = 'extension') : c && (l = 'mobile'), {id: s, from: l});
  }
  const Td = (t, e, n) => {
      if (Uu(t))
        if (n || (e && typeof e == 'object' && e !== null && 'error' in e)) {
          const r = n || (e == null ? void 0 : e.error);
          r && r.code === 4001
            ? kt.analytics.track('sdk_action_rejected', {action: t})
            : kt.analytics.track('sdk_action_failed', {action: t});
        } else kt.analytics.track('sdk_action_succeeded', {action: t});
    },
    LT = ({provider: t, sdkInstance: e}) => {
      if ('state' in t) throw new Error('INVALID EXTENSION PROVIDER');
      return new Proxy(t, {
        get: (n, r) =>
          r === 'request'
            ? function (i) {
                var s, o;
                return ue(this, void 0, void 0, function* () {
                  re('[wrapExtensionProvider()] Overwriting request method', i);
                  const {method: a, params: c} = i,
                    l = wK.includes(a.toLowerCase()),
                    {id: u, from: d} = q2(e);
                  if (
                    (l &&
                      ((s = e.analytics) === null ||
                        s === void 0 ||
                        s.send({
                          event: Mt.SDK_RPC_REQUEST,
                          params: {method: a, from: d, id: u}
                        })),
                    Uu(a) &&
                      kt.analytics.track('sdk_action_requested', {action: a}),
                    a === xe.METAMASK_BATCH && Array.isArray(c))
                  )
                    return (({
                      target: g,
                      args: m,
                      trackEvent: y,
                      sdkInstance: p
                    }) =>
                      ue(void 0, void 0, void 0, function* () {
                        var b, v;
                        if (m.method !== 'metamask_batch')
                          throw new Error('Invalid usage');
                        const x = [],
                          C =
                            (b = m == null ? void 0 : m.params) !== null &&
                            b !== void 0
                              ? b
                              : [];
                        for (const L of C) {
                          const F = yield g == null
                            ? void 0
                            : g.request({method: L.method, params: L.params});
                          x.push(F);
                        }
                        const {id: $, from: G} = q2(p);
                        y &&
                          ((v = p.analytics) === null ||
                            v === void 0 ||
                            v.send({
                              event: Mt.SDK_RPC_REQUEST_DONE,
                              params: {method: m.method, from: G, id: $}
                            }));
                        for (const L of x) Td(m.method, L, null);
                        return x;
                      }))({target: n, args: i, trackEvent: l, sdkInstance: e});
                  if (
                    a.toLowerCase() === xe.METAMASK_CONNECTSIGN.toLowerCase() &&
                    Array.isArray(c)
                  )
                    return (({target: g, params: m}) =>
                      ue(void 0, void 0, void 0, function* () {
                        let y,
                          p = null;
                        try {
                          const b = yield g.request({
                            method: xe.ETH_REQUESTACCOUNTS,
                            params: []
                          });
                          if (!b.length)
                            throw new Error(
                              'SDK state invalid -- undefined accounts'
                            );
                          return (
                            (y = yield g.request({
                              method: xe.PERSONAL_SIGN,
                              params: [m[0], b[0]]
                            })),
                            y
                          );
                        } catch (b) {
                          throw ((p = b), b);
                        } finally {
                          Td(xe.PERSONAL_SIGN, y, p);
                        }
                      }))({target: n, params: c});
                  if (
                    a.toLowerCase() === xe.METAMASK_CONNECTWITH.toLowerCase() &&
                    Array.isArray(c)
                  )
                    return (({target: g, params: m}) =>
                      ue(void 0, void 0, void 0, function* () {
                        const [y] = m,
                          p = y.method,
                          b = y.params;
                        let v,
                          x = null;
                        try {
                          const C = yield g.request({
                            method: xe.ETH_REQUESTACCOUNTS,
                            params: []
                          });
                          if (!Array.isArray(C) || !C.length)
                            throw new Error(
                              'SDK state invalid -- undefined accounts'
                            );
                          return (p == null ? void 0 : p.toLowerCase()) ===
                            xe.PERSONAL_SIGN.toLowerCase()
                            ? ((v = yield g.request({
                                method: p,
                                params: [b[0], C[0]]
                              })),
                              v)
                            : (p == null ? void 0 : p.toLowerCase()) ===
                                xe.ETH_SENDTRANSACTION.toLowerCase()
                              ? ((v = yield g.request({
                                  method: p,
                                  params: [
                                    Object.assign(Object.assign({}, b[0]), {
                                      from: C[0]
                                    })
                                  ]
                                })),
                                v)
                              : OT.includes(p.toLowerCase())
                                ? (console.warn(
                                    `MetaMaskSDK connectWith method=${p} -- not handled by the extension -- call separately`
                                  ),
                                  (v = C),
                                  v)
                                : ((v = yield g.request({
                                    method: p,
                                    params: b
                                  })),
                                  v);
                        } catch (C) {
                          throw ((x = C), C);
                        } finally {
                          Td(p, v, x);
                        }
                      }))({target: n, params: c});
                  let f,
                    h = null;
                  try {
                    return ((f = yield n.request(i)), f);
                  } catch (g) {
                    throw ((h = g), g);
                  } finally {
                    (l &&
                      ((o = e.analytics) === null ||
                        o === void 0 ||
                        o.send({
                          event: Mt.SDK_RPC_REQUEST_DONE,
                          params: {method: a, from: d, id: u}
                        })),
                      Td(a, f, h));
                  }
                });
              }
            : r === 'getChainId'
              ? function () {
                  return t.chainId;
                }
              : r === 'getNetworkVersion'
                ? function () {
                    return t.networkVersion;
                  }
                : r === 'getSelectedAddress'
                  ? function () {
                      return t.selectedAddress;
                    }
                  : r === 'isConnected'
                    ? function () {
                        return t._state.isConnected;
                      }
                    : n[r]
      });
    };
  var Gh;
  function MK({mustBeMetaMask: t, sdkInstance: e}) {
    return ue(this, void 0, void 0, function* () {
      if (typeof window > 'u') throw new Error('window not available');
      try {
        const n = yield new Promise((r, i) => {
          const s = setTimeout(() => {
            i(new Error('eip6963RequestProvider timed out'));
          }, 500);
          (window.addEventListener(Gh.Announce, (o) => {
            const a = o,
              {detail: {info: c, provider: l} = {}} = a,
              {name: u, rdns: d, uuid: f} = c ?? {};
            bK.test(f) &&
              u.startsWith(j2.NAME) &&
              j2.RDNS.includes(d) &&
              (clearTimeout(s), r(l));
          }),
            window.dispatchEvent(new Event(Gh.Request)));
        });
        return LT({provider: n, sdkInstance: e});
      } catch {
        throw new Error('Provider not found');
      }
    });
  }
  (function (t) {
    ((t.Announce = 'eip6963:announceProvider'),
      (t.Request = 'eip6963:requestProvider'));
  })(Gh || (Gh = {}));
  const OK = (t) =>
      ue(void 0, void 0, void 0, function* () {
        const {options: e} = t,
          {infuraAPIKey: n} = e;
        if (!n) return;
        const r = {
          '0x1': `https://mainnet.infura.io/v3/${n}`,
          '0x5': `https://goerli.infura.io/v3/${n}`,
          '0xaa36a7': `https://sepolia.infura.io/v3/${n}`,
          '0xe708': `https://linea-mainnet.infura.io/v3/${n}`,
          '0xe704': `https://linea-goerli.infura.io/v3/${n}`,
          '0x89': `https://polygon-mainnet.infura.io/v3/${n}`,
          '0x13881': `https://polygon-mumbai.infura.io/v3/${n}`,
          '0x45': `https://optimism-mainnet.infura.io/v3/${n}`,
          '0x1a4': `https://optimism-goerli.infura.io/v3/${n}`,
          '0xa4b1': `https://arbitrum-mainnet.infura.io/v3/${n}`,
          '0x66eed': `https://arbitrum-goerli.infura.io/v3/${n}`,
          '0x2a15c308d': `https://palm-mainnet.infura.io/v3/${n}`,
          '0x2a15c3083': `https://palm-testnet.infura.io/v3/${n}`,
          '0xa86a': `https://avalanche-mainnet.infura.io/v3/${n}`,
          '0xa869': `https://avalanche-fuji.infura.io/v3/${n}`,
          '0x4e454152': `https://aurora-mainnet.infura.io/v3/${n}`,
          '0x4e454153': `https://aurora-testnet.infura.io/v3/${n}`,
          '0x534e5f4d41494e': `https://starknet-mainnet.infura.io/v3/${n}`,
          '0x534e5f474f45524c49': `https://starknet-goerli.infura.io/v3/${n}`,
          '0x534e5f474f45524c4932': `https://starknet-goerli2.infura.io/v3/${n}`,
          '0xa4ec': `https://celo-mainnet.infura.io/v3/${n}`,
          '0xaef3': `https://celo-alfajores.infura.io/v3/${n}`
        };
        t.options.readonlyRPCMap
          ? (t.options.readonlyRPCMap = Object.assign(
              Object.assign({}, t.options.readonlyRPCMap),
              r
            ))
          : (t.options.readonlyRPCMap = r);
      }),
    NK = (t) =>
      ue(void 0, void 0, void 0, function* () {
        const {options: e} = t,
          {readonlyRPCMap: n} = e;
        if (n)
          try {
            (re(
              '[MetaMaskSDK: setupReadOnlyRPCProviders()] Setting up Readonly RPC Providers',
              n
            ),
              t.setReadOnlyRPCCalls(!0));
          } catch {
            throw new Error('Invalid Infura Settings');
          }
      });
  function LK(t, e, n, r) {
    return new (n || (n = Promise))(function (i, s) {
      function o(l) {
        try {
          c(r.next(l));
        } catch (u) {
          s(u);
        }
      }
      function a(l) {
        try {
          c(r.throw(l));
        } catch (u) {
          s(u);
        }
      }
      function c(l) {
        var u;
        l.done
          ? i(l.value)
          : ((u = l.value),
            u instanceof n
              ? u
              : new n(function (d) {
                  d(u);
                })).then(o, a);
      }
      c((r = r.apply(t, [])).next());
    });
  }
  function BK(t, e) {
    var n,
      r,
      i,
      s,
      o = {
        label: 0,
        sent: function () {
          if (1 & i[0]) throw i[1];
          return i[1];
        },
        trys: [],
        ops: []
      };
    return (
      (s = {next: a(0), throw: a(1), return: a(2)}),
      typeof Symbol == 'function' &&
        (s[Symbol.iterator] = function () {
          return this;
        }),
      s
    );
    function a(c) {
      return function (l) {
        return (function (u) {
          if (n) throw new TypeError('Generator is already executing.');
          for (; o; )
            try {
              if (
                ((n = 1),
                r &&
                  (i =
                    2 & u[0]
                      ? r.return
                      : u[0]
                        ? r.throw || ((i = r.return) && i.call(r), 0)
                        : r.next) &&
                  !(i = i.call(r, u[1])).done)
              )
                return i;
              switch (((r = 0), i && (u = [2 & u[0], i.value]), u[0])) {
                case 0:
                case 1:
                  i = u;
                  break;
                case 4:
                  return (o.label++, {value: u[1], done: !1});
                case 5:
                  (o.label++, (r = u[1]), (u = [0]));
                  continue;
                case 7:
                  ((u = o.ops.pop()), o.trys.pop());
                  continue;
                default:
                  if (
                    ((i = o.trys),
                    !(
                      (i = i.length > 0 && i[i.length - 1]) ||
                      (u[0] !== 6 && u[0] !== 2)
                    ))
                  ) {
                    o = 0;
                    continue;
                  }
                  if (u[0] === 3 && (!i || (u[1] > i[0] && u[1] < i[3]))) {
                    o.label = u[1];
                    break;
                  }
                  if (u[0] === 6 && o.label < i[1]) {
                    ((o.label = i[1]), (i = u));
                    break;
                  }
                  if (i && o.label < i[2]) {
                    ((o.label = i[2]), o.ops.push(u));
                    break;
                  }
                  (i[2] && o.ops.pop(), o.trys.pop());
                  continue;
              }
              u = e.call(t, o);
            } catch (d) {
              ((u = [6, d]), (r = 0));
            } finally {
              n = i = 0;
            }
          if (5 & u[0]) throw u[1];
          return {value: u[0] ? u[1] : void 0, done: !0};
        })([c, l]);
      };
    }
  }
  var V2 = 'INSTALLED',
    G2 = 'NOT_INSTALLED',
    z2 = 'REGISTERED',
    W2 = 'REGISTERING',
    Z2 = 'RELOADING',
    Y2 = {
      CHROME:
        'https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn',
      FIREFOX: 'https://addons.mozilla.org/firefox/addon/ether-metamask/',
      DEFAULT: 'https://metamask.io'
    },
    Id = 'REGISTRATION_IN_PROGRESS',
    Q2 = 'FORWARDER_ID',
    DK = (function () {
      function t(e) {
        var n = e === void 0 ? {} : e,
          r = n.forwarderOrigin,
          i = r === void 0 ? 'https://fwd.metamask.io' : r,
          s = n.forwarderMode,
          o = s === void 0 ? t.FORWARDER_MODE.INJECT : s;
        ((this.forwarderOrigin = i),
          (this.forwarderMode = o),
          (this.state = t.isMetaMaskInstalled() ? V2 : G2));
        var a = t._detectBrowser();
        ((this.downloadUrl = a ? Y2[a] : Y2.DEFAULT),
          (this._onMessage = this._onMessage.bind(this)),
          (this._onMessageFromForwarder =
            this._onMessageFromForwarder.bind(this)),
          (this._openForwarder = this._openForwarder.bind(this)),
          (this._openDownloadPage = this._openDownloadPage.bind(this)),
          (this.startOnboarding = this.startOnboarding.bind(this)),
          (this.stopOnboarding = this.stopOnboarding.bind(this)),
          window.addEventListener('message', this._onMessage),
          o === t.FORWARDER_MODE.INJECT &&
            sessionStorage.getItem(Id) === 'true' &&
            t._injectForwarder(this.forwarderOrigin));
      }
      return (
        (t.prototype._onMessage = function (e) {
          if (e.origin === this.forwarderOrigin)
            return e.data.type === 'metamask:reload'
              ? this._onMessageFromForwarder(e)
              : void console.debug(
                  "Unknown message from '" +
                    e.origin +
                    "' with data " +
                    JSON.stringify(e.data)
                );
        }),
        (t.prototype._onMessageUnknownStateError = function (e) {
          throw new Error("Unknown state: '" + e + "'");
        }),
        (t.prototype._onMessageFromForwarder = function (e) {
          return LK(this, 0, void 0, function () {
            return BK(this, function (n) {
              switch (n.label) {
                case 0:
                  switch (this.state) {
                    case Z2:
                      return [3, 1];
                    case G2:
                      return [3, 2];
                    case V2:
                      return [3, 3];
                    case W2:
                      return [3, 5];
                    case z2:
                      return [3, 6];
                  }
                  return [3, 7];
                case 1:
                  return (
                    console.debug('Ignoring message while reloading'),
                    [3, 8]
                  );
                case 2:
                  return (
                    console.debug('Reloading now to register with MetaMask'),
                    (this.state = Z2),
                    location.reload(),
                    [3, 8]
                  );
                case 3:
                  return (
                    console.debug('Registering with MetaMask'),
                    (this.state = W2),
                    [4, t._register()]
                  );
                case 4:
                  return (
                    n.sent(),
                    (this.state = z2),
                    e.source.postMessage(
                      {type: 'metamask:registrationCompleted'},
                      e.origin
                    ),
                    this.stopOnboarding(),
                    [3, 8]
                  );
                case 5:
                  return (
                    console.debug(
                      'Already registering - ignoring reload message'
                    ),
                    [3, 8]
                  );
                case 6:
                  return (
                    console.debug(
                      'Already registered - ignoring reload message'
                    ),
                    [3, 8]
                  );
                case 7:
                  (this._onMessageUnknownStateError(this.state), (n.label = 8));
                case 8:
                  return [2];
              }
            });
          });
        }),
        (t.prototype.startOnboarding = function () {
          (sessionStorage.setItem(Id, 'true'),
            this._openDownloadPage(),
            this._openForwarder());
        }),
        (t.prototype.stopOnboarding = function () {
          sessionStorage.getItem(Id) === 'true' &&
            (this.forwarderMode === t.FORWARDER_MODE.INJECT &&
              (console.debug('Removing forwarder'), t._removeForwarder()),
            sessionStorage.setItem(Id, 'false'));
        }),
        (t.prototype._openForwarder = function () {
          this.forwarderMode === t.FORWARDER_MODE.OPEN_TAB
            ? window.open(this.forwarderOrigin, '_blank')
            : t._injectForwarder(this.forwarderOrigin);
        }),
        (t.prototype._openDownloadPage = function () {
          window.open(this.downloadUrl, '_blank');
        }),
        (t.isMetaMaskInstalled = function () {
          return !!(window.ethereum && window.ethereum.isMetaMask);
        }),
        (t._register = function () {
          return window.ethereum.request({method: 'wallet_registerOnboarding'});
        }),
        (t._injectForwarder = function (e) {
          var n = document.body,
            r = document.createElement('iframe');
          (r.setAttribute('height', '0'),
            r.setAttribute('width', '0'),
            r.setAttribute('style', 'display: none;'),
            r.setAttribute('src', e),
            r.setAttribute('id', Q2),
            n.insertBefore(r, n.children[0]));
        }),
        (t._removeForwarder = function () {
          var e;
          (e = document.getElementById(Q2)) === null ||
            e === void 0 ||
            e.remove();
        }),
        (t._detectBrowser = function () {
          var e = PT.parse(window.navigator.userAgent);
          return e.browser.name === 'Firefox'
            ? 'FIREFOX'
            : ['Chrome', 'Chromium'].includes(e.browser.name || '')
              ? 'CHROME'
              : null;
        }),
        (t.FORWARDER_MODE = {INJECT: 'INJECT', OPEN_TAB: 'OPEN_TAB'}),
        t
      );
    })();
  function FK(t, {wait: e = !1}) {
    return ue(this, void 0, void 0, function* () {
      return (
        re(`[MetamaskInstaller: startInstaller()] wait=${e}`),
        e && (yield NT(1e3)),
        yield t.checkInstallation()
      );
    });
  }
  class $K {
    constructor({
      remote: e,
      preferDesktop: n,
      platformManager: r,
      debug: i = !1
    }) {
      ((this.state = {
        isInstalling: !1,
        hasInstalled: !1,
        resendRequest: null,
        preferDesktop: !1,
        platformManager: null,
        remote: null,
        debug: !1,
        connectWith: void 0
      }),
        (this.state.remote = e),
        (this.state.preferDesktop = n),
        (this.state.platformManager = r),
        (this.state.debug = i));
    }
    startDesktopOnboarding() {
      return (function () {
        return ue(this, void 0, void 0, function* () {
          (re(
            '[MetamaskInstaller: startDesktopOnboarding() starting desktop onboarding'
          ),
            window.ethereum && (window.ethereum = void 0),
            new DK().startOnboarding());
        });
      })();
    }
    redirectToProperInstall() {
      return ue(this, void 0, void 0, function* () {
        return (function (e) {
          var n, r;
          return ue(this, void 0, void 0, function* () {
            const {state: i} = e,
              s =
                (n = i.platformManager) === null || n === void 0
                  ? void 0
                  : n.getPlatformType();
            if (
              (re(
                `[MetamaskInstaller: redirectToProperInstall()] platform=${s}`
              ),
              s === fn.MetaMaskMobileWebview)
            )
              return !1;
            i.isInstalling = !0;
            try {
              (yield (r = i.remote) === null || r === void 0
                ? void 0
                : r.startConnection({connectWith: i.connectWith}),
                (i.isInstalling = !1),
                (i.hasInstalled = !0));
            } catch (o) {
              throw ((i.isInstalling = !1), o);
            }
            return !0;
          });
        })(this);
      });
    }
    checkInstallation() {
      return ue(this, void 0, void 0, function* () {
        return (function (e) {
          var n;
          return ue(this, void 0, void 0, function* () {
            const {state: r} = e,
              i =
                (n = r.platformManager) === null || n === void 0
                  ? void 0
                  : n.isMetaMaskInstalled();
            return (
              re(`[MetamaskInstaller: checkInstallation()] isInstalled=${i}`),
              !!i || (yield e.redirectToProperInstall())
            );
          });
        })(this);
      });
    }
    start({wait: e = !1, connectWith: n}) {
      return ue(this, void 0, void 0, function* () {
        ((this.state.connectWith = n),
          re(`[MetaMaskInstaller: start()] wait=${e}`, n),
          yield FK(this, {wait: e}));
      });
    }
  }
  class BT {
    constructor({debug: e, sdkVersion: n}) {
      ((this.containers = {install: void 0, pending: void 0, select: void 0}),
        (this.defined = {install: !1, pending: !1, select: !1}),
        (this.debug = e != null && e),
        (this.sdkVersion = n));
    }
    loadComponent(e) {
      return ue(this, void 0, void 0, function* () {
        if (!this.defined[e]) {
          this.defined[e] = !0;
          try {
            const n = yield Promise.resolve().then(function () {
              return bq;
            });
            (console.log('loader', n), n.defineCustomElements());
          } catch (n) {
            console.error(`Failed to load ${e} modal:`, n);
          }
        }
      });
    }
    renderInstallModal(e) {
      var n;
      return ue(this, void 0, void 0, function* () {
        (this.debug && console.debug('ModalLoader: renderInstallModal', e),
          (this.containers.install = e.parentElement),
          yield this.loadComponent('install'));
        const r = document.createElement('mm-install-modal');
        ((r.link = e.link),
          (r.preferDesktop = e.preferDesktop),
          (r.sdkVersion =
            (n = e.sdkVersion) !== null && n !== void 0 ? n : this.sdkVersion),
          r.addEventListener('close', ({detail: {shouldTerminate: i}}) =>
            e.onClose(i)
          ),
          r.addEventListener(
            'startDesktopOnboarding',
            e.metaMaskInstaller.startDesktopOnboarding
          ),
          r.addEventListener('trackAnalytics', (i) => {
            var s;
            return (s = e.onAnalyticsEvent) === null || s === void 0
              ? void 0
              : s.call(e, i.detail);
          }),
          e.parentElement.appendChild(r));
      });
    }
    renderSelectModal(e) {
      var n;
      return ue(this, void 0, void 0, function* () {
        ((this.containers.select = e.parentElement),
          yield this.loadComponent('select'));
        const r = document.createElement('mm-select-modal');
        ((r.link = e.link),
          (r.sdkVersion =
            (n = e.sdkVersion) !== null && n !== void 0 ? n : this.sdkVersion),
          (r.preferDesktop = e.preferDesktop),
          r.addEventListener('close', ({detail: {shouldTerminate: i}}) =>
            e.onClose(i)
          ),
          r.addEventListener('connectWithExtension', e.connectWithExtension),
          e.parentElement.appendChild(r),
          setTimeout(() => this.updateQRCode(e.link), 100));
      });
    }
    renderPendingModal(e) {
      var n;
      return ue(this, void 0, void 0, function* () {
        ((this.containers.pending = e.parentElement),
          yield this.loadComponent('pending'));
        const r = document.createElement('mm-pending-modal');
        ((r.sdkVersion =
          (n = e.sdkVersion) !== null && n !== void 0 ? n : this.sdkVersion),
          (r.displayOTP = e.displayOTP),
          r.addEventListener('close', e.onClose),
          r.addEventListener('updateOTPValue', ({detail: {otpValue: i}}) =>
            e.updateOTPValue(i)
          ),
          e.onDisconnect && r.addEventListener('disconnect', e.onDisconnect),
          e.parentElement.appendChild(r));
      });
    }
    updateOTPValue(e) {
      const n = () => {
        var r;
        const i =
          (r = this.containers.pending) === null || r === void 0
            ? void 0
            : r.querySelector('mm-pending-modal');
        return !!i && ((i.otpCode = e), !0);
      };
      setTimeout(() => {
        n();
      }, 800);
    }
    updateQRCode(e) {
      var n, r;
      const i =
        (n = this.containers.install) === null || n === void 0
          ? void 0
          : n.querySelector('mm-install-modal');
      if (i) i.link = e;
      else {
        const s =
          (r = this.containers.select) === null || r === void 0
            ? void 0
            : r.querySelector('mm-select-modal');
        s && (s.link = e);
      }
    }
    unmount() {
      Object.entries(this.containers).forEach(([e, n]) => {
        var r;
        ((r = n == null ? void 0 : n.parentNode) === null ||
          r === void 0 ||
          r.removeChild(n),
          (this.containers[e] = void 0));
      });
    }
  }
  const HK = ({
      link: t,
      debug: e,
      installer: n,
      terminate: r,
      connectWithExtension: i,
      preferDesktop: s,
      onAnalyticsEvent: o
    }) => {
      let a = null,
        c = null;
      (re(
        '[UI: InstallModal-web: sdkWebInstallModal()] ################## Installing Modal #################'
      ),
        re(`[UI: InstallModal-web: sdkWebInstallModal()] link=${t}`),
        re(
          `[UI: InstallModal-web: sdkWebInstallModal()] npx uri-scheme open "${t}" --ios`
        ),
        re(
          `[UI: InstallModal-web: sdkWebInstallModal()] npx uri-scheme open "${t}" --android`
        ),
        re(
          `[UI: InstallModal-web: sdkWebInstallModal()] adb shell am start -a android.intent.action.VIEW -d "${t}"`
        ));
      const l = (u) => {
        var d;
        (re(
          '[UI: InstallModal-web: sdkWebInstallModal()] installModal-web unmounting install modal -- shouldTerminate:',
          u,
          c
        ),
          c != null &&
            c.parentNode &&
            ((d = c.parentNode) === null || d === void 0 || d.removeChild(c)),
          (c = null),
          (a = null),
          u === !0 && (r == null || r()));
      };
      return {
        mount: (u) => {
          if (
            (re(
              '[UI: InstallModal-web: sdkWebInstallModal()] installModal-web mounting install modal',
              c
            ),
            c)
          )
            return (
              (c.style.display = 'block'),
              void (a == null || a.updateQRCode(u))
            );
          ((a = new BT({debug: e, sdkVersion: ua.version})),
            (c = document.createElement('div')),
            document.body.appendChild(c),
            window.extension
              ? a
                  .renderSelectModal({
                    parentElement: c,
                    connectWithExtension: () => {
                      (l(), i == null || i());
                    },
                    onClose: l,
                    link: t,
                    preferDesktop: s != null && s
                  })
                  .catch((d) => {
                    console.error(d);
                  })
              : a
                  .renderInstallModal({
                    parentElement: c,
                    preferDesktop: s != null && s,
                    link: t,
                    metaMaskInstaller: n,
                    onClose: l,
                    onAnalyticsEvent: o
                  })
                  .catch((d) => {
                    console.error(
                      '[UI: InstallModal-web: sdkWebInstallModal()]',
                      d
                    );
                  }));
        },
        unmount: l
      };
    },
    jK = ({onDisconnect: t, debug: e}) => {
      let n = null,
        r = null;
      const i = () => {
          (re(
            '[UI: pendingModal-web: sdkWebPendingModal()] pendingModal-web unmount',
            n
          ),
            n != null && n.parentNode && n.parentNode.removeChild(n),
            (n = null),
            (r = null));
        },
        s = (a) => {
          (re(
            '[UI: pendingModal-web: sdkWebPendingModal()] pendingModal-web updateOTPValue',
            a
          ),
            r && r.updateOTPValue(a));
        },
        o = ({displayOTP: a} = {displayOTP: !0}) => {
          (re(
            '[UI: pendingModal-web: sdkWebPendingModal()] pendingModal-web mount',
            n
          ),
            n
              ? (n.style.display = 'block')
              : ((r = new BT({debug: e, sdkVersion: ua.version})),
                (n = document.createElement('div')),
                document.body.appendChild(n),
                r
                  .renderPendingModal({
                    parentElement: n,
                    onClose: i,
                    onDisconnect: t,
                    updateOTPValue: s,
                    displayOTP: a
                  })
                  .catch((c) => {
                    console.error(
                      '[UI: pendingModal-web: sdkWebPendingModal()]',
                      c
                    );
                  })));
        };
      return (o(), {mount: o, unmount: i, updateOTPValue: s});
    };
  function DT(t, e) {
    var n, r, i, s;
    t.connector ||
      (re('[RemoteConnection: initializeConnector()] initialize connector'),
      (t.connector = new qj({
        anonId: e.anonId,
        platformType: e.platformManager.getPlatformType(),
        communicationLayerPreference: e.communicationLayerPreference,
        transports: e.transports,
        dappMetadata: Object.assign(Object.assign({}, e.dappMetadata), {
          source: e._source
        }),
        analytics: e.enableAnalytics,
        communicationServerUrl: e.communicationServerUrl,
        sdkVersion: ua.version,
        context: 'dapp',
        ecies: e.ecies,
        storage: e.storage,
        logging: e.logging
      })),
      e.timer &&
        (re(
          '[RemoteConnection: initializeConnector()] reset background timer',
          e.timer
        ),
        (r =
          (n = e.timer) === null || n === void 0
            ? void 0
            : n.stopBackgroundTimer) === null ||
          r === void 0 ||
          r.call(n),
        (s =
          (i = e.timer) === null || i === void 0
            ? void 0
            : i.runBackgroundTimer) === null ||
          s === void 0 ||
          s.call(i, () => !1, 1e4)));
  }
  function cy(t) {
    (t.listeners.forEach(({event: e, handler: n}) => {
      var r;
      (r = t.connector) === null || r === void 0 || r.off(e, n);
    }),
      (t.listeners = []));
  }
  function UK(t, e, n) {
    return ue(this, void 0, void 0, function* () {
      const r = setTimeout(() => {
        kt.analytics.track('sdk_connection_failed', {
          transport_type: 'websocket'
        });
      }, 6e4);
      return new Promise((i, s) => {
        if (!t.connector) return void s(new Error('No connector available'));
        re('[RemoteConnection: connectWithModalInstaller()]', {
          state: t,
          options: e,
          linkParams: n
        });
        const o = `${t.useDeeplink ? Su : Au}?${n}`;
        ((function (a, c, l) {
          var u, d, f, h;
          ((a.installModal =
            (d = (u = c.modals).install) === null || d === void 0
              ? void 0
              : d.call(u, {
                  link: l,
                  preferDesktop: a.preferDesktop,
                  installer: c.getMetaMaskInstaller(),
                  terminate: () => {
                    (re(
                      '[RemoteConnection: showInstallModal() => terminate()] terminate connection'
                    ),
                      c.sdk.terminate().catch((g) => {
                        console.warn(
                          '[MMSDK] failed to terminate connection',
                          g
                        );
                      }));
                  },
                  debug: a.developerMode,
                  connectWithExtension: () => {
                    var g;
                    return (
                      (g = c.connectWithExtensionProvider) === null ||
                        g === void 0 ||
                        g.call(c),
                      !1
                    );
                  },
                  onAnalyticsEvent: ({event: g, params: m}) => {
                    var y, p, b;
                    const v = Object.assign(Object.assign({}, m), {
                      sdkVersion: c.sdk.getVersion(),
                      dappId:
                        (y = c.dappMetadata) === null || y === void 0
                          ? void 0
                          : y.name,
                      source: c._source,
                      url:
                        (p = c.dappMetadata) === null || p === void 0
                          ? void 0
                          : p.url
                    });
                    (b = a.analytics) === null ||
                      b === void 0 ||
                      b.send({event: g, params: v});
                  }
                })),
            (h =
              (f = a.installModal) === null || f === void 0
                ? void 0
                : f.mount) === null ||
              h === void 0 ||
              h.call(f, l));
        })(t, e, o),
          e.sdk.once(me.PROVIDER_UPDATE, (a) =>
            ue(this, void 0, void 0, function* () {
              if (
                (re(
                  '[RemoteConnection: connectWithModalInstaller()] once provider_update -- resolving startConnection promise'
                ),
                a === hi.TERMINATE)
              ) {
                const c = {code: 4001, message: 'User rejected the request.'};
                return (clearTimeout(r), void s(c));
              }
              s(a);
            })
          ),
          t.connector.once(me.AUTHORIZED, () => {
            (clearTimeout(r), i());
          }),
          t.connector.once(me.REJECTED, () => {
            (clearTimeout(r), s(me.REJECTED));
          }),
          t.connector.once(me.CLIENTS_READY, () =>
            ue(this, void 0, void 0, function* () {
              (re(
                '[RemoteConnection: connectWithModalInstaller()] once clients_ready -- resolving startConnection promise'
              ),
                clearTimeout(r),
                i());
            })
          ));
      });
    });
  }
  function FT(t, e) {
    function n(r, i) {
      var s;
      ((s = t.connector) === null || s === void 0 || s.on(r, i),
        t.listeners.push({event: r, handler: i}));
    }
    t.connector &&
      (cy(t),
      n(me.WALLET_INIT, ({accounts: r, chainId: i}) =>
        ue(this, void 0, void 0, function* () {
          re(
            `[RemoteConnection: setupListeners() => EventType.WALLET_INIT] 'wallet_init' accounts=${r} chainId=${i}`
          );
          const s = Br.getProvider();
          s._setConnected();
          const o = {accounts: r, chainId: i, isUnlocked: !1};
          (s._initializeState(o),
            s.emit('chainChanged', i),
            s.emit('accountsChanged', r));
        })
      ),
      n(me.AUTHORIZED, () =>
        ue(this, void 0, void 0, function* () {
          var r, i, s, o;
          try {
            re(
              "[RemoteConnection: setupListeners() => EventType.AUTHORIZED] 'authorized' closing modals",
              t.pendingModal,
              t.installModal
            );
            const a = Br.getProvider();
            (a._setConnected(),
              (i =
                (r = t.pendingModal) === null || r === void 0
                  ? void 0
                  : r.unmount) === null ||
                i === void 0 ||
                i.call(r),
              (o =
                (s = t.installModal) === null || s === void 0
                  ? void 0
                  : s.unmount) === null ||
                o === void 0 ||
                o.call(s, !1),
              (t.otpAnswer = void 0),
              (t.authorized = !0),
              re(
                "[RemoteConnection: setupListeners() => EventType.AUTHORIZED] 'authorized' provider.state",
                a.getState()
              ),
              yield a.forceInitializeState());
          } catch {}
        })
      ),
      n(me.TERMINATE, () => {
        var r, i, s, o, a;
        ((i =
          (r = t.pendingModal) === null || r === void 0
            ? void 0
            : r.unmount) === null ||
          i === void 0 ||
          i.call(r),
          (o =
            (s = t.installModal) === null || s === void 0
              ? void 0
              : s.unmount) === null ||
            o === void 0 ||
            o.call(s, !0),
          (t.pendingModal = void 0),
          (t.installModal = void 0),
          (t.otpAnswer = void 0),
          (a = t.connector) === null ||
            a === void 0 ||
            a.disconnect({terminate: !0}),
          (t.authorized = !1),
          Br.getProvider().handleDisconnect({terminate: !0}),
          cy(t),
          re('[RemoteConnection: setupListeners()] All listeners cleaned up'));
      }));
  }
  function KK(t, e, {initialCheck: n, connectWith: r} = {}) {
    var i, s, o, a, c, l, u, d, f, h, g, m, y, p, b, v, x, C, $;
    return ue(this, void 0, void 0, function* () {
      try {
        if ((DT(t, e), !t.connector)) throw new Error('no connector defined');
        FT(t);
        const G = Br.getProvider();
        ((t.authorized = !1), G.emit('connecting'));
        const L = yield (i = t.connector) === null || i === void 0
          ? void 0
          : i.originatorSessionConnect();
        re(
          `[RemoteConnection: startConnection()] after originatorSessionConnect initialCheck=${n}`,
          L
        );
        let F =
            (s = L == null ? void 0 : L.channelId) !== null && s !== void 0
              ? s
              : '',
          k =
            (a =
              (o = t.connector.getKeyInfo()) === null || o === void 0
                ? void 0
                : o.ecies.public) !== null && a !== void 0
              ? a
              : '',
          V =
            (l =
              (c = t.connector.getKeyInfo()) === null || c === void 0
                ? void 0
                : c.ecies.private) !== null && l !== void 0
              ? l
              : '';
        if (n && !L) return Promise.resolve();
        if (!L && !n) {
          const O = yield t.connector.generateChannelIdConnect();
          ((F = (u = O.channelId) !== null && u !== void 0 ? u : ''),
            (k = (d = O.pubKey) !== null && d !== void 0 ? d : ''),
            (V = (f = O.privKey) !== null && f !== void 0 ? f : ''));
          const H = Date.now();
          (h = t.connector.state.storageManager) === null ||
            h === void 0 ||
            h.persistChannelConfig({
              channelId: F,
              localKey: V,
              lastActive: H,
              validUntil: H + xc
            });
        }
        if (n && L != null && L.channelId)
          return (
            (!((g = t.connector) === null || g === void 0) &&
              g.isConnected()) ||
              (re(
                `[RemoteConnection: startConnection()] reconnecting to channel initialCheck=${n}`,
                L
              ),
              yield (m = t.connector) === null || m === void 0
                ? void 0
                : m.connectToChannel({channelId: F})),
            Promise.resolve()
          );
        L &&
          !(!((y = t.connector) === null || y === void 0) && y.isConnected()) &&
          (re(
            '[RemoteConnection: startConnection()] reconnecting to channel',
            L
          ),
          yield (p = t.connector) === null || p === void 0
            ? void 0
            : p.connectToChannel({channelId: F}));
        const K =
            !((b = t.platformManager) === null || b === void 0) && b.isSecure()
              ? ''
              : '&t=q',
          B = ua.version,
          {iconUrl: D, name: E, url: P, scheme: U} = e.dappMetadata || {},
          w =
            (v = t.platformManager) === null || v === void 0
              ? void 0
              : v.getPlatformType();
        let A = 'N/A';
        typeof window < 'u' && window.location && window.location.hostname
          ? (A = window.location.hostname)
          : E !== void 0
            ? (A = E)
            : P !== void 0 && (A = P);
        const T = {
            url: P ?? '',
            title: E ?? '',
            icon: D,
            scheme: U ?? '',
            apiVersion: B,
            dappId: A || P || 'N/A',
            anonId: e.anonId,
            platform: w ?? '',
            source: (x = e._source) !== null && x !== void 0 ? x : ''
          },
          R = Vh(JSON.stringify(T));
        let _ = `channelId=${F}&v=2&comm=${(C = t.communicationLayerPreference) !== null && C !== void 0 ? C : ''}&pubkey=${k}${K}&originatorInfo=${R}`;
        if (r) {
          _ += `&rpc=${Vh(JSON.stringify(r))}`;
          const O = t.connector.getRPCMethodTracker();
          O &&
            (O[`${r.id}`] = Object.assign(Object.assign({}, r), {
              id: `${r.id}`,
              timestamp: Date.now()
            }));
        }
        const S = encodeURI(_),
          I = `${t.useDeeplink ? Su : Au}?${_}`;
        if (
          ((t.qrcodeLink = I),
          t.developerMode &&
            re(`[RemoteConnection: startConnection()] qrcodeLink=${S}`),
          G.emit('display_uri', I),
          kt.analytics.track('sdk_connection_initiated', {
            transport_type: 'websocket'
          }),
          ($ = t.platformManager) === null || $ === void 0
            ? void 0
            : $.isSecure())
        ) {
          const O = setTimeout(() => {
            kt.analytics.track('sdk_connection_failed', {
              transport_type: 'websocket'
            });
          }, 6e4);
          return (
            yield (function (H, M) {
              var q, z;
              return ue(this, void 0, void 0, function* () {
                const Z = `${Au}?${M}`,
                  X = `${Su}?${M}`;
                (z =
                  (q = H.platformManager) === null || q === void 0
                    ? void 0
                    : q.openDeeplink) === null ||
                  z === void 0 ||
                  z.call(q, Z, X, '_self');
              });
            })(t, S),
            new Promise((H, M) => {
              var q, z, Z;
              if (
                !((q = t.connector) === null || q === void 0) &&
                q.isAuthorized()
              )
                return (clearTimeout(O), void H());
              ((z = t.connector) === null ||
                z === void 0 ||
                z.once(me.AUTHORIZED, () => {
                  (clearTimeout(O), H());
                }),
                (Z = t.connector) === null ||
                  Z === void 0 ||
                  Z.once(me.REJECTED, () => {
                    (clearTimeout(O), M(me.REJECTED));
                  }));
            })
          );
        }
        return UK(t, e, S);
      } catch (G) {
        throw (console.error('[startConnection] error', G), G);
      }
    });
  }
  class qK {
    constructor(e) {
      var n, r, i;
      ((this.state = {
        connector: void 0,
        qrcodeLink: void 0,
        analytics: void 0,
        developerMode: !1,
        authorized: !1,
        reconnection: !1,
        preferDesktop: !1,
        deeplinkProtocol: !1,
        listeners: [],
        communicationLayerPreference: void 0,
        platformManager: void 0,
        pendingModal: void 0,
        installModal: void 0,
        otpAnswer: void 0
      }),
        (this.options = e));
      const s =
        ((n = e.logging) === null || n === void 0
          ? void 0
          : n.developerMode) === !0 ||
        ((r = e.logging) === null || r === void 0 ? void 0 : r.sdk) === !0;
      ((this.state.developerMode = s),
        (this.state.analytics = e.analytics),
        (this.state.preferDesktop =
          (i = e.preferDesktop) !== null && i !== void 0 && i),
        (this.state.useDeeplink = e.sdk.options.useDeeplink),
        (this.state.communicationLayerPreference =
          e.communicationLayerPreference),
        (this.state.platformManager = e.platformManager),
        e.modals.install || (e.modals.install = HK),
        e.modals.otp || (e.modals.otp = jK));
    }
    startConnection(e) {
      return ue(this, void 0, void 0, function* () {
        return KK(this.state, this.options, e);
      });
    }
    initRemoteCommunication({sdkInstance: e}) {
      var n, r, i;
      return ue(this, void 0, void 0, function* () {
        const s = yield (r =
          (n = e.options.storage) === null || n === void 0
            ? void 0
            : n.storageManager) === null || r === void 0
          ? void 0
          : r.getPersistedChannelConfig();
        if (!this.options.ecies) {
          const o = {privateKey: s == null ? void 0 : s.localKey};
          this.options.ecies = o;
        }
        (DT(this.state, this.options),
          yield (i = this.getConnector()) === null || i === void 0
            ? void 0
            : i.initFromDappStorage(),
          FT(this.state, this.options));
      });
    }
    showActiveModal() {
      return (function (e) {
        var n, r, i, s;
        e.authorized
          ? re('[RemoteConnection: showActiveModal()] already authorized')
          : e.pendingModal
            ? (r = (n = e.pendingModal).mount) === null ||
              r === void 0 ||
              r.call(n)
            : e.installModal &&
              ((s = (i = e.installModal).mount) === null ||
                s === void 0 ||
                s.call(i, e.qrcodeLink || ''));
      })(this.state);
    }
    closeModal() {
      var e, n, r, i;
      ((n =
        (e = this.state.pendingModal) === null || e === void 0
          ? void 0
          : e.unmount) === null ||
        n === void 0 ||
        n.call(e),
        (i =
          (r = this.state.installModal) === null || r === void 0
            ? void 0
            : r.unmount) === null ||
          i === void 0 ||
          i.call(r, !1));
    }
    getUniversalLink() {
      if (!this.state.qrcodeLink)
        throw new Error('connection not started. run startConnection() first.');
      return this.state.qrcodeLink;
    }
    getChannelConfig() {
      var e;
      return (e = this.state.connector) === null || e === void 0
        ? void 0
        : e.getChannelConfig();
    }
    getKeyInfo() {
      var e;
      return (e = this.state.connector) === null || e === void 0
        ? void 0
        : e.getKeyInfo();
    }
    getConnector() {
      if (!this.state.connector) throw new Error('invalid remote connector');
      return this.state.connector;
    }
    getPlatformManager() {
      if (!this.state.platformManager)
        throw new Error('PlatformManager not available');
      return this.state.platformManager;
    }
    isConnected() {
      var e;
      return (
        ((e = this.state.connector) === null || e === void 0
          ? void 0
          : e.isReady()) || !1
      );
    }
    isAuthorized() {
      var e;
      return (
        ((e = this.state.connector) === null || e === void 0
          ? void 0
          : e.isAuthorized()) || !1
      );
    }
    isPaused() {
      var e;
      return (e = this.state.connector) === null || e === void 0
        ? void 0
        : e.isPaused();
    }
    disconnect(e) {
      var n, r, i;
      (re('[RemoteConnection: disconnect()]', e),
        e != null &&
          e.terminate &&
          (Br.getProvider().handleDisconnect({terminate: !0}),
          (r =
            (n = this.state.pendingModal) === null || n === void 0
              ? void 0
              : n.unmount) === null ||
            r === void 0 ||
            r.call(n),
          (this.state.otpAnswer = void 0)),
        (i = this.state.connector) === null || i === void 0 || i.disconnect(e),
        (function (s) {
          (re('[RemoteConnection: cleanupConnector()] cleaning up connector'),
            s.connector &&
              (cy(s),
              s.connector.disconnect({terminate: !0}).catch((o) => {
                re(
                  '[RemoteConnection: cleanupConnector()] error disconnecting connector',
                  o
                );
              })));
        })(this.state));
    }
  }
  function VK(t) {
    var e, n, r, i, s, o, a, c, l, u, d;
    return ue(this, void 0, void 0, function* () {
      const {options: f} = t;
      if (
        ((f.logging = (e = f.logging) !== null && e !== void 0 ? e : {}),
        (f.communicationLayerPreference =
          (n = f.communicationLayerPreference) !== null && n !== void 0
            ? n
            : ta.SOCKET),
        f.enableDebug !== void 0 &&
          (Cn.enable('MM_SDK'),
          console.warn(
            'enableDebug is removed. Please use enableAnalytics instead.'
          )),
        (f.enableAnalytics =
          (r = f.enableAnalytics) === null || r === void 0 || r),
        (f.injectProvider =
          (i = f.injectProvider) === null || i === void 0 || i),
        (f.shouldShimWeb3 =
          (s = f.shouldShimWeb3) === null || s === void 0 || s),
        (f.extensionOnly = (o = f.extensionOnly) === null || o === void 0 || o),
        (f.useDeeplink = (a = f.useDeeplink) === null || a === void 0 || a),
        (f.storage =
          (c = f.storage) !== null && c !== void 0 ? c : {enabled: !0}),
        f.headless)
      ) {
        Cn('[MetaMaskSDK: performSDKInitialization()] headless mode enabled');
        const b = () => {},
          v = {install: () => ({mount: b, unmount: b})},
          x = {installer: b};
        ((f.modals = v), (f.ui = x));
      }
      const h =
        ((l = f.logging) === null || l === void 0
          ? void 0
          : l.developerMode) === !0;
      ((t.debug =
        ((u = f.logging) === null || u === void 0 ? void 0 : u.sdk) || h),
        re('[MetaMaskSDK: performSDKInitialization()] options', t.options));
      const g = Object.assign({}, f.logging);
      (h &&
        ((g.sdk = !0),
        (g.eciesLayer = !0),
        (g.keyExchangeLayer = !0),
        (g.remoteLayer = !0),
        (g.serviceLayer = !0),
        (g.plaintext = !0)),
        yield (function (b) {
          var v;
          return ue(this, void 0, void 0, function* () {
            const {options: x} = b;
            b.platformManager = new _u({
              useDeepLink: (v = x.useDeeplink) !== null && v !== void 0 && v,
              preferredOpenLink: x.openDeeplink,
              debug: b.debug
            });
          });
        })(t),
        yield (function (b) {
          var v, x, C, $, G;
          return ue(this, void 0, void 0, function* () {
            const {options: L} = b,
              F =
                (v = b.platformManager) === null || v === void 0
                  ? void 0
                  : v.getPlatformType();
            b.analytics = new kK({
              serverUrl:
                (x = L.communicationServerUrl) !== null && x !== void 0
                  ? x
                  : Sc,
              enabled: L.enableAnalytics,
              originatorInfo: {
                url: (C = L.dappMetadata.url) !== null && C !== void 0 ? C : '',
                title:
                  ($ = L.dappMetadata.name) !== null && $ !== void 0 ? $ : '',
                dappId: b.getDappId(),
                platform: F ?? '',
                source: (G = L._source) !== null && G !== void 0 ? G : '',
                anonId: ''
              }
            });
          });
        })(t),
        yield (function (b) {
          var v, x, C;
          return ue(this, void 0, void 0, function* () {
            if (
              !b.options.enableAnalytics ||
              (!(
                !((v = b.platformManager) === null || v === void 0) &&
                v.isBrowser()
              ) &&
                !(
                  !((x = b.platformManager) === null || x === void 0) &&
                  x.isReactNative()
                ))
            )
              return;
            const $ = b.getVersion(),
              G = b.getDappId(),
              L = yield b.getAnonId(),
              F =
                (C = b.platformManager) === null || C === void 0
                  ? void 0
                  : C.getPlatformType(),
              k = b.options._source;
            (kt.analytics.setGlobalProperty('sdk_version', $),
              kt.analytics.setGlobalProperty('dapp_id', G),
              kt.analytics.setGlobalProperty('anon_id', L),
              kt.analytics.setGlobalProperty('platform', F),
              kt.analytics.setGlobalProperty('integration_type', k),
              kt.analytics.enable(),
              kt.analytics.track('sdk_initialized', {}));
          });
        })(t),
        yield (function (b) {
          var v;
          return ue(this, void 0, void 0, function* () {
            const {options: x} = b;
            ((v = x.storage) === null || v === void 0 ? void 0 : v.enabled) !==
              !0 ||
              x.storage.storageManager ||
              (x.storage.storageManager = yield MT(x.storage));
          });
        })(t),
        yield (function (b) {
          return ue(this, void 0, void 0, function* () {
            const {options: v} = b,
              x = /^(http|https):\/\/[^\s]*$/;
            if (v.dappMetadata) {
              (v.dappMetadata.iconUrl &&
                !x.test(v.dappMetadata.iconUrl) &&
                (console.warn(
                  'Invalid dappMetadata.iconUrl: URL must start with http:// or https://'
                ),
                (v.dappMetadata.iconUrl = void 0)),
                v.dappMetadata.base64Icon &&
                  v.dappMetadata.base64Icon.length > PK &&
                  (console.warn(
                    'Invalid dappMetadata.base64Icon: Base64-encoded icon string length must be less than 163400 characters'
                  ),
                  (v.dappMetadata.base64Icon = void 0)),
                v.dappMetadata.url &&
                  !x.test(v.dappMetadata.url) &&
                  console.warn(
                    'Invalid dappMetadata.url: URL must start with http:// or https://'
                  ));
              const C = RK();
              if (C && !v.dappMetadata.iconUrl && !v.dappMetadata.base64Icon) {
                const $ = `${window.location.protocol}//${window.location.host}${C}`;
                v.dappMetadata.iconUrl = $;
              }
            }
            b.dappMetadata = v.dappMetadata;
          });
        })(t),
        yield OK(t),
        yield NK(t));
      const {
        metamaskBrowserExtension: m,
        preferExtension: y,
        shouldReturn: p
      } = yield (function (b) {
        var v, x, C, $;
        return ue(this, void 0, void 0, function* () {
          const {options: G} = b;
          let L,
            F = !1,
            k = !1;
          if (
            typeof window < 'u' &&
            window.ethereum &&
            !(
              !((v = b.platformManager) === null || v === void 0) &&
              v.isMetaMaskMobileWebView()
            )
          ) {
            F = localStorage.getItem(qh) === 'extension';
            try {
              ((L = yield MK({mustBeMetaMask: !0, sdkInstance: b})),
                (window.extension = L),
                L.on(qr.CHAIN_CHANGED, (V) => {
                  (re(
                    `[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE chainChanged chainId=${V}`
                  ),
                    b.sdkProvider &&
                      b.getMobileProvider().emit(qr.CHAIN_CHANGED, V));
                }),
                L.on(qr.ACCOUNTS_CHANGED, (V) =>
                  ue(this, void 0, void 0, function* () {
                    var K;
                    re(
                      `[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE accountsChanged accounts=${V}`
                    );
                    const B = !!b.sdkProvider,
                      D = !!b.extensionActive;
                    if (
                      (B && b.getMobileProvider().emit(qr.ACCOUNTS_CHANGED, V),
                      D &&
                        (V == null ? void 0 : V.length) === 0 &&
                        (yield (K = b.getProvider()) === null || K === void 0
                          ? void 0
                          : K.request({
                              method: xe.WALLET_GETPERMISSIONS,
                              params: []
                            })).length === 0)
                    )
                      try {
                        yield b.terminate();
                      } catch (E) {
                        re(
                          '[MetaMaskSDK: setupExtensionPreferences()] error terminating on permissions revoked',
                          E
                        );
                      }
                  })
                ),
                L.on(qr.DISCONNECT, (V) => {
                  (re(
                    `[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE disconnect error=${V}`
                  ),
                    b.sdkProvider &&
                      b.getMobileProvider().emit(qr.DISCONNECT, V));
                }),
                L.on(qr.CONNECT, (V) => {
                  (re(
                    `[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE connect args=${V}`
                  ),
                    b.sdkProvider && b.getMobileProvider().emit(qr.CONNECT, V));
                }),
                L.on(qr.CONNECTED, (V) => {
                  (re(
                    '[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE connected',
                    V
                  ),
                    b.sdkProvider &&
                      b.getMobileProvider().emit(qr.CONNECTED, V));
                }));
            } catch {
              window.extension = void 0;
            }
          } else
            !((x = b.platformManager) === null || x === void 0) &&
              x.isMetaMaskMobileWebView() &&
              ((C = b.analytics) === null ||
                C === void 0 ||
                C.send({event: Mt.SDK_USE_INAPP_BROWSER}),
              (b.activeProvider = LT({
                provider: window.ethereum,
                sdkInstance: b
              })),
              (b._initialized = !0),
              (k = !0));
          return (
            L &&
              G.extensionOnly &&
              (re(
                '[MetaMaskSDK: setupExtensionPreferences()] EXTENSION ONLY --- prevent sdk initialization'
              ),
              ($ = b.analytics) === null ||
                $ === void 0 ||
                $.send({event: Mt.SDK_USE_EXTENSION}),
              (b.activeProvider = L),
              (b.extensionActive = !0),
              (b.extension = L),
              (b._initialized = !0),
              (k = !0)),
            {preferExtension: F, shouldReturn: k, metamaskBrowserExtension: L}
          );
        });
      })(t);
      if (p)
        re(
          '[MetaMaskSDK: performSDKInitialization()] shouldReturn=true --- prevent sdk initialization'
        );
      else {
        (yield (function (b, v) {
          var x, C, $, G, L;
          return ue(this, void 0, void 0, function* () {
            const {options: F} = b,
              k = Object.assign({}, F.logging);
            ((b.remoteConnection = new qK({
              anonId: yield b.getAnonId(),
              preferDesktop:
                (x = F.preferDesktop) !== null && x !== void 0 && x,
              communicationLayerPreference:
                (C = F.communicationLayerPreference) !== null && C !== void 0
                  ? C
                  : ta.SOCKET,
              analytics: b.analytics,
              dappMetadata: F.dappMetadata,
              _source: F._source,
              enableAnalytics:
                ($ = F.enableAnalytics) === null || $ === void 0 || $,
              timer: F.timer,
              sdk: b,
              platformManager: b.platformManager,
              transports: F.transports,
              communicationServerUrl: F.communicationServerUrl,
              storage:
                (G = F.storage) !== null && G !== void 0 ? G : {enabled: !0},
              getMetaMaskInstaller: () => {
                if (!b.installer)
                  throw new Error(
                    'Invalid SDK status -- installer not initialized'
                  );
                return b.installer;
              },
              logging: k,
              connectWithExtensionProvider: v === void 0 ? void 0 : () => U2(b),
              modals: Object.assign(Object.assign({}, F.modals), {
                onPendingModalDisconnect: b.terminate.bind(b)
              })
            })),
              yield b.remoteConnection.initRemoteCommunication({
                sdkInstance: b
              }),
              (b.installer = new $K({
                remote: b.remoteConnection,
                preferDesktop:
                  (L = F.preferDesktop) !== null && L !== void 0 && L,
                platformManager: b.platformManager,
                debug: b.debug
              })));
          });
        })(t, m),
          yield TK(t),
          yield (function (b, v) {
            var x, C;
            return ue(this, void 0, void 0, function* () {
              const {options: $} = b;
              (v
                ? (re(
                    '[MetaMaskSDK: handleAutoAndExtensionConnections()] preferExtension is detected -- connect with it.'
                  ),
                  (x = b.analytics) === null ||
                    x === void 0 ||
                    x.send({event: Mt.SDK_EXTENSION_UTILIZED}),
                  U2(b).catch((G) => {
                    (console.warn(
                      "Can't connect with MetaMask extension...",
                      G
                    ),
                      localStorage.removeItem(qh));
                  }))
                : $.checkInstallationImmediately &&
                  (!((C = b.platformManager) === null || C === void 0) &&
                  C.isDesktopWeb()
                    ? (re(
                        '[MetaMaskSDK: handleAutoAndExtensionConnections()] checkInstallationImmediately'
                      ),
                      b.connect().catch((G) => {
                        re(
                          `[MetaMaskSDK: handleAutoAndExtensionConnections()] checkInstallationImmediately --- IGNORED --- error on autoconnect _err=${G}`
                        );
                      }))
                    : console.warn(
                        '[handleAutoAndExtensionConnections()] checkInstallationImmediately --- IGNORED --- only for web desktop'
                      )),
                (b._initialized = !0));
            });
          })(t, y));
        try {
          yield (d = t.remoteConnection) === null || d === void 0
            ? void 0
            : d.startConnection({initialCheck: !0});
        } catch (b) {
          console.error(
            '[MetaMaskSDK: setupRemoteConnectionAndInstaller()] Error while checking installation',
            b
          );
        }
        t.emit(Kn.ProviderUpdate, hi.INITIALIZED);
      }
    });
  }
  class GK extends R$ {
    constructor(
      e = {
        storage: {enabled: !0},
        injectProvider: !0,
        forceInjectProvider: !1,
        enableAnalytics: !0,
        shouldShimWeb3: !0,
        useDeeplink: !0,
        extensionOnly: !0,
        headless: !1,
        dappMetadata: {name: '', url: '', iconUrl: ''},
        _source: H2,
        i18nOptions: {enabled: !1}
      }
    ) {
      var n, r, i;
      (super(),
        (this.extensionActive = !1),
        (this._initialized = !1),
        (this.sdkInitPromise = void 0),
        (this.debug = !1),
        (this.readonlyRPCCalls = !1),
        (this.availableLanguages = ['en']),
        (this.ANON_ID_STORAGE_KEY = 'mm-sdk-anon-id'),
        Cn.disable());
      const s =
        ((n = e.logging) === null || n === void 0
          ? void 0
          : n.developerMode) === !0;
      if (
        (((!((r = e.logging) === null || r === void 0) && r.sdk) || s) &&
          Cn.enable('MM_SDK'),
        re('[MetaMaskSDK: constructor()]: begin.'),
        this.setMaxListeners(50),
        !(!((i = e.dappMetadata) === null || i === void 0) && i.url))
      ) {
        if (typeof window > 'u' || typeof document > 'u')
          throw new Error('You must provide dAppMetadata url');
        e.dappMetadata = Object.assign(Object.assign({}, e.dappMetadata), {
          url: `${window.location.protocol}//${window.location.host}`
        });
      }
      ((this.options = e),
        this.options._source || (e._source = H2),
        this.init()
          .then(() => {
            (re('[MetaMaskSDK: constructor()]: initialized successfully.'),
              typeof window < 'u' && (window.mmsdk = this));
          })
          .catch((o) => {
            console.error(
              '[MetaMaskSDK: constructor()] error during initialization',
              o
            );
          }));
    }
    init() {
      return ue(this, void 0, void 0, function* () {
        return (function (e) {
          var n;
          return ue(this, void 0, void 0, function* () {
            if (
              typeof window < 'u' &&
              !((n = window.mmsdk) === null || n === void 0) &&
              n.isInitialized()
            )
              return (
                re(
                  '[MetaMaskSDK: initializeMetaMaskSDK()] already initialized'
                ),
                Promise.resolve(window.mmsdk)
              );
            if (e._initialized)
              return (
                re(
                  '[MetaMaskSDK: initializeMetaMaskSDK()] already initialized'
                ),
                e.sdkInitPromise
              );
            if (e.sdkInitPromise)
              return (
                re(
                  '[MetaMaskSDK: initializeMetaMaskSDK()] already initializing'
                ),
                e.sdkInitPromise
              );
            try {
              ((e.sdkInitPromise = VK(e)), yield e.sdkInitPromise);
            } catch (r) {
              throw (console.error(r), r);
            }
            return e.sdkInitPromise;
          });
        })(this);
      });
    }
    isExtensionActive() {
      return this.extensionActive;
    }
    checkExtensionAvailability() {
      var e;
      return (
        typeof window < 'u' &&
        !!(!((e = window.ethereum) === null || e === void 0) && e.isMetaMask)
      );
    }
    connect() {
      return ue(this, void 0, void 0, function* () {
        return (function (e) {
          return ue(this, void 0, void 0, function* () {
            if (
              (e._initialized ||
                (re(
                  '[MetaMaskSDK: connect()] provider not ready -- wait for init()'
                ),
                yield e.init()),
              re(
                `[MetaMaskSDK: connect()] isExtensionActive=${e.isExtensionActive()} activeProvider`,
                e.activeProvider
              ),
              !e.activeProvider)
            )
              throw new Error('SDK state invalid -- undefined provider');
            const n = e.activeProvider.getSelectedAddress();
            return n
              ? [n]
              : e.activeProvider.request({
                  method: xe.ETH_REQUESTACCOUNTS,
                  params: []
                });
          });
        })(this);
      });
    }
    connectAndSign({msg: e}) {
      return ue(this, void 0, void 0, function* () {
        return AK({instance: this, msg: e});
      });
    }
    connectWith(e) {
      return ue(this, void 0, void 0, function* () {
        return (function ({instance: n, rpc: r}) {
          return ue(this, void 0, void 0, function* () {
            if (
              (n._initialized ||
                (re(
                  '[MetaMaskSDK: connectWith()] provider not ready -- wait for init()'
                ),
                yield n.init()),
              re(`[MetaMaskSDK: connectWith()] method: ${r.method} rpc=${r}`),
              !n.activeProvider)
            )
              throw new Error('SDK state invalid -- undefined provider');
            return n.activeProvider.request({
              method: xe.METAMASK_CONNECTWITH,
              params: [r]
            });
          });
        })({instance: this, rpc: e});
      });
    }
    resume() {
      return (function (e) {
        var n, r, i;
        return ue(this, void 0, void 0, function* () {
          if (
            !(
              !(
                (r =
                  (n = e.remoteConnection) === null || n === void 0
                    ? void 0
                    : n.getConnector()) === null || r === void 0
              ) && r.isReady()
            )
          )
            return (
              re(
                '[MetaMaskSDK: resume()] channel is not ready -- starting connection'
              ),
              void (
                (i = e.remoteConnection) === null ||
                i === void 0 ||
                i.startConnection()
              )
            );
          re('[MetaMaskSDK: resume()] channel is ready');
        });
      })(this);
    }
    disconnect() {
      return (
        console.warn('MetaMaskSDK.disconnect() is deprecated, use terminate()'),
        this.terminate()
      );
    }
    isAuthorized() {
      var e;
      (e = this.remoteConnection) === null || e === void 0 || e.isAuthorized();
    }
    terminate() {
      return (function (e) {
        var n, r, i;
        return ue(this, void 0, void 0, function* () {
          if (
            !(
              !((n = e.platformManager) === null || n === void 0) &&
              n.isMetaMaskMobileWebView()
            )
          ) {
            if (
              (EK &&
                (window.localStorage.removeItem(qh),
                window.localStorage.removeItem(ay),
                window.localStorage.removeItem(oy)),
              e.extensionActive)
            ) {
              try {
                yield (r = e.activeProvider) === null || r === void 0
                  ? void 0
                  : r.request({
                      method: xe.WALLET_REVOKEPERMISSIONS,
                      params: [{eth_accounts: {}}]
                    });
              } catch (s) {
                re('[MetaMaskSDK: terminate()] error revoking permissions', s);
              }
              return e.options.extensionOnly
                ? (e.emit(Kn.ProviderUpdate, hi.TERMINATE),
                  void re(
                    '[MetaMaskSDK: terminate()] extensionOnly --- prevent switching providers'
                  ))
                : ((e.activeProvider = e.sdkProvider),
                  (window.ethereum = e.activeProvider),
                  (e.extensionActive = !1),
                  void e.emit(Kn.ProviderUpdate, hi.TERMINATE));
            }
            (e.emit(Kn.ProviderUpdate, hi.TERMINATE),
              re(
                `[MetaMaskSDK: terminate()] remoteConnection=${e.remoteConnection}`
              ),
              (i = e.remoteConnection) === null ||
                i === void 0 ||
                i.disconnect({terminate: !0, sendMessage: !0}));
          }
        });
      })(this);
    }
    isInitialized() {
      return this._initialized;
    }
    setReadOnlyRPCCalls(e) {
      this.readonlyRPCCalls = e;
    }
    hasReadOnlyRPCCalls() {
      return this.readonlyRPCCalls;
    }
    getProvider() {
      if (this.activeProvider) return this.activeProvider;
      console.warn('MetaMaskSDK: No active provider found');
    }
    getMobileProvider() {
      if (!this.sdkProvider)
        throw new Error('SDK state invalid -- undefined mobile provider');
      return this.sdkProvider;
    }
    getUniversalLink() {
      var e;
      const n =
        (e = this.remoteConnection) === null || e === void 0
          ? void 0
          : e.getUniversalLink();
      if (!n)
        throw new Error(
          'No Universal Link available, please call eth_requestAccounts first.'
        );
      return n;
    }
    getChannelId() {
      var e, n;
      return (n =
        (e = this.remoteConnection) === null || e === void 0
          ? void 0
          : e.getChannelConfig()) === null || n === void 0
        ? void 0
        : n.channelId;
    }
    getRPCHistory() {
      var e, n;
      return (n =
        (e = this.remoteConnection) === null || e === void 0
          ? void 0
          : e.getConnector()) === null || n === void 0
        ? void 0
        : n.getRPCMethodTracker();
    }
    getVersion() {
      return ua.version;
    }
    getDappId() {
      var e, n, r, i;
      return typeof window > 'u' || window.location === void 0
        ? (i =
            (n =
              (e = this.options.dappMetadata) === null || e === void 0
                ? void 0
                : e.name) !== null && n !== void 0
              ? n
              : (r = this.options.dappMetadata) === null || r === void 0
                ? void 0
                : r.url) !== null && i !== void 0
          ? i
          : 'N/A'
        : window.location.hostname;
    }
    getAnonId() {
      var e, n;
      return ue(this, void 0, void 0, function* () {
        if (this._anonId) return this._anonId;
        let r;
        return (
          (r =
            !((e = this.platformManager) === null || e === void 0) &&
            e.isBrowser()
              ? this.getBrowserAnonId()
              : !((n = this.platformManager) === null || n === void 0) &&
                  n.isReactNative()
                ? yield this.getReactNativeAnonId()
                : Ls()),
          (this._anonId = r),
          r
        );
      });
    }
    getBrowserAnonId() {
      const e = this.ANON_ID_STORAGE_KEY;
      try {
        const n = localStorage.getItem(e);
        if (n) return n;
        const r = Ls();
        return (localStorage.setItem(e, r), r);
      } catch (n) {
        return (
          console.error(
            '[MetaMaskSDK: getBrowserAnonId()] LocalStorage access error:',
            n
          ),
          Ls()
        );
      }
    }
    getReactNativeAnonId() {
      return ue(this, void 0, void 0, function* () {
        const e = this.ANON_ID_STORAGE_KEY;
        try {
          const n =
              require('@react-native-async-storage/async-storage').default,
            r = yield n.getItem(e);
          if (r) return r;
          const i = Ls();
          return (yield n.setItem(e, i), i);
        } catch (n) {
          return (
            console.error(
              '[MetaMaskSDK: getReactNativeAnonId()] Error accessing AsyncStorage:',
              n
            ),
            Ls()
          );
        }
      });
    }
    getWalletStatus() {
      var e, n;
      return (n =
        (e = this.remoteConnection) === null || e === void 0
          ? void 0
          : e.getConnector()) === null || n === void 0
        ? void 0
        : n.getConnectionStatus();
    }
    _getChannelConfig() {
      var e;
      return (e = this.remoteConnection) === null || e === void 0
        ? void 0
        : e.getChannelConfig();
    }
    _ping() {
      var e, n;
      (n =
        (e = this.remoteConnection) === null || e === void 0
          ? void 0
          : e.getConnector()) === null ||
        n === void 0 ||
        n.ping();
    }
    _keyCheck() {
      var e, n;
      (n =
        (e = this.remoteConnection) === null || e === void 0
          ? void 0
          : e.getConnector()) === null ||
        n === void 0 ||
        n.keyCheck();
    }
    _getServiceStatus() {
      var e, n;
      return (n =
        (e = this.remoteConnection) === null || e === void 0
          ? void 0
          : e.getConnector()) === null || n === void 0
        ? void 0
        : n.getServiceStatus();
    }
    _getRemoteConnection() {
      return this.remoteConnection;
    }
    _getDappMetadata() {
      return this.dappMetadata;
    }
    _getKeyInfo() {
      var e;
      return (e = this.remoteConnection) === null || e === void 0
        ? void 0
        : e.getKeyInfo();
    }
    _resetKeys() {
      var e, n;
      (n =
        (e = this.remoteConnection) === null || e === void 0
          ? void 0
          : e.getConnector()) === null ||
        n === void 0 ||
        n.resetKeys();
    }
    _getConnection() {
      return this.remoteConnection;
    }
    emit(e, n) {
      return super.emit(e, n);
    }
    on(e, n) {
      return super.on(e, n);
    }
  }
  var zK = Object.freeze({
    __proto__: null,
    StorageManagerWeb: class {
      constructor({enabled: t} = {enabled: !1}) {
        ((this.enabled = !1), (this.enabled = t));
      }
      persistChannelConfig(t) {
        return ue(this, void 0, void 0, function* () {
          const e = JSON.stringify(t);
          (re(
            `[StorageManagerWeb: persistChannelConfig()] enabled=${this.enabled}`,
            t
          ),
            localStorage.setItem(A0, e));
        });
      }
      getPersistedChannelConfig() {
        return ue(this, void 0, void 0, function* () {
          let t;
          try {
            if (
              (re(
                `[StorageManagerWeb: getPersistedChannelConfig()] enabled=${this.enabled}`
              ),
              (t = localStorage.getItem(A0)),
              re('[StorageManagerWeb: getPersistedChannelConfig()]', t),
              !t)
            )
              return;
            const e = JSON.parse(t);
            return (
              re(
                '[StorageManagerWeb: getPersistedChannelConfig()] channelConfig',
                e
              ),
              e
            );
          } catch (e) {
            return void console.error(
              "[StorageManagerWeb: getPersistedChannelConfig()] Can't find existing channel config",
              e
            );
          }
        });
      }
      persistAccounts(t) {
        return ue(this, void 0, void 0, function* () {
          re(
            `[StorageManagerWeb: persistAccounts()] enabled=${this.enabled}`,
            t
          );
          const e = JSON.stringify(t);
          localStorage.setItem(oy, e);
        });
      }
      getCachedAccounts() {
        return ue(this, void 0, void 0, function* () {
          try {
            const t = localStorage.getItem(oy);
            return t ? JSON.parse(t) : [];
          } catch (t) {
            throw (
              console.error(
                '[StorageManagerWeb: getCachedAccounts()] Error reading cached accounts',
                t
              ),
              t
            );
          }
        });
      }
      persistChainId(t) {
        return ue(this, void 0, void 0, function* () {
          (re(
            `[StorageManagerWeb: persistChainId()] enabled=${this.enabled}`,
            t
          ),
            localStorage.setItem(ay, t));
        });
      }
      getCachedChainId() {
        return ue(this, void 0, void 0, function* () {
          try {
            const t = localStorage.getItem(ay);
            return t ?? void 0;
          } catch (t) {
            throw (
              console.error(
                '[StorageManagerWeb: getCachedChainId()] Error reading cached chainId',
                t
              ),
              t
            );
          }
        });
      }
      terminate() {
        return ue(this, void 0, void 0, function* () {
          (re(`[StorageManagerWeb: terminate()] enabled=${this.enabled}`),
            localStorage.removeItem(A0));
        });
      }
    }
  });
  const WK = 'hydrated',
    ZK = !1,
    YK = !0;
  var QK = Object.defineProperty,
    y1 = new WeakMap(),
    js = (t) => y1.get(t),
    v1 = (t, e) => y1.set((e.$lazyInstance$ = t), e),
    J2 = (t, e) => e in t,
    Uo = (t, e) => (0, console.error)(t, e),
    S0 = new Map(),
    gf = new Map(),
    $T = 'slot-fb{display:contents}slot-fb[hidden]{display:none}',
    Wp = typeof window < 'u' ? window : {},
    ai = Wp.document || {head: {}},
    Qt = {
      $flags$: 0,
      $resourcesUrl$: '',
      jmp: (t) => t(),
      raf: (t) => requestAnimationFrame(t),
      ael: (t, e, n, r) => t.addEventListener(e, n, r),
      rel: (t, e, n, r) => t.removeEventListener(e, n, r),
      ce: (t, e) => new CustomEvent(t, e)
    },
    HT = (() => {
      try {
        return (
          new CSSStyleSheet(),
          typeof new CSSStyleSheet().replaceSync == 'function'
        );
      } catch {}
      return !1;
    })(),
    ly = !1,
    X2 = [],
    jT = [],
    JK = (t, e) => (n) => {
      (t.push(n), ly || ((ly = !0), 4 & Qt.$flags$ ? b1(uy) : Qt.raf(uy)));
    },
    eE = (t) => {
      for (let e = 0; e < t.length; e++)
        try {
          t[e](performance.now());
        } catch (n) {
          Uo(n);
        }
      t.length = 0;
    },
    uy = () => {
      (eE(X2), eE(jT), (ly = X2.length > 0) && Qt.raf(uy));
    },
    b1 = (t) => ((e) => Promise.resolve(e))().then(t),
    XK = JK(jT),
    tE = {},
    w1 = (t) => (t = typeof t) == 'object' || t === 'function';
  function UT(t) {
    var e, n, r;
    return (r =
      (n =
        (e = t.head) == null
          ? void 0
          : e.querySelector('meta[name="csp-nonce"]')) == null
        ? void 0
        : n.getAttribute('content')) != null
      ? r
      : void 0;
  }
  ((t, e) => {
    for (var n in e) QK(t, n, {get: e[n], enumerable: !0});
  })(
    {},
    {
      err: () => KT,
      map: () => eq,
      ok: () => dy,
      unwrap: () => tq,
      unwrapErr: () => nq
    }
  );
  var dy = (t) => ({isOk: !0, isErr: !1, value: t}),
    KT = (t) => ({isOk: !1, isErr: !0, value: t});
  function eq(t, e) {
    if (t.isOk) {
      const n = e(t.value);
      return n instanceof Promise ? n.then((r) => dy(r)) : dy(n);
    }
    if (t.isErr) {
      const n = t.value;
      return KT(n);
    }
    throw 'should never get here';
  }
  var _1,
    tq = (t) => {
      if (t.isOk) return t.value;
      throw t.value;
    },
    nq = (t) => {
      if (t.isErr) return t.value;
      throw t.value;
    },
    ae = (t, e, ...n) => {
      let r = null,
        i = !1,
        s = !1;
      const o = [],
        a = (l) => {
          for (let u = 0; u < l.length; u++)
            ((r = l[u]),
              Array.isArray(r)
                ? a(r)
                : r != null &&
                  typeof r != 'boolean' &&
                  ((i = typeof t != 'function' && !w1(r)) && (r = String(r)),
                  i && s
                    ? (o[o.length - 1].$text$ += r)
                    : o.push(i ? zh(null, r) : r),
                  (s = i)));
        };
      if ((a(n), e)) {
        const l = e.className || e.class;
        l &&
          (e.class =
            typeof l != 'object'
              ? l
              : Object.keys(l)
                  .filter((u) => l[u])
                  .join(' '));
      }
      if (typeof t == 'function') return t(e === null ? {} : e, o, iq);
      const c = zh(t, null);
      return ((c.$attrs$ = e), o.length > 0 && (c.$children$ = o), c);
    },
    zh = (t, e) => ({
      $flags$: 0,
      $tag$: t,
      $text$: e,
      $elm$: null,
      $children$: null,
      $attrs$: null
    }),
    rq = {},
    iq = {
      forEach: (t, e) => t.map(nE).forEach(e),
      map: (t, e) => t.map(nE).map(e).map(sq)
    },
    nE = (t) => ({
      vattrs: t.$attrs$,
      vchildren: t.$children$,
      vkey: t.$key$,
      vname: t.$name$,
      vtag: t.$tag$,
      vtext: t.$text$
    }),
    sq = (t) => {
      if (typeof t.vtag == 'function') {
        const n = {...t.vattrs};
        return (
          t.vkey && (n.key = t.vkey),
          t.vname && (n.name = t.vname),
          ae(t.vtag, n, ...(t.vchildren || []))
        );
      }
      const e = zh(t.vtag, t.vtext);
      return (
        (e.$attrs$ = t.vattrs),
        (e.$children$ = t.vchildren),
        (e.$key$ = t.vkey),
        (e.$name$ = t.vname),
        e
      );
    },
    Zp = (t) => js(t).$hostElement$,
    Zs = (t, e, n) => {
      const r = Zp(t);
      return {
        emit: (i) =>
          qT(r, e, {bubbles: !0, composed: !0, cancelable: !0, detail: i})
      };
    },
    qT = (t, e, n) => {
      const r = Qt.ce(e, n);
      return (t.dispatchEvent(r), r);
    },
    rE = new WeakMap(),
    oq = (t) => {
      const e = t.$cmpMeta$,
        n = t.$hostElement$,
        r = e.$flags$;
      e.$tagName$;
      const i = ((s, o, a) => {
        var c;
        const l = VT(o),
          u = gf.get(l);
        if (((s = s.nodeType === 11 ? s : ai), u))
          if (typeof u == 'string') {
            s = s.head || s;
            let d,
              f = rE.get(s);
            if ((f || rE.set(s, (f = new Set())), !f.has(l))) {
              {
                ((d = ai.createElement('style')), (d.innerHTML = u));
                const h = (c = Qt.$nonce$) != null ? c : UT(ai);
                if ((h != null && d.setAttribute('nonce', h), !(1 & o.$flags$)))
                  if (s.nodeName === 'HEAD') {
                    const g = s.querySelectorAll('link[rel=preconnect]'),
                      m =
                        g.length > 0
                          ? g[g.length - 1].nextSibling
                          : s.querySelector('style');
                    s.insertBefore(d, m);
                  } else if ('host' in s)
                    if (HT) {
                      const g = new CSSStyleSheet();
                      (g.replaceSync(u),
                        (s.adoptedStyleSheets = [g, ...s.adoptedStyleSheets]));
                    } else {
                      const g = s.querySelector('style');
                      g ? (g.innerHTML = u + g.innerHTML) : s.prepend(d);
                    }
                  else s.append(d);
                1 & o.$flags$ &&
                  s.nodeName !== 'HEAD' &&
                  s.insertBefore(d, null);
              }
              (4 & o.$flags$ && (d.innerHTML += $T), f && f.add(l));
            }
          } else
            s.adoptedStyleSheets.includes(u) ||
              (s.adoptedStyleSheets = [...s.adoptedStyleSheets, u]);
        return l;
      })(n.shadowRoot ? n.shadowRoot : n.getRootNode(), e);
      10 & r && 2 & r && ((n['s-sc'] = i), n.classList.add(i + '-h'));
    },
    VT = (t, e) => 'sc-' + t.$tagName$,
    iE = (t, e, n, r, i, s) => {
      if (n !== r) {
        let o = J2(t, e),
          a = e.toLowerCase();
        if (e === 'class') {
          const c = t.classList,
            l = sE(n),
            u = sE(r);
          (c.remove(...l.filter((d) => d && !u.includes(d))),
            c.add(...u.filter((d) => d && !l.includes(d))));
        } else if (e === 'style') {
          for (const c in n)
            (r && r[c] != null) ||
              (c.includes('-') ? t.style.removeProperty(c) : (t.style[c] = ''));
          for (const c in r)
            (n && r[c] === n[c]) ||
              (c.includes('-')
                ? t.style.setProperty(c, r[c])
                : (t.style[c] = r[c]));
        } else if (o || e[0] !== 'o' || e[1] !== 'n') {
          const c = w1(r);
          if ((o || (c && r !== null)) && !i)
            try {
              if (t.tagName.includes('-')) t[e] = r;
              else {
                const l = r ?? '';
                e === 'list'
                  ? (o = !1)
                  : (n != null && t[e] == l) ||
                    (typeof t.__lookupSetter__(e) == 'function'
                      ? (t[e] = l)
                      : t.setAttribute(e, l));
              }
            } catch {}
          r == null || r === !1
            ? (r === !1 && t.getAttribute(e) !== '') || t.removeAttribute(e)
            : (!o || 4 & s || i) &&
              !c &&
              ((r = r === !0 ? '' : r), t.setAttribute(e, r));
        } else if (
          ((e =
            e[2] === '-'
              ? e.slice(3)
              : J2(Wp, a)
                ? a.slice(2)
                : a[2] + e.slice(3)),
          n || r)
        ) {
          const c = e.endsWith(GT);
          ((e = e.replace(cq, '')),
            n && Qt.rel(t, e, n, c),
            r && Qt.ael(t, e, r, c));
        }
      }
    },
    aq = /\s/,
    sE = (t) => (t ? t.split(aq) : []),
    GT = 'Capture',
    cq = new RegExp(GT + '$'),
    zT = (t, e, n) => {
      const r =
          e.$elm$.nodeType === 11 && e.$elm$.host ? e.$elm$.host : e.$elm$,
        i = (t && t.$attrs$) || tE,
        s = e.$attrs$ || tE;
      for (const o of oE(Object.keys(i)))
        o in s || iE(r, o, i[o], void 0, n, e.$flags$);
      for (const o of oE(Object.keys(s))) iE(r, o, i[o], s[o], n, e.$flags$);
    };
  function oE(t) {
    return t.includes('ref') ? [...t.filter((e) => e !== 'ref'), 'ref'] : t;
  }
  var gr = !1,
    E1 = (t, e, n, r) => {
      const i = e.$children$[n];
      let s,
        o,
        a = 0;
      if (i.$text$ !== null) s = i.$elm$ = ai.createTextNode(i.$text$);
      else {
        if (
          (gr || (gr = i.$tag$ === 'svg'),
          (s = i.$elm$ =
            ai.createElementNS(
              gr
                ? 'http://www.w3.org/2000/svg'
                : 'http://www.w3.org/1999/xhtml',
              i.$tag$
            )),
          gr && i.$tag$ === 'foreignObject' && (gr = !1),
          zT(null, i, gr),
          s.getRootNode().querySelector('body'),
          i.$children$)
        )
          for (a = 0; a < i.$children$.length; ++a)
            ((o = E1(t, i, a)), o && s.appendChild(o));
        i.$tag$ === 'svg'
          ? (gr = !1)
          : s.tagName === 'foreignObject' && (gr = !0);
      }
      return ((s['s-hn'] = _1), s);
    },
    aE = (t, e, n, r, i, s) => {
      let o,
        a = t;
      for (a.shadowRoot && a.tagName === _1 && (a = a.shadowRoot); i <= s; ++i)
        r[i] && ((o = E1(null, n, i)), o && ((r[i].$elm$ = o), yf(a, o, e)));
    },
    cE = (t, e, n) => {
      for (let r = e; r <= n; ++r) {
        const i = t[r];
        if (i) {
          const s = i.$elm$;
          s && s.remove();
        }
      }
    },
    kd = (t, e, n = !1) => t.$tag$ === e.$tag$,
    ol = (t, e, n = !1) => {
      const r = (e.$elm$ = t.$elm$),
        i = t.$children$,
        s = e.$children$,
        o = e.$tag$,
        a = e.$text$;
      a === null
        ? (zT(t, e, (gr = o === 'svg' || (o !== 'foreignObject' && gr))),
          i !== null && s !== null
            ? ((c, l, u, d, f = !1) => {
                let h,
                  g = 0,
                  m = 0,
                  y = l.length - 1,
                  p = l[0],
                  b = l[y],
                  v = d.length - 1,
                  x = d[0],
                  C = d[v];
                for (; g <= y && m <= v; )
                  p == null
                    ? (p = l[++g])
                    : b == null
                      ? (b = l[--y])
                      : x == null
                        ? (x = d[++m])
                        : C == null
                          ? (C = d[--v])
                          : kd(p, x, f)
                            ? (ol(p, x, f), (p = l[++g]), (x = d[++m]))
                            : kd(b, C, f)
                              ? (ol(b, C, f), (b = l[--y]), (C = d[--v]))
                              : kd(p, C, f)
                                ? (ol(p, C, f),
                                  yf(c, p.$elm$, b.$elm$.nextSibling),
                                  (p = l[++g]),
                                  (C = d[--v]))
                                : kd(b, x, f)
                                  ? (ol(b, x, f),
                                    yf(c, b.$elm$, p.$elm$),
                                    (b = l[--y]),
                                    (x = d[++m]))
                                  : ((h = E1(l && l[m], u, m)),
                                    (x = d[++m]),
                                    h && yf(p.$elm$.parentNode, h, p.$elm$));
                g > y
                  ? aE(c, d[v + 1] == null ? null : d[v + 1].$elm$, u, d, m, v)
                  : m > v && cE(l, g, y);
              })(r, i, e, s, n)
            : s !== null
              ? (t.$text$ !== null && (r.textContent = ''),
                aE(r, null, e, s, 0, s.length - 1))
              : !n && YK && i !== null && cE(i, 0, i.length - 1),
          gr && o === 'svg' && (gr = !1))
        : t.$text$ !== a && (r.data = a);
    },
    yf = (t, e, n) => (t == null ? void 0 : t.insertBefore(e, n)),
    lq = (t, e, n = !1) => {
      const r = t.$hostElement$,
        i = t.$cmpMeta$,
        s = t.$vnode$ || zh(null, null),
        o = (a = e) && a.$tag$ === rq ? e : ae(null, null, e);
      var a;
      if (((_1 = r.tagName), n && o.$attrs$))
        for (const c of Object.keys(o.$attrs$))
          r.hasAttribute(c) &&
            !['key', 'ref', 'style', 'class'].includes(c) &&
            (o.$attrs$[c] = r[c]);
      ((o.$tag$ = null),
        (o.$flags$ |= 4),
        (t.$vnode$ = o),
        (o.$elm$ = s.$elm$ = r.shadowRoot || r),
        r['s-sc'],
        1 & i.$flags$,
        ol(s, o, n));
    },
    WT = (t, e) => {
      e &&
        !t.$onRenderResolve$ &&
        e['s-p'] &&
        e['s-p'].push(new Promise((n) => (t.$onRenderResolve$ = n)));
    },
    A1 = (t, e) => (
      (t.$flags$ |= 16),
      4 & t.$flags$
        ? void (t.$flags$ |= 512)
        : (WT(t, t.$ancestorComponent$), XK(() => uq(t, e)))
    ),
    uq = (t, e) => {
      const n = t.$hostElement$;
      t.$cmpMeta$.$tagName$;
      const r = t.$lazyInstance$;
      if (!r)
        throw new Error(
          `Can't render component <${n.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`
        );
      return dq(void 0, () => hq(t, r, e));
    },
    dq = (t, e) =>
      fq(t)
        ? t.then(e).catch((n) => {
            (console.error(n), e());
          })
        : e(),
    fq = (t) =>
      t instanceof Promise || (t && t.then && typeof t.then == 'function'),
    hq = async (t, e, n) => {
      var r;
      const i = t.$hostElement$;
      t.$cmpMeta$.$tagName$;
      const s = i['s-rc'];
      (n && oq(t),
        t.$cmpMeta$.$tagName$,
        pq(t, e, i, n),
        s && (s.map((o) => o()), (i['s-rc'] = void 0)));
      {
        const o = (r = i['s-p']) != null ? r : [],
          a = () => mq(t);
        o.length === 0
          ? a()
          : (Promise.all(o).then(a), (t.$flags$ |= 4), (o.length = 0));
      }
    },
    pq = (t, e, n, r) => {
      try {
        ((e = e.render()), (t.$flags$ &= -17), (t.$flags$ |= 2), lq(t, e, r));
      } catch (i) {
        Uo(i, t.$hostElement$);
      }
      return null;
    },
    mq = (t) => {
      t.$cmpMeta$.$tagName$;
      const e = t.$hostElement$,
        n = () => {},
        r = t.$lazyInstance$,
        i = t.$ancestorComponent$;
      (64 & t.$flags$
        ? n()
        : ((t.$flags$ |= 64),
          YT(e),
          S1(r, 'componentDidLoad'),
          t.$onReadyResolve$(e),
          i || ZT()),
        t.$onRenderResolve$ &&
          (t.$onRenderResolve$(), (t.$onRenderResolve$ = void 0)),
        512 & t.$flags$ && b1(() => A1(t, !1)),
        (t.$flags$ &= -517));
    },
    ZT = (t) => {
      (YT(ai.documentElement),
        b1(() =>
          qT(Wp, 'appload', {detail: {namespace: 'sdk-install-modal-web'}})
        ));
    },
    S1 = (t, e, n) => {
      if (t && t[e])
        try {
          return t[e](n);
        } catch (r) {
          Uo(r);
        }
    },
    YT = (t) => {
      var e;
      return t.classList.add((e = WK) != null ? e : 'hydrated');
    },
    gq = (t, e, n, r) => {
      const i = js(t);
      if (!i)
        throw new Error(
          `Couldn't find host element for "${r.$tagName$}" as it is unknown to this Stencil runtime. This usually happens when integrating a 3rd party Stencil component with another Stencil component or application. Please reach out to the maintainers of the 3rd party Stencil component or report this on the Stencil Discord server (https://chat.stenciljs.com) or comment on this similar [GitHub issue](https://github.com/ionic-team/stencil/issues/5457).`
        );
      const s = i.$hostElement$,
        o = i.$instanceValues$.get(e),
        a = i.$flags$,
        c = i.$lazyInstance$;
      var l, u;
      ((l = n),
        (u = r.$members$[e][0]),
        (n =
          l == null || w1(l)
            ? l
            : 4 & u
              ? l !== 'false' && (l === '' || !!l)
              : 1 & u
                ? String(l)
                : l));
      const d = Number.isNaN(o) && Number.isNaN(n);
      if (
        (!(8 & a) || o === void 0) &&
        n !== o &&
        !d &&
        (i.$instanceValues$.set(e, n), c)
      ) {
        if (r.$watchers$ && 128 & a) {
          const f = r.$watchers$[e];
          f &&
            f.map((h) => {
              try {
                c[h](n, o, e);
              } catch (g) {
                Uo(g, s);
              }
            });
        }
        (18 & a) == 2 && A1(i, !1);
      }
    },
    QT = (t, e, n) => {
      var r, i;
      const s = t.prototype;
      if (e.$members$ || e.$watchers$ || t.watchers) {
        t.watchers && !e.$watchers$ && (e.$watchers$ = t.watchers);
        const o = Object.entries((r = e.$members$) != null ? r : {});
        if (
          (o.map(([a, [c]]) => {
            (31 & c || (2 & n && 32 & c)) &&
              Object.defineProperty(s, a, {
                get() {
                  return ((l = a), js(this).$instanceValues$.get(l));
                  var l;
                },
                set(l) {
                  gq(this, a, l, e);
                },
                configurable: !0,
                enumerable: !0
              });
          }),
          1 & n)
        ) {
          const a = new Map();
          ((s.attributeChangedCallback = function (c, l, u) {
            Qt.jmp(() => {
              var d;
              const f = a.get(c);
              if (this.hasOwnProperty(f)) ((u = this[f]), delete this[f]);
              else {
                if (
                  s.hasOwnProperty(f) &&
                  typeof this[f] == 'number' &&
                  this[f] == u
                )
                  return;
                if (f == null) {
                  const h = js(this),
                    g = h == null ? void 0 : h.$flags$;
                  if (g && !(8 & g) && 128 & g && u !== l) {
                    const m = h.$lazyInstance$,
                      y = (d = e.$watchers$) == null ? void 0 : d[c];
                    y == null ||
                      y.forEach((p) => {
                        m[p] != null && m[p].call(m, u, l, c);
                      });
                  }
                  return;
                }
              }
              this[f] = (u !== null || typeof this[f] != 'boolean') && u;
            });
          }),
            (t.observedAttributes = Array.from(
              new Set([
                ...Object.keys((i = e.$watchers$) != null ? i : {}),
                ...o
                  .filter(([c, l]) => 15 & l[0])
                  .map(([c, l]) => {
                    const u = l[1] || c;
                    return (a.set(u, c), u);
                  })
              ])
            )));
        }
      }
      return t;
    },
    yq = async (t, e, n, r) => {
      let i;
      if ((32 & e.$flags$) == 0) {
        if (((e.$flags$ |= 32), n.$lazyBundleId$)) {
          const a = ((c, l, u) => {
            const d = c.$tagName$.replace(/-/g, '_'),
              f = c.$lazyBundleId$;
            if (!f) return;
            const h = S0.get(f);
            if (h) return h[d];
            {
              const g = (m) => (S0.set(f, m), m[d]);
              if (f === 'mm-install-modal_3')
                return Promise.resolve()
                  .then(function () {
                    return Mq;
                  })
                  .then(g, Uo);
            }
            return E$(() => import(`./${f}.entry.js`), []).then(
              (g) => (S0.set(f, g), g[d]),
              Uo
            );
          })(n);
          if ((a && 'then' in a ? (i = await a) : (i = a), !i))
            throw new Error(
              `Constructor for "${n.$tagName$}#${e.$modeName$}" was not found`
            );
          (i.isProxied ||
            ((n.$watchers$ = i.watchers), QT(i, n, 2), (i.isProxied = !0)),
            n.$tagName$,
            (e.$flags$ |= 8));
          try {
            new i(e);
          } catch (c) {
            Uo(c);
          }
          ((e.$flags$ &= -9), (e.$flags$ |= 128), fy(e.$lazyInstance$));
        } else {
          i = t.constructor;
          const a = t.localName;
          customElements.whenDefined(a).then(() => (e.$flags$ |= 128));
        }
        if (i && i.style) {
          let a;
          typeof i.style == 'string' && (a = i.style);
          const c = VT(n);
          gf.has(c) ||
            (n.$tagName$,
            ((l, u, d) => {
              let f = gf.get(l);
              (HT && d
                ? ((f = f || new CSSStyleSheet()),
                  typeof f == 'string' ? (f = u) : f.replaceSync(u))
                : (f = u),
                gf.set(l, f));
            })(c, a, !!(1 & n.$flags$)));
        }
      }
      const s = e.$ancestorComponent$,
        o = () => A1(e, !0);
      s && s['s-rc'] ? s['s-rc'].push(o) : o();
    },
    fy = (t) => {
      S1(t, 'connectedCallback');
    },
    lE = (t) => {
      S1(t, 'disconnectedCallback');
    },
    vq = (t, e = {}) => {
      var n;
      const r = [],
        i = e.exclude || [],
        s = Wp.customElements,
        o = ai.head,
        a = o.querySelector('meta[charset]'),
        c = ai.createElement('style'),
        l = [];
      let u,
        d = !0;
      (Object.assign(Qt, e),
        (Qt.$resourcesUrl$ = new URL(e.resourcesUrl || './', ai.baseURI).href));
      let f = !1;
      if (
        (t.map((h) => {
          h[1].map((g) => {
            var m;
            const y = {
              $flags$: g[0],
              $tagName$: g[1],
              $members$: g[2],
              $listeners$: g[3]
            };
            (4 & y.$flags$ && (f = !0),
              (y.$members$ = g[2]),
              (y.$watchers$ = (m = g[4]) != null ? m : {}));
            const p = y.$tagName$,
              b = class extends HTMLElement {
                constructor(v) {
                  if (
                    (super(v),
                    (this.hasRegisteredEventListeners = !1),
                    ((x, C) => {
                      const $ = {
                        $flags$: 0,
                        $hostElement$: x,
                        $cmpMeta$: C,
                        $instanceValues$: new Map()
                      };
                      (($.$onReadyPromise$ = new Promise(
                        (G) => ($.$onReadyResolve$ = G)
                      )),
                        (x['s-p'] = []),
                        (x['s-rc'] = []),
                        y1.set(x, $));
                    })((v = this), y),
                    1 & y.$flags$)
                  )
                    if (v.shadowRoot) {
                      if (v.shadowRoot.mode !== 'open')
                        throw new Error(
                          `Unable to re-use existing shadow root for ${y.$tagName$}! Mode is set to ${v.shadowRoot.mode} but Stencil only supports open shadow roots.`
                        );
                    } else v.attachShadow({mode: 'open'});
                }
                connectedCallback() {
                  (js(this),
                    this.hasRegisteredEventListeners ||
                      (this.hasRegisteredEventListeners = !0),
                    u && (clearTimeout(u), (u = null)),
                    d
                      ? l.push(this)
                      : Qt.jmp(() =>
                          ((v) => {
                            if ((1 & Qt.$flags$) == 0) {
                              const x = js(v),
                                C = x.$cmpMeta$;
                              if ((C.$tagName$, 1 & x.$flags$))
                                x != null && x.$lazyInstance$
                                  ? fy(x.$lazyInstance$)
                                  : x != null &&
                                    x.$onReadyPromise$ &&
                                    x.$onReadyPromise$.then(() =>
                                      fy(x.$lazyInstance$)
                                    );
                              else {
                                x.$flags$ |= 1;
                                {
                                  let $ = v;
                                  for (; ($ = $.parentNode || $.host); )
                                    if ($['s-p']) {
                                      WT(x, (x.$ancestorComponent$ = $));
                                      break;
                                    }
                                }
                                (C.$members$ &&
                                  Object.entries(C.$members$).map(
                                    ([$, [G]]) => {
                                      if (31 & G && v.hasOwnProperty($)) {
                                        const L = v[$];
                                        (delete v[$], (v[$] = L));
                                      }
                                    }
                                  ),
                                  yq(v, x, C));
                              }
                            }
                          })(this)
                        ));
                }
                disconnectedCallback() {
                  Qt.jmp(() =>
                    (async (v) => {
                      if ((1 & Qt.$flags$) == 0) {
                        const x = js(v);
                        x != null && x.$lazyInstance$
                          ? lE(x.$lazyInstance$)
                          : x != null &&
                            x.$onReadyPromise$ &&
                            x.$onReadyPromise$.then(() => lE(x.$lazyInstance$));
                      }
                    })(this)
                  );
                }
                componentOnReady() {
                  return js(this).$onReadyPromise$;
                }
              };
            ((y.$lazyBundleId$ = h[0]),
              i.includes(p) ||
                s.get(p) ||
                (r.push(p), s.define(p, QT(b, y, 1))));
          });
        }),
        r.length > 0 &&
          (f && (c.textContent += $T),
          (c.textContent +=
            r.sort() + '{visibility:hidden}.hydrated{visibility:inherit}'),
          c.innerHTML.length))
      ) {
        c.setAttribute('data-styles', '');
        const h = (n = Qt.$nonce$) != null ? n : UT(ai);
        (h != null && c.setAttribute('nonce', h),
          o.insertBefore(c, a ? a.nextSibling : o.firstChild));
      }
      ((d = !1),
        l.length
          ? l.map((h) => h.connectedCallback())
          : Qt.jmp(() => (u = setTimeout(ZT, 30))));
    };
  (function () {
    if (
      typeof window < 'u' &&
      window.Reflect !== void 0 &&
      window.customElements !== void 0
    ) {
      var t = HTMLElement;
      ((window.HTMLElement = function () {
        return Reflect.construct(t, [], this.constructor);
      }),
        (HTMLElement.prototype = t.prototype),
        (HTMLElement.prototype.constructor = HTMLElement),
        Object.setPrototypeOf(HTMLElement, t));
    }
  })();
  var bq = Object.freeze({
    __proto__: null,
    defineCustomElements: async (t, e) => {
      if (typeof window < 'u')
        return (
          await void 0,
          vq(
            [
              [
                'mm-install-modal_3',
                [
                  [
                    1,
                    'mm-install-modal',
                    {
                      link: [1],
                      sdkVersion: [1, 'sdk-version'],
                      preferDesktop: [4, 'prefer-desktop'],
                      tab: [32],
                      isDefaultTab: [32],
                      translationsLoaded: [32]
                    },
                    null,
                    {preferDesktop: ['updatePreferDesktop']}
                  ],
                  [
                    1,
                    'mm-pending-modal',
                    {
                      displayOTP: [4, 'display-o-t-p'],
                      sdkVersion: [1, 'sdk-version'],
                      otpCode: [1, 'otp-code'],
                      translationsLoaded: [32]
                    }
                  ],
                  [
                    1,
                    'mm-select-modal',
                    {
                      link: [1],
                      sdkVersion: [1, 'sdk-version'],
                      preferDesktop: [4, 'prefer-desktop'],
                      tab: [32],
                      isDefaultTab: [32],
                      translationsLoaded: [32]
                    },
                    null,
                    {preferDesktop: ['updatePreferDesktop']}
                  ]
                ]
              ]
            ],
            e
          )
        );
    },
    setNonce: (t) => (Qt.$nonce$ = t)
  });
  const wq = {fontFamily: 'Roboto, sans-serif'},
    x1 = ({className: t}, e) => ae('div', {style: wq, class: t}, e),
    x0 = ({Icon: t, text: e}) =>
      ae(
        'div',
        {class: 'flexContainer', style: {padding: '6', flexDirection: 'row'}},
        ae('div', {class: 'flexItem1'}, ae(t, null)),
        ae(
          'div',
          {class: 'flexItem11'},
          ae('span', {style: {lineHeight: '2', color: 'black'}}, e)
        )
      ),
    _q = () =>
      ae(
        'svg',
        {
          width: '20',
          height: '18',
          viewBox: '0 0 20 18',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg'
        },
        ae('path', {
          d: 'M20.0002 7.9702V10.0302C20.0002 10.5802 19.5602 11.0302 19.0002 11.0502H17.0402C15.9602 11.0502 14.9702 10.2602 14.8802 9.1802C14.8202 8.5502 15.0602 7.9602 15.4802 7.5502C15.8502 7.1702 16.3602 6.9502 16.9202 6.9502H19.0002C19.5602 6.9702 20.0002 7.4202 20.0002 7.9702Z',
          fill: '#037DD6'
        }),
        ae('path', {
          d: 'M18.47 12.55H17.04C15.14 12.55 13.54 11.12 13.38 9.3C13.29 8.26 13.67 7.22 14.43 6.48C15.07 5.82 15.96 5.45 16.92 5.45H18.47C18.76 5.45 19 5.21 18.97 4.92C18.75 2.49 17.14 0.83 14.75 0.55C14.51 0.51 14.26 0.5 14 0.5H5C4.72 0.5 4.45 0.52 4.19 0.56C1.64 0.88 0 2.78 0 5.5V12.5C0 15.26 2.24 17.5 5 17.5H14C16.8 17.5 18.73 15.75 18.97 13.08C19 12.79 18.76 12.55 18.47 12.55ZM11 6.75H5C4.59 6.75 4.25 6.41 4.25 6C4.25 5.59 4.59 5.25 5 5.25H11C11.41 5.25 11.75 5.59 11.75 6C11.75 6.41 11.41 6.75 11 6.75Z',
          fill: '#037DD6'
        })
      ),
    Eq = () =>
      ae(
        'svg',
        {
          width: '20',
          height: '18',
          viewBox: '0 0 20 18',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg'
        },
        ae('path', {
          d: 'M14.44 0.0999756C12.63 0.0999756 11.01 0.979976 10 2.32998C8.99 0.979976 7.37 0.0999756 5.56 0.0999756C2.49 0.0999756 0 2.59998 0 5.68998C0 6.87998 0.19 7.97998 0.52 8.99998C2.1 14 6.97 16.99 9.38 17.81C9.72 17.93 10.28 17.93 10.62 17.81C13.03 16.99 17.9 14 19.48 8.99998C19.81 7.97998 20 6.87998 20 5.68998C20 2.59998 17.51 0.0999756 14.44 0.0999756Z',
          fill: '#037DD6'
        })
      ),
    Aq = () =>
      ae(
        'svg',
        {
          width: '20',
          height: '20',
          viewBox: '0 0 20 20',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg'
        },
        ae('path', {
          d: 'M16.28 7.53V6.28C16.28 3.58 15.63 0 10 0C4.37 0 3.72 3.58 3.72 6.28V7.53C0.92 7.88 0 9.3 0 12.79V14.65C0 18.75 1.25 20 5.35 20H14.65C18.75 20 20 18.75 20 14.65V12.79C20 9.3 19.08 7.88 16.28 7.53ZM10 16.74C8.33 16.74 6.98 15.38 6.98 13.72C6.98 12.05 8.34 10.7 10 10.7C11.66 10.7 13.02 12.06 13.02 13.72C13.02 15.39 11.67 16.74 10 16.74ZM5.35 7.44C5.27 7.44 5.2 7.44 5.12 7.44V6.28C5.12 3.35 5.95 1.4 10 1.4C14.05 1.4 14.88 3.35 14.88 6.28V7.45C14.8 7.45 14.73 7.45 14.65 7.45H5.35V7.44Z',
          fill: '#037DD6'
        })
      ),
    Sq = () =>
      ae(
        'svg',
        {
          width: '20',
          height: '20',
          viewBox: '0 0 24 24',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg'
        },
        ae('path', {
          d: 'M16.4405 8.8999C20.0405 9.2099 21.5105 11.0599 21.5105 15.1099V15.2399C21.5105 19.7099 19.7205 21.4999 15.2505 21.4999H8.74047C4.27047 21.4999 2.48047 19.7099 2.48047 15.2399V15.1099C2.48047 11.0899 3.93047 9.2399 7.47047 8.9099',
          stroke: 'white',
          'stroke-width': '1.5',
          'stroke-linecap': 'round',
          'stroke-linejoin': 'round'
        }),
        ae('path', {
          d: 'M12 2V14.88',
          stroke: 'white',
          'stroke-width': '1.5',
          'stroke-linecap': 'round',
          'stroke-linejoin': 'round'
        }),
        ae('path', {
          d: 'M15.3504 12.6499L12.0004 15.9999L8.65039 12.6499',
          stroke: 'white',
          'stroke-width': '1.5',
          'stroke-linecap': 'round',
          'stroke-linejoin': 'round'
        })
      );
  function C1({version: t}) {
    return ae(
      'div',
      {style: {textAlign: 'center', color: '#BBC0C5', fontSize: '12'}},
      'SDK Version ',
      t ? `v${t}` : 'unknown'
    );
  }
  const T1 = () =>
      ae(
        'svg',
        {
          width: '14',
          height: '14',
          viewBox: '0 0 16 16',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg'
        },
        ae('rect', {width: '16', height: '16', fill: 'white'}),
        ae('path', {
          'fill-rule': 'evenodd',
          'clip-rule': 'evenodd',
          d: 'M2.40554 2.40554C2.94627 1.86482 3.82296 1.86482 4.36369 2.40554L8 6.04186L11.6363 2.40554C12.177 1.86482 13.0537 1.86482 13.5945 2.40554C14.1352 2.94627 14.1352 3.82296 13.5945 4.36369L9.95814 8L13.5945 11.6363C14.1352 12.177 14.1352 13.0537 13.5945 13.5945C13.0537 14.1352 12.177 14.1352 11.6363 13.5945L8 9.95814L4.36369 13.5945C3.82296 14.1352 2.94627 14.1352 2.40554 13.5945C1.86482 13.0537 1.86482 12.177 2.40554 11.6363L6.04186 8L2.40554 4.36369C1.86482 3.82296 1.86482 2.94627 2.40554 2.40554Z',
          fill: '#BBC0C5'
        })
      ),
    I1 = () =>
      ae(
        'svg',
        {
          width: '120',
          xmlns: 'http://www.w3.org/2000/svg',
          fill: 'none',
          viewBox: '0 0 127 63'
        },
        ae('path', {
          fill: 'currentColor',
          d: 'M71.554 48.607v13.81h-7.072v-9.568l-8.059.945c-1.77.205-2.548.79-2.548 1.864 0 1.575 1.478 2.239 4.648 2.239 1.932 0 4.073-.29 5.963-.79l-3.66 5.225c-1.479.332-2.92.496-4.44.496-6.414 0-10.074-2.57-10.074-7.132 0-4.023 2.877-6.136 9.416-6.884l8.638-1.012c-.467-2.532-2.362-3.633-6.13-3.633-3.537 0-7.443.912-10.937 2.613l1.111-6.18c3.248-1.369 6.95-2.074 10.69-2.074 8.226 0 12.461 3.444 12.461 10.075l-.008.005ZM7.938 31.315.208 62.416h7.73l3.836-15.628 6.65 8.039h8.06l6.65-8.039 3.836 15.628h7.73l-7.73-31.105-14.518 17.388L7.934 31.311l.004.004ZM36.97.21 22.452 17.598 7.938.21.208 31.315h7.73l3.836-15.628 6.65 8.039h8.06l6.65-8.039 3.836 15.628h7.73L36.97.21Zm53.17 48.107-6.25-.912c-1.562-.247-2.178-.747-2.178-1.617 0-1.41 1.52-2.032 4.647-2.032 3.62 0 6.868.747 10.283 2.364l-.862-6.094c-2.757-.995-5.922-1.491-9.212-1.491-7.688 0-11.886 2.696-11.886 7.547 0 3.776 2.303 5.889 7.196 6.636l6.335.954c1.603.248 2.261.87 2.261 1.865 0 1.41-1.478 2.074-4.481 2.074-3.948 0-8.225-.953-11.72-2.654l.7 6.094c3.003 1.122 6.91 1.785 10.57 1.785 7.896 0 12.007-2.78 12.007-7.715 0-3.94-2.303-6.057-7.4-6.8l-.01-.004ZM100.3 34.09v28.325h7.071V34.091H100.3Zm15.334 15.595 9.833-10.744h-8.8l-9.296 11.114 9.912 12.356h8.925l-10.574-12.73v.004Zm-16.321-25.09c0 4.56 3.66 7.13 10.074 7.13 1.52 0 2.961-.167 4.44-.495l3.66-5.225c-1.89.496-4.031.79-5.963.79-3.166 0-4.648-.664-4.648-2.239 0-1.079.783-1.659 2.549-1.864l8.058-.945v9.567h7.072v-13.81c0-6.635-4.236-10.075-12.461-10.075-3.744 0-7.442.705-10.691 2.075l-1.112 6.178c3.495-1.701 7.401-2.613 10.937-2.613 3.769 0 5.664 1.1 6.13 3.633l-8.637 1.013c-6.539.747-9.417 2.86-9.417 6.883l.009-.004Zm-19.779-1.492c0 5.725 3.29 8.627 9.787 8.627 2.59 0 4.732-.416 6.785-1.37l.903-6.261c-1.974 1.2-3.99 1.822-6.005 1.822-3.044 0-4.402-1.243-4.402-4.023v-8.295h10.732V7.84H86.601V2.948l-13.448 7.174v3.482h6.372V23.1l.008.004Zm-6.95-2.612v1.411H53.47c.862 2.873 3.423 4.187 7.97 4.187 3.62 0 6.993-.747 9.992-2.196l-.862 6.056c-2.757 1.16-6.251 1.785-9.829 1.785-9.5 0-14.68-4.23-14.68-12.066 0-7.838 5.264-12.235 13.406-12.235s13.119 4.771 13.119 13.062l-.005-.004ZM53.378 17.09h12.086c-.637-2.751-2.732-4.188-6.08-4.188-3.349 0-5.335 1.399-6.006 4.188Z'
        })
      );
  function vo(t, e) {
    return t.toString(2).padStart(e, '0');
  }
  function uE(t, e) {
    const n = t % e;
    return n >= 0 ? n : e + n;
  }
  function Jn(t, e) {
    return new Array(t).fill(e);
  }
  function dE(...t) {
    let e = 0;
    for (const r of t) e = Math.max(e, r.length);
    const n = [];
    for (let r = 0; r < e; r++)
      for (const i of t) r >= i.length || n.push(i[r]);
    return new Uint8Array(n);
  }
  function fE(t, e, n) {
    if (n < 0 || n + e.length > t.length) return !1;
    for (let r = 0; r < e.length; r++) if (e[r] !== t[n + r]) return !1;
    return !0;
  }
  function hE(t) {
    return {
      has: (e) => t.includes(e),
      decode: (e) => {
        if (!Array.isArray(e) || (e.length && typeof e[0] != 'string'))
          throw new Error('alphabet.decode input should be array of strings');
        return e.map((n) => {
          if (typeof n != 'string')
            throw new Error(`alphabet.decode: not string element=${n}`);
          const r = t.indexOf(n);
          if (r === -1)
            throw new Error(`Unknown letter: "${n}". Allowed: ${t}`);
          return r;
        });
      },
      encode: (e) => {
        if (!Array.isArray(e) || (e.length && typeof e[0] != 'number'))
          throw new Error(
            'alphabet.encode input should be an array of numbers'
          );
        return e.map((n) => {
          if (
            ((function (r) {
              if (!Number.isSafeInteger(r))
                throw new Error(`Wrong integer: ${r}`);
            })(n),
            n < 0 || n >= t.length)
          )
            throw new Error(
              `Digit index outside alphabet: ${n} (alphabet: ${t.length})`
            );
          return t[n];
        });
      }
    };
  }
  class Yn {
    static size(e, n) {
      if (
        (typeof e == 'number' && (e = {height: e, width: e}),
        !Number.isSafeInteger(e.height) && e.height !== 1 / 0)
      )
        throw new Error(
          `Bitmap: wrong height=${e.height} (${typeof e.height})`
        );
      if (!Number.isSafeInteger(e.width) && e.width !== 1 / 0)
        throw new Error(`Bitmap: wrong width=${e.width} (${typeof e.width})`);
      return (
        n !== void 0 &&
          (e = {
            width: Math.min(e.width, n.width),
            height: Math.min(e.height, n.height)
          }),
        e
      );
    }
    static fromString(e) {
      const n = (e = e.replace(/^\n+/g, '').replace(/\n+$/g, '')).split(`
`),
        r = n.length,
        i = new Array(r);
      let s;
      for (const o of n) {
        const a = o.split('').map((c) => {
          if (c === 'X') return !0;
          if (c === ' ') return !1;
          if (c !== '?')
            throw new Error(`Bitmap.fromString: unknown symbol=${c}`);
        });
        if (s && a.length !== s)
          throw new Error(
            `Bitmap.fromString different row sizes: width=${s} cur=${a.length}`
          );
        ((s = a.length), i.push(a));
      }
      return (s || (s = 0), new Yn({height: r, width: s}, i));
    }
    constructor(e, n) {
      const {height: r, width: i} = Yn.size(e);
      ((this.data = n || Array.from({length: r}, () => Jn(i, void 0))),
        (this.height = r),
        (this.width = i));
    }
    point(e) {
      return this.data[e.y][e.x];
    }
    isInside(e) {
      return 0 <= e.x && e.x < this.width && 0 <= e.y && e.y < this.height;
    }
    size(e) {
      if (!e) return {height: this.height, width: this.width};
      const {x: n, y: r} = this.xy(e);
      return {height: this.height - r, width: this.width - n};
    }
    xy(e) {
      if (
        (typeof e == 'number' && (e = {x: e, y: e}), !Number.isSafeInteger(e.x))
      )
        throw new Error(`Bitmap: wrong x=${e.x}`);
      if (!Number.isSafeInteger(e.y)) throw new Error(`Bitmap: wrong y=${e.y}`);
      return ((e.x = uE(e.x, this.width)), (e.y = uE(e.y, this.height)), e);
    }
    rect(e, n, r) {
      const {x: i, y: s} = this.xy(e),
        {height: o, width: a} = Yn.size(n, this.size({x: i, y: s}));
      for (let c = 0; c < o; c++)
        for (let l = 0; l < a; l++)
          this.data[s + c][i + l] =
            typeof r == 'function'
              ? r({x: l, y: c}, this.data[s + c][i + l])
              : r;
      return this;
    }
    rectRead(e, n, r) {
      return this.rect(e, n, (i, s) => (r(i, s), s));
    }
    hLine(e, n, r) {
      return this.rect(e, {width: n, height: 1}, r);
    }
    vLine(e, n, r) {
      return this.rect(e, {width: 1, height: n}, r);
    }
    border(e = 2, n) {
      const r = this.height + 2 * e,
        i = this.width + 2 * e,
        s = Jn(e, n),
        o = Array.from({length: e}, () => Jn(i, n));
      return new Yn({height: r, width: i}, [
        ...o,
        ...this.data.map((a) => [...s, ...a, ...s]),
        ...o
      ]);
    }
    embed(e, n) {
      return this.rect(e, n.size(), ({x: r, y: i}) => n.data[i][r]);
    }
    rectSlice(e, n = this.size()) {
      const r = new Yn(Yn.size(n, this.size(this.xy(e))));
      return (this.rect(e, n, ({x: i, y: s}, o) => (r.data[s][i] = o)), r);
    }
    inverse() {
      const {height: e, width: n} = this;
      return new Yn({height: n, width: e}).rect(
        {x: 0, y: 0},
        1 / 0,
        ({x: r, y: i}) => this.data[r][i]
      );
    }
    scale(e) {
      if (!Number.isSafeInteger(e) || e > 1024)
        throw new Error(`Wrong scale factor: ${e}`);
      const {height: n, width: r} = this;
      return new Yn({height: e * n, width: e * r}).rect(
        {x: 0, y: 0},
        1 / 0,
        ({x: i, y: s}) => this.data[Math.floor(s / e)][Math.floor(i / e)]
      );
    }
    clone() {
      return new Yn(this.size()).rect(
        {x: 0, y: 0},
        this.size(),
        ({x: e, y: n}) => this.data[n][e]
      );
    }
    assertDrawn() {
      this.rectRead(0, 1 / 0, (e, n) => {
        if (typeof n != 'boolean')
          throw new Error('Invalid color type=' + typeof n);
      });
    }
    toString() {
      return this.data.map((e) =>
        e.map((n) => (n === void 0 ? '?' : n ? 'X' : ' ')).join('')
      ).join(`
`);
    }
    toASCII() {
      const {height: e, width: n, data: r} = this;
      let i = '';
      for (let s = 0; s < e; s += 2) {
        for (let o = 0; o < n; o++) {
          const a = r[s][o],
            c = s + 1 >= e || r[s + 1][o];
          a || c
            ? !a && c
              ? (i += '▀')
              : a && !c
                ? (i += '▄')
                : a && c && (i += ' ')
            : (i += '█');
        }
        i += `
`;
      }
      return i;
    }
    toTerm() {
      const e = '\x1B[0m',
        n = `\x1B[1;47m  ${e}`,
        r = `\x1B[40m  ${e}`;
      return this.data.map((i) => i.map((s) => (s ? r : n)).join('')).join(`
`);
    }
    toSVG() {
      let e = `<svg xmlns:svg="http://www.w3.org/2000/svg" viewBox="0 0 ${this.width} ${this.height}" version="1.1" xmlns="http://www.w3.org/2000/svg">`;
      return (
        this.rectRead(0, 1 / 0, ({x: n, y: r}, i) => {
          i && (e += `<rect x="${n}" y="${r}" width="1" height="1" />`);
        }),
        (e += '</svg>'),
        e
      );
    }
    toGIF() {
      const e = (a) => [255 & a, (a >>> 8) & 255],
        n = [...e(this.width), ...e(this.height)],
        r = [];
      this.rectRead(0, 1 / 0, (a, c) => r.push(+(c === !0)));
      const i = 126,
        s = [
          71,
          73,
          70,
          56,
          55,
          97,
          ...n,
          246,
          0,
          0,
          255,
          255,
          255,
          ...Jn(381, 0),
          44,
          0,
          0,
          0,
          0,
          ...n,
          0,
          7
        ],
        o = Math.floor(r.length / i);
      for (let a = 0; a < o; a++)
        s.push(127, 128, ...r.slice(i * a, i * (a + 1)).map((c) => +c));
      return (
        s.push((r.length % i) + 1, 128, ...r.slice(o * i).map((a) => +a)),
        s.push(1, 129, 0, 59),
        new Uint8Array(s)
      );
    }
    toImage(e = !1) {
      const {height: n, width: r} = this.size(),
        i = new Uint8Array(n * r * (e ? 3 : 4));
      let s = 0;
      for (let o = 0; o < n; o++)
        for (let a = 0; a < r; a++) {
          const c = this.data[o][a] ? 0 : 255;
          ((i[s++] = c), (i[s++] = c), (i[s++] = c), e || (i[s++] = 255));
        }
      return {height: n, width: r, data: i};
    }
  }
  const pE = ['low', 'medium', 'quartile', 'high'],
    mE = ['numeric', 'alphanumeric', 'byte', 'kanji', 'eci'],
    xq = [
      26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655,
      733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921,
      2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706
    ],
    Cq = {
      low: [
        7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30,
        28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
        30, 30, 30, 30
      ],
      medium: [
        10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26,
        26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
        28, 28, 28, 28
      ],
      quartile: [
        13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28,
        26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
        30, 30, 30, 30
      ],
      high: [
        17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28,
        26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
        30, 30, 30, 30
      ]
    },
    Tq = {
      low: [
        1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10,
        12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25
      ],
      medium: [
        1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17,
        17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47,
        49
      ],
      quartile: [
        1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23,
        23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65,
        68
      ],
      high: [
        1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25,
        25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74,
        77, 81
      ]
    },
    pn = {
      size: {encode: (t) => 21 + 4 * (t - 1), decode: (t) => (t - 17) / 4},
      sizeType: (t) => Math.floor((t + 7) / 17),
      alignmentPatterns(t) {
        if (t === 1) return [];
        const e = pn.size.encode(t) - 6 - 1,
          n = e - 6,
          r = Math.ceil(n / 28);
        let i = Math.floor(n / r);
        i % 2 ? (i += 1) : (n % r) * 2 >= r && (i += 2);
        const s = [6];
        for (let o = 1; o < r; o++) s.push(e - (r - o) * i);
        return (s.push(e), s);
      },
      ECCode: {low: 1, medium: 0, quartile: 3, high: 2},
      formatMask: 21522,
      formatBits(t, e) {
        const n = (pn.ECCode[t] << 3) | e;
        let r = n;
        for (let i = 0; i < 10; i++) r = (r << 1) ^ (1335 * (r >> 9));
        return ((n << 10) | r) ^ pn.formatMask;
      },
      versionBits(t) {
        let e = t;
        for (let n = 0; n < 12; n++) e = (e << 1) ^ (7973 * (e >> 11));
        return (t << 12) | e;
      },
      alphabet: {
        numeric: hE('0123456789'),
        alphanumerc: hE('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:')
      },
      lengthBits: (t, e) =>
        ({
          numeric: [10, 12, 14],
          alphanumeric: [9, 11, 13],
          byte: [8, 16, 16],
          kanji: [8, 10, 12],
          eci: [0, 0, 0]
        })[e][pn.sizeType(t)],
      modeBits: {
        numeric: '0001',
        alphanumeric: '0010',
        byte: '0100',
        kanji: '1000',
        eci: '0111'
      },
      capacity(t, e) {
        const n = xq[t - 1],
          r = Cq[e][t - 1],
          i = Tq[e][t - 1],
          s = Math.floor(n / i) - r,
          o = i - (n % i);
        return {
          words: r,
          numBlocks: i,
          shortBlocks: o,
          blockLen: s,
          capacity: 8 * (n - r * i),
          total: (r + s) * i + i - o
        };
      }
    },
    hy = [
      (t, e) => (t + e) % 2 == 0,
      (t, e) => e % 2 == 0,
      (t, e) => t % 3 == 0,
      (t, e) => (t + e) % 3 == 0,
      (t, e) => (Math.floor(e / 2) + Math.floor(t / 3)) % 2 == 0,
      (t, e) => ((t * e) % 2) + ((t * e) % 3) == 0,
      (t, e) => (((t * e) % 2) + ((t * e) % 3)) % 2 == 0,
      (t, e) => (((t + e) % 2) + ((t * e) % 3)) % 2 == 0
    ],
    Ae = {
      tables: ((t) => {
        const e = Jn(256, 0),
          n = Jn(256, 0);
        for (let r = 0, i = 1; r < 256; r++)
          ((e[r] = i), (n[i] = r), (i <<= 1), 256 & i && (i ^= 285));
        return {exp: e, log: n};
      })(),
      exp: (t) => Ae.tables.exp[t],
      log(t) {
        if (t === 0) throw new Error(`GF.log: wrong arg=${t}`);
        return Ae.tables.log[t] % 255;
      },
      mul: (t, e) =>
        t === 0 || e === 0
          ? 0
          : Ae.tables.exp[(Ae.tables.log[t] + Ae.tables.log[e]) % 255],
      add: (t, e) => t ^ e,
      pow: (t, e) => Ae.tables.exp[(Ae.tables.log[t] * e) % 255],
      inv(t) {
        if (t === 0) throw new Error(`GF.inverse: wrong arg=${t}`);
        return Ae.tables.exp[255 - Ae.tables.log[t]];
      },
      polynomial(t) {
        if (t.length == 0) throw new Error('GF.polymomial: wrong length');
        if (t[0] !== 0) return t;
        let e = 0;
        for (; e < t.length - 1 && t[e] == 0; e++);
        return t.slice(e);
      },
      monomial(t, e) {
        if (t < 0) throw new Error(`GF.monomial: wrong degree=${t}`);
        if (e == 0) return [0];
        let n = Jn(t + 1, 0);
        return ((n[0] = e), Ae.polynomial(n));
      },
      degree: (t) => t.length - 1,
      coefficient: (t, e) => t[Ae.degree(t) - e],
      mulPoly(t, e) {
        if (t[0] === 0 || e[0] === 0) return [0];
        const n = Jn(t.length + e.length - 1, 0);
        for (let r = 0; r < t.length; r++)
          for (let i = 0; i < e.length; i++)
            n[r + i] = Ae.add(n[r + i], Ae.mul(t[r], e[i]));
        return Ae.polynomial(n);
      },
      mulPolyScalar(t, e) {
        if (e == 0) return [0];
        if (e == 1) return t;
        const n = Jn(t.length, 0);
        for (let r = 0; r < t.length; r++) n[r] = Ae.mul(t[r], e);
        return Ae.polynomial(n);
      },
      mulPolyMonomial(t, e, n) {
        if (e < 0) throw new Error('GF.mulPolyMonomial: wrong degree');
        if (n == 0) return [0];
        const r = Jn(t.length + e, 0);
        for (let i = 0; i < t.length; i++) r[i] = Ae.mul(t[i], n);
        return Ae.polynomial(r);
      },
      addPoly(t, e) {
        if (t[0] === 0) return e;
        if (e[0] === 0) return t;
        let n = t,
          r = e;
        n.length > r.length && ([n, r] = [r, n]);
        let i = Jn(r.length, 0),
          s = r.length - n.length,
          o = r.slice(0, s);
        for (let a = 0; a < o.length; a++) i[a] = o[a];
        for (let a = s; a < r.length; a++) i[a] = Ae.add(n[a - s], r[a]);
        return Ae.polynomial(i);
      },
      remainderPoly(t, e) {
        const n = Array.from(t);
        for (let r = 0; r < t.length - e.length + 1; r++) {
          const i = n[r];
          if (i !== 0)
            for (let s = 1; s < e.length; s++)
              e[s] !== 0 && (n[r + s] = Ae.add(n[r + s], Ae.mul(e[s], i)));
        }
        return n.slice(t.length - e.length + 1, n.length);
      },
      divisorPoly(t) {
        let e = [1];
        for (let n = 0; n < t; n++) e = Ae.mulPoly(e, [1, Ae.pow(2, n)]);
        return e;
      },
      evalPoly(t, e) {
        if (e == 0) return Ae.coefficient(t, 0);
        let n = t[0];
        for (let r = 1; r < t.length; r++) n = Ae.add(Ae.mul(e, n), t[r]);
        return n;
      },
      euclidian(t, e, n) {
        Ae.degree(t) < Ae.degree(e) && ([t, e] = [e, t]);
        let r = t,
          i = e,
          s = [0],
          o = [1];
        for (; 2 * Ae.degree(i) >= n; ) {
          let l = r,
            u = s;
          if (((r = i), (s = o), r[0] === 0)) throw new Error('rLast[0] === 0');
          i = l;
          let d = [0];
          const f = Ae.inv(r[0]);
          for (; Ae.degree(i) >= Ae.degree(r) && i[0] !== 0; ) {
            const h = Ae.degree(i) - Ae.degree(r),
              g = Ae.mul(i[0], f);
            ((d = Ae.addPoly(d, Ae.monomial(h, g))),
              (i = Ae.addPoly(i, Ae.mulPolyMonomial(r, h, g))));
          }
          if (
            ((d = Ae.mulPoly(d, s)),
            (o = Ae.addPoly(d, u)),
            Ae.degree(i) >= Ae.degree(r))
          )
            throw new Error(`Division failed r: ${i}, rLast: ${r}`);
        }
        const a = Ae.coefficient(o, 0);
        if (a == 0) throw new Error('sigmaTilde(0) was zero');
        const c = Ae.inv(a);
        return [Ae.mulPolyScalar(o, c), Ae.mulPolyScalar(i, c)];
      }
    };
  function Iq(t, e) {
    const {
        words: n,
        shortBlocks: r,
        numBlocks: i,
        blockLen: s,
        total: o
      } = pn.capacity(t, e),
      a =
        ((c = n),
        {
          encode(l) {
            const u = Ae.divisorPoly(c),
              d = Array.from(l);
            return (
              d.push(...u.slice(0, -1).fill(0)),
              Uint8Array.from(Ae.remainderPoly(d, u))
            );
          },
          decode(l) {
            const u = l.slice(),
              d = Ae.polynomial(Array.from(l));
            let f = Jn(c, 0),
              h = !1;
            for (let v = 0; v < c; v++) {
              const x = Ae.evalPoly(d, Ae.exp(v));
              ((f[f.length - 1 - v] = x), x !== 0 && (h = !0));
            }
            if (!h) return u;
            f = Ae.polynomial(f);
            const g = Ae.monomial(c, 1),
              [m, y] = Ae.euclidian(g, f, c),
              p = Jn(Ae.degree(m), 0);
            let b = 0;
            for (let v = 1; v < 256 && b < p.length; v++)
              Ae.evalPoly(m, v) === 0 && (p[b++] = Ae.inv(v));
            if (b !== p.length)
              throw new Error('RS.decode: wrong errors number');
            for (let v = 0; v < p.length; v++) {
              const x = u.length - 1 - Ae.log(p[v]);
              if (x < 0) throw new Error('RS.decode: wrong error location');
              const C = Ae.inv(p[v]);
              let $ = 1;
              for (let G = 0; G < p.length; G++)
                v !== G && ($ = Ae.mul($, Ae.add(1, Ae.mul(p[G], C))));
              u[x] = Ae.add(u[x], Ae.mul(Ae.evalPoly(y, C), Ae.inv($)));
            }
            return u;
          }
        });
    var c;
    return {
      encode(l) {
        const u = [],
          d = [];
        for (let m = 0; m < i; m++) {
          const y = s + (m < r ? 0 : 1);
          (u.push(l.subarray(0, y)),
            d.push(a.encode(l.subarray(0, y))),
            (l = l.subarray(y)));
        }
        const f = dE(...u),
          h = dE(...d),
          g = new Uint8Array(f.length + h.length);
        return (g.set(f), g.set(h, f.length), g);
      },
      decode(l) {
        if (l.length !== o)
          throw new Error(
            `interleave.decode: len(data)=${l.length}, total=${o}`
          );
        const u = [];
        for (let h = 0; h < i; h++) {
          const g = h < r;
          u.push(new Uint8Array(n + s + (g ? 0 : 1)));
        }
        let d = 0;
        for (let h = 0; h < s; h++)
          for (let g = 0; g < i; g++) u[g][h] = l[d++];
        for (let h = r; h < i; h++) u[h][s] = l[d++];
        for (let h = s; h < s + n; h++)
          for (let g = 0; g < i; g++) {
            const m = g < r;
            u[g][h + (m ? 0 : 1)] = l[d++];
          }
        const f = [];
        for (const h of u) f.push(...Array.from(a.decode(h)).slice(0, -n));
        return Uint8Array.from(f);
      }
    };
  }
  function gE(t, e, n, r) {
    let i = '',
      s = n.length;
    if (r === 'numeric') {
      const d = pn.alphabet.numeric.decode(n.split('')),
        f = d.length;
      for (let h = 0; h < f - 2; h += 3)
        i += vo(100 * d[h] + 10 * d[h + 1] + d[h + 2], 10);
      f % 3 == 1
        ? (i += vo(d[f - 1], 4))
        : f % 3 == 2 && (i += vo(10 * d[f - 2] + d[f - 1], 7));
    } else if (r === 'alphanumeric') {
      const d = pn.alphabet.alphanumerc.decode(n.split('')),
        f = d.length;
      for (let h = 0; h < f - 1; h += 2) i += vo(45 * d[h] + d[h + 1], 11);
      f % 2 == 1 && (i += vo(d[f - 1], 6));
    } else {
      if (r !== 'byte') throw new Error('encode: unsupported type');
      {
        const d = (function (f) {
          if (typeof f != 'string')
            throw new Error('utf8ToBytes expected string, got ' + typeof f);
          return new Uint8Array(new TextEncoder().encode(f));
        })(n);
        ((s = d.length),
          (i = Array.from(d)
            .map((f) => vo(f, 8))
            .join('')));
      }
    }
    const {capacity: o} = pn.capacity(t, e),
      a = vo(s, pn.lengthBits(t, r));
    let c = pn.modeBits[r] + a + i;
    if (c.length > o) throw new Error('Capacity overflow');
    ((c += '0'.repeat(Math.min(4, Math.max(0, o - c.length)))),
      c.length % 8 && (c += '0'.repeat(8 - (c.length % 8))));
    const l = '1110110000010001';
    for (let d = 0; c.length !== o; d++) c += l[d % 16];
    const u = Uint8Array.from(c.match(/(.{8})/g).map((d) => +`0b${d}`));
    return Iq(t, e).encode(u);
  }
  function yE(t, e, n, r, i = !1) {
    const s = (function (c, l, u, d = !1) {
      const f = pn.size.encode(c);
      let h = new Yn(f + 2);
      const g = new Yn(3)
        .rect(0, 3, !0)
        .border(1, !1)
        .border(1, !0)
        .border(1, !1);
      ((h = h
        .embed(0, g)
        .embed({x: -g.width, y: 0}, g)
        .embed({x: 0, y: -g.height}, g)),
        (h = h.rectSlice(1, f)));
      const m = new Yn(1).rect(0, 1, !0).border(1, !1).border(1, !0),
        y = pn.alignmentPatterns(c);
      for (const p of y)
        for (const b of y)
          h.data[p][b] === void 0 && h.embed({x: b - 2, y: p - 2}, m);
      h = h
        .hLine({x: 0, y: 6}, 1 / 0, ({x: p}, b) =>
          b === void 0 ? p % 2 == 0 : b
        )
        .vLine({x: 6, y: 0}, 1 / 0, ({y: p}, b) =>
          b === void 0 ? p % 2 == 0 : b
        );
      {
        const p = pn.formatBits(l, u),
          b = (v) => !d && ((p >> v) & 1) == 1;
        for (let v = 0; v < 6; v++) h.data[v][8] = b(v);
        for (let v = 6; v < 8; v++) h.data[v + 1][8] = b(v);
        for (let v = 8; v < 15; v++) h.data[f - 15 + v][8] = b(v);
        for (let v = 0; v < 8; v++) h.data[8][f - v - 1] = b(v);
        for (let v = 8; v < 9; v++) h.data[8][15 - v - 1 + 1] = b(v);
        for (let v = 9; v < 15; v++) h.data[8][15 - v - 1] = b(v);
        h.data[f - 8][8] = !d;
      }
      if (c >= 7) {
        const p = pn.versionBits(c);
        for (let b = 0; b < 18; b += 1) {
          const v = !d && ((p >> b) & 1) == 1,
            x = Math.floor(b / 3),
            C = (b % 3) + f - 8 - 3;
          ((h.data[x][C] = v), (h.data[C][x] = v));
        }
      }
      return h;
    })(t, e, r, i);
    let o = 0;
    const a = 8 * n.length;
    if (
      ((function (c, l, u) {
        const d = c.height,
          f = hy[l];
        let h = -1,
          g = d - 1;
        for (let m = d - 1; m > 0; m -= 2) {
          for (m == 6 && (m = 5); ; g += h) {
            for (let y = 0; y < 2; y += 1) {
              const p = m - y;
              c.data[g][p] === void 0 && u(p, g, f(p, g));
            }
            if (g + h < 0 || g + h >= d) break;
          }
          h = -h;
        }
      })(s, r, (c, l, u) => {
        let d = !1;
        (o < a && ((d = ((n[o >>> 3] >> ((7 - o) & 7)) & 1) != 0), o++),
          (s.data[l][c] = d !== u));
      }),
      o !== a)
    )
      throw new Error('QR: bytes left after draw');
    return s;
  }
  function kq(t) {
    const e = t.inverse(),
      n = (h) => {
        let g = 0;
        for (let m, y = 0, p = 1; y < h.length; y++)
          (m === h[y] && (p++, y !== h.length - 1)) ||
            (p >= 5 && (g += p - 5 + 3), (m = h[y]), (p = 1));
        return g;
      };
    let r = 0;
    (t.data.forEach((h) => (r += n(h))), e.data.forEach((h) => (r += n(h))));
    let i = 0,
      s = t.data;
    const o = t.width - 1,
      a = t.height - 1;
    for (let h = 0; h < o; h++)
      for (let g = 0; g < a; g++) {
        const m = h + 1,
          y = g + 1;
        s[h][g] === s[m][g] &&
          s[m][g] === s[h][y] &&
          s[m][g] === s[m][y] &&
          (i += 3);
      }
    const c = (h) => {
      const g = [!0, !1, !0, !0, !0, !1, !0],
        m = [!1, !1, !1, !1],
        y = [...g, ...m],
        p = [...m, ...g];
      let b = 0;
      for (let v = 0; v < h.length; v++)
        (fE(h, y, v) && (b += 40), fE(h, p, v) && (b += 40));
      return b;
    };
    let l = 0;
    for (const h of t.data) l += c(h);
    for (const h of e.data) l += c(h);
    let u = 0;
    t.rectRead(0, 1 / 0, (h, g) => (u += g ? 1 : 0));
    const d = (u / (t.height * t.width)) * 100,
      f = 10 * Math.floor(Math.abs(d - 50) / 5);
    return r + i + l + f;
  }
  function JT(t, e = 'raw', n = {}) {
    const r = n.ecc !== void 0 ? n.ecc : 'medium';
    (function (u) {
      if (!pE.includes(u))
        throw new Error(`Invalid error correction mode=${u}. Expected: ${pE}`);
    })(r);
    const i =
      n.encoding !== void 0
        ? n.encoding
        : (function (u) {
            let d = 'numeric';
            for (let f of u)
              if (
                !pn.alphabet.numeric.has(f) &&
                ((d = 'alphanumeric'), !pn.alphabet.alphanumerc.has(f))
              )
                return 'byte';
            return d;
          })(t);
    ((function (u) {
      if (!mE.includes(u))
        throw new Error(`Encoding: invalid mode=${u}. Expected: ${mE}`);
      if (u === 'kanji' || u === 'eci')
        throw new Error(`Encoding: ${u} is not supported (yet?).`);
    })(i),
      n.mask !== void 0 &&
        (function (u) {
          if (![0, 1, 2, 3, 4, 5, 6, 7].includes(u) || !hy[u])
            throw new Error(`Invalid mask=${u}. Expected number [0..7]`);
        })(n.mask));
    let s,
      o = n.version,
      a = new Error('Unknown error');
    if (o !== void 0)
      ((function (u) {
        if (!Number.isSafeInteger(u) || u < 1 || u > 40)
          throw new Error(`Invalid version=${u}. Expected number [1..40]`);
      })(o),
        (s = gE(o, r, t, i)));
    else
      for (let u = 1; u <= 40; u++)
        try {
          ((s = gE(u, r, t, i)), (o = u));
          break;
        } catch (d) {
          a = d;
        }
    if (!o || !s) throw a;
    let c = (function (u, d, f, h) {
      if (h === void 0) {
        const g = (function () {
          let m,
            y = 1 / 0;
          return {
            add(p, b) {
              p >= y || ((m = b), (y = p));
            },
            get: () => m,
            score: () => y
          };
        })();
        for (let m = 0; m < hy.length; m++) g.add(kq(yE(u, d, f, m, !0)), m);
        h = g.get();
      }
      if (h === void 0) throw new Error('Cannot find mask');
      return yE(u, d, f, h);
    })(o, r, s, n.mask);
    c.assertDrawn();
    const l = n.border === void 0 ? 2 : n.border;
    if (!Number.isSafeInteger(l))
      throw new Error('Wrong border type=' + typeof l);
    if (
      ((c = c.border(l, !1)),
      n.scale !== void 0 && (c = c.scale(n.scale)),
      e === 'raw')
    )
      return c.data;
    if (e === 'ascii') return c.toASCII();
    if (e === 'svg') return c.toSVG();
    if (e === 'gif') return c.toGIF();
    if (e === 'term') return c.toTerm();
    throw new Error(`Unknown output: ${e}`);
  }
  const C0 = {
    DESKTOP: 'Desktop',
    MOBILE: 'Mobile',
    META_MASK_MOBILE_APP: 'MetaMask mobile app',
    SCAN_TO_CONNECT: 'Scan to connect and sign with',
    CONNECT_WITH_EXTENSION: 'Connect With MetaMask Extension',
    INSTALL_MODAL: {
      TRUSTED_BY_USERS:
        'Trusted by over 30 million users to buy, store, send and swap crypto securely',
      LEADING_CRYPTO_WALLET:
        'The leading crypto wallet & gateway to blockchain apps built on Ethereum Mainnet, Polygon, Optimism, and many other networks',
      CONTROL_DIGITAL_INTERACTIONS:
        'Puts you in control of your digital interactions by making power of cryptography more accessible',
      INSTALL_META_MASK_EXTENSION: 'Install MetaMask Extension'
    },
    PENDING_MODAL: {
      OPEN_META_MASK_SELECT_CODE:
        'Please open the MetaMask wallet app and select the code on the screen OR disconnect',
      OPEN_META_MASK_CONTINUE:
        'Open the MetaMask app to continue with your session.',
      NUMBER_AFTER_OPEN_NOTICE:
        "If a number doesn't appear after opening MetaMask, please click disconnect and re-scan the QRCode.",
      DISCONNECT: 'Disconnect'
    },
    SELECT_MODAL: {
      CRYPTO_TAKE_CONTROL_TEXT:
        'Take control of your crypto and explore the blockchain with the wallet trusted by over 30 million people worldwide'
    },
    META_MASK_MODAL: {
      ADDRESS_COPIED: 'Address copied to clipboard!',
      DISCONNECT: 'Disconnect',
      ACTIVE_NETWORK: 'Active Network'
    }
  };
  class k1 {
    constructor(e) {
      var n;
      ((this.translations = C0),
        (this.supportedLocales = ['es', 'fr', 'he', 'it', 'pt', 'tr']),
        (this.baseUrl =
          (n = e == null ? void 0 : e.baseUrl) !== null && n !== void 0
            ? n
            : 'https://raw.githubusercontent.com/MetaMask/metamask-sdk/refs/heads/gh-pages/locales'));
    }
    getBrowserLanguage() {
      if (
        (navigator.languages || [navigator.language]).some((n) =>
          n.toLowerCase().startsWith('en')
        )
      )
        return 'en';
      const e = navigator.language.toLowerCase().split('-')[0];
      return this.supportedLocales.includes(e) ? e : 'en';
    }
    async init(e) {
      const n = this.getBrowserLanguage() || e.fallbackLng;
      await this.loadTranslations(n);
    }
    async loadTranslations(e) {
      const n = e.split('-')[0];
      if (n !== 'en' && this.supportedLocales.includes(n))
        try {
          const r = `${this.baseUrl}/${n}.json`,
            i = await fetch(r);
          if (!i.ok) throw new Error(`HTTP error! status: ${i.status}`);
          this.translations = await i.json();
        } catch (r) {
          (console.warn(
            `❌ Failed to load ${n} translations, falling back to English:`,
            r
          ),
            (this.translations = C0));
        }
      else this.translations = C0;
    }
    t(e) {
      return this.getNestedTranslation(e, this.translations) || e;
    }
    getNestedTranslation(e, n) {
      const r = e.split('.');
      let i = n;
      for (const s of r) {
        if (typeof i != 'object') return '';
        i = i[s];
      }
      return typeof i == 'string' ? i : '';
    }
  }
  var Rl;
  (function (t) {
    ((t.SDK_MODAL_VIEWED = 'sdk_modal_viewed'),
      (t.SDK_MODAL_BUTTON_CLICKED = 'sdk_modal_button_clicked'),
      (t.SDK_MODAL_TOGGLE_CHANGED = 'sdk_modal_toggle_changed'));
  })(Rl || (Rl = {}));
  const XT = class {
    constructor(t) {
      (v1(this, t),
        (this.close = Zs(this, 'close')),
        (this.startDesktopOnboarding = Zs(this, 'startDesktopOnboarding')),
        (this.trackAnalytics = Zs(this, 'trackAnalytics')),
        (this.link = void 0),
        (this.sdkVersion = void 0),
        (this.preferDesktop = void 0),
        (this.tab = 1),
        (this.isDefaultTab = !0),
        (this.translationsLoaded = !1),
        (this.onClose = this.onClose.bind(this)),
        (this.onStartDesktopOnboardingHandler =
          this.onStartDesktopOnboardingHandler.bind(this)),
        (this.setTab = this.setTab.bind(this)),
        (this.render = this.render.bind(this)),
        this.setTab(this.preferDesktop ? 1 : 2),
        (this.i18nInstance = new k1()));
    }
    componentDidLoad() {
      this.trackAnalytics.emit({
        event: Rl.SDK_MODAL_VIEWED,
        params: {
          extensionInstalled: !1,
          tab: this.tab === 1 ? 'desktop' : 'mobile'
        }
      });
    }
    async connectedCallback() {
      (await this.i18nInstance.init({fallbackLng: 'en'}),
        (this.translationsLoaded = !0));
    }
    updatePreferDesktop(t) {
      t ? this.setTab(1) : this.setTab(2);
    }
    onClose(t = !1) {
      this.close.emit({shouldTerminate: t});
    }
    onStartDesktopOnboardingHandler() {
      (this.trackAnalytics.emit({
        event: Rl.SDK_MODAL_BUTTON_CLICKED,
        params: {button_type: 'install_extension', tab: 'desktop'}
      }),
        this.startDesktopOnboarding.emit());
    }
    setTab(t, e = !1) {
      (e &&
        this.trackAnalytics.emit({
          event: Rl.SDK_MODAL_TOGGLE_CHANGED,
          params: {
            toggle: this.tab === 1 ? 'desktop_to_mobile' : 'mobile_to_desktop'
          }
        }),
        (this.tab = t),
        (this.isDefaultTab = !1));
    }
    render() {
      if (!this.translationsLoaded) return null;
      const t = (r) => this.i18nInstance.t(r),
        e = this.isDefaultTab ? (this.preferDesktop ? 1 : 2) : this.tab,
        n = JT(this.link, 'svg', {ecc: 'medium', scale: 2});
      return ae(
        x1,
        {className: 'install-model'},
        ae('div', {class: 'backdrop', onClick: () => this.onClose(!0)}),
        ae(
          'div',
          {class: 'modal'},
          ae(
            'div',
            {class: 'closeButtonContainer'},
            ae(
              'div',
              {class: 'right'},
              ae(
                'span',
                {class: 'closeButton', onClick: () => this.onClose(!0)},
                ae(T1, null)
              )
            )
          ),
          ae('div', {class: 'logoContainer'}, ae(I1, null)),
          ae(
            'div',
            null,
            ae(
              'div',
              {class: 'tabcontainer'},
              ae(
                'div',
                {class: 'flexContainer'},
                ae(
                  'div',
                  {
                    onClick: () => this.setTab(1, !0),
                    class: 'tab flexItem ' + (e === 1 ? 'tabactive' : '')
                  },
                  t('DESKTOP')
                ),
                ae(
                  'div',
                  {
                    onClick: () => this.setTab(2, !0),
                    class: 'tab flexItem ' + (e === 2 ? 'tabactive' : '')
                  },
                  t('MOBILE')
                )
              )
            ),
            ae(
              'div',
              {style: {display: e === 1 ? 'none' : 'block'}},
              ae(
                'div',
                {class: 'flexContainer'},
                ae(
                  'div',
                  {
                    class: 'flexItem',
                    style: {textAlign: 'center', marginTop: '4'}
                  },
                  n &&
                    ae('div', {
                      id: 'sdk-mm-qrcode',
                      class: 'center',
                      innerHTML: n
                    }),
                  ae(
                    'div',
                    {class: 'connectMobileText'},
                    t('SCAN_TO_CONNECT'),
                    ' ',
                    ae('br', null),
                    ae(
                      'span',
                      {class: 'blue'},
                      ae('b', null, t('META_MASK_MOBILE_APP'))
                    )
                  )
                )
              )
            ),
            ae(
              'div',
              {style: {display: e === 2 ? 'none' : 'block'}},
              ae(
                'div',
                {class: 'item'},
                ae(x0, {Icon: Eq, text: t('INSTALL_MODAL.TRUSTED_BY_USERS')})
              ),
              ae(
                'div',
                {class: 'item'},
                ae(x0, {
                  Icon: _q,
                  text: t('INSTALL_MODAL.LEADING_CRYPTO_WALLET')
                })
              ),
              ae(
                'div',
                {class: 'item'},
                ae(x0, {
                  Icon: Aq,
                  text: t('INSTALL_MODAL.CONTROL_DIGITAL_INTERACTIONS')
                })
              ),
              ae(
                'button',
                {
                  class: 'button',
                  onClick: () => this.onStartDesktopOnboardingHandler()
                },
                ae(Sq, null),
                ae(
                  'span',
                  {class: 'installExtensionText'},
                  t('INSTALL_MODAL.INSTALL_META_MASK_EXTENSION')
                )
              )
            )
          ),
          ae(C1, {version: this.sdkVersion})
        )
      );
    }
    get el() {
      return Zp(this);
    }
    static get watchers() {
      return {preferDesktop: ['updatePreferDesktop']};
    }
  };
  XT.style = `.flexContainer {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: row;
}

.flexItem {
    flex: 1;
    justify-content: center;
    align-items: center;
}

.flexItem11 {
    flex: 11;
    justify-content: center;
    align-items: center;
}

.flexItem1 {
    flex: 1;
    justify-content: center;
    align-items: center;
}

.tab {
    padding: 8px;
    cursor: pointer;
    background-color: #F2F4F6;
    font-size: 12px;
    text-align: center;
    color: #24292E;
}

.tabcontainer {
    padding: 4px;
    background-color: #F2F4F6;
    border-radius: 8px;
    margin-bottom: 30px;
    margin-top: 30px;
}

.tabactive {
    background-color: white;
    -webkit-transition: background-color 300ms linear;
    -ms-transition: background-color 300ms linear;
    transition: background-color 300ms linear;
    border-radius: 8px;
}

.item {
    font-size: 12px;
    margin-bottom: 16px;
    border-radius: 8px;
    padding: 10px;
    border: 2px #F2F4F6 solid;
    color: #24292E;
}

.extensionLabel {
    font-style: normal;
    font-weight: bold;
    font-size: 14px;
    text-align: cetner;
    color: #24272A;
}

.notice {
    font-size: 12px;
    margin-left: 10px;
    margin-right: 10px;
    color: grey;
}

.button {
    margin-top: 41.5px;
    margin-bottom: 20px;
    width: 100%;
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
    padding: 12px 20px;
    background: #037DD6;
    border-radius: 32px;
    color: white;
    border: 0;
    font-size: 14px;
    cursor: pointer;
}

.backdrop {
    visibility: visible;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    z-index: 99998;
    background: rgba(0, 0, 0, 0.87);
    opacity: 0.3;
}

.modal {
    visibility: visible;
    position: fixed;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 99999;
    background: white;
    padding: 20px;
    border-radius: 8px;
    top: 50%;
    max-width: 100%;
    width: 460px;
    min-width: 300px;
    box-shadow: rgba(0, 0, 0, 0.2) 0px 11px 15px -7px, rgba(0, 0, 0, 0.14) 0px 24px 38px 3px, rgba(0, 0, 0, 0.12) 0px 9px 46px 8px;
    -webkit-font-smoothing: antialiased;
}

.closeButton {
    color: #BBC0C5;
    cursor: pointer;
}

.logoContainer {
    margin-left: 24px;
    margin-right: 24px;
    margin-top: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.connectMobileText {
    font-size: 14px;
    color: black;
    margin-top: 28px;
    margin-bottom: 28px;
    line-height: 2;
}

.blue {
    color: #037DD6;
    font-weight: 700;
}

.installExtensionText {
    margin-left: 10px;
}

.center {
    display: flex;
    justify-content: center;
    align-items: center;
}

.right {
    display: flex;
    align-items: center;
    justify-content: right;
}

#sdk-mm-qrcode {
    svg {
        width: 50%;
    }
}`;
  const e6 = class {
    constructor(t) {
      (v1(this, t),
        (this.close = Zs(this, 'close')),
        (this.disconnect = Zs(this, 'disconnect')),
        (this.updateOTPValue = Zs(this, 'updateOTPValue')),
        (this.displayOTP = void 0),
        (this.sdkVersion = void 0),
        (this.otpCode = void 0),
        (this.translationsLoaded = !1),
        (this.i18nInstance = new k1()));
    }
    async connectedCallback() {
      (await this.i18nInstance.init({fallbackLng: 'en'}),
        (this.translationsLoaded = !0));
    }
    onClose() {
      this.close.emit();
    }
    onDisconnect() {
      this.disconnect.emit();
    }
    onUpdateOTPValueHandler(t) {
      this.updateOTPValue.emit({otpValue: t});
    }
    disconnectedCallback() {
      this.onClose();
    }
    render() {
      var t;
      if (!this.translationsLoaded) return null;
      const e = (t = this.displayOTP) === null || t === void 0 || t,
        n = this.sdkVersion,
        r = (i) => this.i18nInstance.t(i);
      return ae(
        x1,
        {className: 'pending-modal'},
        ae('div', {class: 'backdrop', onClick: () => this.onClose()}),
        ae(
          'div',
          {class: 'modal'},
          ae(
            'div',
            {class: 'closeButtonContainer'},
            ae(
              'div',
              {class: 'right'},
              ae(
                'span',
                {class: 'closeButton', onClick: () => this.onClose()},
                ae(T1, null)
              )
            )
          ),
          ae('div', {class: 'logoContainer'}, ae(I1, null)),
          ae(
            'div',
            null,
            ae(
              'div',
              {
                class: 'flexContainer',
                style: {flexDirection: 'column', color: 'black'}
              },
              ae(
                'div',
                {
                  class: 'flexItem',
                  style: {
                    textAlign: 'center',
                    marginTop: '30px',
                    marginBottom: '30px',
                    fontSize: '16px'
                  }
                },
                r(
                  e
                    ? 'PENDING_MODAL.OPEN_META_MASK_SELECT_CODE'
                    : 'PENDING_MODAL.OPEN_META_MASK_CONTINUE'
                )
              ),
              ae(
                'div',
                {
                  id: 'sdk-mm-otp-value',
                  style: {
                    padding: '10px',
                    fontSize: '32px',
                    display: this.otpCode ? 'block' : 'none'
                  }
                },
                this.otpCode
              ),
              e &&
                ae(
                  'div',
                  {class: 'notice'},
                  '* ',
                  r('PENDING_MODAL.NUMBER_AFTER_OPEN_NOTICE')
                )
            ),
            ae(
              'div',
              {style: {marginTop: '20px'}},
              ae(
                'button',
                {
                  class: 'button blue',
                  style: {
                    marginTop: '5px',
                    color: '#0376C9',
                    borderColor: '#0376C9',
                    borderWidth: '1px',
                    borderStyle: 'solid',
                    backgroundColor: 'white'
                  },
                  onClick: () => this.onDisconnect()
                },
                r('PENDING_MODAL.DISCONNECT')
              )
            )
          ),
          ae(C1, {version: n})
        )
      );
    }
    get el() {
      return Zp(this);
    }
  };
  e6.style = `.flexContainer {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: row;
}

.flexItem {
    flex: 1;
    justify-content: center;
    align-items: center;
}

.flexItem11 {
    flex: 11;
    justify-content: center;
    align-items: center;
}

.flexItem1 {
    flex: 1;
    justify-content: center;
    align-items: center;
}

.tab {
    padding: 8px;
    cursor: pointer;
    background-color: #F2F4F6;
    font-size: 12px;
    text-align: center;
    color: #24292E;
}

.tabcontainer {
    padding: 4px;
    background-color: #F2F4F6;
    border-radius: 8px;
    margin-bottom: 30px;
    margin-top: 30px;
}

.tabactive {
    background-color: white;
    -webkit-transition: background-color 300ms linear;
    -ms-transition: background-color 300ms linear;
    transition: background-color 300ms linear;
    border-radius: 8px;
}

.item {
    font-size: 12px;
    margin-bottom: 16px;
    border-radius: 8px;
    padding: 10px;
    border: 2px #F2F4F6 solid;
    color: #24292E;
}

.extensionLabel {
    font-style: normal;
    font-weight: bold;
    font-size: 14px;
    text-align: cetner;
    color: #24272A;
}

.notice {
    font-size: 12px;
    margin-left: 10px;
    margin-right: 10px;
    color: grey;
}

.button {
    margin-top: 41.5px;
    margin-bottom: 20px;
    width: 100%;
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
    padding: 12px 20px;
    background: #037DD6;
    border-radius: 32px;
    color: white;
    border: 0;
    font-size: 14px;
    cursor: pointer;
}

.backdrop {
    visibility: visible;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    z-index: 99998;
    background: rgba(0, 0, 0, 0.87);
    opacity: 0.3;
}

.modal {
    visibility: visible;
    position: fixed;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 99999;
    background: white;
    padding: 20px;
    border-radius: 8px;
    top: 50%;
    max-width: 100%;
    width: 460px;
    min-width: 300px;
    box-shadow: rgba(0, 0, 0, 0.2) 0px 11px 15px -7px, rgba(0, 0, 0, 0.14) 0px 24px 38px 3px, rgba(0, 0, 0, 0.12) 0px 9px 46px 8px;
    -webkit-font-smoothing: antialiased;
}

.closeButton {
    color: #BBC0C5;
    cursor: pointer;
}

.logoContainer {
    margin-left: 24px;
    margin-right: 24px;
    margin-top: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.connectMobileText {
    font-size: 14px;
    color: black;
    margin-top: 28px;
    margin-bottom: 28px;
    line-height: 2;
}

.blue {
    color: #037DD6;
    font-weight: 700;
}

.installExtensionText {
    margin-left: 10px;
}

.center {
    display: flex;
    justify-content: center;
    align-items: center;
}

.right {
    display: flex;
    align-items: center;
    justify-content: right;
}

#sdk-mm-qrcode {
    svg {
        width: 50%;
    }
}`;
  const Rq = () =>
      ae(
        'svg',
        {
          width: '21',
          height: '15',
          viewBox: '0 0 21 15',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg'
        },
        ae('path', {
          d: 'M14.1364 14.9851C13.5909 14.9851 13.2273 14.5851 13.2273 13.9851C13.2273 13.3851 13.5909 12.9851 14.1364 12.9851C16.6818 12.9851 18.6818 10.7851 18.6818 7.98508C18.6818 5.18508 16.6818 2.98508 14.1364 2.98508C11.5909 2.98508 9.59091 5.18508 9.59091 7.98508C9.59091 8.58508 9.22727 8.98508 8.68182 8.98508C8.13636 8.98508 7.77273 8.58508 7.77273 7.98508C7.77273 4.08508 10.5909 0.985077 14.1364 0.985077C17.6818 0.985077 20.5 4.08508 20.5 7.98508C20.5 11.8851 17.6818 14.9851 14.1364 14.9851ZM6.68182 14.7851C3.22727 14.7851 0.5 11.6851 0.5 7.98508C0.5 4.28508 3.22727 1.18508 6.68182 1.18508C7.22727 1.18508 7.59091 1.58508 7.59091 2.18508C7.59091 2.78508 7.22727 3.18508 6.68182 3.18508C4.22727 3.18508 2.31818 5.38508 2.31818 7.98508C2.31818 10.5851 4.22727 12.7851 6.68182 12.7851C9.13636 12.7851 11.0455 10.6851 11.0455 7.98508C11.0455 7.38508 11.4091 6.98508 11.9545 6.98508C12.5 6.98508 12.8636 7.38508 12.8636 7.98508C12.7727 11.6851 10.0455 14.7851 6.68182 14.7851Z',
          fill: 'white'
        })
      ),
    Pq = () =>
      ae(
        'svg',
        {
          width: '400',
          height: '300',
          viewBox: '0 0 400 300',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg'
        },
        ae('rect', {width: '400', height: '300', fill: 'white'}),
        ae('path', {
          d: 'M300.116 242.46L250.485 227.681L213.057 250.055L186.944 250.045L149.493 227.681L99.8843 242.46L84.7939 191.518L99.8843 134.979L84.7939 87.1777L99.8843 27.9336L177.402 74.2466H222.598L300.116 27.9336L315.206 87.1777L300.116 134.979L315.206 191.518L300.116 242.46Z',
          fill: '#FF5C16'
        }),
        ae('path', {
          d: 'M99.8955 27.9336L177.414 74.2792L174.331 106.085L99.8955 27.9336Z',
          fill: '#FF5C16'
        }),
        ae('path', {
          d: 'M149.505 191.539L183.612 217.521L149.505 227.681V191.539Z',
          fill: '#FF5C16'
        }),
        ae('path', {
          d: 'M180.886 148.585L174.33 106.107L132.369 134.991L132.348 134.98V135.001L132.477 164.732L149.493 148.585H149.504H180.886Z',
          fill: '#FF5C16'
        }),
        ae('path', {
          d: 'M300.116 27.9336L222.598 74.2792L225.67 106.085L300.116 27.9336Z',
          fill: '#FF5C16'
        }),
        ae('path', {
          d: 'M250.508 191.539L216.4 217.521L250.508 227.681V191.539Z',
          fill: '#FF5C16'
        }),
        ae('path', {
          d: 'M267.652 135.001H267.663H267.652V134.98L267.641 134.991L225.68 106.107L219.125 148.585H250.507L267.533 164.732L267.652 135.001Z',
          fill: '#FF5C16'
        }),
        ae('path', {
          d: 'M149.493 227.681L99.8843 242.46L84.7939 191.54H149.493V227.681Z',
          fill: '#E34807'
        }),
        ae('path', {
          d: 'M180.875 148.574L190.351 209.98L177.219 175.838L132.456 164.732L149.483 148.574H180.864H180.875Z',
          fill: '#E34807'
        }),
        ae('path', {
          d: 'M250.507 227.681L300.116 242.46L315.206 191.54H250.507V227.681Z',
          fill: '#E34807'
        }),
        ae('path', {
          d: 'M219.126 148.574L209.649 209.98L222.782 175.838L267.545 164.732L250.507 148.574H219.126Z',
          fill: '#E34807'
        }),
        ae('path', {
          d: 'M84.7939 191.517L99.8843 134.979H132.337L132.456 164.721L177.219 175.826L190.351 209.969L183.601 217.488L149.493 191.506H84.7939V191.517Z',
          fill: '#FF8D5D'
        }),
        ae('path', {
          d: 'M315.206 191.517L300.116 134.979H267.664L267.545 164.721L222.782 175.826L209.649 209.969L216.4 217.488L250.507 191.506H315.206V191.517Z',
          fill: '#FF8D5D'
        }),
        ae('path', {
          d: 'M222.598 74.2466H200H177.402L174.33 106.053L190.351 209.936H209.649L225.681 106.053L222.598 74.2466Z',
          fill: '#FF8D5D'
        }),
        ae('path', {
          d: 'M99.8843 27.9336L84.7939 87.1777L99.8843 134.979H132.337L174.319 106.085L99.8843 27.9336Z',
          fill: '#661800'
        }),
        ae('path', {
          d: 'M171.496 160.906H156.795L148.79 168.752L177.229 175.804L171.496 160.896V160.906Z',
          fill: '#661800'
        }),
        ae('path', {
          d: 'M300.116 27.9336L315.206 87.1777L300.116 134.979H267.663L225.681 106.085L300.116 27.9336Z',
          fill: '#661800'
        }),
        ae('path', {
          d: 'M228.525 160.906H243.248L251.253 168.763L222.781 175.826L228.525 160.896V160.906Z',
          fill: '#661800'
        }),
        ae('path', {
          d: 'M213.046 229.789L216.399 217.51L209.649 209.991H190.34L183.59 217.51L186.943 229.789',
          fill: '#661800'
        }),
        ae('path', {
          d: 'M213.047 229.789V250.066H186.944V229.789H213.047Z',
          fill: '#C0C4CD'
        }),
        ae('path', {
          d: 'M149.504 227.66L186.965 250.056V229.779L183.611 217.5L149.504 227.66Z',
          fill: '#E7EBF6'
        }),
        ae('path', {
          d: 'M250.506 227.66L213.045 250.056V229.779L216.398 217.5L250.506 227.66Z',
          fill: '#E7EBF6'
        })
      ),
    t6 = class {
      constructor(t) {
        (v1(this, t),
          (this.close = Zs(this, 'close')),
          (this.connectWithExtension = Zs(this, 'connectWithExtension')),
          (this.link = void 0),
          (this.sdkVersion = void 0),
          (this.preferDesktop = void 0),
          (this.tab = 1),
          (this.isDefaultTab = !0),
          (this.translationsLoaded = !1),
          (this.i18nInstance = new k1()),
          this.setTab(this.preferDesktop ? 1 : 2));
      }
      async connectedCallback() {
        (await this.i18nInstance.init({fallbackLng: 'en'}),
          (this.translationsLoaded = !0));
      }
      onClose(t = !1) {
        this.close.emit({shouldTerminate: t});
      }
      connectWithExtensionHandler() {
        this.connectWithExtension.emit();
      }
      setTab(t) {
        ((this.tab = t), (this.isDefaultTab = !1));
      }
      disconnectedCallback() {
        this.onClose();
      }
      updatePreferDesktop(t) {
        t ? this.setTab(1) : this.setTab(2);
      }
      render() {
        if (!this.translationsLoaded) return null;
        const t = (i) => this.i18nInstance.t(i),
          e = this.sdkVersion,
          n = this.isDefaultTab ? (this.preferDesktop ? 1 : 2) : this.tab,
          r = JT(this.link, 'svg', {ecc: 'medium', scale: 2});
        return ae(
          x1,
          {className: 'select-modal'},
          ae('div', {class: 'backdrop', onClick: () => this.onClose(!0)}),
          ae(
            'div',
            {class: 'modal'},
            ae(
              'div',
              {class: 'closeButtonContainer'},
              ae(
                'div',
                {class: 'right'},
                ae(
                  'span',
                  {class: 'closeButton', onClick: () => this.onClose(!0)},
                  ae(T1, null)
                )
              )
            ),
            ae('div', {class: 'logoContainer'}, ae(I1, null)),
            ae(
              'div',
              null,
              ae(
                'div',
                {class: 'tabcontainer'},
                ae(
                  'div',
                  {class: 'flexContainer'},
                  ae(
                    'div',
                    {
                      onClick: () => this.setTab(1),
                      class: 'tab flexItem ' + (n === 1 ? 'tabactive' : '')
                    },
                    t('DESKTOP')
                  ),
                  ae(
                    'div',
                    {
                      onClick: () => this.setTab(2),
                      class: 'tab flexItem ' + (n === 2 ? 'tabactive' : '')
                    },
                    t('MOBILE')
                  )
                )
              ),
              ae(
                'div',
                {style: {display: n === 1 ? 'none' : 'block'}},
                ae(
                  'div',
                  {class: 'flexContainer'},
                  ae(
                    'div',
                    {
                      class: 'flexItem',
                      style: {textAlign: 'center', marginTop: '4'}
                    },
                    ae('div', {
                      class: 'center',
                      id: 'sdk-mm-qrcode',
                      innerHTML: r
                    }),
                    ae(
                      'div',
                      {class: 'connectMobileText'},
                      t('SCAN_TO_CONNECT'),
                      ae('br', null),
                      ae(
                        'span',
                        {class: 'blue'},
                        ae('b', null, t('META_MASK_MOBILE_APP'))
                      )
                    )
                  )
                )
              ),
              ae(
                'div',
                {style: {display: n === 2 ? 'none' : 'block'}},
                ae(
                  'div',
                  {
                    style: {
                      display: 'flex',
                      justifyContent: 'center',
                      height: '300',
                      marginTop: '-20'
                    }
                  },
                  ae(Pq, null)
                ),
                ae(
                  'div',
                  {class: 'extensionLabel'},
                  t('SELECT_MODAL.CRYPTO_TAKE_CONTROL_TEXT')
                ),
                ae(
                  'button',
                  {
                    class: 'button',
                    onClick: () => this.connectWithExtensionHandler()
                  },
                  ae(Rq, null),
                  ae(
                    'span',
                    {class: 'installExtensionText'},
                    t('CONNECT_WITH_EXTENSION')
                  )
                )
              )
            ),
            ae(C1, {version: e})
          )
        );
      }
      get el() {
        return Zp(this);
      }
      static get watchers() {
        return {preferDesktop: ['updatePreferDesktop']};
      }
    };
  t6.style = `.flexContainer {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: row;
}

.flexItem {
    flex: 1;
    justify-content: center;
    align-items: center;
}

.flexItem11 {
    flex: 11;
    justify-content: center;
    align-items: center;
}

.flexItem1 {
    flex: 1;
    justify-content: center;
    align-items: center;
}

.tab {
    padding: 8px;
    cursor: pointer;
    background-color: #F2F4F6;
    font-size: 12px;
    text-align: center;
    color: #24292E;
}

.tabcontainer {
    padding: 4px;
    background-color: #F2F4F6;
    border-radius: 8px;
    margin-bottom: 30px;
    margin-top: 30px;
}

.tabactive {
    background-color: white;
    -webkit-transition: background-color 300ms linear;
    -ms-transition: background-color 300ms linear;
    transition: background-color 300ms linear;
    border-radius: 8px;
}

.item {
    font-size: 12px;
    margin-bottom: 16px;
    border-radius: 8px;
    padding: 10px;
    border: 2px #F2F4F6 solid;
    color: #24292E;
}

.extensionLabel {
    font-style: normal;
    font-weight: bold;
    font-size: 14px;
    text-align: cetner;
    color: #24272A;
}

.notice {
    font-size: 12px;
    margin-left: 10px;
    margin-right: 10px;
    color: grey;
}

.button {
    margin-top: 41.5px;
    margin-bottom: 20px;
    width: 100%;
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
    padding: 12px 20px;
    background: #037DD6;
    border-radius: 32px;
    color: white;
    border: 0;
    font-size: 14px;
    cursor: pointer;
}

.backdrop {
    visibility: visible;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    z-index: 99998;
    background: rgba(0, 0, 0, 0.87);
    opacity: 0.3;
}

.modal {
    visibility: visible;
    position: fixed;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 99999;
    background: white;
    padding: 20px;
    border-radius: 8px;
    top: 50%;
    max-width: 100%;
    width: 460px;
    min-width: 300px;
    box-shadow: rgba(0, 0, 0, 0.2) 0px 11px 15px -7px, rgba(0, 0, 0, 0.14) 0px 24px 38px 3px, rgba(0, 0, 0, 0.12) 0px 9px 46px 8px;
    -webkit-font-smoothing: antialiased;
}

.closeButton {
    color: #BBC0C5;
    cursor: pointer;
}

.logoContainer {
    margin-left: 24px;
    margin-right: 24px;
    margin-top: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.connectMobileText {
    font-size: 14px;
    color: black;
    margin-top: 28px;
    margin-bottom: 28px;
    line-height: 2;
}

.blue {
    color: #037DD6;
    font-weight: 700;
}

.installExtensionText {
    margin-left: 10px;
}

.center {
    display: flex;
    justify-content: center;
    align-items: center;
}

.right {
    display: flex;
    align-items: center;
    justify-content: right;
}

#sdk-mm-qrcode {
    svg {
        width: 50%;
    }
}`;
  var Mq = Object.freeze({
    __proto__: null,
    mm_install_modal: XT,
    mm_pending_modal: e6,
    mm_select_modal: t6
  });
  const n6 = new GK({
    dappMetadata: {name: 'Naka Web Wallet', url: window.location.origin}
  });
  n6.getProvider();
  const Oq = JSON.parse(
      '[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"inputs":[],"name":"ReentrancyGuardReentrantCall","type":"error"},{"inputs":[{"internalType":"address","name":"token","type":"address"}],"name":"SafeERC20FailedOperation","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"cardKey","type":"address"},{"indexed":false,"internalType":"bool","name":"active","type":"bool"}],"name":"AddCardKey","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"merchantId","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"merchantPaymentId","type":"bytes32"},{"indexed":true,"internalType":"uint16","name":"merchantTerminalId","type":"uint16"},{"components":[{"internalType":"bytes","name":"paymentData","type":"bytes"},{"internalType":"uint256","name":"paymentAmount","type":"uint256"},{"internalType":"uint256","name":"forProtocolTokenAmount","type":"uint256"},{"internalType":"uint256","name":"executeAfter","type":"uint256"},{"internalType":"uint256","name":"totalReservationAmountNow","type":"uint256"},{"internalType":"uint256","name":"dailySpendingNow","type":"uint256"},{"internalType":"uint256","name":"protocolGatewayFeeAmount","type":"uint256"},{"internalType":"bytes32","name":"gatewayPaymentId","type":"bytes32"},{"internalType":"bytes","name":"paymentProcessorTranData","type":"bytes"}],"indexed":false,"internalType":"struct IVault.ReservationEventData","name":"reservationData","type":"tuple"}],"name":"AddProcessPaymentReservation","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"bridgeAddress","type":"address"},{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"string","name":"chainId","type":"string"},{"indexed":false,"internalType":"string","name":"recipient","type":"string"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"fullMessage","type":"bytes"}],"name":"BridgeWithdrawal","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"merchantId","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"merchantPaymentId","type":"bytes32"},{"indexed":true,"internalType":"uint16","name":"merchantTerminalId","type":"uint16"},{"components":[{"internalType":"bytes","name":"paymentData","type":"bytes"},{"internalType":"uint256","name":"paymentAmount","type":"uint256"},{"internalType":"uint256","name":"forProtocolTokenAmount","type":"uint256"},{"internalType":"uint256","name":"executeAfter","type":"uint256"},{"internalType":"uint256","name":"totalReservationAmountNow","type":"uint256"},{"internalType":"uint256","name":"dailySpendingNow","type":"uint256"},{"internalType":"uint256","name":"protocolGatewayFeeAmount","type":"uint256"},{"internalType":"bytes32","name":"gatewayPaymentId","type":"bytes32"},{"internalType":"bytes","name":"paymentProcessorTranData","type":"bytes"}],"indexed":false,"internalType":"struct IVault.ReservationEventData","name":"reservationData","type":"tuple"}],"name":"CancelProcessPaymentReservation","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"CanceledWithdrawReservation","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"cardKey","type":"address"},{"indexed":false,"internalType":"bool","name":"oldValue","type":"bool"},{"indexed":false,"internalType":"bool","name":"newValue","type":"bool"}],"name":"CardKeyActiveChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"ContractInitialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":true,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Deposit","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"oldValue","type":"uint256"},{"indexed":true,"internalType":"uint256","name":"newValue","type":"uint256"}],"name":"MaxPaymentProcessorAllowedDailyAmountChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"oldValue","type":"uint256"},{"indexed":true,"internalType":"uint256","name":"newValue","type":"uint256"}],"name":"MaxPaymentProcessorAllowedSingleAmountChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferStarted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"merchantId","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"merchantPaymentId","type":"bytes32"},{"indexed":true,"internalType":"uint16","name":"merchantTerminalId","type":"uint16"},{"components":[{"internalType":"bytes","name":"paymentData","type":"bytes"},{"internalType":"uint256","name":"paymentAmount","type":"uint256"},{"internalType":"uint256","name":"forProtocolTokenAmount","type":"uint256"},{"internalType":"uint256","name":"executeAfter","type":"uint256"},{"internalType":"uint256","name":"totalReservationAmountNow","type":"uint256"},{"internalType":"uint256","name":"dailySpendingNow","type":"uint256"},{"internalType":"uint256","name":"protocolGatewayFeeAmount","type":"uint256"},{"internalType":"bytes32","name":"gatewayPaymentId","type":"bytes32"},{"internalType":"bytes","name":"paymentProcessorTranData","type":"bytes"}],"indexed":false,"internalType":"struct IVault.ReservationEventData","name":"reservationData","type":"tuple"}],"name":"ProcessPaymentFailure","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"merchantId","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"merchantPaymentId","type":"bytes32"},{"indexed":true,"internalType":"uint16","name":"merchantTerminalId","type":"uint16"},{"components":[{"internalType":"bytes","name":"paymentData","type":"bytes"},{"internalType":"uint256","name":"paymentAmount","type":"uint256"},{"internalType":"uint256","name":"forProtocolTokenAmount","type":"uint256"},{"internalType":"uint256","name":"executeAfter","type":"uint256"},{"internalType":"uint256","name":"totalReservationAmountNow","type":"uint256"},{"internalType":"uint256","name":"dailySpendingNow","type":"uint256"},{"internalType":"uint256","name":"protocolGatewayFeeAmount","type":"uint256"},{"internalType":"bytes32","name":"gatewayPaymentId","type":"bytes32"},{"internalType":"bytes","name":"paymentProcessorTranData","type":"bytes"}],"indexed":false,"internalType":"struct IVault.ReservationEventData","name":"reservationData","type":"tuple"}],"name":"ProcessPaymentSuccess","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint16","name":"oldValue","type":"uint16"},{"indexed":true,"internalType":"uint16","name":"newValue","type":"uint16"}],"name":"VaultKYCLevelChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"unlockTime","type":"uint256"}],"name":"WithdrawRequest","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"token","type":"address"},{"indexed":true,"internalType":"address","name":"recipient","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Withdrawal","type":"event"},{"stateMutability":"payable","type":"fallback"},{"inputs":[],"name":"GATEWAY_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"acceptOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"cardKey_","type":"address"},{"internalType":"bool","name":"active_","type":"bool"}],"name":"addCardKey","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"merchantId_","type":"bytes32"},{"internalType":"bytes32","name":"merchantPaymentId_","type":"bytes32"},{"internalType":"uint16","name":"merchantTerminalId_","type":"uint16"},{"internalType":"bytes","name":"paymentData_","type":"bytes"},{"internalType":"uint256","name":"protocolTokenAmount_","type":"uint256"},{"internalType":"uint256","name":"protocolGatewayFeeAmount_","type":"uint256"},{"internalType":"bytes32","name":"gatewayPaymentId_","type":"bytes32"},{"internalType":"bytes","name":"paymentProcessorTranData_","type":"bytes"}],"name":"addProcessPaymentReservation","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"bridgeAddress_","type":"address"},{"internalType":"address","name":"token_","type":"address"},{"internalType":"string","name":"chainId_","type":"string"},{"internalType":"string","name":"recipient_","type":"string"},{"internalType":"uint256","name":"amount_","type":"uint256"},{"internalType":"bytes","name":"fullMessage_","type":"bytes"}],"name":"bridgeWithdraw","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"bridgeAddress_","type":"address"},{"internalType":"address","name":"token_","type":"address"},{"internalType":"string","name":"chainId_","type":"string"},{"internalType":"string","name":"recipient_","type":"string"},{"internalType":"uint256","name":"amount_","type":"uint256"},{"internalType":"bytes","name":"fullMessage_","type":"bytes"}],"name":"bridgeWithdrawRequest","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"gatewayPaymentId_","type":"bytes32"}],"name":"cancelProcessPaymentReservation","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"token_","type":"address"}],"name":"cancelWithdrawRequest","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"merchantId_","type":"bytes32"},{"internalType":"bytes32","name":"merchantPaymentId_","type":"bytes32"},{"internalType":"uint256","name":"protocolTokenAmount_","type":"uint256"},{"internalType":"bytes","name":"paymentProcessorTranData_","type":"bytes"}],"name":"checkLimitsAndSignitures","outputs":[{"internalType":"bool","name":"success_","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"token_","type":"address"},{"internalType":"uint256","name":"amount_","type":"uint256"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"gatewayPaymentId_","type":"bytes32"}],"name":"executeProcessPayment","outputs":[{"internalType":"bool","name":"success","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"getAvaliableCardKeysCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"cardKey_","type":"address"}],"name":"getCardKey","outputs":[{"components":[{"internalType":"address","name":"cardKey","type":"address"},{"internalType":"bool","name":"active","type":"bool"}],"internalType":"struct IVault.CardKeyResult","name":"cardKeyResult_","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"index","type":"uint256"}],"name":"getCardKeyByIndex","outputs":[{"components":[{"internalType":"address","name":"cardKey","type":"address"},{"internalType":"bool","name":"active","type":"bool"}],"internalType":"struct IVault.CardKeyResult","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint16","name":"page_","type":"uint16"},{"internalType":"uint16","name":"pageSize_","type":"uint16"},{"internalType":"bool","name":"activeOnly_","type":"bool"}],"name":"getCardKeys","outputs":[{"components":[{"internalType":"address","name":"cardKey","type":"address"},{"internalType":"bool","name":"active","type":"bool"}],"internalType":"struct IVault.CardKeyResult[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getMaxPaymentProcessorAllowedDailyAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getMaxPaymentProcessorAllowedSingleAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"barSigniture_","type":"bytes"},{"internalType":"bytes32","name":"merchantPaymentId_","type":"bytes32"},{"internalType":"uint256","name":"protocolTokenAmount_","type":"uint256"},{"internalType":"bytes32","name":"merchantId_","type":"bytes32"}],"name":"getPaymentProcessorHash","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes32","name":"merchantId_","type":"bytes32"},{"internalType":"uint256","name":"paymentAmount_","type":"uint256"}],"name":"getProcessPaymentProtocolTokenAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getProcessPaymentProtocolTokenReservation","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getProtocolTokenAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getProtocolTokenBalances","outputs":[{"components":[{"internalType":"uint256","name":"balance","type":"uint256"},{"internalType":"uint256","name":"avaliableBalance","type":"uint256"},{"internalType":"uint256","name":"withdrawalReservation","type":"uint256"},{"internalType":"uint256","name":"processPaymentReservation","type":"uint256"}],"internalType":"struct IVault.ProtocolBalanceData","name":"protocolBalanceData_","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"paymentProtocolTokenAmountForNewReservation_","type":"uint256"}],"name":"getProtocolTokenBalancesWithLimitsCheck","outputs":[{"components":[{"internalType":"uint256","name":"balance","type":"uint256"},{"internalType":"uint256","name":"avaliableBalance","type":"uint256"},{"internalType":"uint256","name":"withdrawalReservation","type":"uint256"},{"internalType":"uint256","name":"processPaymentReservation","type":"uint256"}],"internalType":"struct IVault.ProtocolBalanceData","name":"protocolBalanceData_","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getProtocolTokenBridgeAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getProtocolTokenIsWrapped","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getVaultKYCLevel","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getVaultRegistryAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getVaultVersion","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"getWithdrawProtocolTokenReservation","outputs":[{"components":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint256","name":"unlockTime","type":"uint256"}],"internalType":"struct IVault.TokenReservationData","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"ownerAddress_","type":"address"},{"internalType":"address","name":"vaultRegistry_","type":"address"},{"internalType":"uint16","name":"vaultKYCLevel_","type":"uint16"}],"name":"init","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"cardKey_","type":"address"}],"name":"isCardKeyActive","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"isInitialized","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"isKYCLevelValid","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pendingOwner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"cardKey_","type":"address"},{"internalType":"bool","name":"active_","type":"bool"}],"name":"setCardKeyActive","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"maxPaymentProcessorAllowedDailyAmount_","type":"uint256"}],"name":"setMaxPaymentProcessorAllowedDailyAmount","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"maxPaymentProcessorAllowedSingleAmount_","type":"uint256"}],"name":"setMaxPaymentProcessorAllowedSingleAmount","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint16","name":"vaultKYCLevel_","type":"uint16"},{"internalType":"bytes","name":"signature_","type":"bytes"},{"internalType":"address","name":"signer_","type":"address"}],"name":"setVaultKYCLevel","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId_","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner_","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"merchantId_","type":"bytes32"},{"internalType":"bytes32","name":"merchantPaymentId_","type":"bytes32"},{"internalType":"uint256","name":"protocolTokenAmount_","type":"uint256"},{"internalType":"bytes","name":"paymentProcessorTranData_","type":"bytes"}],"name":"verifySignitures","outputs":[{"internalType":"uint256","name":"paymentAmount_","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"token_","type":"address"},{"internalType":"address","name":"recipient_","type":"address"},{"internalType":"uint256","name":"amount_","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"token_","type":"address"},{"internalType":"address","name":"recipient_","type":"address"},{"internalType":"uint256","name":"amount_","type":"uint256"}],"name":"withdrawRequest","outputs":[],"stateMutability":"nonpayable","type":"function"},{"stateMutability":"payable","type":"receive"}]'
    ),
    Nq = JSON.parse(
      '[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"AccessControlBadConfirmation","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"bytes32","name":"neededRole","type":"bytes32"}],"name":"AccessControlUnauthorizedAccount","type":"error"},{"inputs":[],"name":"EnforcedPause","type":"error"},{"inputs":[],"name":"ExpectedPause","type":"error"},{"inputs":[],"name":"FailedDeployment","type":"error"},{"inputs":[{"internalType":"uint256","name":"balance","type":"uint256"},{"internalType":"uint256","name":"needed","type":"uint256"}],"name":"InsufficientBalance","type":"error"},{"inputs":[{"internalType":"address","name":"token","type":"address"}],"name":"SafeERC20FailedOperation","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"ContractInitialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint16","name":"oldValue","type":"uint16"},{"indexed":true,"internalType":"uint16","name":"newValue","type":"uint16"}],"name":"DefaultVaultKYCLevelChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"oldValue","type":"address"},{"indexed":true,"internalType":"address","name":"newValue","type":"address"}],"name":"FeeVaultAddressChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint16","name":"KYCLevel","type":"uint16"},{"indexed":false,"internalType":"uint256","name":"maxProtocolAmountSingle","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"maxProtocolAmountDaily","type":"uint256"},{"indexed":false,"internalType":"bool","name":"active","type":"bool"}],"name":"KYCLevelAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint16","name":"KYCLevel","type":"uint16"},{"indexed":false,"internalType":"uint256","name":"maxProtocolAmountSingle","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"maxProtocolAmountDaily","type":"uint256"},{"indexed":false,"internalType":"bool","name":"active","type":"bool"}],"name":"KYCLevelChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Paused","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"oldValue","type":"address"},{"indexed":true,"internalType":"address","name":"newValue","type":"address"}],"name":"PaymentProcessorSignerAddressChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"oldValue","type":"address"},{"indexed":true,"internalType":"address","name":"newValue","type":"address"}],"name":"PaymentRouterChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"oldValue","type":"uint256"},{"indexed":true,"internalType":"uint256","name":"newValue","type":"uint256"}],"name":"ProtocolFeeChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"oldValue","type":"address"},{"indexed":true,"internalType":"address","name":"newValue","type":"address"}],"name":"ProtocolTokenChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"oldValue","type":"uint256"},{"indexed":true,"internalType":"uint256","name":"newValue","type":"uint256"}],"name":"ProtocolTokenProcessPaymentReservationTimeOutDurationChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"oldValue","type":"uint256"},{"indexed":true,"internalType":"uint256","name":"newValue","type":"uint256"}],"name":"ProtocolTokenWithdrawalReservationLockDurationChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"tokenAddress","type":"address"},{"indexed":true,"internalType":"address","name":"userAddress","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"TokensSalvaged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Unpaused","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"vaultAddress","type":"address"},{"indexed":true,"internalType":"address","name":"ownerAddress","type":"address"},{"indexed":true,"internalType":"address","name":"vaultTemplateAddress","type":"address"},{"indexed":false,"internalType":"uint16","name":"vaultVersion","type":"uint16"}],"name":"VaultCreated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"oldValue","type":"address"},{"indexed":true,"internalType":"address","name":"newValue","type":"address"}],"name":"VaultTemplateAddressChanged","type":"event"},{"inputs":[],"name":"DEFAULT_ADMIN_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"GATEWAY_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"MODERATOR_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint16","name":"KYCLevel_","type":"uint16"},{"internalType":"uint256","name":"maxProtocolAmountSingle_","type":"uint256"},{"internalType":"uint256","name":"maxProtocolAmountDaily_","type":"uint256"},{"internalType":"bool","name":"active_","type":"bool"}],"name":"addKYCLevel","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"merchantPaymentId_","type":"bytes32"}],"name":"burnMerchantPaymentId","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"ownerAddress_","type":"address"}],"name":"createVault","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"getDefaultKYCLevel","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getFeeVaultAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint16","name":"KYCLevel_","type":"uint16"}],"name":"getKYCLevel","outputs":[{"components":[{"internalType":"uint16","name":"KYCLevel","type":"uint16"},{"internalType":"uint256","name":"maxProtocolAmountSingle","type":"uint256"},{"internalType":"uint256","name":"maxProtocolAmountDaily","type":"uint256"},{"internalType":"bool","name":"active","type":"bool"}],"internalType":"struct IVaultRegistry.KYCLevelResult","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getKYCLevelCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint16","name":"page_","type":"uint16"},{"internalType":"uint16","name":"pageSize_","type":"uint16"},{"internalType":"bool","name":"activeOnly_","type":"bool"}],"name":"getKYCLevels","outputs":[{"components":[{"internalType":"uint16","name":"KYCLevel","type":"uint16"},{"internalType":"uint256","name":"maxProtocolAmountSingle","type":"uint256"},{"internalType":"uint256","name":"maxProtocolAmountDaily","type":"uint256"},{"internalType":"bool","name":"active","type":"bool"}],"internalType":"struct IVaultRegistry.KYCLevelResult[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getPaymentProcessorSignerAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getPaymentRouterAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getProtocolTokenAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getProtocolTokenBridgeAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getProtocolTokenIsWrapped","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getProtocolTokenProcessPaymentReservationTimeOutDuration","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getProtocolTokenWithdrawalReservationLockDuration","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"getRoleMember","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleMemberCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleMembers","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"index","type":"uint256"}],"name":"getVault","outputs":[{"components":[{"internalType":"address","name":"vaultAddress","type":"address"},{"internalType":"uint16","name":"vaultVersion","type":"uint16"},{"internalType":"address","name":"ownerAddress","type":"address"},{"internalType":"uint16","name":"vaultKYCLevel","type":"uint16"},{"internalType":"uint256","name":"protocolTokenAvaliableBalance","type":"uint256"}],"internalType":"struct IVaultRegistry.VaultResult","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"getVaultAddressByOwner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"getVaultByOwner","outputs":[{"components":[{"internalType":"address","name":"vaultAddress","type":"address"},{"internalType":"uint16","name":"vaultVersion","type":"uint16"},{"internalType":"address","name":"ownerAddress","type":"address"},{"internalType":"uint16","name":"vaultKYCLevel","type":"uint16"},{"internalType":"uint256","name":"protocolTokenAvaliableBalance","type":"uint256"}],"internalType":"struct IVaultRegistry.VaultResult","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"vaultAddress_","type":"address"}],"name":"getVaultData","outputs":[{"components":[{"internalType":"address","name":"vaultAddress","type":"address"},{"internalType":"uint16","name":"vaultVersion","type":"uint16"},{"internalType":"address","name":"ownerAddress","type":"address"},{"internalType":"uint16","name":"vaultKYCLevel","type":"uint16"},{"internalType":"uint256","name":"protocolTokenAvaliableBalance","type":"uint256"}],"internalType":"struct IVaultRegistry.VaultResult","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getVaultTemplateAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint16","name":"page_","type":"uint16"},{"internalType":"uint16","name":"pageSize_","type":"uint16"}],"name":"getVaults","outputs":[{"components":[{"internalType":"address","name":"vaultAddress","type":"address"},{"internalType":"uint16","name":"vaultVersion","type":"uint16"},{"internalType":"address","name":"ownerAddress","type":"address"},{"internalType":"uint16","name":"vaultKYCLevel","type":"uint16"},{"internalType":"uint256","name":"protocolTokenAvaliableBalance","type":"uint256"}],"internalType":"struct IVaultRegistry.VaultResult[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getVaultsCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"defaultAdminAddress_","type":"address"},{"internalType":"address","name":"moderatorAddress_","type":"address"},{"internalType":"address","name":"vaultTemplateAddress_","type":"address"},{"internalType":"address","name":"gatewayAddress_","type":"address"},{"internalType":"address","name":"paymentProcessorSignerAddress_","type":"address"},{"internalType":"address","name":"paymentRouterAddress_","type":"address"},{"internalType":"address","name":"feeVaultAddress_","type":"address"}],"name":"init","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"isInitialized","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint16","name":"KYCLevel_","type":"uint16"}],"name":"isKYCLevelActive","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"merchantPaymentId_","type":"bytes32"}],"name":"isMerchantPaymentIdAvaliable","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"vaultAddress_","type":"address"}],"name":"isVaultAvaliable","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"paused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"callerConfirmation","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"tokenAddress_","type":"address"},{"internalType":"address","name":"to_","type":"address"},{"internalType":"uint256","name":"amount_","type":"uint256"}],"name":"salvageTokensFromContract","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint16","name":"defaultKYCLevel_","type":"uint16"}],"name":"setDefaultKYCLevel","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"feeVaultAddress_","type":"address"}],"name":"setFeeVaultAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint16","name":"KYCLevel_","type":"uint16"},{"internalType":"uint256","name":"maxProtocolAmountSingle_","type":"uint256"},{"internalType":"uint256","name":"maxProtocolAmountDaily_","type":"uint256"},{"internalType":"bool","name":"active_","type":"bool"}],"name":"setKYCLevel","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"setPause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"paymentProcessorSignerAddress_","type":"address"}],"name":"setPaymentProcessorSignerAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"paymentRouterAddress_","type":"address"}],"name":"setPaymentRouterAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"timeOutDuration_","type":"uint256"}],"name":"setProtocolTokenProcessPaymentReservationTimeOutDuration","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"lockDuration_","type":"uint256"}],"name":"setProtocolTokenWithdrawalReservationLockDuration","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"setUnpause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"vaultTemplateAddress_","type":"address"}],"name":"setVaultTemplateAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId_","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"vaultAddress_","type":"address"}],"name":"updateVaultOwner","outputs":[],"stateMutability":"nonpayable","type":"function"}]'
    ),
    Wh = (t, e, n) => {
      $e(t, {
        autoClose: e,
        type: 'info',
        theme: 'dark',
        position: 'bottom-center',
        transition: 'bounce',
        hideProgressBar: !0,
        toastClassName: `toast__wrap ${n || ''}`,
        bodyClassName: 'toast__body'
      });
    },
    r6 = (t) => {
      (navigator.clipboard.writeText(t), Wh('Copied to clipboard', 1e3));
    };
  function Lq() {
    const t = navigator.userAgent,
      e = /Android|iPhone|iPad|iPod/i.test(t),
      n =
        (/Chrome/i.test(t) || /CriOS/i.test(t)) &&
        !/Edg/i.test(t) &&
        !/OPR/i.test(t) &&
        !/Brave/i.test(t),
      r = t.includes('MetaMask');
    return e && n && !r;
  }
  const Bq = (t, e) =>
      t
        ? new Date(t).toLocaleDateString('sl-SI', {
            day: '2-digit',
            month: '2-digit',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
          })
        : e || '/',
    Rd = (t, e = 6) => {
      const n = 10n ** BigInt(e),
        r = t / n,
        i = t % n;
      return Number(r) + Number(i) / Number(n);
    },
    T0 = (t, e = 6) => BigInt(Math.round(t * 10 ** e)),
    Vu = (t) => {
      const [e, n] = t.toString().split('.');
      return n ? (n.length === 1 ? `${e}.${n}0` : t) : parseFloat(e).toFixed(2);
    },
    Ei = $k('contracts', {
      state: () => ({
        web3: null,
        firstSign: !1,
        connectedAccount: '',
        chainId: null,
        balance: '',
        contractBalance: {eth: 0, usdt: 0},
        provider: null,
        allAccounts: [],
        signature: {
          message: 'Please sign this message to confirm you own this wallet',
          value: ''
        },
        inputs: {
          privateKey: '',
          nonce: '',
          transactionHash: '',
          apiKey: '',
          factory: ''
        },
        loading: {
          transactionHash: !1,
          factory: !1,
          balance: !1,
          withdrawConnected: !1,
          withdrawExternal: !1,
          connect: !1,
          history: !1,
          withdraw: !1,
          cancelWithdraw: !1,
          completeWithdraw: !1
        },
        transactionHash: {contractAddress: ''},
        factory: {contractAddress: '', factoryABI: []},
        deployer: {contractAddress: ''},
        modal: {
          connect: !1,
          withdrawConnected: !1,
          withdrawExternal: !1,
          cancelWithdraw: !1,
          completeWithdraw: !1,
          overtime: !1
        },
        withdrawals: [],
        form: {
          connected: {amount: {required: !0, value: null}},
          external: {
            amount: {required: !0, value: null},
            address: {required: !0, value: ''}
          }
        },
        wallets: {connected: {step: 1}, external: {step: 1}},
        error: {external: !1, connected: !1, externalAddress: !1},
        factoryContract: null,
        vaultContract: null,
        transactionGas: null,
        activeRequest: null,
        lastBlock: 0,
        withdrawalRequests: [],
        vaultAddress: '',
        blocksOffset: 5e3,
        completedWithdrawals: [],
        cancelledWithdrawals: [],
        daysOffset: 2,
        thresholdPrompt: ''
      }),
      getters: {
        activeNetwork: (t) => ({
          name: nd[t.chainId].name || `Unknown Chain (ID: ${t.chainId})`,
          icon: nd[t.chainId].icon || './img/icons/bitcoin-btc-logo.png',
          id: nd[t.chainId].id || 'No id',
          symbol: nd[t.chainId].symbol || ''
        })
      },
      actions: {
        initializeWeb3(t) {
          ((this.provider = window.ethereum || t),
            (this.web3 = new Lc(this.provider)),
            this.updateNetwork(),
            this.onAccountsChanged());
        },
        updateLoading(t) {
          this.loading = {...this.loading, ...t};
        },
        updateFirstSign(t) {
          this.firstSign = t;
        },
        updateModal(t) {
          this.modal = {...this.modal, ...t};
        },
        updateForm(t) {
          this.form = {...this.form, ...t};
        },
        updateError(t) {
          this.error = {...this.error, ...t};
        },
        updateOffsetDays(t) {
          this.daysOffset = t;
        },
        updateWallet(t, e) {
          this.wallets = {...this.wallets, [t]: {...this.wallets[t], ...e}};
        },
        resetConnectedForm() {
          (this.updateError({connected: !1}),
            this.updateWallet('connected', {step: 1}),
            this.updateFormField(null, 'connected', 'amount'),
            this.updateLoading({withdrawConnected: !1}));
        },
        resetExternalForm() {
          (this.updateError({external: !1}),
            this.updateWallet('external', {step: 1}),
            this.updateFormField(null, 'external', 'amount'),
            this.updateFormField('', 'external', 'address'),
            this.updateLoading({withdrawExternal: !1}));
        },
        updateFormField(t, e, n, r) {
          if (r) {
            this.updateForm({
              [e]: {
                ...this.form[e],
                [n]: {
                  ...this.form[e][n],
                  [r]: {...this.form[e][n][r], value: t}
                }
              }
            });
            return;
          }
          this.updateForm({
            [e]: {...this.form[e], [n]: {...this.form[e][n], value: t}}
          });
        },
        updateChain(t) {
          this.chainId = t;
        },
        async getBalance() {
          if (this.web3) {
            this.updateLoading({balance: !0});
            try {
              const t = await this.web3.eth.getBalance(this.connectedAccount),
                e = this.web3.utils.fromWei(t, 'ether');
              this.balance = parseFloat(e).toFixed(5);
            } catch (t) {
              console.error(t);
            } finally {
              this.updateLoading({balance: !1});
            }
          }
        },
        async connectMetamask() {
          var t;
          if (!this.web3) {
            $e.info('no Web3 provided');
            return;
          }
          if (!this.provider) {
            $e.error('Please install MetaMask!');
            return;
          }
          if (!this.loading.connect) {
            if (this.vaultContract && !this.loading.connect) {
              this.updateModal({connect: !0});
              return;
            }
            this.updateLoading({connect: !0});
            try {
              await this.provider.request({method: 'eth_requestAccounts'});
              const e = await this.web3.eth.getAccounts();
              if (!e.length) throw new Error('No accounts found.');
              (((!this.firstSign && !Lq()) || this.firstSign) &&
                (await this.provider.request({
                  method: 'wallet_switchEthereumChain',
                  params: [{chainId: Yd.chainId}]
                })),
                (this.allAccounts = e),
                (this.connectedAccount = e[0]),
                (this.signature.value = await this.web3.eth.personal.sign(
                  this.signature.message,
                  this.connectedAccount,
                  ''
                )),
                sessionStorage.setItem('firstSign', 'true'));
              const n = await this.web3.eth.getChainId();
              (this.updateChain(Number(n)),
                await this.getBalance(),
                await this.connectContract());
            } catch (e) {
              if (((t = e.cause) == null ? void 0 : t.code) !== 4902) {
                $e.error(`${e.message}`);
                return;
              }
              try {
                await window.ethereum.request({
                  method: 'wallet_addEthereumChain',
                  params: [Yd]
                });
              } catch (n) {
                console.error('Failed to add Polygon network:', n);
              }
            } finally {
              this.updateLoading({connect: !1});
            }
          }
        },
        disconnectMetamask() {
          ((this.connectedAccount = ''),
            (this.chainId = null),
            (this.signature.value = ''),
            (this.balance = ''),
            (this.contractBalance = {eth: 0, usdt: 0}),
            (this.vaultContract = null),
            (this.factoryContract = null),
            sessionStorage.removeItem('firstSign'));
        },
        updateNetwork() {
          this.provider &&
            this.provider.on('chainChanged', async (t) => {
              t !== Yd.chainId && this.disconnectMetamask();
            });
        },
        onAccountsChanged() {
          this.provider &&
            this.provider.on('accountsChanged', (t) => {
              t.length ||
                (this.updateModal({connect: !1}), this.disconnectMetamask());
            });
        },
        async connectMobile() {
          const t = n6.getProvider(),
            e =
              /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                navigator.userAgent
              ),
            n = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
          !t ||
            (!e && !n) ||
            (this.initializeWeb3(t),
            this.updateNetwork(),
            this.onAccountsChanged());
        },
        async checkConnection() {
          if (this.web3)
            try {
              const t = await window.ethereum.request({method: 'eth_accounts'});
              if (!t.length) return;
              ((this.connectedAccount = t[0]), (this.allAccounts = t));
            } catch (t) {
              console.error('Error connecting to metamask', t.message);
            }
        },
        async getEstimatedGas() {
          if (!this.web3) return;
          const t = 30;
          try {
            const e = await this.web3.eth.getBlockNumber(),
              n = [];
            for (let r = 0; r < t; r++) {
              const i = await this.web3.eth.getBlock(Number(e) - r, !0);
              for (const s of i.transactions)
                n.push({
                  gas: Number(s.gas),
                  gasPrice: Number(s.gasPrice),
                  maxFeePerGas: Number(s.maxFeePerGas),
                  maxPriorityFeePerGas: Number(s.maxPriorityFeePerGas)
                });
            }
            if (!n.length)
              throw new Error('No createVault txs found in last 30 blocks');
            this.transactionGas = {
              gas: Math.floor(
                n.filter((r) => !isNaN(r.gas)).reduce((r, i) => r + i.gas, 0) /
                  n.length
              ),
              gasPrice: Math.floor(
                n
                  .filter((r) => !isNaN(r.gasPrice))
                  .reduce((r, i) => r + i.gasPrice, 0) / n.length
              ),
              maxFeePerGas: Math.floor(
                n
                  .filter((r) => !isNaN(r.maxFeePerGas))
                  .reduce((r, i) => r + i.maxFeePerGas, 0) / n.length
              ),
              maxPriorityFeePerGas: Math.floor(
                n
                  .filter((r) => !isNaN(r.maxPriorityFeePerGas))
                  .reduce((r, i) => r + i.maxPriorityFeePerGas, 0) / n.length
              )
            };
          } catch (e) {
            console.error('Error estimating gas: ', e.message);
          }
        },
        async submitConnectedForm() {
          var t, e, n;
          if (
            !(
              this.loading.withdrawConnected ||
              !this.form.connected.amount.value ||
              this.contractBalance.usdt < this.form.connected.amount.value ||
              !this.vaultContract
            )
          ) {
            if (this.error.connected) {
              this.resetConnectedForm();
              return;
            }
            this.updateLoading({withdrawConnected: !0});
            try {
              if (this.wallets.connected.step === 1) {
                (await this.vaultContract.methods
                  .withdrawRequest(
                    rd,
                    this.connectedAccount,
                    T0(this.form.connected.amount.value)
                  )
                  .send({
                    from: this.connectedAccount,
                    gas:
                      (t = this.transactionGas) != null && t.gas
                        ? `${this.transactionGas.gas}`
                        : void 0,
                    maxFeePerGas:
                      (e = this.transactionGas) != null && e.maxFeePerGas
                        ? `${this.transactionGas.maxFeePerGas}`
                        : void 0,
                    maxPriorityFeePerGas:
                      (n = this.transactionGas) != null &&
                      n.maxPriorityFeePerGas
                        ? `${this.transactionGas.maxPriorityFeePerGas}`
                        : void 0
                  }),
                  this.updateWallet('connected', {step: 2}),
                  await this.getVaultBalance());
                return;
              }
              (this.updateModal({withdrawConnected: !1}),
                this.updateFormField(null, 'connected', 'amount'),
                this.updateWallet('connected', {step: 1}),
                await this.getWithdrawalHistory());
            } catch (r) {
              (console.error('Error submitting form: ', r.message),
                $e.error(`${r.message}`),
                this.updateError({connected: !0}),
                this.updateLoading({withdrawConnected: !1}),
                await this.getEstimatedGas());
            } finally {
              this.updateLoading({withdrawConnected: !1});
            }
          }
        },
        async submitExternalForm() {
          var t, e, n;
          if (
            !(
              this.loading.withdrawExternal ||
              !this.form.external.amount.value ||
              !this.vaultContract ||
              this.contractBalance.usdt < this.form.external.amount.value ||
              !this.form.external.amount.value
            )
          ) {
            if (this.error.external) {
              this.resetExternalForm();
              return;
            }
            this.updateLoading({withdrawExternal: !0});
            try {
              if (this.wallets.external.step === 1) {
                this.updateWallet('external', {step: 2});
                return;
              }
              if (this.wallets.external.step === 2) {
                (await this.vaultContract.methods
                  .withdrawRequest(
                    rd,
                    this.form.external.address.value,
                    T0(this.form.external.amount.value)
                  )
                  .send({
                    from: this.connectedAccount,
                    gas:
                      (t = this.transactionGas) != null && t.gas
                        ? `${this.transactionGas.gas}`
                        : void 0,
                    maxFeePerGas:
                      (e = this.transactionGas) != null && e.maxFeePerGas
                        ? `${this.transactionGas.maxFeePerGas}`
                        : void 0,
                    maxPriorityFeePerGas:
                      (n = this.transactionGas) != null &&
                      n.maxPriorityFeePerGas
                        ? `${this.transactionGas.maxPriorityFeePerGas}`
                        : void 0
                  }),
                  this.updateWallet('external', {step: 3}),
                  await this.getVaultBalance());
                return;
              }
              (this.updateModal({withdrawExternal: !1}),
                this.updateFormField(null, 'external', 'amount'),
                this.updateFormField('', 'external', 'address'),
                this.updateWallet('external', {step: 1}),
                await this.getWithdrawalHistory());
            } catch (r) {
              (console.error('Error submitting form: ', r.message),
                $e.error(`${r.message}`),
                this.updateError({external: !0}),
                this.updateLoading({withdrawExternal: !1}),
                await this.getEstimatedGas());
            } finally {
              this.updateLoading({withdrawExternal: !1});
            }
          }
        },
        async getVaultBalance() {
          if (this.vaultContract)
            try {
              const t = await this.vaultContract.methods
                  .getProtocolTokenBalances()
                  .call(),
                e = Rd(t.avaliableBalance);
              this.contractBalance = {...this.contractBalance, usdt: e};
            } catch (t) {
              console.error('Error fetching vault balance: ', t.message);
            }
        },
        async estimateBlocksPerHour(t = 20) {
          if (this.web3)
            try {
              const e = await this.web3.eth.getBlockNumber(),
                n = await this.web3.eth.getBlock(e),
                r = await this.web3.eth.getBlock(Number(e) - t),
                s = (Number(n.timestamp) - Number(r.timestamp)) / t;
              this.blocksOffset = Math.ceil((3600 * 24) / s);
            } catch (e) {
              console.error('Error estimating block offset: ', e.message);
            }
        },
        async getWithdrawRequests() {
          if (this.vaultContract)
            try {
              this.withdrawalRequests = await this.vaultContract.getPastEvents(
                'WithdrawRequest',
                {
                  fromBlock: Math.ceil(
                    this.lastBlock - this.blocksOffset * this.daysOffset
                  ),
                  toBlock: 'latest'
                }
              );
            } catch (t) {
              console.error('Error fetching withdraw requests; ', t.message);
            }
        },
        async getActiveRequest() {
          if (!(!this.factoryContract || !this.vaultContract || !this.web3))
            try {
              const t = await this.vaultContract.methods
                  .getWithdrawProtocolTokenReservation()
                  .call(),
                e = Number(t.amount);
              if (e <= 0) {
                this.activeRequest = null;
                return;
              }
              const n = await this.factoryContract.methods
                .getProtocolTokenWithdrawalReservationLockDuration()
                .call();
              if (
                (await this.getWithdrawRequests(),
                !this.withdrawalRequests.length)
              ) {
                e &&
                  ((this.thresholdPrompt =
                    'It seems the Polygon chain is experiencing a lot of traffic right now. We have detected you have an outstanding withdrawal request. Please note that a small gas fee is required to cancel or complete your withdrawal.'),
                  this.updateModal({overtime: !0}));
                return;
              }
              const r = this.withdrawalRequests.reverse()[0],
                s = (
                  await this.web3.eth.getBlock(r.blockNumber, !0)
                ).transactions.find((c) => c.hash === r.transactionHash);
              if (!s) return;
              const o = this.web3.eth.abi.decodeParameters(
                ['address', 'address', 'uint256'],
                '0x' + s.input.slice(10)
              );
              if (
                ((this.activeRequest = {
                  address: `${o[1]}`,
                  amount: Rd(r.returnValues.amount),
                  date: new Date(
                    (Number(r.returnValues.unlockTime) - Number(n)) * 1e3
                  ),
                  status:
                    Number(r.returnValues.unlockTime) * 1e3 < Date.now()
                      ? 'ready'
                      : 'pending'
                }),
                new Date(Date.now() - 2 * 24 * 60 * 60 * 1e3).getTime() <
                  this.activeRequest.date.getTime())
              )
                return;
              ((this.thresholdPrompt =
                'It has been more than 2 days since your requested your withdrawal. Please cancel or complete your withdrawal request. Please note that a small gas fee is required to complete your withdrawal.'),
                this.updateModal({overtime: !0}));
            } catch (t) {
              console.error('Error fetching active request: ', t.message);
            }
        },
        async findRecipientForCancellation(t) {
          if (!(!this.web3 || !this.vaultContract))
            try {
              const e = await this.web3.eth.getTransactionReceipt(t);
              if (!e) return;
              const n = e.logs.find((l) => {
                var u;
                return (
                  ((u = l.address) == null ? void 0 : u.toLowerCase()) ===
                  this.vaultAddress.toLowerCase()
                );
              });
              if (!n || !n.data || !n.topics) return;
              const r = this.web3.eth.abi.decodeLog(
                  [
                    {indexed: !0, name: 'token', type: 'address'},
                    {indexed: !1, name: 'amount', type: 'uint256'}
                  ],
                  n.data,
                  n.topics
                ),
                i = r.token,
                s = r.amount;
              this.withdrawalRequests.length ||
                (await this.getWithdrawRequests());
              const o = this.withdrawalRequests.find(
                (l) => s === l.returnValues.amount && i === l.returnValues.token
              );
              if (!o) return;
              const a = await this.web3.eth.getTransaction(o.transactionHash);
              return {
                recipient: this.web3.eth.abi.decodeParameters(
                  ['address', 'address', 'uint256'],
                  '0x' + a.input.slice(10)
                )[1],
                withdrawTxHash: o.transactionHash
              };
            } catch {
              throw new Error('Matching withdrawRequest not found');
            }
        },
        async getCancelledWithdrawals() {
          try {
            const e = (
              await this.vaultContract.getPastEvents(
                'CanceledWithdrawReservation',
                {
                  fromBlock: Math.ceil(
                    this.lastBlock - this.blocksOffset * this.daysOffset
                  ),
                  toBlock: 'latest'
                }
              )
            ).map(async (n) => {
              if (!this.web3) return;
              const i = (await this.web3.eth.getBlock(n.blockNumber, !0))
                  .timestamp,
                s = await this.findRecipientForCancellation(n.transactionHash);
              return {
                address: s ? s.recipient : '',
                amount: Rd(n.returnValues.amount),
                date: new Date(Number(i) * 1e3),
                status: 'cancelled'
              };
            });
            this.cancelledWithdrawals = (await Promise.all(e)).filter((n) =>
              n == null ? void 0 : n.address
            );
          } catch (t) {
            console.error('Error fetching cancelled withdrawals: ', t.message);
          }
        },
        async getCompletedWithdrawals() {
          try {
            const e = (
              await this.vaultContract.getPastEvents('Withdrawal', {
                fromBlock: Math.ceil(
                  this.lastBlock - this.blocksOffset * this.daysOffset
                ),
                toBlock: 'latest'
              })
            ).map(async (n) => {
              if (!this.web3) return;
              const i = (await this.web3.eth.getBlock(n.blockNumber)).timestamp;
              return {
                address: n.returnValues.recipient,
                amount: Rd(n.returnValues.amount),
                date: new Date(Number(i) * 1e3),
                status: 'complete'
              };
            });
            this.completedWithdrawals = await Promise.all(e);
          } catch (t) {
            console.error('Error fetching completed withdrawals', t.message);
          }
        },
        async getWithdrawalHistory() {
          if (!(!this.vaultContract || !this.factoryContract || !this.web3)) {
            this.updateLoading({history: !0});
            try {
              (await this.getActiveRequest(),
                await this.getCancelledWithdrawals(),
                await this.getCompletedWithdrawals());
              const t = [
                ...this.cancelledWithdrawals,
                ...this.completedWithdrawals
              ].sort((e, n) => +n.date - +e.date);
              this.withdrawals = this.activeRequest
                ? [this.activeRequest, ...t]
                : t;
            } catch (t) {
              console.error('Error fetching withdrawal history: ', t.message);
            } finally {
              this.updateLoading({history: !1});
            }
          }
        },
        async setVaultContract(t) {
          if (this.web3)
            try {
              ((this.vaultContract = new this.web3.eth.Contract(Oq, t)),
                await this.getWithdrawalHistory(),
                await this.getVaultBalance());
            } catch (e) {
              console.error('Error setting vault contract: ', e.message);
            }
        },
        async connectContract() {
          var e, n, r, i;
          if (!this.web3) return;
          this.factoryContract = new this.web3.eth.Contract(Nq, b$);
          const t = $e.loading('Connecting to the contract...');
          try {
            if (
              ((this.vaultAddress = await this.factoryContract.methods
                .getVaultAddressByOwner(this.connectedAccount)
                .call()),
              parseInt(this.vaultAddress, 16))
            ) {
              (await this.setVaultContract(this.vaultAddress), $e.remove(t));
              return;
            }
            await this.getEstimatedGas();
            const o = await this.factoryContract.methods
              .createVault(this.connectedAccount)
              .send({
                from: this.connectedAccount,
                gas:
                  (e = this.transactionGas) != null && e.gas
                    ? `${this.transactionGas.gas}`
                    : void 0,
                maxFeePerGas:
                  (n = this.transactionGas) != null && n.maxFeePerGas
                    ? `${this.transactionGas.maxFeePerGas}`
                    : void 0,
                maxPriorityFeePerGas:
                  (r = this.transactionGas) != null && r.maxPriorityFeePerGas
                    ? `${this.transactionGas.maxPriorityFeePerGas}`
                    : void 0
              });
            if (!o.events)
              throw new Error(
                'Something went wrong while creating the Vault contract. Try again.'
              );
            (await this.setVaultContract(o.events.ContractInitialized.address),
              $e.remove(t),
              $e.success('Vault contract successfully created:'));
          } catch (s) {
            if (
              ($e.remove(t),
              ((i = s.cause) == null ? void 0 : i.code) === -32603)
            ) {
              $e.error("Couldn't connect to the contract.");
              return;
            }
            ($e.error(
              s.message.replace('Returned error: MetaMask Tx Signature: ', '')
            ),
              console.error('Error connecting to Vault: ', s.message));
          }
        },
        async completeWithdraw() {
          var t, e, n;
          if (
            !(
              !this.vaultContract ||
              this.loading.withdraw ||
              !this.activeRequest
            )
          ) {
            this.updateLoading({withdraw: !0});
            try {
              (await this.vaultContract.methods
                .withdraw(
                  rd,
                  this.activeRequest.address,
                  T0(this.activeRequest.amount)
                )
                .send({
                  from: this.connectedAccount,
                  gas:
                    (t = this.transactionGas) != null && t.gas
                      ? `${this.transactionGas.gas}`
                      : void 0,
                  maxFeePerGas:
                    (e = this.transactionGas) != null && e.maxFeePerGas
                      ? `${this.transactionGas.maxFeePerGas}`
                      : void 0,
                  maxPriorityFeePerGas:
                    (n = this.transactionGas) != null && n.maxPriorityFeePerGas
                      ? `${this.transactionGas.maxPriorityFeePerGas}`
                      : void 0
                }),
                this.updateModal({completeWithdraw: !1}),
                this.updateModal({overtime: !1}),
                Wh(
                  `Withdraw to: ${this.activeRequest.address.substring(0, 4)}...${this.activeRequest.address.slice(-4)} has been successfully completed.`,
                  3e3,
                  'toast__wide toast__withdrawal'
                ),
                await this.getWithdrawalHistory());
            } catch (r) {
              (console.error('Error withdrawing funds: ', r.message),
                $e.error(`Error withdrawing funds: ${r.message}`),
                this.updateLoading({withdraw: !1}),
                await this.getEstimatedGas());
            } finally {
              this.updateLoading({withdraw: !1});
            }
          }
        },
        async cancelWithdrawRequest() {
          if (
            !(
              this.loading.cancelWithdraw ||
              !this.vaultContract ||
              !this.transactionGas
            )
          ) {
            this.updateLoading({cancelWithdraw: !0});
            try {
              (await this.vaultContract.methods
                .cancelWithdrawRequest(rd)
                .send({
                  from: this.connectedAccount,
                  gas: `${this.transactionGas.gas}`,
                  maxFeePerGas: `${this.transactionGas.maxFeePerGas}`,
                  maxPriorityFeePerGas: `${this.transactionGas.maxPriorityFeePerGas}`
                }),
                this.updateModal({cancelWithdraw: !1}),
                this.updateModal({overtime: !1}),
                await this.getVaultBalance(),
                await this.getWithdrawalHistory(),
                $e.success('Withdrawal request canceled'));
            } catch (t) {
              ($e.error(`${t.message}`),
                this.updateLoading({cancelWithdraw: !1}),
                await this.getEstimatedGas());
            } finally {
              this.updateLoading({cancelWithdraw: !1});
            }
          }
        },
        async getLastNetworkBlock() {
          if (this.web3)
            try {
              const t = await this.web3.eth.getBlockNumber();
              this.lastBlock = Number(t);
            } catch (t) {
              console.error('Error fetching the last block: ', t.message);
            }
        }
      }
    }),
    Dq =
      "data:image/svg+xml,%3csvg%20width='81'%20height='19'%20viewBox='0%200%2081%2019'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='Logo%20Shape'%3e%3cpath%20d='M7.91667%200.000616074H0V19.0006H3.95833V0.673532L10.2917%2019.0006H18.2083V0.000616074H14.25V18.3277L7.91667%200.000616074Z'%20fill='black'/%3e%3cpath%20d='M42.4253%200.000616074H46.3836V7.91202L53.3897%200.000616074H58.488L50.6812%208.78781H53.944L59.5411%2019.0003H55.0919L49.9429%209.61873L46.3836%2013.625V19.0006H42.4253V0.000616074Z'%20fill='black'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M24.2881%2019.0006H20.3298L26.6393%200.000616074H33.9937L40.3033%2019.0006H36.345L34.8441%2014.4809H27.9306L26.486%2012.3819L24.2881%2019.0006ZM30.3165%200.847195L33.7057%2011.053H26.9273L30.3165%200.847195Z'%20fill='black'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M60.7764%2019H64.7348L66.9327%2012.3813L68.3773%2014.4803H75.2908L76.7917%2019H80.75L74.4404%200H67.086L60.7764%2019ZM74.1524%2011.0524L70.7632%200.846579L67.374%2011.0524H74.1524Z'%20fill='black'/%3e%3c/g%3e%3c/svg%3e",
    ka = xt({
      __name: 'Modal',
      props: {
        class: {},
        wrapClass: {},
        backdropClass: {},
        closeModal: {type: Function},
        active: {type: Boolean}
      },
      setup(t) {
        const e = t,
          n = (r) => {
            if (r) {
              document.body.style.overflow = 'hidden';
              return;
            }
            document.body.style.overflow = 'auto';
          };
        return (
          qs(
            () => e.active,
            (r) => {
              n(r);
            }
          ),
          (r, i) =>
            e.active
              ? (Ce(),
                qe(
                  'div',
                  {key: 0, class: tn(['modal__wrap', e.wrapClass])},
                  [
                    ee(
                      'div',
                      {
                        class: tn(['modal__backdrop', e.backdropClass]),
                        onClick:
                          i[0] ||
                          (i[0] = (...s) => e.closeModal && e.closeModal(...s))
                      },
                      null,
                      2
                    ),
                    ee(
                      'div',
                      {class: tn(['modal__box', e.class])},
                      [
                        ee(
                          'button',
                          {
                            type: 'button',
                            'aria-label': 'Close modal',
                            class: 'modal__close',
                            onClick:
                              i[1] ||
                              (i[1] = (...s) =>
                                e.closeModal && e.closeModal(...s))
                          },
                          i[2] ||
                            (i[2] = [
                              ee(
                                'svg',
                                {
                                  width: '16',
                                  height: '16',
                                  viewBox: '0 0 16 16',
                                  fill: 'none',
                                  xmlns: 'http://www.w3.org/2000/svg'
                                },
                                [
                                  ee('path', {
                                    d: 'M7.99995 8.70256L1.13241 15.7632C1.04011 15.8555 0.924092 15.9028 0.784348 15.9049C0.644615 15.907 0.526459 15.8598 0.429882 15.7632C0.333293 15.6667 0.284998 15.5496 0.284998 15.412C0.284998 15.2744 0.333293 15.1573 0.429882 15.0607L7.2974 8.00001L0.333265 1.03586C0.240954 0.943556 0.193732 0.827534 0.191598 0.68779C0.189454 0.548057 0.236676 0.429901 0.333265 0.333323C0.429843 0.236734 0.546932 0.18844 0.684532 0.18844C0.822132 0.18844 0.93922 0.236734 1.0358 0.333323L7.99995 7.29746L15.1525 0.282453C15.2448 0.190142 15.3609 0.14292 15.5006 0.140786C15.6403 0.138642 15.7585 0.185864 15.8551 0.282453C15.9517 0.379031 16 0.49612 16 0.63372C16 0.77132 15.9517 0.888408 15.8551 0.984986L8.70249 8.00001L15.57 15.0607C15.6623 15.153 15.7095 15.269 15.7117 15.4088C15.7138 15.5485 15.6666 15.6667 15.57 15.7632C15.4734 15.8598 15.3563 15.9081 15.2187 15.9081C15.0811 15.9081 14.964 15.8598 14.8675 15.7632L7.99995 8.70256Z',
                                    fill: '#616161'
                                  })
                                ],
                                -1
                              )
                            ])
                        ),
                        vI(r.$slots, 'default')
                      ],
                      2
                    )
                  ],
                  2
                ))
              : rt('', !0)
        );
      }
    }),
    Fq = {class: 'connect__profile'},
    $q = {class: 'profile'},
    Hq = {class: 'network'},
    jq = ['src', 'alt'],
    Uq = {class: 'network__name'},
    Kq = {class: 'connect__amount'},
    qq = {class: 'header__wrapper'},
    Vq = {class: 'header__wrapper--connect'},
    Gq = {
      key: 0,
      width: '16',
      height: '16',
      viewBox: '0 0 16 16',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg',
      class: 'button__connect--icon'
    },
    zq = xt({
      __name: 'Header',
      setup(t) {
        const e = Ei(),
          n = () => {
            (e.updateModal({connect: !1}), e.disconnectMetamask());
          },
          r = () => {
            r6(e.connectedAccount);
          };
        return (i, s) => (
          Ce(),
          qe(
            Dt,
            null,
            [
              ke(
                ka,
                {
                  class: 'modal__connect',
                  closeModal: () => he(e).updateModal({connect: !1}),
                  active: he(e).modal.connect
                },
                {
                  default: Ns(() => [
                    s[3] ||
                      (s[3] = ee(
                        'div',
                        {class: 'connect__header'},
                        'Connected',
                        -1
                      )),
                    ee('div', Fq, [
                      ee('div', $q, [
                        ee('div', Hq, [
                          ee(
                            'img',
                            {
                              src: he(e).activeNetwork.icon,
                              alt: he(e).activeNetwork.name,
                              width: '30',
                              height: '30',
                              class: 'network__icon'
                            },
                            null,
                            8,
                            jq
                          ),
                          ee('div', Uq, Ft(he(e).activeNetwork.name), 1)
                        ])
                      ])
                    ]),
                    ee('div', {class: 'connect__address', onClick: r}, [
                      ee(
                        'span',
                        null,
                        Ft(
                          `${he(e).connectedAccount.substring(0, 6)}••••${he(e).connectedAccount.slice(-4)}`
                        ),
                        1
                      ),
                      s[1] ||
                        (s[1] = ee(
                          'svg',
                          {
                            width: '20',
                            height: '20',
                            viewBox: '0 0 20 20',
                            fill: 'none',
                            xmlns: 'http://www.w3.org/2000/svg'
                          },
                          [
                            ee('path', {
                              'fill-rule': 'evenodd',
                              'clip-rule': 'evenodd',
                              d: 'M1.04199 1.66797C1.04199 1.32279 1.32181 1.04297 1.66699 1.04297H13.3337C13.6788 1.04297 13.9587 1.32279 13.9587 1.66797V6.04297H18.3337C18.6788 6.04297 18.9587 6.32279 18.9587 6.66797V18.3346C18.9587 18.6798 18.6788 18.9596 18.3337 18.9596H6.66699C6.32181 18.9596 6.04199 18.6798 6.04199 18.3346V13.9596H1.66699C1.32181 13.9596 1.04199 13.6798 1.04199 13.3346V1.66797ZM7.29199 13.9596V17.7096H17.7087V7.29297H13.9587V13.3346C13.9587 13.6798 13.6788 13.9596 13.3337 13.9596H7.29199ZM12.7087 2.29297H2.29199V12.7096H12.7087V2.29297Z'
                            })
                          ],
                          -1
                        ))
                    ]),
                    ee('div', Kq, [
                      ee(
                        'span',
                        {class: tn({loading: he(e).loading.balance})},
                        Ft(he(e).balance) +
                          ' ' +
                          Ft(he(e).activeNetwork.symbol),
                        3
                      )
                    ]),
                    ee('div', {class: 'connect__button'}, [
                      ee(
                        'button',
                        {
                          type: 'button',
                          'aria-label': 'Disconnect from MetaMask',
                          onClick: n,
                          class: 'button__default'
                        },
                        s[2] ||
                          (s[2] = [
                            ee(
                              'svg',
                              {
                                'aria-hidden': 'true',
                                width: '15',
                                height: '14',
                                viewBox: '0 0 15 14',
                                fill: 'none',
                                xmlns: 'http://www.w3.org/2000/svg'
                              },
                              [
                                ee('path', {
                                  'fill-rule': 'evenodd',
                                  'clip-rule': 'evenodd',
                                  d: 'M4 0C1.79086 0 0 1.79086 0 4V10C0 12.2091 1.79086 14 4 14H6C6.55228 14 7 13.5523 7 13C7 12.4477 6.55228 12 6 12H4C2.89543 12 2 11.1046 2 10V4C2 2.89543 2.89543 2 4 2H6C6.55228 2 7 1.55228 7 1C7 0.447715 6.55228 0 6 0H4ZM11.7071 3.29289C11.3166 2.90237 10.6834 2.90237 10.2929 3.29289C9.90237 3.68342 9.90237 4.31658 10.2929 4.70711L11.5858 6H9.5H6C5.44772 6 5 6.44772 5 7C5 7.55228 5.44772 8 6 8H9.5H11.5858L10.2929 9.29289C9.90237 9.68342 9.90237 10.3166 10.2929 10.7071C10.6834 11.0976 11.3166 11.0976 11.7071 10.7071L14.7071 7.70711C15.0976 7.31658 15.0976 6.68342 14.7071 6.29289L11.7071 3.29289Z'
                                })
                              ],
                              -1
                            ),
                            ee('span', null, 'Disconnect', -1)
                          ])
                      )
                    ])
                  ]),
                  _: 1,
                  __: [3]
                },
                8,
                ['closeModal', 'active']
              ),
              ee('header', null, [
                ee('div', qq, [
                  ee('nav', null, [
                    ke(
                      he(KA),
                      {to: '/', class: 'nav__logo'},
                      {
                        default: Ns(
                          () =>
                            s[4] ||
                            (s[4] = [
                              ee(
                                'img',
                                {
                                  src: Dq,
                                  alt: 'Logo',
                                  width: '81',
                                  height: '19'
                                },
                                null,
                                -1
                              )
                            ])
                        ),
                        _: 1,
                        __: [4]
                      }
                    ),
                    ee('div', Vq, [
                      ee(
                        'button',
                        {
                          class: tn([
                            'button__default button__connect',
                            {
                              connected:
                                he(e).vaultContract && !he(e).loading.connect
                            }
                          ]),
                          'aria-label': 'Connect with MetaMask',
                          type: 'button',
                          onClick:
                            s[0] ||
                            (s[0] = (...o) =>
                              he(e).connectMetamask &&
                              he(e).connectMetamask(...o))
                        },
                        [
                          he(e).vaultContract && !he(e).loading.connect
                            ? (Ce(),
                              qe(
                                'svg',
                                Gq,
                                s[5] ||
                                  (s[5] = [
                                    ee(
                                      'g',
                                      {id: 'Group'},
                                      [
                                        ee('path', {
                                          id: 'Vector',
                                          d: 'M14.6667 0H4V2.66667H14.6667V0Z',
                                          fill: '#C6FC50'
                                        }),
                                        ee('path', {
                                          id: 'Vector_2',
                                          d: 'M15.3333 4.00016H2C1.63267 4.00016 1.33333 3.70083 1.33333 3.3335C1.33333 2.96616 1.63267 2.66683 2 2.66683H2.66667V1.3335H2C0.895333 1.3335 0 2.22883 0 3.3335V13.3335C0 14.8062 1.194 16.0002 2.66667 16.0002H15.3333C15.7013 16.0002 16 15.7015 16 15.3335V4.66683C16 4.29883 15.7013 4.00016 15.3333 4.00016ZM12 11.3335C11.2633 11.3335 10.6667 10.7368 10.6667 10.0002C10.6667 9.2635 11.2633 8.66683 12 8.66683C12.7367 8.66683 13.3333 9.2635 13.3333 10.0002C13.3333 10.7368 12.7367 11.3335 12 11.3335Z',
                                          fill: '#C6FC50'
                                        })
                                      ],
                                      -1
                                    )
                                  ])
                              ))
                            : rt('', !0),
                          !he(e).vaultContract || he(e).loading.connect
                            ? (Ce(),
                              qe(
                                'svg',
                                {
                                  key: 1,
                                  width: '16',
                                  height: '16',
                                  viewBox: '0 0 16 16',
                                  fill: 'none',
                                  xmlns: 'http://www.w3.org/2000/svg',
                                  class: tn([
                                    {loading: he(e).loading.connect},
                                    'button__connect--icon'
                                  ])
                                },
                                s[6] ||
                                  (s[6] = [
                                    ee(
                                      'path',
                                      {
                                        d: 'M13.8474 11.0386L12.9135 10.0486C13.4675 9.89287 13.9147 9.58656 14.255 9.12967C14.5953 8.67279 14.7654 8.14578 14.7654 7.54864C14.7654 6.83776 14.5227 6.23047 14.0373 5.72676C13.5519 5.22305 12.9663 4.97119 12.2804 4.97119H9.7637C9.5888 4.97119 9.44219 4.91011 9.32387 4.78795C9.20557 4.66578 9.14642 4.5144 9.14642 4.33381C9.14642 4.15321 9.20557 4.00192 9.32387 3.87994C9.44219 3.75797 9.5888 3.69698 9.7637 3.69698H12.2804C13.3095 3.69698 14.1867 4.07288 14.912 4.82467C15.6373 5.57648 16 6.48572 16 7.55238C16 8.30495 15.8043 8.99244 15.4128 9.61486C15.0213 10.2373 14.4995 10.7118 13.8474 11.0386ZM10.9983 8.05554L9.8935 6.91527H10.6343C10.8091 6.91527 10.9557 6.97664 11.0741 7.09938C11.1924 7.22212 11.2515 7.37421 11.2515 7.55565C11.2515 7.66237 11.229 7.75888 11.184 7.84518C11.139 7.93147 11.0771 8.00159 10.9983 8.05554ZM15.3194 15.8154C15.2002 15.9385 15.0556 16 14.8857 16C14.7158 16 14.5713 15.9385 14.4521 15.8154L0.174988 1.07982C0.0610207 0.962207 0.00272007 0.814366 8.62549e-05 0.636297C-0.00256128 0.458242 0.0557393 0.307675 0.174988 0.184597C0.294223 0.0615325 0.438781 0 0.608662 0C0.778543 0 0.923101 0.0615325 1.04234 0.184597L15.3194 14.9202C15.4334 15.0378 15.4917 15.1857 15.4943 15.3637C15.497 15.5418 15.4387 15.6923 15.3194 15.8154ZM4.09721 11.4078C3.06374 11.4078 2.1828 11.0319 1.45438 10.2801C0.72597 9.52827 0.361763 8.61904 0.361763 7.55238C0.361763 6.60813 0.656434 5.7796 1.24578 5.06678C1.83512 4.35396 2.57456 3.9235 3.46411 3.77539H3.65405L4.81266 4.97119H4.09721C3.40604 4.97119 2.81644 5.22305 2.3284 5.72676C1.84036 6.23047 1.59634 6.83901 1.59634 7.55238C1.59634 8.26575 1.84036 8.87428 2.3284 9.378C2.81644 9.88171 3.40728 10.1336 4.10094 10.1336H6.59806C6.77296 10.1336 6.91957 10.1946 7.03789 10.3168C7.15619 10.439 7.21534 10.5904 7.21534 10.7709C7.21534 10.9515 7.15619 11.1028 7.03789 11.2248C6.91957 11.3468 6.77296 11.4078 6.59806 11.4078H4.09721ZM5.7275 8.18948C5.55262 8.18948 5.40601 8.1284 5.2877 8.00624C5.16938 7.88407 5.11022 7.73269 5.11022 7.5521C5.11022 7.3715 5.16938 7.22021 5.2877 7.09823C5.40601 6.97626 5.55262 6.91527 5.7275 6.91527H6.70889L7.92289 8.18948H5.7275Z',
                                        fill: '#F8F8F8'
                                      },
                                      null,
                                      -1
                                    )
                                  ]),
                                2
                              ))
                            : rt('', !0),
                          ee(
                            'span',
                            null,
                            Ft(
                              !he(e).vaultContract || he(e).loading.connect
                                ? 'Connect'
                                : 'Connected'
                            ),
                            1
                          )
                        ],
                        2
                      )
                    ])
                  ])
                ])
              ])
            ],
            64
          )
        );
      }
    }),
    Wq = {class: 'naka'},
    Zq = {class: 'naka__wrap'},
    Yq = xt({
      __name: 'App',
      setup(t) {
        const e = Ei();
        return (
          Ic(() => {
            e.initializeWeb3();
          }),
          (n, r) => (
            Ce(),
            qe(
              Dt,
              null,
              [ke(zq), ee('main', Wq, [ee('div', Zq, [ke(he(qA))])])],
              64
            )
          )
        );
      }
    }),
    Qq = {class: 'home'},
    Jq = {class: 'home__box'},
    Xq = {class: 'home__box--button'},
    eV = {
      key: 0,
      width: '16',
      height: '16',
      viewBox: '0 0 16 16',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg'
    },
    tV = xt({
      __name: 'Metamask',
      setup(t) {
        const e = Ei();
        return (
          Ic(() => {
            (e.updateFirstSign(!!sessionStorage.getItem('firstSign')),
              e.connectMobile(),
              e.checkConnection(),
              e.getEstimatedGas(),
              e.getLastNetworkBlock(),
              e.estimateBlocksPerHour());
          }),
          (n, r) => (
            Ce(),
            qe('div', Qq, [
              ee('div', Jq, [
                r[3] ||
                  (r[3] = Js(
                    '<div class="home__box--title-wrap"><h1 class="home__box--title">NAKA Web Wallet</h1><svg width="48" height="48" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M44.2744 2.89074L26.6952 15.9319L29.9642 8.2463L44.2744 2.89074Z" fill="#E17726"></path><path d="M3.7258 2.89074L21.1485 16.0536L18.0361 8.2463L3.7258 2.89074Z" fill="#E27625"></path><path d="M37.9454 33.1296L33.268 40.2935L43.2835 43.0583L46.1525 33.2861L37.9454 33.1296Z" fill="#E27625"></path><path d="M1.8653 33.2861L4.71692 43.0583L14.715 40.2935L10.055 33.1296L1.8653 33.2861Z" fill="#E27625"></path><path d="M14.1763 21.0275L11.3942 25.2354L21.3053 25.6875L20.975 14.9938L14.1763 21.0275Z" fill="#E27625"></path><path d="M33.8245 21.027L26.9215 14.8716L26.6954 25.687L36.6066 25.2349L33.8245 21.027Z" fill="#E27625"></path><path d="M14.715 40.2935L20.7138 37.3889L15.5496 33.3548L14.715 40.2935Z" fill="#E27625"></path><path d="M27.2865 37.3889L33.268 40.2935L32.4507 33.3548L27.2865 37.3889Z" fill="#E27625"></path><path d="M33.268 40.2935L27.2865 37.3889L27.7731 41.2837L27.721 42.9356L33.268 40.2935Z" fill="#D5BFB2"></path><path d="M14.715 40.2935L20.279 42.9356L20.2443 41.2837L20.7138 37.3889L14.715 40.2935Z" fill="#D5BFB2"></path><path d="M20.3834 30.7819L15.4104 29.3213L18.9228 27.7042L20.3834 30.7819Z" fill="#233447"></path><path d="M27.6168 30.7819L29.0774 27.7042L32.6072 29.3213L27.6168 30.7819Z" fill="#233447"></path><path d="M14.715 40.2935L15.584 33.129L10.0546 33.2855L14.715 40.2935Z" fill="#CC6228"></path><path d="M32.4156 33.129L33.268 40.2935L37.9449 33.2855L32.4156 33.129Z" fill="#CC6228"></path><path d="M36.6066 25.2349L26.6954 25.687L27.6168 30.7819L29.0774 27.7042L32.6072 29.3213L36.6066 25.2349Z" fill="#CC6228"></path><path d="M15.4104 29.3213L18.9228 27.7042L20.3834 30.7819L21.3053 25.6875L11.3942 25.2354L15.4104 29.3213Z" fill="#CC6228"></path><path d="M11.3942 25.2354L15.5496 33.3548L15.4104 29.3213L11.3942 25.2354Z" fill="#E27525"></path><path d="M32.6072 29.3213L32.4507 33.3548L36.6066 25.2349L32.6072 29.3213Z" fill="#E27525"></path><path d="M21.3053 25.6875L20.3834 30.7819L21.5483 36.7982L21.8091 28.8692L21.3053 25.6875Z" fill="#E27525"></path><path d="M26.6954 25.687L26.2081 28.8518L26.4515 36.7982L27.6168 30.7819L26.6954 25.687Z" fill="#E27525"></path><path d="M27.6168 30.7819L26.4515 36.7982L27.2865 37.3889L32.4507 33.3548L32.6072 29.3213L27.6168 30.7819Z" fill="#F5841F"></path><path d="M15.4104 29.3213L15.5496 33.3548L20.7138 37.3889L21.5483 36.7982L20.3834 30.7819L15.4104 29.3213Z" fill="#F5841F"></path><path d="M27.721 42.9356L27.7731 41.2837L27.3211 40.9015H20.6789L20.2443 41.2837L20.279 42.9356L14.715 40.2935L16.6623 41.8926L20.6093 44.6226H27.3732L31.3377 41.8926L33.268 40.2935L27.721 42.9356Z" fill="#C0AC9D"></path><path d="M27.2865 37.3889L26.4515 36.7982H21.5483L20.7138 37.3889L20.2443 41.2837L20.6789 40.9015H27.3211L27.7731 41.2837L27.2865 37.3889Z" fill="#161616"></path><path d="M45.0221 16.7838L46.5 9.58514L44.2744 2.89074L27.2864 15.4971L33.8245 21.027L43.0572 23.7217L45.0916 21.3395L44.2048 20.6962L45.6133 19.4094L44.5352 18.5748L45.9436 17.4967L45.0221 16.7838Z" fill="#763E1A"></path><path d="M1.5 9.58531L2.99536 16.784L2.03903 17.4969L3.46484 18.575L2.38678 19.4096L3.79521 20.6963L2.90842 21.3397L4.94281 23.7219L14.1763 21.0275L20.7137 15.4973L3.7258 2.89074L1.5 9.58531Z" fill="#763E1A"></path><path d="M43.0572 23.7217L33.8245 21.027L36.6066 25.2349L32.4507 33.3548L37.9449 33.2855L46.1525 33.2861L43.0572 23.7217Z" fill="#F5841F"></path><path d="M14.1763 21.0275L4.94281 23.7219L1.8653 33.2861L10.0546 33.2855L15.5496 33.3548L11.3942 25.2354L14.1763 21.0275Z" fill="#F5841F"></path><path d="M26.6954 25.687L27.2864 15.4971L29.9642 8.2463L18.0361 8.2463L20.7137 15.4973L21.3053 25.6875L21.5311 28.8863L21.5483 36.7982H26.4515L26.4693 28.8863L26.6954 25.687Z" fill="#F5841F"></path></svg></div><p class="home__box--text"> Please connect your MetaMask wallet to gain access to its functionalities. </p><div class="external__form--info"><div class="info__icon"><svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_5979_7824)"><path d="M6 9.75C6.41421 9.75 6.75 9.41421 6.75 9C6.75 8.58579 6.41421 8.25 6 8.25C5.58579 8.25 5.25 8.58579 5.25 9C5.25 9.41421 5.58579 9.75 6 9.75Z" fill="#303030"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M6 2.25C6.20711 2.25 6.375 2.41789 6.375 2.625V6.75C6.375 6.95711 6.20711 7.125 6 7.125C5.79289 7.125 5.625 6.95711 5.625 6.75V2.625C5.625 2.41789 5.79289 2.25 6 2.25Z" fill="#303030"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 0.75C1.08579 0.75 0.75 1.08579 0.75 1.5V10.5C0.75 10.9142 1.08579 11.25 1.5 11.25H10.5C10.9142 11.25 11.25 10.9142 11.25 10.5V1.5C11.25 1.08579 10.9142 0.75 10.5 0.75H1.5ZM0 1.5C0 0.671573 0.671573 0 1.5 0H10.5C11.3284 0 12 0.671573 12 1.5V10.5C12 11.3284 11.3284 12 10.5 12H1.5C0.671573 12 0 11.3284 0 10.5V1.5Z" fill="#303030"></path></g><defs><clipPath id="clip0_5979_7824"><rect width="12" height="12" fill="white"></rect></clipPath></defs></svg></div><div class="info__detail"><div class="info__details--title">Please Switch to Polygon</div><div class="info__details--text"> To access this application, please switch your wallet to the Polygon network. </div></div></div>',
                    3
                  )),
                ee('div', Xq, [
                  ee(
                    'button',
                    {
                      id: 'connect',
                      class: tn([
                        'button__default home__button--connect',
                        {
                          connected:
                            he(e).vaultContract && !he(e).loading.connect
                        }
                      ]),
                      onClick:
                        r[0] ||
                        (r[0] = (...i) =>
                          he(e).connectMetamask && he(e).connectMetamask(...i))
                    },
                    [
                      he(e).vaultContract && !he(e).loading.connect
                        ? (Ce(),
                          qe(
                            'svg',
                            eV,
                            r[1] ||
                              (r[1] = [
                                ee(
                                  'g',
                                  {id: 'Group'},
                                  [
                                    ee('path', {
                                      id: 'Vector',
                                      d: 'M14.6667 0H4V2.66667H14.6667V0Z',
                                      fill: '#C6FC50'
                                    }),
                                    ee('path', {
                                      id: 'Vector_2',
                                      d: 'M15.3333 4.00016H2C1.63267 4.00016 1.33333 3.70083 1.33333 3.3335C1.33333 2.96616 1.63267 2.66683 2 2.66683H2.66667V1.3335H2C0.895333 1.3335 0 2.22883 0 3.3335V13.3335C0 14.8062 1.194 16.0002 2.66667 16.0002H15.3333C15.7013 16.0002 16 15.7015 16 15.3335V4.66683C16 4.29883 15.7013 4.00016 15.3333 4.00016ZM12 11.3335C11.2633 11.3335 10.6667 10.7368 10.6667 10.0002C10.6667 9.2635 11.2633 8.66683 12 8.66683C12.7367 8.66683 13.3333 9.2635 13.3333 10.0002C13.3333 10.7368 12.7367 11.3335 12 11.3335Z',
                                      fill: '#C6FC50'
                                    })
                                  ],
                                  -1
                                )
                              ])
                          ))
                        : rt('', !0),
                      !he(e).vaultContract || he(e).loading.connect
                        ? (Ce(),
                          qe(
                            'svg',
                            {
                              key: 1,
                              width: '22',
                              height: '22',
                              viewBox: '0 0 22 22',
                              fill: 'none',
                              xmlns: 'http://www.w3.org/2000/svg',
                              class: tn({loading: he(e).loading.connect})
                            },
                            r[2] ||
                              (r[2] = [
                                Js(
                                  '<g clip-path="url(#clip0_5859_1203)"><path fill-rule="evenodd" clip-rule="evenodd" d="M15.125 12.375C14.3656 12.375 13.75 12.9906 13.75 13.75C13.75 14.5094 14.3656 15.125 15.125 15.125C15.8844 15.125 16.5 14.5094 16.5 13.75C16.5 12.9906 15.8844 12.375 15.125 12.375ZM12.375 13.75C12.375 12.2312 13.6062 11 15.125 11C16.6438 11 17.875 12.2312 17.875 13.75C17.875 15.2688 16.6438 16.5 15.125 16.5C13.6062 16.5 12.375 15.2688 12.375 13.75Z" fill="#F8F8F8"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M3.4375 1.375C2.89049 1.375 2.36589 1.5923 1.97909 1.97909C1.5923 2.36589 1.375 2.89049 1.375 3.4375C1.375 3.98451 1.5923 4.50911 1.97909 4.89591C2.36589 5.2827 2.89049 5.5 3.4375 5.5H21.3125C21.6922 5.5 22 5.8078 22 6.1875V21.3125C22 21.6922 21.6922 22 21.3125 22H3.4375C2.52582 22 1.65148 21.6378 1.00682 20.9932C0.362164 20.3485 0 19.4742 0 18.5625V3.4375C0 2.52582 0.362164 1.65148 1.00682 1.00682C1.65148 0.362164 2.52582 0 3.4375 0H15.8125C16.1922 0 16.5 0.307804 16.5 0.6875V3.4375C16.5 3.8172 16.1922 4.125 15.8125 4.125C15.4328 4.125 15.125 3.8172 15.125 3.4375V1.375H3.4375ZM1.375 6.18752V18.5625C1.375 19.1095 1.5923 19.6341 1.97909 20.0209C2.36589 20.4077 2.89049 20.625 3.4375 20.625H20.625V6.875H3.4375C2.68944 6.875 1.96652 6.63117 1.375 6.18752Z" fill="#F8F8F8"></path></g><defs><clipPath id="clip0_5859_1203"><rect width="22" height="22" fill="white"></rect></clipPath></defs>',
                                  2
                                )
                              ]),
                            2
                          ))
                        : rt('', !0),
                      ee(
                        'span',
                        {class: 'button__text', ref: 'buttonText'},
                        Ft(
                          !he(e).vaultContract || he(e).loading.connect
                            ? 'Connect'
                            : 'Connected'
                        ),
                        513
                      )
                    ],
                    2
                  )
                ])
              ])
            ])
          )
        );
      }
    }),
    nV = {class: 'connected__form--step-amount'},
    rV = {class: 'connected__form--amount'},
    iV = ['required'],
    sV = {key: 0, class: 'error__text'},
    oV = {class: 'connected__form--submit'},
    aV = {key: 0, class: 'loader'},
    i6 = xt({
      __name: 'DefineAmount',
      props: {
        resetAmount: {type: Function},
        amountData: {},
        loading: {type: Boolean},
        setMax: {type: Function}
      },
      setup(t) {
        const e = t,
          n = Ei(),
          r = Pr(!1),
          i = (a) => {
            r.value = a;
          },
          s = (a) => {
            const c = parseFloat(a.target.value);
            c >= 0 || isNaN(c) || !c || ((a.target.value = 0), e.resetAmount());
          },
          o = () => {
            if (e.amountData.value) {
              if (n.contractBalance.usdt >= e.amountData.value) {
                i(!1);
                return;
              }
              i(!0);
            }
          };
        return (
          qs(
            () => e.amountData.value,
            () => {
              o();
            }
          ),
          (a, c) => (
            Ce(),
            qe('div', nV, [
              c[7] ||
                (c[7] = ee(
                  'div',
                  {class: 'modal__title'},
                  'Define amount',
                  -1
                )),
              ee('div', rV, [
                ee(
                  'div',
                  {class: tn(['amount__wrap', {error: r.value}])},
                  [
                    Iy(
                      ee(
                        'input',
                        {
                          type: 'number',
                          required: e.amountData.required,
                          min: '0',
                          onInput: s,
                          placeholder: '0.00000',
                          step: '0.00001',
                          'onUpdate:modelValue':
                            c[0] || (c[0] = (l) => (e.amountData.value = l))
                        },
                        null,
                        40,
                        iV
                      ),
                      [[AA, e.amountData.value]]
                    ),
                    c[4] ||
                      (c[4] = ee(
                        'span',
                        {class: 'amount__currency'},
                        'USD₮',
                        -1
                      )),
                    e.amountData.value
                      ? (Ce(),
                        qe(
                          'button',
                          {
                            key: 0,
                            type: 'reset',
                            'aria-label': 'Reset amount',
                            onClick:
                              c[1] ||
                              (c[1] = (...l) =>
                                e.resetAmount && e.resetAmount(...l))
                          },
                          c[3] ||
                            (c[3] = [
                              Js(
                                '<svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_5958_7667)"><path d="M7 0C10.866 1.28851e-07 14 3.13401 14 7C14 10.866 10.866 14 7 14C3.13401 14 1.28855e-07 10.866 0 7C0 3.13401 3.13401 0 7 0ZM9.93457 4.06543C9.76372 3.89458 9.48628 3.89458 9.31543 4.06543L7 6.38086L4.68457 4.06543C4.51372 3.89458 4.23628 3.89458 4.06543 4.06543C3.89458 4.23628 3.89458 4.51372 4.06543 4.68457L6.38086 7L4.06543 9.31543C3.89458 9.48628 3.89458 9.76372 4.06543 9.93457C4.23628 10.1054 4.51372 10.1054 4.68457 9.93457L7 7.61914L9.31543 9.93457C9.48628 10.1054 9.76372 10.1054 9.93457 9.93457C10.1054 9.76372 10.1054 9.48628 9.93457 9.31543L7.61914 7L9.93457 4.68457C10.1054 4.51372 10.1054 4.23628 9.93457 4.06543Z" fill="#939393"></path></g><defs><clipPath id="clip0_5958_7667"><rect width="14" height="14" fill="white"></rect></clipPath></defs></svg>',
                                1
                              )
                            ])
                        ))
                      : rt('', !0)
                  ],
                  2
                ),
                ee(
                  'button',
                  {
                    type: 'button',
                    'aria-label': 'Set max amount',
                    class: 'amount__max',
                    onClick:
                      c[2] || (c[2] = (...l) => e.setMax && e.setMax(...l))
                  },
                  ' MAX '
                ),
                r.value
                  ? (Ce(),
                    qe(
                      'div',
                      sV,
                      ' The entered amount is higher than your balance '
                    ))
                  : rt('', !0)
              ]),
              ee('div', oV, [
                ee(
                  'button',
                  {
                    class: tn([
                      'submit__button',
                      {
                        active: e.amountData.value && !r.value,
                        loading: e.loading
                      }
                    ]),
                    type: 'submit',
                    'aria-label': 'Submit form'
                  },
                  [
                    c[6] || (c[6] = Mr(' Confirm ')),
                    e.loading
                      ? (Ce(),
                        qe(
                          'span',
                          aV,
                          c[5] ||
                            (c[5] = [
                              ee('span', null, null, -1),
                              ee('span', null, null, -1)
                            ])
                        ))
                      : rt('', !0)
                  ],
                  2
                )
              ])
            ])
          )
        );
      }
    }),
    cV = {class: 'connected__form--step-process'},
    lV = {class: 'process__statement'},
    uV = {class: 'statement__value'},
    s6 = xt({
      __name: 'Processing',
      props: {amountData: {}},
      setup(t) {
        const e = t;
        return (n, r) => (
          Ce(),
          qe('div', cV, [
            r[1] ||
              (r[1] = ee(
                'div',
                {class: 'modal__title'},
                'Withdraw processing',
                -1
              )),
            r[2] ||
              (r[2] = ee(
                'div',
                {class: 'process__description'},
                [
                  Mr(' During this period, your selected '),
                  ee('b', null, 'funds will be reserved for 1h'),
                  Mr(
                    ' this is done to provide an extra layer of security. After the Token Reservation Period ends you can complete the withdraw of reserved funds by pressing on the complete withdraw button. '
                  )
                ],
                -1
              )),
            ee('div', lV, [
              r[0] ||
                (r[0] = ee('div', {class: 'statement__label'}, 'Amount:', -1)),
              ee('div', uV, Ft(he(Vu)(e.amountData.value)) + ' USD₮ ', 1)
            ]),
            r[3] ||
              (r[3] = ee(
                'div',
                {class: 'process__button'},
                [
                  ee(
                    'button',
                    {type: 'submit', 'aria-label': 'Close the modal'},
                    'I understand'
                  )
                ],
                -1
              ))
          ])
        );
      }
    }),
    dV = {class: 'withdraw__fail'},
    fV = {class: 'withdraw__fail--buttons'},
    hV = {key: 0, class: 'loader'},
    o6 = xt({
      __name: 'Unsuccessful',
      props: {cancelForm: {type: Function}, loading: {type: Boolean}},
      setup(t) {
        const e = t;
        return (n, r) => (
          Ce(),
          qe('div', dV, [
            r[3] ||
              (r[3] = ee(
                'div',
                {class: 'withdraw__fail--title modal__title'},
                'Withdraw un-successful',
                -1
              )),
            r[4] ||
              (r[4] = ee(
                'div',
                {class: 'withdraw__fail--description'},
                ' Oops! It seems there was an issue processing your withdrawal request. Please double-check your details and try again. If the problem persists, feel free to reach out to our support team for assistance. ',
                -1
              )),
            ee('div', fV, [
              ee(
                'button',
                {
                  type: 'button',
                  class: 'button__cancel',
                  'aria-label': 'Close the modal',
                  onClick:
                    r[0] ||
                    (r[0] = (...i) => e.cancelForm && e.cancelForm(...i))
                },
                ' Cancel '
              ),
              ee(
                'button',
                {
                  type: 'submit',
                  class: tn(['button__submit', {loading: e.loading}]),
                  'aria-label': 'Retry to submit the form'
                },
                [
                  r[2] || (r[2] = ee('span', {class: 'text'}, 'Re-Try', -1)),
                  e.loading
                    ? (Ce(),
                      qe(
                        'span',
                        hV,
                        r[1] ||
                          (r[1] = [
                            ee('span', null, null, -1),
                            ee('span', null, null, -1)
                          ])
                      ))
                    : rt('', !0)
                ],
                2
              )
            ])
          ])
        );
      }
    }),
    pV = xt({
      __name: 'ConnectedWallet',
      setup(t) {
        const e = Ei(),
          n = () => {
            e.updateFormField(null, 'connected', 'amount');
          },
          r = () => {
            (e.updateModal({withdrawConnected: !1}),
              e.updateError({connected: !1}),
              e.updateLoading({withdrawConnected: !1}),
              e.updateWallet('connected', {step: 1}),
              e.updateFormField(null, 'connected', 'amount'));
          },
          i = () => {
            e.updateFormField(e.contractBalance.usdt, 'connected', 'amount');
          };
        return (s, o) => (
          Ce(),
          qe(
            'form',
            {
              class: 'connected__form',
              onSubmit:
                o[0] ||
                (o[0] = SA(
                  (...a) =>
                    he(e).submitConnectedForm &&
                    he(e).submitConnectedForm(...a),
                  ['prevent']
                ))
            },
            [
              he(e).wallets.connected.step === 1 && !he(e).error.connected
                ? (Ce(),
                  Sn(
                    i6,
                    {
                      key: 0,
                      resetAmount: n,
                      amountData: he(e).form.connected.amount,
                      setMax: i,
                      loading: he(e).loading.withdrawConnected
                    },
                    null,
                    8,
                    ['amountData', 'loading']
                  ))
                : rt('', !0),
              he(e).wallets.connected.step === 2 && !he(e).error.connected
                ? (Ce(),
                  Sn(
                    s6,
                    {key: 1, amountData: he(e).form.connected.amount},
                    null,
                    8,
                    ['amountData']
                  ))
                : rt('', !0),
              he(e).error.connected
                ? (Ce(),
                  Sn(
                    o6,
                    {
                      key: 2,
                      cancelForm: r,
                      loading: he(e).loading.withdrawConnected
                    },
                    null,
                    8,
                    ['loading']
                  ))
                : rt('', !0)
            ],
            32
          )
        );
      }
    }),
    mV = {class: 'connected__form--step-process external__form--step-address'},
    gV = {class: 'external__form--address'},
    yV = {class: 'address__input'},
    vV = ['required'],
    bV = {key: 0, class: 'error'},
    wV = {class: 'process__statement'},
    _V = {class: 'statement__value'},
    EV = {class: 'connected__form--submit'},
    AV = {key: 0, class: 'loader'},
    SV = xt({
      __name: 'DefineAddress',
      props: {
        form: {},
        resetAddress: {type: Function},
        onAddressChange: {type: Function},
        errorActive: {type: Boolean},
        loading: {type: Boolean}
      },
      setup(t) {
        const e = t,
          n = () => {
            e.form.address.value && r6(e.form.address.value);
          };
        return (r, i) => (
          Ce(),
          qe('div', mV, [
            i[8] ||
              (i[8] = Js(
                '<div class="modal__title">Define address</div><div class="process__description external__form--description"><div class="process__description--text"> You are about to withdraw USD₮ funds from your balance to an external wallet. Make sure the selected wallet supports the selected currency and blockchain network. </div><div class="external__form--info"><div class="info__icon"><svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_5979_7824)"><path d="M6 9.75C6.41421 9.75 6.75 9.41421 6.75 9C6.75 8.58579 6.41421 8.25 6 8.25C5.58579 8.25 5.25 8.58579 5.25 9C5.25 9.41421 5.58579 9.75 6 9.75Z" fill="#303030"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M6 2.25C6.20711 2.25 6.375 2.41789 6.375 2.625V6.75C6.375 6.95711 6.20711 7.125 6 7.125C5.79289 7.125 5.625 6.95711 5.625 6.75V2.625C5.625 2.41789 5.79289 2.25 6 2.25Z" fill="#303030"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 0.75C1.08579 0.75 0.75 1.08579 0.75 1.5V10.5C0.75 10.9142 1.08579 11.25 1.5 11.25H10.5C10.9142 11.25 11.25 10.9142 11.25 10.5V1.5C11.25 1.08579 10.9142 0.75 10.5 0.75H1.5ZM0 1.5C0 0.671573 0.671573 0 1.5 0H10.5C11.3284 0 12 0.671573 12 1.5V10.5C12 11.3284 11.3284 12 10.5 12H1.5C0.671573 12 0 11.3284 0 10.5V1.5Z" fill="#303030"></path></g><defs><clipPath id="clip0_5979_7824"><rect width="12" height="12" fill="white"></rect></clipPath></defs></svg></div><div class="info__detail"><div class="info__details--title">Only USD₮ from Polygon</div><div class="info__details--text"> Deposit USD₮ from the Polygon network only. </div></div></div></div>',
                2
              )),
            ee('div', gV, [
              ee('div', yV, [
                Iy(
                  ee(
                    'input',
                    {
                      type: 'text',
                      'onUpdate:modelValue':
                        i[0] || (i[0] = (s) => (e.form.address.value = s)),
                      required: e.form.address.required,
                      placeholder: 'Paste or enter the Withdrawal Address',
                      onInput:
                        i[1] ||
                        (i[1] = (...s) =>
                          e.onAddressChange && e.onAddressChange(...s)),
                      class: tn({error: e.errorActive})
                    },
                    null,
                    42,
                    vV
                  ),
                  [[AA, e.form.address.value]]
                ),
                e.errorActive
                  ? (Ce(), qe('small', bV, 'Invalid withdrawal address '))
                  : rt('', !0),
                e.form.address.value
                  ? (Ce(),
                    qe(
                      'button',
                      {
                        key: 1,
                        type: 'reset',
                        class: 'reset',
                        'aria-label': 'Clear address',
                        onClick:
                          i[2] ||
                          (i[2] = (...s) =>
                            e.resetAddress && e.resetAddress(...s))
                      },
                      i[3] ||
                        (i[3] = [
                          Js(
                            '<svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_5958_7667)"><path d="M7 0C10.866 1.28851e-07 14 3.13401 14 7C14 10.866 10.866 14 7 14C3.13401 14 1.28855e-07 10.866 0 7C0 3.13401 3.13401 0 7 0ZM9.93457 4.06543C9.76372 3.89458 9.48628 3.89458 9.31543 4.06543L7 6.38086L4.68457 4.06543C4.51372 3.89458 4.23628 3.89458 4.06543 4.06543C3.89458 4.23628 3.89458 4.51372 4.06543 4.68457L6.38086 7L4.06543 9.31543C3.89458 9.48628 3.89458 9.76372 4.06543 9.93457C4.23628 10.1054 4.51372 10.1054 4.68457 9.93457L7 7.61914L9.31543 9.93457C9.48628 10.1054 9.76372 10.1054 9.93457 9.93457C10.1054 9.76372 10.1054 9.48628 9.93457 9.31543L7.61914 7L9.93457 4.68457C10.1054 4.51372 10.1054 4.23628 9.93457 4.06543Z" fill="#939393"></path></g><defs><clipPath id="clip0_5958_7667"><rect width="14" height="14" fill="white"></rect></clipPath></defs></svg>',
                            1
                          )
                        ])
                    ))
                  : rt('', !0)
              ]),
              ee(
                'button',
                {
                  type: 'button',
                  'aria-label': 'Copy address to clipboard',
                  onClick: n,
                  class: 'address__copy'
                },
                i[4] ||
                  (i[4] = [
                    ee(
                      'svg',
                      {
                        width: '20',
                        height: '20',
                        viewBox: '0 0 20 20',
                        fill: 'none',
                        xmlns: 'http://www.w3.org/2000/svg'
                      },
                      [
                        ee('path', {
                          'fill-rule': 'evenodd',
                          'clip-rule': 'evenodd',
                          d: 'M1.0415 1.66675C1.0415 1.32157 1.32133 1.04175 1.6665 1.04175H13.8887C14.2339 1.04175 14.5137 1.32157 14.5137 1.66675V13.889C14.5137 14.2342 14.2339 14.514 13.8887 14.514H1.6665C1.32133 14.514 1.0415 14.2342 1.0415 13.889V1.66675ZM2.2915 2.29175V13.264H13.2637V2.29175H2.2915Z'
                        }),
                        ee('path', {
                          'fill-rule': 'evenodd',
                          'clip-rule': 'evenodd',
                          d: 'M14.7452 6.11119C14.7452 5.76602 15.025 5.48619 15.3702 5.48619H16.111C16.4561 5.48619 16.736 5.76602 16.736 6.11119C16.736 6.45637 16.4561 6.73619 16.111 6.73619H15.3702C15.025 6.73619 14.7452 6.45637 14.7452 6.11119ZM16.9674 6.11119C16.9674 5.76602 17.2473 5.48619 17.5924 5.48619H18.3332C18.6784 5.48619 18.9582 5.76602 18.9582 6.11119V7.12971C18.9582 7.47489 18.6784 7.75471 18.3332 7.75471C17.988 7.75471 17.7082 7.47489 17.7082 7.12971V6.73619H17.5924C17.2473 6.73619 16.9674 6.45637 16.9674 6.11119ZM18.3332 8.54175C18.6784 8.54175 18.9582 8.82157 18.9582 9.16675V11.2038C18.9582 11.549 18.6784 11.8288 18.3332 11.8288C17.988 11.8288 17.7082 11.549 17.7082 11.2038V9.16675C17.7082 8.82157 17.988 8.54175 18.3332 8.54175ZM18.3332 12.6158C18.6784 12.6158 18.9582 12.8956 18.9582 13.2408V15.2779C18.9582 15.623 18.6784 15.9029 18.3332 15.9029C17.988 15.9029 17.7082 15.623 17.7082 15.2779V13.2408C17.7082 12.8956 17.988 12.6158 18.3332 12.6158ZM6.11095 14.7455C6.45613 14.7455 6.73595 15.0253 6.73595 15.3705V16.1112C6.73595 16.4564 6.45613 16.7362 6.11095 16.7362C5.76577 16.7362 5.48595 16.4564 5.48595 16.1112V15.3705C5.48595 15.0253 5.76577 14.7455 6.11095 14.7455ZM18.3332 16.6899C18.6784 16.6899 18.9582 16.9697 18.9582 17.3149V18.3334C18.9582 18.6786 18.6784 18.9584 18.3332 18.9584H17.3147C16.9695 18.9584 16.6897 18.6786 16.6897 18.3334C16.6897 17.9882 16.9695 17.7084 17.3147 17.7084H17.7082V17.3149C17.7082 16.9697 17.988 16.6899 18.3332 16.6899ZM6.11095 16.9677C6.45613 16.9677 6.73595 17.2475 6.73595 17.5927V17.7084H7.12947C7.47465 17.7084 7.75447 17.9882 7.75447 18.3334C7.75447 18.6786 7.47465 18.9584 7.12947 18.9584H6.11095C5.76577 18.9584 5.48595 18.6786 5.48595 18.3334V17.5927C5.48595 17.2475 5.76577 16.9677 6.11095 16.9677ZM8.5415 18.3334C8.5415 17.9882 8.82133 17.7084 9.1665 17.7084H11.2035C11.5487 17.7084 11.8285 17.9882 11.8285 18.3334C11.8285 18.6786 11.5487 18.9584 11.2035 18.9584H9.1665C8.82133 18.9584 8.5415 18.6786 8.5415 18.3334ZM12.6156 18.3334C12.6156 17.9882 12.8954 17.7084 13.2406 17.7084H15.2776C15.6228 17.7084 15.9026 17.9882 15.9026 18.3334C15.9026 18.6786 15.6228 18.9584 15.2776 18.9584H13.2406C12.8954 18.9584 12.6156 18.6786 12.6156 18.3334Z'
                        })
                      ],
                      -1
                    )
                  ])
              )
            ]),
            ee('div', wV, [
              i[5] ||
                (i[5] = ee('div', {class: 'statement__label'}, 'Amount:', -1)),
              ee('div', _V, Ft(he(Vu)(e.form.amount.value)) + ' USD₮ ', 1)
            ]),
            ee('div', EV, [
              ee(
                'button',
                {
                  class: tn([
                    'submit__button',
                    {active: e.form.address.value, loading: e.loading}
                  ]),
                  type: 'submit',
                  'aria-label': 'Submit form'
                },
                [
                  i[7] || (i[7] = Mr(' Confirm ')),
                  e.loading
                    ? (Ce(),
                      qe(
                        'span',
                        AV,
                        i[6] ||
                          (i[6] = [
                            ee('span', null, null, -1),
                            ee('span', null, null, -1)
                          ])
                      ))
                    : rt('', !0)
                ],
                2
              )
            ])
          ])
        );
      }
    }),
    xV = xt({
      __name: 'ExternalWallet',
      setup(t) {
        const e = Ei(),
          n = () => {
            e.updateFormField(null, 'external', 'amount');
          },
          r = () => {
            e.updateFormField('', 'external', 'address');
          },
          i = () => {
            (e.updateError({externalAddress: !1}),
              !(
                e.form.external.address.value.startsWith('0x') ||
                e.form.external.address.value.length < 2
              ) && e.updateError({externalAddress: !0}));
          },
          s = () => {
            (e.updateModal({withdrawExternal: !1}),
              e.updateError({external: !1}),
              e.updateLoading({withdrawExternal: !1}),
              e.updateWallet('external', {step: 1}),
              e.updateFormField(null, 'external', 'amount'),
              e.updateFormField('', 'external', 'address'));
          },
          o = () => {
            e.updateFormField(e.contractBalance.usdt, 'external', 'amount');
          };
        return (a, c) => (
          Ce(),
          qe(
            'form',
            {
              class: 'connected__form external__form',
              onSubmit:
                c[0] ||
                (c[0] = SA(
                  (...l) =>
                    he(e).submitExternalForm && he(e).submitExternalForm(...l),
                  ['prevent']
                ))
            },
            [
              he(e).wallets.external.step === 1 && !he(e).error.external
                ? (Ce(),
                  Sn(
                    i6,
                    {
                      key: 0,
                      amountData: he(e).form.external.amount,
                      resetAmount: n,
                      setMax: o
                    },
                    null,
                    8,
                    ['amountData']
                  ))
                : rt('', !0),
              he(e).wallets.external.step === 2 && !he(e).error.external
                ? (Ce(),
                  Sn(
                    SV,
                    {
                      key: 1,
                      form: he(e).form.external,
                      resetAddress: r,
                      onAddressChange: i,
                      errorActive: he(e).error.externalAddress,
                      loading: he(e).loading.withdrawExternal
                    },
                    null,
                    8,
                    ['form', 'errorActive', 'loading']
                  ))
                : rt('', !0),
              he(e).wallets.external.step === 3 && !he(e).error.external
                ? (Ce(),
                  Sn(
                    s6,
                    {key: 2, amountData: he(e).form.external.amount},
                    null,
                    8,
                    ['amountData']
                  ))
                : rt('', !0),
              he(e).error.external
                ? (Ce(),
                  Sn(
                    o6,
                    {
                      key: 3,
                      cancelForm: s,
                      loading: he(e).loading.withdrawExternal
                    },
                    null,
                    8,
                    ['loading']
                  ))
                : rt('', !0)
            ],
            32
          )
        );
      }
    }),
    CV = {
      key: 0,
      width: '12',
      height: '13',
      viewBox: '0 0 12 13',
      fill: 'none',
      xmlns: 'http://www.w3.org/2000/svg'
    },
    TV = xt({
      __name: 'NetworkIcon',
      props: {network: {}},
      setup(t) {
        const e = t;
        return (n, r) =>
          e.network === 'polygon'
            ? (Ce(),
              qe(
                'svg',
                CV,
                r[0] ||
                  (r[0] = [
                    Js(
                      '<path d="M11.8204 7.69268C11.0188 10.9069 7.76291 12.8629 4.54868 12.0621C1.33444 11.2604 -0.622576 8.00442 0.179965 4.79023C0.980472 1.57605 4.23641 -0.379961 7.45064 0.420783C10.6659 1.22254 12.6219 4.47849 11.8204 7.69268Z" fill="url(#paint0_linear_5942_3763)"></path><path d="M6.45856 6.29975C6.3131 6.30688 6.16154 6.31096 6.00592 6.31096C5.85029 6.31096 5.69975 6.30688 5.55328 6.29975V5.81177C4.73955 5.85456 4.09874 6.00839 3.92175 6.20399C4.13027 6.43525 4.98469 6.60844 6.00592 6.60844C7.02715 6.60844 7.88055 6.43525 8.08907 6.20399C7.91208 6.00839 7.27127 5.85354 6.45754 5.81177V6.29975H6.45856Z" fill="white"></path><path d="M10.1094 5.79548L8.71588 3.39936C8.65892 3.30156 8.55415 3.24146 8.43922 3.24146H3.65652C3.54565 3.24146 3.44291 3.29851 3.38494 3.39223L1.89581 5.79344C1.81851 5.91875 1.83783 6.07971 1.94362 6.18261L5.77425 9.92756C5.89834 10.0488 6.09771 10.0488 6.22282 9.92756L10.0585 6.17751C10.1613 6.07666 10.1826 5.91977 10.1104 5.79548H10.1094ZM8.14017 6.46073C8.13508 6.70625 7.41697 6.91 6.45982 6.95992V8.10399H5.55556V6.95992C4.59841 6.91 3.88029 6.70523 3.87521 6.46073V5.94931C3.88029 5.70379 4.59841 5.49902 5.55556 5.4491V4.98251H4.19256V4.31013H7.82282V4.98251H6.46083V5.4491C7.41798 5.49902 8.1361 5.70379 8.14119 5.94931V6.46073H8.14017Z" fill="white"></path><defs><linearGradient id="paint0_linear_5942_3763" x1="7.2" y1="0.241455" x2="3.6" y2="11.6415" gradientUnits="userSpaceOnUse"><stop stop-color="#1DC9C4"></stop><stop offset="1" stop-color="#009490"></stop></linearGradient></defs>',
                      4
                    )
                  ])
              ))
            : rt('', !0);
      }
    }),
    IV = {class: 'connect__withdraw--box'},
    kV = {class: 'box__title'},
    RV = {class: 'box__text'},
    PV = {class: 'box__chain'},
    MV = {class: 'box__chain--network'},
    OV = {class: 'box__button'},
    NV = {'aria-label': 'Withdraw to connected wallet', type: 'button'},
    LV = {class: 'button__text'},
    vE = xt({
      __name: 'WithdrawBox',
      props: {title: {}, description: {}, buttonText: {}},
      setup(t) {
        const e = t;
        return (n, r) => (
          Ce(),
          qe('div', IV, [
            ee('div', kV, Ft(e.title), 1),
            ee('div', RV, Ft(e.description), 1),
            ee('div', PV, [
              r[1] ||
                (r[1] = ee(
                  'div',
                  {class: 'box__chain--text'},
                  'Supported:',
                  -1
                )),
              ee('div', MV, [
                ke(TV, {network: 'polygon'}),
                r[0] || (r[0] = ee('span', null, 'USDt on Polygon', -1))
              ])
            ]),
            ee('div', OV, [
              ee('button', NV, [
                r[2] ||
                  (r[2] = Js(
                    '<svg class="arrow" width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_5950_10307)"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1402 0.859835C11.2866 1.00628 11.2866 1.24372 11.1402 1.39017L1.39017 11.1402C1.24372 11.2866 1.00628 11.2866 0.859835 11.1402C0.713388 10.9937 0.713388 10.7563 0.859835 10.6098L10.6098 0.859835C10.7563 0.713388 10.9937 0.713388 11.1402 0.859835Z" fill="#F8F8F8"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M5.25 1.125C5.25 0.917893 5.41789 0.75 5.625 0.75H10.875C11.0821 0.75 11.25 0.917893 11.25 1.125V6.375C11.25 6.58211 11.0821 6.75 10.875 6.75C10.6679 6.75 10.5 6.58211 10.5 6.375V1.5H5.625C5.41789 1.5 5.25 1.33211 5.25 1.125Z" fill="#F8F8F8"></path></g><defs><clipPath id="clip0_5950_10307"><rect width="12" height="12" fill="white"></rect></clipPath></defs></svg>',
                    1
                  )),
                ee('span', LV, Ft(e.buttonText), 1)
              ])
            ])
          ])
        );
      }
    }),
    BV = '/naka-web-wallet/img/cardbg.webp',
    DV = {class: 'connect__withdraw--card'},
    FV = {class: 'card__balance'},
    $V = {class: 'card__balance--value'},
    HV = {class: 'value__number'},
    jV = xt({
      __name: 'Card',
      props: {amount: {}},
      setup(t) {
        const e = t;
        return (n, r) => (
          Ce(),
          qe('div', DV, [
            r[2] ||
              (r[2] = ee(
                'img',
                {
                  class: 'card__image',
                  src: BV,
                  alt: 'Naka card',
                  width: '592',
                  height: '358'
                },
                null,
                -1
              )),
            r[3] ||
              (r[3] = ee(
                'div',
                {class: 'card__logo'},
                [
                  ee(
                    'svg',
                    {
                      width: '42',
                      height: '42',
                      viewBox: '0 0 42 42',
                      fill: 'none',
                      xmlns: 'http://www.w3.org/2000/svg'
                    },
                    [
                      ee('path', {
                        d: 'M18.0959 0.827637H0.344727V41.6552H9.22029V2.27361L23.4212 41.6552H41.1723V0.827637H32.2968V40.2092L18.0959 0.827637Z',
                        fill: '#F8F8F8'
                      })
                    ]
                  )
                ],
                -1
              )),
            ee('div', FV, [
              r[1] ||
                (r[1] = ee(
                  'div',
                  {class: 'card__balance--title'},
                  'Balance',
                  -1
                )),
              ee('div', $V, [
                ee('div', HV, Ft(he(Vu)(e.amount)), 1),
                r[0] ||
                  (r[0] = ee('div', {class: 'value__currency'}, 'USD₮', -1))
              ])
            ])
          ])
        );
      }
    }),
    a6 = (t, e) => {
      const n = t.__vccOpts || t;
      for (const [r, i] of e) n[r] = i;
      return n;
    },
    UV = {},
    KV = {class: 'history__list--empty loading'};
  function qV(t, e) {
    return (
      Ce(),
      qe('div', KV, e[0] || (e[0] = [ee('div', {class: 'loader'}, null, -1)]))
    );
  }
  const VV = a6(UV, [['render', qV]]),
    GV = '/naka-web-wallet/img/frame.png',
    zV = {},
    WV = {class: 'history__list--empty'};
  function ZV(t, e) {
    return (
      Ce(),
      qe(
        'div',
        WV,
        e[0] ||
          (e[0] = [
            ee(
              'div',
              {class: 'empty__image'},
              [ee('img', {width: '116', height: '90', src: GV, alt: 'Frame'})],
              -1
            ),
            ee('div', {class: 'empty__title'}, 'No Withdrawals Yet', -1),
            ee(
              'div',
              {class: 'empty__text'},
              [
                Mr(" It looks like you haven't made any withdrawals."),
                ee('br'),
                Mr(' Once you do, they’ll show up here. ')
              ],
              -1
            )
          ])
      )
    );
  }
  const YV = a6(zV, [['render', ZV]]),
    QV = {class: 'withdrawal__row--statement'},
    JV = {class: 'withdrawal__details'},
    XV = {class: 'withdrawal__details--address'},
    eG = {class: 'withdrawal__details--date'},
    tG = {class: 'withdrawal__amount'},
    nG = {class: 'withdrawal__row--button'},
    rG = xt({
      __name: 'Withdrawal',
      props: {withdrawal: {}},
      setup(t) {
        const e = t,
          n = Ei(),
          r = () => {
            e.withdrawal.status !== 'complete' &&
              n.updateModal({cancelWithdraw: !0});
          };
        return (i, s) => (
          Ce(),
          qe(
            'div',
            {
              class: tn([
                'withdrawal__row',
                `withdrawal__row--${e.withdrawal.status}`
              ])
            },
            [
              ee('div', QV, [
                s[1] ||
                  (s[1] = Js(
                    '<div class="withdrawal__icon"><div class="withdrawal__icon--status"></div><svg width="18" height="19" viewBox="0 0 18 19" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_5964_5147)"><path fill-rule="evenodd" clip-rule="evenodd" d="M16.8204 8.43721C16.9137 8.63314 16.8859 8.86525 16.7491 9.03366L9.43656 18.0337C9.32974 18.1651 9.16938 18.2415 8.99999 18.2415C8.83061 18.2415 8.67024 18.1651 8.56343 18.0337L1.25093 9.03366C1.11409 8.86525 1.08633 8.63314 1.17959 8.43721C1.27285 8.24127 1.4705 8.11645 1.68749 8.11645L5.62499 8.11645L5.62499 3.61645C5.62499 1.75217 7.13571 0.241455 8.99999 0.241455C10.8643 0.241455 12.375 1.75217 12.375 3.61645L12.375 8.11645L16.3125 8.11646C16.5295 8.11646 16.7271 8.24127 16.8204 8.43721Z" fill="#0C0C0C"></path></g><defs><clipPath id="clip0_5964_5147"><rect width="18" height="18" fill="white" transform="translate(0 0.241455)"></rect></clipPath></defs></svg></div>',
                    1
                  )),
                ee('div', JV, [
                  ee('span', XV, ' Withdraw: ' + Ft(e.withdrawal.address), 1),
                  ee('div', eG, Ft(he(Bq)(e.withdrawal.date)), 1)
                ]),
                ee(
                  'div',
                  tG,
                  ' -' + Ft(he(Vu)(e.withdrawal.amount)) + ' USD₮ ',
                  1
                )
              ]),
              ee('div', nG, [
                ['ready', 'pending'].includes(e.withdrawal.status)
                  ? (Ce(),
                    qe(
                      'button',
                      {
                        key: 0,
                        class: 'cancel',
                        type: 'button',
                        'aria-label': 'Cancel withdraw request',
                        onClick: r
                      },
                      ' Cancel withdraw '
                    ))
                  : rt('', !0),
                e.withdrawal.status === 'ready'
                  ? (Ce(),
                    qe(
                      'button',
                      {
                        key: 1,
                        type: 'button',
                        'aria-label': 'Complete withdraw',
                        onClick:
                          s[0] ||
                          (s[0] = (o) =>
                            he(n).updateModal({completeWithdraw: !0}))
                      },
                      ' Complete withdraw '
                    ))
                  : rt('', !0)
              ])
            ],
            2
          )
        );
      }
    }),
    iG = {class: 'withdraw__screen--row withdraw__screen--history'},
    sG = {class: 'history__list'},
    oG = {key: 1, class: 'history__list--grid'},
    aG = {class: 'history__selector'},
    cG = ['disabled', 'value'],
    lG = xt({
      __name: 'HistoryList',
      setup(t) {
        const e = [
            {
              text: 'Today',
              value: (Date.now() - new Date().setHours(0, 0, 0, 0)) / 36e5 / 24
            },
            {text: '2 days', value: 2},
            {text: '5 days', value: 5},
            {text: '10 days', value: 10}
          ],
          n = Ei(),
          r = Pr(2),
          i = () => {
            n.loading.history ||
              (n.updateOffsetDays(r.value), n.getWithdrawalHistory());
          };
        return (
          qs(r, () => {
            i();
          }),
          (s, o) => (
            Ce(),
            qe('div', iG, [
              o[2] ||
                (o[2] = ee(
                  'div',
                  {class: 'history__title'},
                  'Withdrawal History',
                  -1
                )),
              ee('div', sG, [
                !he(n).withdrawals.length && !he(n).loading.history
                  ? (Ce(), Sn(YV, {key: 0}))
                  : rt('', !0),
                he(n).withdrawals.length && !he(n).loading.history
                  ? (Ce(),
                    qe('div', oG, [
                      (Ce(!0),
                      qe(
                        Dt,
                        null,
                        B1(
                          he(n).withdrawals,
                          (a) => (
                            Ce(),
                            Sn(rG, {withdrawal: a}, null, 8, ['withdrawal'])
                          )
                        ),
                        256
                      ))
                    ]))
                  : rt('', !0),
                he(n).loading.history ? (Ce(), Sn(VV, {key: 2})) : rt('', !0)
              ]),
              ee('div', aG, [
                o[1] || (o[1] = ee('label', {for: 'days'}, 'Sort by time', -1)),
                Iy(
                  ee(
                    'select',
                    {
                      id: 'days',
                      class: 'history__selector--select',
                      'onUpdate:modelValue':
                        o[0] || (o[0] = (a) => (r.value = a))
                    },
                    [
                      (Ce(),
                      qe(
                        Dt,
                        null,
                        B1(e, (a) =>
                          ee(
                            'option',
                            {disabled: he(n).loading.history, value: a.value},
                            Ft(a.text),
                            9,
                            cG
                          )
                        ),
                        64
                      ))
                    ],
                    512
                  ),
                  [[Ck, r.value]]
                )
              ])
            ])
          )
        );
      }
    }),
    uG = {class: 'complete__button'},
    dG = {key: 0, class: 'loader'},
    fG = {class: 'cancel__button'},
    hG = {key: 0, class: 'loader'},
    pG = {class: 'complete__description'},
    mG = {key: 0, class: 'process__statement'},
    gG = {class: 'statement__value'},
    yG = {class: 'overtime__buttons'},
    vG = {class: 'cancel__button'},
    bG = {key: 0, class: 'loader'},
    wG = {class: 'complete__button'},
    _G = {key: 0, class: 'loader'},
    EG = {class: 'withdraw__screen--wrap'},
    AG = {class: 'withdraw__screen'},
    SG = {class: 'withdraw__screen--row withdraw__screen--connect'},
    xG = xt({
      __name: 'Withdraw',
      setup(t) {
        const e = Ei(),
          n = async () => {
            if (e.chainId !== Rg.POLYGON)
              try {
                (await e.provider.request({
                  method: 'wallet_switchEthereumChain',
                  params: [{chainId: Yd.chainId}]
                }),
                  e.updateChain(Rg.POLYGON),
                  await e.getBalance());
              } catch (u) {
                $e.error(u.message);
              }
          },
          r = () => {
            (e.updateModal({withdrawConnected: !1}), e.resetConnectedForm());
          },
          i = () => {
            (e.updateModal({withdrawExternal: !1}), e.resetExternalForm());
          },
          s = () => {
            if (e.activeRequest) {
              Wh(
                'You can not create multiple withdrawal requests. Confirm or cancel the existing withdrawal to create a new one.',
                5e3,
                'toast__wide toast__withdrawal'
              );
              return;
            }
            e.updateModal({withdrawConnected: !0});
          },
          o = () => {
            if (e.activeRequest) {
              Wh(
                'You can not create multiple withdrawal requests. Confirm or cancel the existing withdrawal to create a new one.',
                5e3,
                'toast__wide toast__withdrawal'
              );
              return;
            }
            e.updateModal({withdrawExternal: !0});
          },
          a = () => {
            (e.updateModal({cancelWithdraw: !1}),
              e.updateLoading({cancelWithdraw: !1}));
          },
          c = () => {
            (e.updateModal({completeWithdraw: !1}),
              e.updateLoading({completeWithdraw: !1}));
          },
          l = () => {
            (e.updateModal({overtime: !1}),
              e.updateLoading({completeWithdraw: !1}),
              e.updateLoading({cancelWithdraw: !1}));
          };
        return (
          Ic(() => {
            n();
          }),
          (u, d) => (
            Ce(),
            qe(
              Dt,
              null,
              [
                ke(
                  ka,
                  {
                    class: 'modal__withdraw--connected',
                    wrapClass: 'modal__withdraw--wrap',
                    backdropClass: 'modal__withdraw--backdrop',
                    closeModal: r,
                    active: he(e).modal.withdrawConnected
                  },
                  {default: Ns(() => [ke(pV)]), _: 1},
                  8,
                  ['active']
                ),
                ke(
                  ka,
                  {
                    class:
                      'modal__withdraw--connected modal__withdraw--external',
                    wrapClass: 'modal__withdraw--wrap',
                    backdropClass: 'modal__withdraw--backdrop',
                    closeModal: i,
                    active: he(e).modal.withdrawExternal
                  },
                  {default: Ns(() => [ke(xV)]), _: 1},
                  8,
                  ['active']
                ),
                ke(
                  ka,
                  {
                    closeModal: c,
                    wrapClass: 'modal__withdraw--wrap-complete',
                    class: 'modal__withdrawal--complete',
                    active: he(e).modal.completeWithdraw
                  },
                  {
                    default: Ns(() => [
                      d[6] ||
                        (d[6] = ee(
                          'div',
                          {class: 'modal__title'},
                          'Complete Withdrawal',
                          -1
                        )),
                      d[7] ||
                        (d[7] = ee(
                          'div',
                          {class: 'complete__description'},
                          ' Please note that a small gas fee is required to complete your withdrawal. This fee ensures the secure and timely processing of your transaction. You can complete the withdrawal process after confirming the payment of the gas fee. Thank you for your understanding. ',
                          -1
                        )),
                      ee('div', uG, [
                        ee(
                          'button',
                          {
                            type: 'button',
                            'aria-label': 'Complete withdrawal',
                            onClick:
                              d[0] ||
                              (d[0] = (...f) =>
                                he(e).completeWithdraw &&
                                he(e).completeWithdraw(...f))
                          },
                          [
                            d[5] || (d[5] = Mr(' Complete withdrawal ')),
                            he(e).loading.withdraw
                              ? (Ce(),
                                qe(
                                  'span',
                                  dG,
                                  d[4] ||
                                    (d[4] = [
                                      ee('span', null, null, -1),
                                      ee('span', null, null, -1)
                                    ])
                                ))
                              : rt('', !0)
                          ]
                        )
                      ])
                    ]),
                    _: 1,
                    __: [6, 7]
                  },
                  8,
                  ['active']
                ),
                ke(
                  ka,
                  {
                    closeModal: a,
                    wrapClass: 'modal__withdraw--wrap-complete',
                    class:
                      'modal__withdrawal--complete modal__withdrawal--cancel',
                    active: he(e).modal.cancelWithdraw
                  },
                  {
                    default: Ns(() => [
                      d[10] ||
                        (d[10] = ee(
                          'div',
                          {class: 'modal__title'},
                          'Cancel Withdrawal Request',
                          -1
                        )),
                      d[11] ||
                        (d[11] = ee(
                          'div',
                          {class: 'complete__description'},
                          ' Please note that a small gas fee is required to complete your cancellation. This fee ensures the secure and timely processing of your transaction. You can cancel the withdrawal after confirming the payment of the gas fee. Thank you for your understanding. ',
                          -1
                        )),
                      ee('div', fG, [
                        ee(
                          'button',
                          {
                            type: 'button',
                            'aria-label': 'Cancel withdrawal request',
                            onClick:
                              d[1] ||
                              (d[1] = (...f) =>
                                he(e).cancelWithdrawRequest &&
                                he(e).cancelWithdrawRequest(...f))
                          },
                          [
                            d[9] || (d[9] = Mr(' Cancel withdrawal request ')),
                            he(e).loading.cancelWithdraw
                              ? (Ce(),
                                qe(
                                  'span',
                                  hG,
                                  d[8] ||
                                    (d[8] = [
                                      ee('span', null, null, -1),
                                      ee('span', null, null, -1)
                                    ])
                                ))
                              : rt('', !0)
                          ]
                        )
                      ])
                    ]),
                    _: 1,
                    __: [10, 11]
                  },
                  8,
                  ['active']
                ),
                ke(
                  ka,
                  {
                    closeModal: l,
                    wrapClass:
                      'modal__withdraw--wrap-complete modal__withdraw--wrap-overtime',
                    class:
                      'modal__withdrawal--complete modal__withdrawal--cancel modal__withdrawal--overtime',
                    active: he(e).modal.overtime
                  },
                  {
                    default: Ns(() => [
                      d[17] ||
                        (d[17] = ee(
                          'div',
                          {class: 'modal__title'},
                          'Withdrawal Request',
                          -1
                        )),
                      ee('div', pG, Ft(he(e).thresholdPrompt), 1),
                      he(e).activeRequest
                        ? (Ce(),
                          qe('div', mG, [
                            d[12] ||
                              (d[12] = ee(
                                'div',
                                {class: 'statement__label'},
                                'Amount:',
                                -1
                              )),
                            ee(
                              'div',
                              gG,
                              Ft(he(Vu)(he(e).activeRequest.amount)) + ' USD₮ ',
                              1
                            )
                          ]))
                        : rt('', !0),
                      ee('div', yG, [
                        ee('div', vG, [
                          ee(
                            'button',
                            {
                              type: 'button',
                              'aria-label': 'Cancel withdrawal request',
                              onClick:
                                d[2] ||
                                (d[2] = (...f) =>
                                  he(e).cancelWithdrawRequest &&
                                  he(e).cancelWithdrawRequest(...f))
                            },
                            [
                              d[14] ||
                                (d[14] = Mr(' Cancel withdrawal request ')),
                              he(e).loading.cancelWithdraw
                                ? (Ce(),
                                  qe(
                                    'span',
                                    bG,
                                    d[13] ||
                                      (d[13] = [
                                        ee('span', null, null, -1),
                                        ee('span', null, null, -1)
                                      ])
                                  ))
                                : rt('', !0)
                            ]
                          )
                        ]),
                        ee('div', wG, [
                          ee(
                            'button',
                            {
                              type: 'button',
                              'aria-label': 'Complete withdrawal',
                              onClick:
                                d[3] ||
                                (d[3] = (...f) =>
                                  he(e).completeWithdraw &&
                                  he(e).completeWithdraw(...f))
                            },
                            [
                              d[16] || (d[16] = Mr(' Complete withdrawal ')),
                              he(e).loading.withdraw
                                ? (Ce(),
                                  qe(
                                    'span',
                                    _G,
                                    d[15] ||
                                      (d[15] = [
                                        ee('span', null, null, -1),
                                        ee('span', null, null, -1)
                                      ])
                                  ))
                                : rt('', !0)
                            ]
                          )
                        ])
                      ])
                    ]),
                    _: 1,
                    __: [17]
                  },
                  8,
                  ['active']
                ),
                ee('div', EG, [
                  ee('div', AG, [
                    d[19] ||
                      (d[19] = ee(
                        'div',
                        {class: 'withdraw__screen--row'},
                        [
                          ee(
                            'h1',
                            {class: 'withdraw__screen--title'},
                            'NAKA Fund Withdrawal'
                          ),
                          ee(
                            'div',
                            {class: 'withdraw__screen--subtitle'},
                            'Your funds, your control.'
                          ),
                          ee(
                            'div',
                            {class: 'withdraw__screen--text'},
                            ' Choose your withdrawal method and get your funds in just a few steps. '
                          )
                        ],
                        -1
                      )),
                    ee('div', SG, [
                      ke(vE, {
                        onClick: s,
                        title: 'Withdraw to connected wallet',
                        description: `Simply withdraw your funds to the currently connected wallet in your
      browser.`,
                        buttonText: 'Withdraw connected'
                      }),
                      ke(vE, {
                        onClick: o,
                        title: 'Withdraw to external wallet',
                        description:
                          'Insert an external wallet address and transfer your funds.',
                        buttonText: 'Withdraw external'
                      }),
                      d[18] || (d[18] = ee('div', {class: 'spacer'}, null, -1)),
                      ke(
                        jV,
                        {
                          amount: he(e).activeRequest
                            ? he(e).contractBalance.usdt +
                              he(e).activeRequest.amount
                            : he(e).contractBalance.usdt
                        },
                        null,
                        8,
                        ['amount']
                      )
                    ]),
                    ke(lG)
                  ])
                ])
              ],
              64
            )
          )
        );
      }
    }),
    CG = xt({
      __name: 'HomeView',
      setup(t) {
        const e = Ei();
        return (n, r) => (
          Ce(),
          qe(
            Dt,
            null,
            [
              !he(e).vaultContract || he(e).loading.connect
                ? (Ce(), Sn(tV, {key: 0}))
                : rt('', !0),
              he(e).vaultContract && !he(e).loading.connect
                ? (Ce(), Sn(xG, {key: 1}))
                : rt('', !0)
            ],
            64
          )
        );
      }
    }),
    TG = $8({
      history: g8('/naka-web-wallet'),
      routes: [{path: '/', name: 'home', component: CG}]
    }),
    R1 = xA(Yq);
  R1.use(Ok());
  R1.use(TG);
  R1.mount('#app');
});
export default IG();
